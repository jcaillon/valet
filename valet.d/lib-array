#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# Sorts an array using the > bash operator (lexicographic order).
# It uses pure bash.
#
# $1: The global variable name of array to sort.
#
# Usage:
#   declare -g myArray=( "z" "a" "b" )
#   array::sort myArray
#   echo "${myArray[@]}"
function array::sort() {
  local -n array=${1}
  local -i i j
  local temp
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      if [[ "${array[i]}" > "${array[j]}" ]]; then
        temp="${array[i]}"
        array[i]="${array[j]}"
        array[j]="${temp}"
      fi
    done
  done
}

# Add a value to an array if it is not already present.
# It uses pure bash.
#
# $1: The global variable name of the array.
# $2: The value to add.
#
# Returns:
#   0 if the value was added, 1 if it was already present.
#
# Usage:
#   declare -g myArray=( "a" "b" )
#   array::appendIfNotPresent myArray "c"
#   echo "${myArray[@]}"
function array::appendIfNotPresent() {
  local -n array=${1}
  local value="${2}"

  # add value to array if not present, check in a loop
  local -i present=0
  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      present=1
      break
    fi
  done
  if [[ present -eq 0 ]]; then
    array+=("${value}")
  fi
  return ${present}
}

# Check if a value is in an array.
# It uses pure bash.
#
# $1: The global variable name of the array.
# $2: The value to check.
#
# Returns:
#   0 if the value is in the array, 1 otherwise.
#
# Usage:
#   declare -g myArray=( "a" "b" )
#   array::isInArray myArray "b" && echo "b is in the array"
function array::isInArray() {
  local -n array="${1}"
  local value="${2}"

  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

# This function makes sure that all the arrays have the same size.
# It will add empty strings to the arrays that are too short.
#
# $1+: The arrays (global variable names) to make the same size.
#
# Usage:
#   array::makeArraysSameSize "array1" "array2" "array3"
function array::makeArraysSameSize() {
  local array
  local -i length
  local -a lengths
  local -i maxLength=0

  # compute max length among all arrays
  for array in "$@"; do
    if [[ ! -v "${array}" ]]; then
      eval "${array}=()"
    fi
    eval "length=\${#${array}[@]}" || length=0
    lengths+=("${length}")
    if [[ length -gt maxLength ]]; then
      maxLength=length
    fi
  done

  for length in "${lengths[@]}"; do
    while [[ length -lt maxLength ]]; do
      eval "${1}+=(\"\")"
      length+=1
    done
    shift
  done
}

# Sorts an array using mulitple criteria.
# Excepts multiple arrays. The first array is the one to sort.
# The other arrays are used as criteria. Criteria are used in the order they are given.
# Each criteria array must have the same size as the array to sort.
# Each criteria array must containing integers representing the order of the elements.
# We first sort using the first criteria (from smallest to biggest), then the second, etc.
#
# $1: the name of the array to sort
# $2+: the names of the arrays to use as criteria
#
# Usage:
#   declare -g myArray=( "a" "b" "c" )
#   declare -g criteria1=( 3 2 2 )
#   declare -g criteria2=( 1 3 2 )
#   array::sortWithCriteria myArray criteria1 criteria2
#   echo "${LAST_RETURNED_VALUE_ARRAY[@]}"
#   > c b a
function array::sortWithCriteria() {
  local -n array="${1}"
  shift
  local -a criteria=("${@}")

  local -i i j k
  local temp
  local -a indexes

  # create an array of indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    indexes+=("${i}")
  done

  # sort the indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do

      for ((k = 0; k < ${#criteria[@]}; k++)); do
        local -n criterion="${criteria[k]}"
        if ((criterion[indexes[i]] > criterion[indexes[j]])); then
            temp="${indexes[i]}"
            indexes[i]="${indexes[j]}"
            indexes[j]="${temp}"
          break;
        elif ((criterion[indexes[i]] < criterion[indexes[j]])); then
          break;
        fi
      done
    done
  done

  # create the sorted array
  local -a sortedArray
  for i in "${indexes[@]}"; do
    sortedArray+=("${array[i]}")
  done

  array=("${sortedArray[@]}")
}


# Allows to fuzzy sort an array against a given pattern.
# Returns an array containing only the lines matching the pattern.
# The array is sorted by (in order):
# - the index of the first matched character in the line
# - the distance between the characters in the line
#
# $1: the pattern to match
# $2: the initial array name
# $3: (optional) string to add before each matched char
# $4: (optional) string to add after each matched char
#
# Returns:
#   an the sorted and filtered in the global variable LAST_RETURNED_ARRAY_VALUE

# Usage:
#   array::fuzzyMatch "pattern" "myarray" && local bestMatch="${LAST_RETURNED_VALUE}"
#
# Note:
#   All characters in the pattern must be found in the same order in the matched line.
#   The function is case insensitive.
#   This function does not sort the results, it only filters them.
function array::fuzzyFilterSort() {
  local pattern="${1}"
  local -n array="${2}"
  local beforeChar="${3:-}"
  local afterChar="${4:-}"

  ARRAY_MATCHES=()
  ARRAY_INDEXES=()
  ARRAY_DISTANCES=()

  local -i patternLength lineLength
  patternLength="${#pattern}"

  # make all match case insensitive
  shopt -s nocasematch

  local line patternChar lineChar modifiedLine
  local -i lineCharIndex patternCharIndex lastLineCharIndex distance patternFirstCharIndex

  for line in "${array[@]}"; do
    lineLength="${#line}"

    modifiedLine=""

    # for each character in the pattern
    patternCharIndex=0
    lineCharIndex=0
    lastLineCharIndex=0
    while [[ patternCharIndex -lt patternLength ]]; do
      patternChar="${pattern:${patternCharIndex}:1}"

      # find the character in the line
      while [[ lineCharIndex -lt lineLength ]]; do
        lineChar="${line:${lineCharIndex}:1}"

        if [[ ${lineChar} == "${patternChar}" ]]; then
          # modify the line
          if ((lineCharIndex - lastLineCharIndex > 0)); then
            modifiedLine+="${line:${lastLineCharIndex}:$((lineCharIndex  - lastLineCharIndex))}"
          fi
          modifiedLine+="${beforeChar}${lineChar}${afterChar}"

          # if we find the character, mark the distance
          distance=$((lineCharIndex - lastLineCharIndex))
          lastLineCharIndex=$((lineCharIndex + 1))

          # if it is the first char of the pattern, remmember the index
          if [[ patternCharIndex -eq 0 ]]; then
            patternFirstCharIndex=${lineCharIndex}
          fi

          # loop on the next pattern character
          break;
        fi

        lineCharIndex+=1
      done

      # if we don't find the character in the line, the line is not a match
      if [[ lineCharIndex -ge lineLength ]]; then
        break;
      else
        lineCharIndex+=1
      fi

      patternCharIndex+=1
    done

    # if we found all the characters in the pattern
    if [[ patternCharIndex -ge patternLength ]]; then
      # add the remaining characters in the line
      if ((lineLength - lastLineCharIndex > 0)); then
        modifiedLine+="${line:$((lastLineCharIndex)):$((lineLength - lastLineCharIndex))}"
      fi

      ARRAY_MATCHES+=("${modifiedLine}")
      ARRAY_INDEXES+=("${patternFirstCharIndex}")
      ARRAY_DISTANCES+=("${distance}")
    fi

  done

  shopt -u nocasematch

  declare -p ARRAY_MATCHES ARRAY_INDEXES ARRAY_DISTANCES

  # sort the results
  array::sortWithCriteria ARRAY_MATCHES ARRAY_INDEXES ARRAY_DISTANCES

  LAST_RETURNED_ARRAY_VALUE=("${ARRAY_MATCHES[@]}")

  unset ARRAY_MATCHES ARRAY_INDEXES ARRAY_DISTANCES
}