#!/usr/bin/env bash
# Title:          valet.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
GLOBAL_CORE_INCLUDED=1

# Handle the case where this script was io::invoked outside of valet
if [[ -z "${GLOBAL_VALET_HOME:-}" ]]; then
  GLOBAL_VALET_HOME="${BASH_SOURCE[0]}"
  if [[ "${GLOBAL_VALET_HOME}" != /* ]]; then
    # resolve relative path
    if pushd "${GLOBAL_VALET_HOME%/*}" &>/dev/null; then GLOBAL_VALET_HOME="${PWD}"; popd 1>/dev/null;
    else GLOBAL_VALET_HOME="${PWD}"; fi
  else
    GLOBAL_VALET_HOME="${GLOBAL_VALET_HOME%/*}" # strip filename
  fi
  GLOBAL_VALET_HOME="${GLOBAL_VALET_HOME%/*}" # strip valet.d directory
fi

# First thing we do is to source the valet configuration from the user config dir
# This file can be used to override the default configuration by setting VALET_* env variables.
VALET_CONFIG_FILE="${VALET_CONFIG_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-$HOME/.config}/valet}/config"}"
if [[ -f ${VALET_CONFIG_FILE} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_FILE}"
fi
# Same with the env script
if [[ ${VALET_CONFIG_DOT_ENV_SCRIPT:-} != "false" && -f ${VALET_CONFIG_DOT_ENV_SCRIPT:-.env} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_DOT_ENV_SCRIPT:-.env}"
fi


#===============================================================
# >>> Temporay files and folders
#===============================================================

# get unique file names for the stdout, stderr and temporary directory
# to be fast, we do not create anything until we really need it
# this could lead to issues, altough it is very unlikely
GLOBAL_TEMPORARY_PREFIX="${TMPDIR:-/tmp}/temp-"
GLOBAL_TEMPORARY_IN_MEM_PREFIX="${VALET_CONFIG_WORK_FILES_DIRECTORY:-${TMPDIR:-/tmp}}/temp-"
GLOBAL_TEMPORARY_WORK_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-work"
while [[ -e "${GLOBAL_TEMPORARY_WORK_FILE}" ]]; do GLOBAL_TEMPORARY_WORK_FILE+="x"; done
GLOBAL_TEMPORARY_STDOUT_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stdout"
while [[ -e "${GLOBAL_TEMPORARY_STDOUT_FILE}" ]]; do GLOBAL_TEMPORARY_STDOUT_FILE+="x"; done
GLOBAL_TEMPORARY_STDERR_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stderr"
while [[ -e "${GLOBAL_TEMPORARY_STDERR_FILE}" ]]; do GLOBAL_TEMPORARY_STDERR_FILE+="x"; done
GLOBAL_TEMPORARY_DIRECTORY="${GLOBAL_TEMPORARY_PREFIX}${BASHPID}.valet.d"
while [[ -e "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; do GLOBAL_TEMPORARY_DIRECTORY+="x"; done

# Creates a temporary file and return its path in the global variable RETURNED_VALUE.
#
# Usage:
#  io::createTempFile && local file="${RETURNED_VALUE}"
function io::createTempFile() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>&2 2>/dev/null
  fi
  TEMPORARY_FILE_NUMBER=${TEMPORARY_FILE_NUMBER:-0}
  while true; do
    TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -f "${RETURNED_VALUE}" ]]; then
      :>"${RETURNED_VALUE}"
      return 0
    fi
  done
}

# Creates a temporary directory and return its path in the global variable RETURNED_VALUE.
#
# Usage:
#  io::createTempDirectory && local directory="${RETURNED_VALUE}"
function io::createTempDirectory() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>&2 2>/dev/null
  fi
  TEMPORARY_DIRECTORY_NUMBER=${TEMPORARY_DIRECTORY_NUMBER:-0}
  while true; do
    TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -d "${RETURNED_VALUE}" ]]; then
      mkdir -p "${RETURNED_VALUE}" 1>&2 2>/dev/null
      return 0
    fi
  done
}

# Removes all the tempoary files that were created.
#
# Usage:
#  io::cleanupTempFiles
# shellcheck disable=SC2016
function io::cleanupTempFiles() {
  if [[ -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    unset TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
  fi
  local _file
  for _file in "${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet"*; do
    rm -f "${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-"* 1>/dev/null
    break
  done
}

#===============================================================
# >>> Logging
#===============================================================

# determine if we support colors (can be overriden by the user with VALET_CONFIG_ENABLE_COLORS)
case "${TERM:-}" in
    xterm-color|xterm-256color|linux) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}";;
    xterm) if [[ -n "${COLORTERM:-}" ]]; then VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}"; fi ;;
    *) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-false}";;
esac

# This function exports the terminal size in the global variables GLOBAL_COLUMNS and GLOBAL_LINES.
#
# Usage:
#   system::exportTerminalSize
function system::exportTerminalSize() {
  shopt -s checkwinsize
  # the following subshell is required to correctly compute the columns and lines
  # the bash manual says it these are computed after the execution of an external command
  (:;:)
  GLOBAL_COLUMNS="${COLUMNS:-180}"
  GLOBAL_LINES="${LINES:-30}"
  shopt -u checkwinsize
}
system::exportTerminalSize

# Re export terminal size on window resize.
trap system::exportTerminalSize SIGWINCH

# Set the log level.
# The log level can be set to one of the following values:
# - debug
# - info
# - success
# - warning
# - error
#
# $1: the log level to set (or defaults to info)
# $2: true to silently switch log level (does not print a message)
#
# Usage:
#   log::setLevel "debug"
function log::setLevel() {
  # log level, defaults to info
  GLOBAL_LOG_LEVEL="${1:-${VALET_LOG_LEVEL:-info}}"
  case "${GLOBAL_LOG_LEVEL}" in
  error) LOG_LEVEL_INT=4 ;;
  warning) LOG_LEVEL_INT=3 ;;
  success) LOG_LEVEL_INT=2 ;;
  debug) LOG_LEVEL_INT=0 ;;
  *) LOG_LEVEL_INT=1 ;;
  esac

  if [[ ${2:-false} != "true" ]]; then
    if [[ ${LOG_LEVEL_INT} -ne 1 ]]; then
      log::debug "Log level set to ${GLOBAL_LOG_LEVEL}."
    fi
    if [[ ${LOG_LEVEL_INT} -eq 0 ]]; then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# Get the current log level.
#
# Returns:
#   the current log level in the global variable RETURNED_VALUE.
#
# Usage:
#   log::getLevel && printf '%s\n' "The log level is ⌜${RETURNED_VALUE}⌝."
function log::getLevel() {
  RETURNED_VALUE="${GLOBAL_LOG_LEVEL:-info}"
}

# The log line function is used to display log messages in the terminal.
#
# $1: the color of the log message (red, green, yellow, cyan, gray, pink)
# $2: the icon to display in the log message (utf8 character from nerdicons)
# $3: the severity of the log message (masx 7 chars)
# $*: the content of the log message (each arg will be separated by a new line)
#
# Usage:
#   log::print "GREEN" $'\uf14a' "SUCCESS" "This is a success message."
# shellcheck disable=SC2317
function log::print() { return 0; }
# We build the log line function dynamically to adapt to the user options.
# This avoid to have to check the options at each log message.
# It creates the global variable GLOBAL_LOG_PRINT_FUNCTION.
# shellcheck disable=SC2016
function log::createPrintFunction() {
  GLOBAL_LOG_PRINT_FUNCTION='
  function log::print() {
    local icon severity
    local colorCode="${1}"
    icon="${2}"
    severity="${3}"
    shift 3
    local IFS='"$'\n'"'
    RETURNED_VALUE="$*"
    unset IFS'

  local cDefault=""
  local cTimestamp=""
  if [[ "${VALET_CONFIG_ENABLE_COLORS:-}" == "true" ]]; then
    cTimestamp=${VALET_CONFIG_COLOR_TIMESTAMP:-$'\e'"[90m"} # Bright Black (Gray)
    cDefault=${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}
    local cDebug=${VALET_CONFIG_COLOR_DEBUG:-$'\e'"[90m"} # Bright Black (Gray)
    local cInfo=${VALET_CONFIG_COLOR_INFO:-$'\e'"[36m"} # Cyan
    local cWarning=${VALET_CONFIG_COLOR_WARNING:-$'\e'"[33m"} # Yellow
    local cSuccess=${VALET_CONFIG_COLOR_SUCCESS:-$'\e'"[32m"} # Green
    local cError=${VALET_CONFIG_COLOR_ERROR:-$'\e'"[31m"} # Red
    local cHighlight=${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"} # Bright Magenta (Pink)

    GLOBAL_LOG_PRINT_FUNCTION+="
    local color
    case \"\${colorCode}\" in
    DEBUG) color=${cDebug@Q} ;;
    INFO) color=${cInfo@Q} ;;
    WARNING) color=${cWarning@Q} ;;
    SUCCESS) color=${cSuccess@Q} ;;
    ERROR) color=${cError@Q} ;;
    *) color=${cDefault@Q} ;;
    esac
    "
    # shellcheck disable=SC2016
    GLOBAL_LOG_PRINT_FUNCTION+='
    RETURNED_VALUE="${RETURNED_VALUE//⌜/'"${cHighlight@Q}"'⌜}"
    RETURNED_VALUE="${RETURNED_VALUE//⌝/⌝'"${cDefault@Q}"'}"
    '
  else
    GLOBAL_LOG_PRINT_FUNCTION+='
    local color=""
    '
  fi

  if [[ "${VALET_CONFIG_DISABLE_LOG_WRAP:-}" != "true" ]]; then
    local wrapTextColumns="${VALET_CONFIG_LOG_COLUMNS:-${GLOBAL_COLUMNS}}"
    local wrapPaddingLength=20

    if [[ ${VALET_CONFIG_DISABLE_LOG_TIME:-} == "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 9))
    fi

    if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} != "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 2))
    fi

    GLOBAL_LOG_PRINT_FUNCTION+='
    string::wrapText "${RETURNED_VALUE}" '"${wrapTextColumns}"' '"${wrapPaddingLength}"''
  fi

  local printfFormat
  local printfArguments

  # timestamp
  if [[ ${VALET_CONFIG_DISABLE_LOG_TIME:-} == "true" ]]; then
    printfFormat+=""
  elif [[ ${VALET_CONFIG_ENABLE_LOG_TIMESTAMP:-} == "true" ]]; then
    printfFormat+="%(%F_%H:%M:%S)T "
    printfArguments+='"${EPOCHSECONDS}" '
  else
    printfFormat+="%s%(%H:%M:%S)T "
    printfArguments+="${cTimestamp@Q}"' "${EPOCHSECONDS}" '
  fi

  # severity
  if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} == "true" ]]; then
    printfFormat+="%s%-8s%-4s%s "
    printfArguments+='"${color:-}" "${severity}" "${icon:-}" '"${cDefault@Q}"' '
  else
    printfFormat+="%s%-8s%s "
    printfArguments+='"${color:-}" "${severity}" '"${cDefault@Q}"' '
  fi

  # message
  printfFormat+="%s\n"
  printfArguments+='"${RETURNED_VALUE}"'

  if [[ -z ${VALET_CONFIG_LOG_FD:-} || ${#VALET_CONFIG_LOG_FD} == 1 ]]; then
    # it is a numbered file descriptor
    GLOBAL_LOG_PRINT_FUNCTION+='
      printf "'"${printfFormat}"'" '"${printfArguments}"' 1>&'"${VALET_CONFIG_LOG_FD:-2}"'
    }'
  else
    # it is a file
    GLOBAL_LOG_PRINT_FUNCTION+='
      printf "'"${printfFormat}"'" '"${printfArguments}"' 1>>'"${VALET_CONFIG_LOG_FD}"'
    }'
  fi
}
log::createPrintFunction
eval "${GLOBAL_LOG_PRINT_FUNCTION}"


# Displays an error message and then exit the program with error.
#
# $@: the error message to display
#
# Usage:
#   core::fail "This is an error message."
function core::fail() {
  log::error "$@"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_DISPLAYED=1
  exit 1
}

# Displays an error message.
# You probably want to exit immediately after an error and should consider using core::fail function instead.
#
# $@: the error message to display
#
# Usage:
#   log::error "This is an error message."
function log::error() {
  local message="$*"
  if log::isDebugEnabled; then
    log::getCallStack 2 && local stack=$'\n'"stack:${RETURNED_VALUE}"
    message+="${stack:-}"
  fi
  log::print "ERROR" "${VALET_CONFIG_ICON_ERROR:-$'\uf2d3'}" "ERROR" "${message}"
}

# Displays a warning and return a warning code.
# $*: the warning message to display
#
# Usage:
#   log::warning "This is a warning message."
function log::warning() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 3 ]]; then
    return 0
  fi
  log::print "WARNING" "${VALET_CONFIG_ICON_WARNING:-$'\uf071'}" "WARNING" "$*"
  return 0
}

# Displays a success message.
# $*: the success message to display
#
# Usage:
#   log::success "This is a success message."
function log::success() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 2 ]]; then
    return 0
  fi
  log::print "SUCCESS" "${VALET_CONFIG_ICON_SUCCESS:-$'\uf14a'}" "SUCCESS" "$*"
  return 0
}

# Displays an info message.
# $*: the info message to display
#
# Usage:
#   log::info "This is an info message."
function log::info() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 1 ]]; then
    return 0
  fi
  log::print "INFO" "${VALET_CONFIG_ICON_INFO:-$'\uf05a'}" "INFO" "$*"
  return 0
}

# Displays a debug message if the global variable DEBUG is set to true.
# $*: the debug message to display
#
# Usage:
#   log::debug "This is a debug message."
function log::debug() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 0 ]]; then
    return 0
  fi
  log::print "DEBUG" "${VALET_CONFIG_ICON_DEBUG:-$'\uf0ae'}" "DEBUG" "$*"
  return 0
}

# Returns 0 if debug mode is active, 1 otherwise.
#
# Usage:
#   log::isDebugEnabled && printf '%s\n' "Debug mode is active."
function log::isDebugEnabled() {
  if [[ ${LOG_LEVEL_INT:-1} -eq 0 ]]; then
    return 0
  fi
  return 1
}

# This function returns the current function stack.
# The stack is returned in the global variable RETURNED_VALUE.
#
# $1: the number of levels to skip (default to 2)
#
# Usage:
#   log::getCallStack 2 && local stack="${RETURNED_VALUE}"
function log::getCallStack() {
  local -i levelToSkip="${1:-2}"
  local stack i stackSize func linen src
  stack=""
  stackSize=${#FUNCNAME[@]}
  treeString="├─"
  for ((i = levelToSkip; i < stackSize; i++)); do
    func="${FUNCNAME[${i}]}"
    if [[ -z "${func}" ]]; then func=MAIN; fi
    linen="${BASH_LINENO[$((i - 1))]}"
    src="${BASH_SOURCE[${i}]}"
    if [[ -z "${src}" ]]; then
      src=non_file_source;
    elif [[ -f "${src/#.\//"${PWD}"\/}" ]]; then
      src="${src/#.\//"${PWD}"\/}"
    elif [[ -f "${src/#.\//"${GLOBAL_VALET_HOME}"\/}" ]]; then
      src="${src/#.\//"${GLOBAL_VALET_HOME}"\/}"
    fi
    if [[ ${i} -eq "$((stackSize - 1))" ]]; then
      treeString="└─"
    fi
    stack+=$'\n'"${treeString} In function ${func}() ${src}:${linen}"
  done
  RETURNED_VALUE="${stack}"
}

#===============================================================
# >>> Core utilities
#===============================================================

# Allows to include a library file. It sources a file.
# It replaces the builtin source command to make sure that we do not include the same file twice.
# This also allows us to specify to spellcheck the included file.
#
# $1: the name of the library (array, interactive, string...) or the file path to include.
#
# Notes:
#   The file can be relative to the current script (script that calls this function).
#   This function makes sure that we do not include the same file twice.
#
# Usage:
#   source string array system
#   source ./my/path my/other/path
function source() {
  local filePathToInclude includedFile
  if [[ -f "${GLOBAL_VALET_HOME}/valet.d/lib-${1}" ]]; then
    filePathToInclude="${GLOBAL_VALET_HOME}/valet.d/lib-${1}"
  elif [[ -f "${BASH_SOURCE[1]%/*}/${1}" ]]; then
    filePathToInclude="${BASH_SOURCE[1]%/*}/${1}"
  elif [[ -f "${1}" ]]; then
    filePathToInclude="${1}"
  else
    core::fail "Cannot source the file ${1} because it does not exist."
  fi
  for includedFile in "${_LIST_OF_INCLUDED_FILES[@]}"; do
    if [[ ${includedFile} == "${filePathToInclude}" ]]; then
      return 0
    fi
  done
  shift
  # shellcheck source=/dev/null
  builtin source "${filePathToInclude}" "$@"
  _LIST_OF_INCLUDED_FILES+=("${filePathToInclude}")
}
_LIST_OF_INCLUDED_FILES=()

# Allows to reset the included files.
# When calling the include function, it will source the files again.
# This is useful when we want to reload the libraries.
#
# Usage:
#   core::resetIncludedFiles
function core::resetIncludedFiles() {
  _LIST_OF_INCLUDED_FILES=()
}

# Source the file associated with the function if needed.
# $1: the function name
#
# Usage:
#  core::sourceFunction "functionName"
function core::sourceFunction() {
  local functionName
  functionName="${1}"

  local fileToSource
  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -f "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -f "${GLOBAL_VALET_HOME:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${GLOBAL_VALET_HOME:-}/${fileToSource}"
      log::debug "Loaded file ⌜${GLOBAL_VALET_HOME:-}/${fileToSource}⌝."
    else
      log::warning "The source file ⌜${GLOBAL_VALET_HOME:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we use the examples commands.
#
# Usage:
#  core::sourceUserCommands
function core::sourceUserCommands() {
  if [[ -n "${_CMD_INCLUDED:-}" ]]; then
    return 0
  fi

  # source the user commands
  local userDirectory
  core::getUserDirectory && userDirectory="${RETURNED_VALUE}"

  local commandsFile
  commandsFile="${userDirectory}/commands"

  # if the commands file does not exist, we use the examples commands or we fail
  if [[ ! -f "${commandsFile}" ]]; then
    log::info "The valet user directory ⌜${userDirectory}⌝ does not contain a built ⌜commands⌝ file."$'\n'"Now building it using ⌜valet self build⌝ command."

    local originalLogLevel
    log::getLevel && originalLogLevel="${RETURNED_VALUE}"
    log::setLevel warning true
    # shellcheck disable=SC1091
    source "${GLOBAL_VALET_HOME}/valet.d/commands.d/self-build.sh"
    selfBuild
    log::setLevel "${originalLogLevel}" true

    if [[ ! -f "${commandsFile}" ]]; then
      core::fail "Could not build the commands file, please check the error above."
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  builtin source "${commandsFile}"
}

# Forcibly source again the user 'commands' file from the valet user directory.
#
# Usage:
#  core::reloadUserCommands
function core::reloadUserCommands() {
  # delete previous variables
  # shellcheck disable=SC2086
  unset -v ${!CMD_*} _CMD_INCLUDED
  core::sourceUserCommands
}

#===============================================================
# >>> String utilities
#===============================================================

# Allows to soft wrap the given text at the given width.
# Optionally applies left padding to each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the padding to apply to each new line (default to 0)
# $4: true/false if the padding should be applied to the first line (default to false)
# Returns the wrapped text in the global variable RETURNED_VALUE
#
# Usage:
#   string::wrapText "This is a long text that should be wrapped at 20 characters." 20 2 false && local wrappedText="${RETURNED_VALUE}"
#
# Note:
#   This function is written in pure bash and is faster than calling the fold command.
#   This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
function string::wrapText() {
  local text width leftPaddingLength appendPaddingToFirstLine
  text="${1}"
  width="${2:-GLOBAL_COLUMNS}"
  leftPaddingLength="${3:-0}"
  appendPaddingToFirstLine="${4:-false}"

  # compute padding in number of spaces
  local leftPadding
  leftPadding=""
  for ((i = 0; i < leftPaddingLength; i++)); do
    leftPadding+=" "
  done

  local sentenceWidth=$((width - leftPaddingLength))

  local wrappedText

  if [[ "${text}" == *$'\n'* ]]; then
    # we call string::wrapSentence for each line of the text
    local firstLine="1"
    local line
    while read -r line; do
      wrappedText+=$'\n'
      string::wrapSentence "${line}" "${sentenceWidth}" "${leftPadding}"
      if [[ ${firstLine} == "1" ]]; then
        firstLine="0"
      else
        wrappedText+="${leftPadding}"
      fi
      wrappedText+="${RETURNED_VALUE}"
    done <<< "${text}"
  else
    string::wrapSentence "${text}" "${sentenceWidth}" "${leftPadding}"
    wrappedText="${RETURNED_VALUE}"
  fi

  # add left padding on the first line (or not)
  if [[ ${appendPaddingToFirstLine} == "true" ]]; then
    RETURNED_VALUE="${leftPadding}${wrappedText#$'\n'}"
  else
    RETURNED_VALUE="${wrappedText#$'\n'}"
  fi
}

# Allows to soft wrap the given sentence (without new lines) at the given width.
# Optionally applies a prefix on each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the prefix to apply to each new line (default to "")
# Returns the wrapped text in the global variable RETURNED_VALUE
#
# Usage:
#   string::wrapSentence "This is a long text that should be wrapped at 20 characters." 20 && local wrappedText="${RETURNED_VALUE}"
#
# Note:
#   This function is written in pure bash and is faster than calling the fold command.
#   This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
function string::wrapSentence() {
  local text newLinePrefix
  local -i width
  text="${1}"
  width="${2}"
  newLinePrefix="${3:-}"

  # short cut in case the text is already shorter than the width
  if [[ "${#text}" -le width ]]; then
    RETURNED_VALUE="${text}"
    return 0
  fi

  # new line to append
  local newLine
  newLine=$'\n'"${newLinePrefix}"

  local wrappedText word
  local -i spaceLeft wordLength partialWordLength
  wrappedText=""
  spaceLeft=${width}
  local firstWord="1"
  local IFS=' '
  for word in ${text}; do

    if [[ ${firstWord} == "1" ]]; then
      firstWord="0"
    else
      # we just added a word
      if [[ spaceLeft -gt 0 ]]; then
        # if we have space left, we add a space
        wrappedText+=" "
        spaceLeft=$((spaceLeft - 1))
      else
        # otherwise we add a new line
        wrappedText+="${newLine}"
        spaceLeft=${width}
      fi
    fi

    wordLength=${#word}

    if [[ wordLength -le spaceLeft ]]; then
      # we have the space to add the word
      wrappedText+="${word}"
      spaceLeft=$((spaceLeft - wordLength))
    else
      # we don't have the space to add the word

      # will the word fit in the width of the next line?
      if [[ wordLength -le width ]]; then
        # then we add the word to the next line
        wrappedText+="${newLine}${word}"
        spaceLeft=$((width - wordLength))
      else
        # the word doesn't fit in the width of the next line
        # we can add the partial word to the current line
        # and the rest on the next lines until we have the full word
        while [[ wordLength -gt 0 ]]; do
          partialWordLength="${wordLength}"
          if [[ partialWordLength -gt spaceLeft ]]; then
            partialWordLength="${spaceLeft}"
          fi
          wrappedText+="${word:0:${partialWordLength}}"
          word="${word:${partialWordLength}}"
          wordLength=$((wordLength - partialWordLength))
          spaceLeft=$((spaceLeft - partialWordLength))
          if [[ spaceLeft -eq 0 && wordLength -gt 0 ]]; then
            wrappedText+="${newLine}"
            spaceLeft="${width}"
          fi
        done
      fi
    fi
  done

  RETURNED_VALUE="${wrappedText}"
}

# Allows to fuzzy match an array against a given pattern.
# Returns an array containing only the lines matching the pattern.
#
# $1: the pattern to match
# $2: the initial array name
#
# Returns:
#   an array containing only the lines matching the pattern in the global variable RETURNED_ARRAY
#   an array of the same size that contains the start index of the match in the global variable RETURNED_ARRAY2
#   an array of the same size that contains the distance of the match in the global variable RETURNED_ARRAY3
#
# Usage:
#   array::fuzzyMatch "pattern" "myarray" && local bestMatch="${RETURNED_VALUE}"
#
# Note:
#   All characters in the pattern must be found in the same order in the matched line.
#   The function is case insensitive.
#   This function does not sort the results, it only filters them.
function array::fuzzyFilter() {
  local pattern="${1}"
  local -n array="${2}"

  local -a matches=()
  local -a indexes=()
  local -a distances=()

  local -i patternLength lineLength
  patternLength="${#pattern}"

  # make all match case insensitive
  shopt -s nocasematch

  local line patternChar lineChar
  local -i lineCharIndex patternCharIndex lastLineCharIndex distance patternFirstCharIndex

  for line in "${array[@]}"; do
    lineLength="${#line}"

    # for each character in the pattern
    patternCharIndex=0
    lineCharIndex=0
    lastLineCharIndex=0
    while [[ patternCharIndex -lt patternLength ]]; do
      patternChar="${pattern:${patternCharIndex}:1}"

      # find the character in the line
      while [[ lineCharIndex -lt lineLength ]]; do
        lineChar="${line:${lineCharIndex}:1}"

        if [[ ${lineChar} == "${patternChar}" ]]; then
          # if we find the character, mark the distance
          distance=$((lineCharIndex - lastLineCharIndex))
          lastLineCharIndex=$((lineCharIndex + 1))

          # if it is the first char of the pattern, remmember the index
          if [[ patternCharIndex -eq 0 ]]; then
            patternFirstCharIndex=${lineCharIndex}
          fi

          # loop on the next pattern character
          break;
        fi

        lineCharIndex+=1
      done

      # if we don't find the character in the line, the line is not a match
      if [[ lineCharIndex -ge lineLength ]]; then
        break;
      else
        lineCharIndex+=1
      fi

      patternCharIndex+=1
    done

    # if we found all the characters in the pattern
    if [[ patternCharIndex -ge patternLength ]]; then
      matches+=("${line}")
      indexes+=("${patternFirstCharIndex}")
      distances+=("${distance}")
    fi

  done

  shopt -u nocasematch

  RETURNED_ARRAY=("${matches[@]}")
  RETURNED_ARRAY2=("${indexes[@]}")
  RETURNED_ARRAY3=("${distances[@]}")
}

#===============================================================
# >>> Valet files and directories
#===============================================================

# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Usage:
#   core::getConfigurationDirectory && local directory="${RETURNED_VALUE}"
function core::getConfigurationDirectory() {
  local directory
  directory="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# Returns the path to the valet locla state directory.
# The base directory relative to which user-specific state files should be stored.
# Creates it if missing.
#
# Usage:
#   core::getLocalStateDirectory && local directory="${RETURNED_VALUE}"
function core::getLocalStateDirectory() {
  local directory
  directory="${VALET_CONFIG_LOCAL_STATE_DIRECTORY:-${XDG_STATE_HOME:-${HOME}/.local/share}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# Returns the path to the valet user directory.
# Does not create it if missing.
#
# Usage:
#   core::getUserDirectory && local directory="${RETURNED_VALUE}"
function core::getUserDirectory() {
  RETURNED_VALUE="${VALET_USER_DIRECTORY:-${HOME}/.valet.d}"
}

#===============================================================
# >>> Parser and interactive mode
#===============================================================

# Show the help for the current function.
# This should be called from a command function for which you want to display the help text.
#
# Usage:
#   core::showHelp
function core::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::printHelp funtion "${functionName}"
}

# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# Usage:
#   core::parseArguments "$@" && eval "${RETURNED_VALUE}"
#
# Notes:
#   - It will return a string that can be evaluated to set the variables
#     corresponding to the arguments and options; e.g.:
#       local arg1 option1
#       arg1="xxx"
#       option1="xxx"
#       ...
#   - It will also set the variable parsingErrors if there are any errors.
#   - Variable name for an option is taken from the first --long version of the option.
#   - If the function expects arguments or options but none are provided, it will
#     automatically go into interactive mode and ask the user inputs.
#   - It will set the variable as an array if the (last) argument name ends with '...'
function core::parseArguments() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::parseFunctionArgumentsOrmain::goInteractive "${functionName}" "$@"
}

# A convenience function to check the parsing results and display an error message if needed.
# Will also display the help if the help option is true.
# This should be called from a command function for which you want to check the parsing results.
#
# Usage:
#   core::checkParseResults "${help:-}" "${parsingErrors:-}"
#   core::checkParseResults "${help:-}" "${parsingErrors:-}" "myFunctionName"
function core::checkParseResults() {
  local functionName help parsingErrors
  functionName="${3:-${FUNCNAME[1]}}"

  help="${1:-}"
  parsingErrors="${2:-}"

  if [[ -n "${help}" ]]; then
    main::printHelp function "${functionName}"
    exit 0
  fi

  if [[ -n "${parsingErrors:-}" ]]; then
    local -n commandName="CMD_COMMAND_${functionName}"
    core::fail "${parsingErrors}"$'\n'"Use valet ${commandName} --help to get help."
  fi
}

#===============================================================
# >>> Main
#===============================================================

# Parsing the options from environment variables
if [[ -n "${VALET_LOG_LEVEL:-}" ]]; then
  log::setLevel "${VALET_LOG_LEVEL}"
fi
if [[ ${VALET_VERBOSE=:-} == "true" ]]; then
  log::setLevel "debug"
fi
if [[ -n "${VALET_CONFIG_LOG_FD:-}" ]]; then
  # make sure the file descriptor is valid
  if ! { : >&"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
    _ORIGINAL_FD="${VALET_CONFIG_LOG_FD}"
    VALET_CONFIG_LOG_FD=2
    core::fail "The file descriptor VALET_CONFIG_LOG_FD=⌜${_ORIGINAL_FD}⌝ is not valid."
  fi
fi

# Include main if not already included
if [[ -z "${GLOBAL_MAIN_INCLUDED:-}" ]]; then
  # shellcheck source=main
  source "${GLOBAL_VALET_HOME}/valet.d/main"
fi