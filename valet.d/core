#!/usr/bin/env bash
# Title:         valet.d/core
# Description:   this script contains the core functions and variables and it should be sourced, not called directly
# Author:        github.com/jcaillon

# we check for this variable to know if this script has already been included
_CORE_INCLUDED=1

#===============================================================
# >>> Core variables
#===============================================================

# the variable EXPORT_VARIABLE_SCRIPT will contain the path to the script that should be modified to
# automatically export variables when running the shell
HOME=~

# determine the color mode expect if the user has set VALET_NO_COLOR
case "$TERM" in
    xterm-color|xterm-256color|linux) VALET_NO_COLOR="${VALET_NO_COLOR:-false}";;
    xterm) [ -n "$COLORTERM" ] && VALET_NO_COLOR="${VALET_NO_COLOR:-false}";;
    *) VALET_NO_COLOR="${VALET_NO_COLOR:-true}";;
esac

# the color code used to output colored text
if [[ ${VALET_CI_MODE:-} != true && ${VALET_NO_COLOR:-} != true ]]; then
  COLOR_DEFAULT=$'\033'"[0m"
  COLOR_RED=$'\033'"[0;31m"
  COLOR_GREEN=$'\033'"[32m"
  COLOR_YELLOW=$'\033'"[33m"
  COLOR_CYAN=$'\033'"[0;36m"
  COLOR_GRAY=$'\033'"[1;30m"
  COLOR_PINK=$'\033'"[1;35m"
fi

if [ "${VALET_NO_WRAP:-}" != "true" ]; then
  _COLUMNS="${_COLUMNS:-$(tput cols 2>/dev/null || echo 120)}"
else
  _COLUMNS="${_COLUMNS:-120}"
fi

#===============================================================
# >>> Temporay files and folders
#===============================================================

# little trick here; since we will use createTempFile / createTempDirectory in subshell $()
# they will not have access to the same global variables.
# thus, we re declare them with a hardcoded value for TMPDIR so that they create temp files
# under this directory (which we can then clean up)
_TEMPORARY_DIRECTORY="${TMPDIR:-/tmp}/valet-${EPOCHSECONDS}"
while true; do
  if [ ! -d "${_TEMPORARY_DIRECTORY}" ]; then break; fi
  _TEMPORARY_DIRECTORY+="-${BASHPID}"
done

# Creates a temporary file and return its path in the global variable LAST_RETURNED_VALUE
# Usage:
#  createTempFile && local file="${LAST_RETURNED_VALUE}"
# shellcheck disable=SC2016
CREATE_TEMP_FILE_FUNCTION='
function createTempFile() {
  TMPDIR="'"${_TEMPORARY_DIRECTORY}"'"
  if [ ! -d "${TMPDIR}" ]; then
    mkdir -p "${TMPDIR}" 1>&2 2>/dev/null
  fi
  TEMPORARY_FILE_NUMBER=${TEMPORARY_FILE_NUMBER:-0}
  while true; do
    TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
    LAST_RETURNED_VALUE="${TMPDIR}/f${BASH_SUBSHELL}${TEMPORARY_FILE_NUMBER}"
    if [ ! -f "${LAST_RETURNED_VALUE}" ]; then
      touch "${LAST_RETURNED_VALUE}" 1>&2 2>/dev/null
      return 0
    fi
  done
}
'

# Creates a temporary directory and return its path in the global variable LAST_RETURNED_VALUE
# Usage:
#  createTempFile && local file="${LAST_RETURNED_VALUE}"
# shellcheck disable=SC2016
CREATE_TEMP_DIRECTORY_FUNCTION='
function createTempDirectory() {
  TMPDIR="'"${_TEMPORARY_DIRECTORY}"'"
  TEMPORARY_DIRECTORY_NUMBER=${TEMPORARY_DIRECTORY_NUMBER:-0}
  while true; do
    TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
    LAST_RETURNED_VALUE="${TMPDIR}/d${BASH_SUBSHELL}${TEMPORARY_DIRECTORY_NUMBER}"
    if [ ! -d "${LAST_RETURNED_VALUE}" ]; then
      mkdir -p "${LAST_RETURNED_VALUE}" 1>&2 2>/dev/null
      return 0
    fi
  done
}
'

# removes all the tempoary files that were created
# shellcheck disable=SC2016
CREATE_TEMP_CLEANUP_FUNCTION='
function cleanupTempFiles() {
  local tmpDir
  tmpDir="'"${_TEMPORARY_DIRECTORY}"'"
  if [ ! -d "${tmpDir}" ]; then
    return 0
  fi
  debug "Deleting temporary files."
  rm -Rf "${tmpDir}" 1>&2 2>/dev/null
}
'

eval "${CREATE_TEMP_FILE_FUNCTION}"$'\n'"${CREATE_TEMP_DIRECTORY_FUNCTION}"$'\n'"${CREATE_TEMP_CLEANUP_FUNCTION}"$'\n'
unset CREATE_TEMP_FILE_FUNCTION
unset CREATE_TEMP_DIRECTORY_FUNCTION
unset CREATE_TEMP_CLEANUP_FUNCTION
unset _TEMPORARY_DIRECTORY

#===============================================================
# >>> Logging
#===============================================================

function setLogLevelInt() {
  # log level, defaults to info
  LOG_LEVEL="${LOG_LEVEL:-info}"
  case "${LOG_LEVEL}" in
  fail) LOG_LEVEL_INT=4 ;;
  warn) LOG_LEVEL_INT=3 ;;
  success) LOG_LEVEL_INT=2 ;;
  debug) LOG_LEVEL_INT=0 ;;
  *) LOG_LEVEL_INT=1 ;;
  esac

  if [ "${LOG_LEVEL_INT}" != 1 ]; then
    debug "Log level set to ${LOG_LEVEL}"
  fi
}

# The log line function is used to display log messages in the terminal.
# The implementation depends on the environment variables VALET_CI_MODE and VALET_NO_WRAP.
# $1: the color of the log message
# $2: the icon to display in the log message (utf8 character from nerdicons)
# $3: the severity of the log message
# $*: the content of the log message
if [ "${VALET_CI_MODE:-}" != "true" ]; then
  if [ "${VALET_NO_WRAP:-}" != "true" ]; then
    if [ -n "${MINGW_PREFIX:-}" ]; then
      _NO_ICON_PADDING="${_NO_ICON_PADDING:-true}"
    fi
    _LOG_COLUMNS="${_COLUMNS:-120}"
    # displays an error message and then exit the program with error
    function logLine() {
      local color icon severity content
      color="COLOR_${1}"
      icon="${2}"
      severity="${3}"
      shift 3
      content="$*"
      content="${content//⌜/${COLOR_PINK}⌜}"
      content="${content//⌝/⌝${COLOR_DEFAULT}}"
      wrapText "${content}" "${_LOG_COLUMNS:-120}" 20
      if [ "${VALET_NO_ICON:-}" != "true" ]; then
        printf "%s%(%H:%M:%S)T %s%-8s%-4s%s %s\n" "${COLOR_GRAY}" "" "${!color}" "${severity}" "${icon:-}" "${COLOR_DEFAULT}" "${content}" 1>&2
      else
        printf "%s%(%H:%M:%S)T %s%-8s%-2s%s %s\n" "${COLOR_GRAY}" "" "${!color}" "${severity}" "" "${COLOR_DEFAULT}" "${content}" 1>&2
      fi
    }
  else
    function logLine() {
      local color icon severity content
      color="COLOR_${1}"
      icon="${2}"
      severity="${3}"
      shift 3
      content="$*"
      if [ "${VALET_NO_ICON:-}" != "true" ]; then
        printf "%s%(%H:%M:%S)T %s%-8s%-4s%s %s\n" "${COLOR_GRAY}" "" "${!color}" "${severity}" "${icon:-}" "${COLOR_DEFAULT}" "${content}" 1>&2
      else
        printf "%s%(%H:%M:%S)T %s%-8s%-2s%s %s\n" "${COLOR_GRAY}" "" "${!color}" "${severity}" "" "${COLOR_DEFAULT}" "${content}" 1>&2
      fi
    }
  fi
else
  function logLine() {
    local severity content
    severity="${3}"
    shift 3
    content="$*"
    printf "%(%F_%H:%M:%S)T %-8s %s\n" "" "${severity}" "${content}" 1>&2
  }
fi

# displays an error message and then exit the program with error
function fail() {
  logLine "RED" $'\uf2d3' "ERROR" "$*"
  # shellcheck disable=SC2034
  ERROR_DISPLAY=1
  exit 1
}

# displays a warning and return a warning code
function warn() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 3 ]]; then
    return 0
  fi
  logLine "YELLOW" $'\uf071' "WARNING" "$*"
  return 0
}

# displays a success message
function succeed() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 2 ]]; then
    return 0
  fi
  logLine "GREEN" $'\uf14a' "SUCCESS" "$*"
  return 0
}

# displays an info message
function inform() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 1 ]]; then
    return 0
  fi
  logLine "CYAN" $'\uf05a' "INFO" "$*"
  return 0
}

# displays a debug message if the global variable DEBUG is set to true
function debug() {
  if [[ ${LOG_LEVEL_INT:-1} -gt 0 ]]; then
    return 0
  fi
  logLine "GRAY" $'\uf0ae' "DEBUG" "$*"
  return 0
}

# returns 0 if debug mode is active, 1 otheriwse
function isDebugMode() {
  if [[ ${LOG_LEVEL_INT:-1} -eq 0 ]]; then
    return 0
  fi
  return 1
}

# Check last return code and fail (exit) if it is an error
# $1: the return code
# $2+ : the error message to display in case of error
#
# Usage in a function:
# command_that_could_fail || checkAndFail "$?"
function checkAndFail() {
  if [ "${1:-1}" != "0" ]; then
    shift
    fail "$*"
  fi
  return 0
}

# Check last return code and return a warning code if error
# $0: the last return code
# $1+ : the warning message to display in case of error
#
# Usage in a function:
# command_that_could_fail || checkAndWarn "$?" || return "0"
function checkAndWarn() {
  if [ "${1:-}" != "0" ]; then
    shift
    warn "$*"
    return 0
  fi
  return 0
}

#===============================================================
# >>> Core utilities
#===============================================================

# Allows to soft wrap the given text at the given width.
# Optionally applies left padding to each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the padding to apply to each new line (default to 0)
# $4: true/false if the padding should be applied to the first line (default to false)
# Returns the wrapped text in the global variable LAST_RETURNED_VALUE
# Usage:
#  wrapText "This is a long text that should be wrapped at 20 characters." 20 2 false && local wrappedText="${LAST_RETURNED_VALUE}"
# Note:
#  This function is written in pure bash and is faster than the fold command.
function wrapText() {
  local text width leftPaddingLength appendPaddingToFirstLine
  text="${1}"
  width="${2}"
  leftPaddingLength="${3:-0}"
  appendPaddingToFirstLine="${4:-false}"

  # compute padding in number of spaces
  local leftPadding
  leftPadding=""
  for ((i = 0; i < leftPaddingLength; i++)); do
    leftPadding+=" "
  done

  local sentenceWidth=$((width - leftPaddingLength))

  local wrappedText

  # we call wrapSentence for each line of the text
  local firstLine="1"
  local line
  while read -r line; do
    wrappedText+=$'\n'
    wrapSentence "${line}" "${sentenceWidth}" "${leftPadding}"
    if [ "${firstLine}" = "1" ]; then
      firstLine="0"
    else
      wrappedText+="${leftPadding}"
    fi
    wrappedText+="${LAST_RETURNED_VALUE}"
  done <<< "${text}"

  # add left padding on the first line (or not)
  if [ "${appendPaddingToFirstLine}" = "true" ]; then
    LAST_RETURNED_VALUE="${leftPadding}${wrappedText#$'\n'}"
  else
    LAST_RETURNED_VALUE="${wrappedText#$'\n'}"
  fi
}

# Allows to soft wrap the given sentence (without new lines) at the given width.
# Optionally applies a prefix on each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the prefix to apply to each new line (default to "")
# Returns the wrapped text in the global variable LAST_RETURNED_VALUE
# Usage:
#  wrapText "This is a long text that should be wrapped at 20 characters." 20 && local wrappedText="${LAST_RETURNED_VALUE}"
# Note:
#  This function is written in pure bash and is faster than the fold command.
function wrapSentence() {
  local text width newLinePrefix
  text="${1}"
  width="${2}"
  newLinePrefix="${3:-}"

  # short cut in case the text is already shorter than the width
  if [ "${#text}" -le "${width}" ]; then
    LAST_RETURNED_VALUE="${text}"
    return 0
  fi

  # new line to append
  local newLine
  newLine=$'\n'"${newLinePrefix}"

  local wrappedText word spaceLeft wordLength partialWordLength
  wrappedText=""
  spaceLeft="${width}"
  local firstWord="1"
  for word in ${text}; do

    if [ "${firstWord}" = "1" ]; then
      firstWord="0"
    else
      # we just added a word
      if [ "${spaceLeft}" -gt 0 ]; then
        # if we have space left, we add a space
        wrappedText+=" "
        spaceLeft=$((spaceLeft - 1))
      else
        # otherwise we add a new line
        wrappedText+="${newLine}"
        spaceLeft="${width}"
      fi
    fi

    wordLength="${#word}"

    if [ "${wordLength}" -le "${spaceLeft}" ]; then
      # we have the space to add the word
      wrappedText+="${word}"
      spaceLeft=$((spaceLeft - wordLength))
    else
      # we don't have the space to add the word

      # will the word fit in the width of the next line?
      if [[ "${wordLength}" -le "${width}" ]]; then
        # then we add the word to the next line
        wrappedText+="${newLine}${word}"
        spaceLeft=$((width - wordLength))
      else
        # the word doesn't fit in the width of the next line
        # we can add the partial word to the current line
        # and the rest on the next lines until we have the full word
        while [ "${wordLength}" -gt 0 ]; do
          partialWordLength="${wordLength}"
          if [ "${partialWordLength}" -gt "${spaceLeft}" ]; then
            partialWordLength="${spaceLeft}"
          fi
          wrappedText+="${word:0:${partialWordLength}}"
          word="${word:${partialWordLength}}"
          wordLength=$((wordLength - partialWordLength))
          spaceLeft=$((spaceLeft - partialWordLength))
          if [[ "${spaceLeft}" -eq 0 && "${wordLength}" -gt 0 ]]; then
            wrappedText+="${newLine}"
            spaceLeft="${width}"
          fi
        done
      fi
    fi
  done

  LAST_RETURNED_VALUE="${wrappedText}"
}


# Allows to get the nth element of a string separated by a given separator.
# This is the equivalent of the cut command "cut -d"${separator}" -f"${fieldNumber}""
# but it uses pure bash to go faster.
# $1: the string to cut
# $2: the field number to get
# $3: the separator (default to tab if not provided)
function cutF() {
  local str fieldNumber separator temp
  str="${1}"
  fieldNumber="${2}"
  separator="${3:-$'\t'}"
}

#===============================================================
# >>> Valet files and directories
#===============================================================

# Returns the path to the valet configuration directory in the global variable LAST_RETURNED_VALUE
# Usage:
#  getConfigurationDirectory && local directory="${LAST_RETURNED_VALUE}"
function getConfigurationDirectory() {
  local directory
  directory="${XDG_CONFIG_HOME:-$HOME/.config}/valet"
  if [ ! -d "${directory}" ]; then
    mkdir -p "${directory}"
  fi
  LAST_RETURNED_VALUE="${directory}"
}

# Returns the path to the valet state directory in the global variable LAST_RETURNED_VALUE
# Usage:
#  getConfigurationDirectory && local directory="${LAST_RETURNED_VALUE}"
function getLocalStateDirectory() {
  local directory
  directory="${XDG_CONFIG_HOME:-$HOME/.local/state}/valet"
  if [ ! -d "${directory}" ]; then
    mkdir -p "${directory}"
  fi
  LAST_RETURNED_VALUE="${directory}"
}

#===============================================================
# >>> Parser and interactive mode
#===============================================================

function showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  showFunctionHelp "${functionName}"
}

# show an interactive menu for a command that has sub menus
function showSubMenu() {
  local menuFunctionName
  # get the function name of the calling function
  menuFunctionName="${FUNCNAME[1]}"

  local parsedArguments
  parseFunctionArguments "this" "$@" && parsedArguments="${LAST_RETURNED_VALUE}"
  debug "Parsed arguments:"$'\n'"${parsedArguments}"
  eval "${parsedArguments}"
  if [ -n "${help:-}" ]; then
    showFunctionHelp "${menuFunctionName}"
    return 0
  fi

  # filter the commands to only keep the sub commands of the function
  local filteredCommandsMenuBody line
  local -n menuCommandName="CMD_COMMAND_${menuFunctionName}"
  filteredCommandsMenuBody=""
  while read -r line; do
    if [[ "${line}" =~ ^(${menuCommandName} [^ ]+ ) ]]; then
      filteredCommandsMenuBody+="${line}"$'\n'
    fi
  done <<<"${CMD_COMMANDS_MENU_BODY}"
  showCommandsMenuAndRun "${filteredCommandsMenuBody%$'\n'}"
}

# Parse the arguments and options of a function
#
# Usage:
#  parseArguments "$@" && eval "${LAST_RETURNED_VALUE}"
#
# Notes:
# - It will return a string that can be evaluated to set the variables
#   corresponding to the arguments and options; e.g.:
#     "local arg1 option1
#     arg1=\"\"
#     option1=\"\"
#     ..."
# - It will also set the variable parsingErrors if there are any errors.
# - Variable name for an option is taken from the first --long version of the option.
# - If the function expects arguments or options but none are provided, it will
#   automatically go into interactive mode and ask the user inputs.
# - It will set the variable as an array if the (last) argument name ends with '...'
function parseArguments() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  parseFunctionArgumentsOrGoInteractive "${functionName}" "$@"
}

function checkParseResults() {
  local functionName help parsingErrors
  functionName="${FUNCNAME[1]}"

  help="${1:-}"
  parsingErrors="${2:-}"

  if [ -n "${help}" ]; then
    showFunctionHelp "${functionName}"
    exit 0
  fi

  if [ -n "${parsingErrors:-}" ]; then
    local -n commandName="CMD_COMMAND_${functionName}"
    fail "${parsingErrors}"$'\n'"Use valet ${commandName} --help to get help."
  fi
}
