#!/usr/bin/env bash
# Title:          valet.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
_CORE_INCLUDED=1

# Handle the case where this script was io::invoked outside of valet
if [[ -z "${VALET_HOME:-}" ]]; then
  VALET_HOME="${BASH_SOURCE[0]}"
  if [[ "${VALET_HOME}" != /* ]]; then
    # resolve relative path
    if pushd "${VALET_HOME%/*}" &>/dev/null; then VALET_HOME="${PWD}"; popd &>/dev/null;
    else VALET_HOME="${PWD}"; fi
  else
    VALET_HOME="${VALET_HOME%/*}" # strip filename
  fi
  VALET_HOME="${VALET_HOME%/*}" # strip valet.d directory
fi

# First thing we do is to source the valet configuration from the user config dir
# This file can be used to override the default configuration by setting VALET_* env variables.
VALET_USER_CONFIG_FILE="${VALET_USER_CONFIG_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-$HOME/.config}/valet}/config"}"
if [[ -e "${VALET_USER_CONFIG_FILE}" ]]; then
  # shellcheck source=/dev/null
  source "${VALET_USER_CONFIG_FILE}"
fi


#===============================================================
# >>> Temporay files and folders
#===============================================================

# get unique file names for the stdout, stderr and temporary directory
# to be fast, we do not create anything until we really need it
# this could lead to issues, altough it is very unlikely
_TEMPORARY_PREFIX="${TMPDIR:-/tmp}/temp-"
_TEMPORARY_IN_MEM_PREFIX="${VALET_WORK_FILES_DIRECTORY:-${TMPDIR:-/tmp}}/temp-"
_TEMPORARY_WORK_FILE="${_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-work"
while [[ -e "${_TEMPORARY_WORK_FILE}" ]]; do _TEMPORARY_WORK_FILE+="x"; done
_TEMPORARY_STDOUT_FILE="${_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stdout"
while [[ -e "${_TEMPORARY_STDOUT_FILE}" ]]; do _TEMPORARY_STDOUT_FILE+="x"; done
_TEMPORARY_STDERR_FILE="${_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stderr"
while [[ -e "${_TEMPORARY_STDERR_FILE}" ]]; do _TEMPORARY_STDERR_FILE+="x"; done
_TEMPORARY_DIRECTORY="${_TEMPORARY_PREFIX}${BASHPID}.valet.d"
while [[ -e "${_TEMPORARY_DIRECTORY}" ]]; do _TEMPORARY_DIRECTORY+="x"; done

# Creates a temporary file and return its path in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  io::createTempFile && local file="${LAST_RETURNED_VALUE}"
function io::createTempFile() {
  if [[ ! -d "${_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${_TEMPORARY_DIRECTORY}" 1>&2 2>/dev/null
  fi
  TEMPORARY_FILE_NUMBER=${TEMPORARY_FILE_NUMBER:-0}
  while true; do
    TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
    LAST_RETURNED_VALUE="${_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -e "${LAST_RETURNED_VALUE}" ]]; then
      :>"${LAST_RETURNED_VALUE}"
      return 0
    fi
  done
}

# Creates a temporary directory and return its path in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  io::createTempDirectory && local directory="${LAST_RETURNED_VALUE}"
function io::createTempDirectory() {
  if [[ ! -d "${_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${_TEMPORARY_DIRECTORY}" 1>&2 2>/dev/null
  fi
  TEMPORARY_DIRECTORY_NUMBER=${TEMPORARY_DIRECTORY_NUMBER:-0}
  while true; do
    TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
    LAST_RETURNED_VALUE="${_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -d "${LAST_RETURNED_VALUE}" ]]; then
      mkdir -p "${LAST_RETURNED_VALUE}" 1>&2 2>/dev/null
      return 0
    fi
  done
}

# Removes all the tempoary files that were created.
#
# Usage:
#  io::cleanupTempFiles
# shellcheck disable=SC2016
function io::cleanupTempFiles() {
  if [[ -e "${_TEMPORARY_DIRECTORY}" ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${_TEMPORARY_DIRECTORY}" 1>&2 2>/dev/null
    unset TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
  fi
  if [[ -e "${_TEMPORARY_WORK_FILE}" ]]; then
    rm -f "${_TEMPORARY_WORK_FILE}" 1>&2 2>/dev/null
  fi
  if [[ -e "${_TEMPORARY_STDOUT_FILE}" ]]; then
    rm -f "${_TEMPORARY_STDOUT_FILE}" 1>&2 2>/dev/null
  fi
  if [[ -e "${_TEMPORARY_STDERR_FILE}" ]]; then
    rm -f "${_TEMPORARY_STDERR_FILE}" 1>&2 2>/dev/null
  fi
}

#===============================================================
# >>> Logging
#===============================================================

# determine the color mode expect if the user has set VALET_NO_COLOR
case "${TERM:-}" in
    xterm-color|xterm-256color|linux) VALET_NO_COLOR="${VALET_NO_COLOR:-false}";;
    xterm) if [[ -n "${COLORTERM:-}" ]]; then VALET_NO_COLOR="${VALET_NO_COLOR:-false}"; else VALET_NO_COLOR="${VALET_NO_COLOR:-true}"; fi ;;
    *) VALET_NO_COLOR="${VALET_NO_COLOR:-true}";;
esac

# This function sets the colors used in the log messages.
function log::setColors() {
  # the color code used to output colored text
  # shellcheck disable=SC2034
  if [[ ${VALET_CI_MODE:-} != true && ${VALET_NO_COLOR:-} != true ]]; then
    COLOR_DEFAULT=${VALET_COLOR_DEFAULT:-$'\e'"[0m"}
    COLOR_DEBUG=${VALET_COLOR_DEBUG:-$'\e'"[1;30m"}
    COLOR_INFO=${VALET_COLOR_INFO:-$'\e'"[0;36m"}
    COLOR_WARNING=${VALET_COLOR_WARNING:-$'\e'"[0;33m"}
    COLOR_SUCCESS=${VALET_COLOR_SUCCESS:-$'\e'"[0;32m"}
    COLOR_ERROR=${VALET_COLOR_ERROR:-$'\e'"[0;31m"}
    COLOR_TIMESTAMP=${VALET_COLOR_TIMESTAMP:-$'\e'"[1;90m"}
    COLOR_HIGHLIGHT=${VALET_COLOR_HIGHLIGHT:-$'\e'"[1;35m"}
  else
    COLOR_DEFAULT=""
    COLOR_DEBUG=""
    COLOR_INFO=""
    COLOR_WARNING=""
    COLOR_SUCCESS=""
    COLOR_ERROR=""
    COLOR_TIMESTAMP=""
    COLOR_HIGHLIGHT=""
  fi
}
log::setColors

# This function exports the terminal size in the global variables _COLUMNS and _LINES.
#
# Usage:
#   system::exportTerminalSize
function system::exportTerminalSize() {
  shopt -s checkwinsize; (:;:)
  _COLUMNS="${COLUMNS:-180}"
  _LINES="${LINES:-30}"
  shopt -u checkwinsize
}
system::exportTerminalSize

# Re export terminal size on window resize.
trap system::exportTerminalSize SIGWINCH

# Set the log level.
# The log level can be set to one of the following values:
# - debug
# - info
# - success
# - warning
# - error
#
# $1: the log level to set (or defaults to info)
# $2: true to silently switch log level (does not print a message)
#
# Usage:
#   log::setLevel "debug"
function log::setLevel() {
  # log level, defaults to info
  VALET_LOG_LEVEL="${1:-${VALET_LOG_LEVEL:-info}}"
  case "${VALET_LOG_LEVEL}" in
  error) _LOG_LEVEL_INT=4 ;;
  warning) _LOG_LEVEL_INT=3 ;;
  success) _LOG_LEVEL_INT=2 ;;
  debug) _LOG_LEVEL_INT=0 ;;
  *) _LOG_LEVEL_INT=1 ;;
  esac

  if [[ -z ${2:-} ]]; then
    if [[ ${_LOG_LEVEL_INT} -ne 1 ]]; then
      log::debug "Log level set to ${VALET_LOG_LEVEL}."
    fi
    if [[ ${_LOG_LEVEL_INT} -eq 0 ]]; then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# The log line function is used to display log messages in the terminal.
# The implementation depends on the environment variables VALET_CI_MODE and VALET_NO_WRAP.
# $1: the color of the log message (red, green, yellow, cyan, gray, pink)
# $2: the icon to display in the log message (utf8 character from nerdicons)
# $3: the severity of the log message (masx 7 chars)
# $*: the content of the log message
#
# Usage:
#   log::print "GREEN" $'\uf14a' "SUCCESS" "This is a success message."
# shellcheck disable=SC2317
function log::print() { return 0; }
# We build the log line function dynamically to adapt to the user options
# This avoid to have to check the options at each log message
# shellcheck disable=SC2016
function log::createPrintFunction() {
  # in CI mode, we disable wrapping, colors and icons
  if [[ ${VALET_CI_MODE:-} == "true" ]]; then
    VALET_NO_WRAP="${VALET_NO_WRAP:-true}"
    VALET_NO_ICON="${VALET_NO_ICON:-true}"
    VALET_NO_COLOR="${VALET_NO_COLOR:-true}"
  fi

  LOG_LINE_FUNCTION='
  function log::print() {
    local icon severity
    local -n color="COLOR_${1^^}"
    icon="${2}"
    severity="${3}"
    shift 3
    LAST_RETURNED_VALUE="$*"'
  if [[ "${VALET_NO_COLOR:-}" != "true" ]]; then
    # shellcheck disable=SC2016
    LOG_LINE_FUNCTION+='
    LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE//⌜/${COLOR_HIGHLIGHT}⌜}"
    LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE//⌝/⌝${COLOR_DEFAULT}}"'
  fi

  if [[ "${VALET_NO_WRAP:-}" != "true" ]]; then
    local wrapTextColumns="${VALET_LOG_COLUMNS:-${_COLUMNS}}"
    local wrapPaddingLength=20

    if [[ ${VALET_NO_TIMESTAMP:-} == "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 9))
    fi

    if [[ ${VALET_NO_ICON:-} == "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 2))
    fi

    LOG_LINE_FUNCTION+='
    string::wrapText "${LAST_RETURNED_VALUE}" '"${wrapTextColumns}"' '"${wrapPaddingLength}"''
  fi

  local printfFormat
  local printfArguments

  # timestamp
  if [[ ${VALET_CI_MODE:-} == "true" && "${VALET_NO_TIMESTAMP:-}" != "true" ]]; then
    printfFormat+="%(%F_%H:%M:%S)T "
    printfArguments+='"${EPOCHSECONDS}" '
  elif [[ ${VALET_NO_TIMESTAMP:-} == "true" ]]; then
    printfFormat+=""
  else
    printfFormat+="%s%(%H:%M:%S)T "
    printfArguments+='"${COLOR_TIMESTAMP}" "${EPOCHSECONDS}" '
  fi

  # severity
  if [[ ${VALET_NO_ICON:-} == "true" ]]; then
    printfFormat+="%s%-8s%s "
    printfArguments+='"${color}" "${severity}" "${COLOR_DEFAULT}" '
  else
    printfFormat+="%s%-8s%-4s%s "
    printfArguments+='"${color}" "${severity}" "${icon:-}" "${COLOR_DEFAULT}" '
  fi

  # message
  printfFormat+="%s\n"
  printfArguments+='"${LAST_RETURNED_VALUE}"'

  LOG_LINE_FUNCTION+='
    printf "'"${printfFormat}"'" '"${printfArguments}"' 1>&2
  }'
}
log::createPrintFunction
eval "${LOG_LINE_FUNCTION}"


# Displays an error message and then exit the program with error.
#
# $@: the error message to display
#
# Usage:
#   core::fail "This is an error message."
function core::fail() {
  log::error "$@"
  # shellcheck disable=SC2034
  ERROR_DISPLAYED=1
  exit 1
}

# Displays an error message.
# You probably want to exit immediately after an error and should consider using core::fail function instead.
#
# $@: the error message to display
#
# Usage:
#   log::error "This is an error message."
function log::error() {
  local message="$*"
  if log::isDebugEnabled; then
    log::getCallStack 2 && local stack=$'\n'"stack:${LAST_RETURNED_VALUE}"
    message+="${stack:-}"
  fi
  log::print "ERROR" $'\uf2d3' "ERROR" "${message}"
}

# Displays a warning and return a warning code.
# $*: the warning message to display
#
# Usage:
#   log::warning "This is a warning message."
function log::warning() {
  if [[ ${_LOG_LEVEL_INT:-1} -gt 3 ]]; then
    return 0
  fi
  log::print "WARNING" $'\uf071' "WARNING" "$*"
  return 0
}

# Displays a success message.
# $*: the success message to display
#
# Usage:
#   log::success "This is a success message."
function log::success() {
  if [[ ${_LOG_LEVEL_INT:-1} -gt 2 ]]; then
    return 0
  fi
  log::print "SUCCESS" $'\uf14a' "SUCCESS" "$*"
  return 0
}

# Displays an info message.
# $*: the info message to display
#
# Usage:
#   log::info "This is an info message."
function log::info() {
  if [[ ${_LOG_LEVEL_INT:-1} -gt 1 ]]; then
    return 0
  fi
  log::print "INFO" $'\uf05a' "INFO" "$*"
  return 0
}

# Displays a debug message if the global variable DEBUG is set to true.
# $*: the debug message to display
#
# Usage:
#   log::debug "This is a debug message."
function log::debug() {
  if [[ ${_LOG_LEVEL_INT:-1} -gt 0 ]]; then
    return 0
  fi
  log::print "DEBUG" $'\uf0ae' "DEBUG" "$*"
  return 0
}

# Returns 0 if debug mode is active, 1 otherwise.
#
# Usage:
#   log::isDebugEnabled && echo "Debug mode is active."
function log::isDebugEnabled() {
  if [[ ${_LOG_LEVEL_INT:-1} -eq 0 ]]; then
    return 0
  fi
  return 1
}

# This function returns the current function stack.
# The stack is returned in the global variable LAST_RETURNED_VALUE.
#
# $1: the number of levels to skip (default to 2)
#
# Usage:
#   log::getCallStack 2 && local stack="${LAST_RETURNED_VALUE}"
function log::getCallStack() {
  local -i levelToSkip="${1:-2}"
  local stack i stackSize func linen src
  stack=""
  stackSize=${#FUNCNAME[@]}
  treeString="├─"
  for ((i = levelToSkip; i < stackSize; i++)); do
    func="${FUNCNAME[${i}]}"
    if [[ -z "${func}" ]]; then func=MAIN; fi
    linen="${BASH_LINENO[$((i - 1))]}"
    src="${BASH_SOURCE[${i}]}"
    if [[ -z "${src}" ]]; then src=non_file_source; fi
    if [[ ${i} -eq "$((stackSize - 1))" ]]; then
      treeString="└─"
    fi
    stack+=$'\n'"${treeString} In function ${func}() ${src}:${linen}"
  done
  LAST_RETURNED_VALUE="${stack}"
}

# Parsing the options from environment variables
if [[ -n "${VALET_LOG_LEVEL:-}" ]]; then
  log::setLevel "${VALET_LOG_LEVEL}"
fi
if [[ ${VALET_VERBOSE=:-} == "true" ]]; then
  log::setLevel "debug"
fi

#===============================================================
# >>> Core utilities
#===============================================================

# Allows to include a library file. It sources a file.
# It replaces the builtin source command to make sure that we do not include the same file twice.
# This also allows us to specify to spellcheck the included file.
#
# $1: the name of the library (array, interactive, string...) or the file path to include.
#
# Notes:
#   The file can be relative to the current script (script that calls this function).
#   This function makes sure that we do not include the same file twice.
#
# Usage:
#   source string array system
#   source ./my/path my/other/path
function source() {
  local filePathToInclude includedFile
  if [[ -e "${VALET_HOME}/valet.d/lib-${1}" ]]; then
    filePathToInclude="${VALET_HOME}/valet.d/lib-${1}"
  elif [[ -e "${BASH_SOURCE[1]%/*}/${1}" ]]; then
    filePathToInclude="${BASH_SOURCE[1]%/*}/${1}"
  elif [[ -e "${1}" ]]; then
    filePathToInclude="${1}"
  else
    core::fail "The file ${1} could not be found."
  fi
  for includedFile in "${_LIST_OF_INCLUDED_FILES[@]}"; do
    if [[ ${includedFile} == "${filePathToInclude}" ]]; then
      return 0
    fi
  done
  shift
  # shellcheck source=/dev/null
  builtin source "${filePathToInclude}" "$@"
  _LIST_OF_INCLUDED_FILES+=("${filePathToInclude}")
}
_LIST_OF_INCLUDED_FILES=()

# Allows to reset the included files.
# When calling the include function, it will source the files again.
# This is useful when we want to reload the libraries.
#
# Usage:
#   core::resetIncludedFiles
function core::resetIncludedFiles() {
  _LIST_OF_INCLUDED_FILES=()
}

# Source the file associated with the function if needed.
# $1: the function name
#
# Usage:
#  core::sourceForFunction "functionName"
function core::sourceForFunction() {
  local functionName
  functionName="${1}"

  local fileToSource
  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -e "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -e "${VALET_HOME:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${VALET_HOME:-}/${fileToSource}"
      log::debug "Loaded file ⌜${VALET_HOME:-}/${fileToSource}⌝."
    else
      log::warning "The file ⌜${VALET_HOME:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we use the examples commands.
#
# Usage:
#  core::sourceUserCommands
function core::sourceUserCommands() {
  if [[ -n "${_CMD_INCLUDED:-}" ]]; then
    return 0
  fi

  # source the user commands
  local userDirectory
  core::getUserDirectory && userDirectory="${LAST_RETURNED_VALUE}"

  local commandsFile
  commandsFile="${userDirectory}/commands"

  # if the commands file does not exist, we use the examples commands or we fail
  if [[ ! -e "${commandsFile}" ]]; then
    local message
    message="The valet user directory ⌜${userDirectory}⌝ does not contain a built ⌜commands⌝ file."$'\n'
    message+="To get started with valet, you must build your command list using the ⌜valet self build⌝ command."$'\n'
    message+="Please check the help using ⌜valet self build --help⌝ for details."
    commandsFile="${VALET_HOME}/examples.d/commands"
    if [[ -e "${commandsFile}" ]]; then
      message+=$'\n'"Now using the examples commands from ⌜${commandsFile%/*}⌝."
      log::warning "${message}"
    else
      core::fail "${message}"
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  builtin source "${commandsFile}"
}

# Forcibly source again the user 'commands' file from the valet user directory.
#
# Usage:
#  core::reloadUserCommands
function core::reloadUserCommands() {
  # delete previous variables
  unset -v ${!CMD_*}
  unset -v _CMD_INCLUDED
  core::sourceUserCommands
}

#===============================================================
# >>> String utilities
#===============================================================

# Allows to soft wrap the given text at the given width.
# Optionally applies left padding to each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the padding to apply to each new line (default to 0)
# $4: true/false if the padding should be applied to the first line (default to false)
# Returns the wrapped text in the global variable LAST_RETURNED_VALUE
#
# Usage:
#   string::wrapText "This is a long text that should be wrapped at 20 characters." 20 2 false && local wrappedText="${LAST_RETURNED_VALUE}"
#
# Note:
#   This function is written in pure bash and is faster than calling the fold command.
function string::wrapText() {
  local text width leftPaddingLength appendPaddingToFirstLine
  text="${1}"
  width="${2:-_COLUMNS}"
  leftPaddingLength="${3:-0}"
  appendPaddingToFirstLine="${4:-false}"

  # compute padding in number of spaces
  local leftPadding
  leftPadding=""
  for ((i = 0; i < leftPaddingLength; i++)); do
    leftPadding+=" "
  done

  local sentenceWidth=$((width - leftPaddingLength))

  local wrappedText

  # TODO: check if faster if we skip the loop in case the text does not have new lines

  # we call string::wrapSentence for each line of the text
  local firstLine="1"
  local line
  while read -r line; do
    wrappedText+=$'\n'
    string::wrapSentence "${line}" "${sentenceWidth}" "${leftPadding}"
    if [[ ${firstLine} == "1" ]]; then
      firstLine="0"
    else
      wrappedText+="${leftPadding}"
    fi
    wrappedText+="${LAST_RETURNED_VALUE}"
  done <<< "${text}"

  # add left padding on the first line (or not)
  if [[ ${appendPaddingToFirstLine} == "true" ]]; then
    LAST_RETURNED_VALUE="${leftPadding}${wrappedText#$'\n'}"
  else
    LAST_RETURNED_VALUE="${wrappedText#$'\n'}"
  fi
}

# Allows to soft wrap the given sentence (without new lines) at the given width.
# Optionally applies a prefix on each new line.
# $1: the text to wrap
# $2: the width to wrap the text at
# $3: the prefix to apply to each new line (default to "")
# Returns the wrapped text in the global variable LAST_RETURNED_VALUE
#
# Usage:
#   string::wrapSentence "This is a long text that should be wrapped at 20 characters." 20 && local wrappedText="${LAST_RETURNED_VALUE}"
#
# Note:
#   This function is written in pure bash and is faster than calling the fold command.
function string::wrapSentence() {
  local text newLinePrefix
  local -i width
  text="${1}"
  width="${2}"
  newLinePrefix="${3:-}"

  # short cut in case the text is already shorter than the width
  if [[ "${#text}" -le width ]]; then
    LAST_RETURNED_VALUE="${text}"
    return 0
  fi

  # new line to append
  local newLine
  newLine=$'\n'"${newLinePrefix}"

  local wrappedText word
  local -i spaceLeft wordLength partialWordLength
  wrappedText=""
  spaceLeft=${width}
  local firstWord="1"
  for word in ${text}; do

    if [[ ${firstWord} == "1" ]]; then
      firstWord="0"
    else
      # we just added a word
      if [[ spaceLeft -gt 0 ]]; then
        # if we have space left, we add a space
        wrappedText+=" "
        spaceLeft=$((spaceLeft - 1))
      else
        # otherwise we add a new line
        wrappedText+="${newLine}"
        spaceLeft=${width}
      fi
    fi

    wordLength=${#word}

    if [[ wordLength -le spaceLeft ]]; then
      # we have the space to add the word
      wrappedText+="${word}"
      spaceLeft=$((spaceLeft - wordLength))
    else
      # we don't have the space to add the word

      # will the word fit in the width of the next line?
      if [[ wordLength -le width ]]; then
        # then we add the word to the next line
        wrappedText+="${newLine}${word}"
        spaceLeft=$((width - wordLength))
      else
        # the word doesn't fit in the width of the next line
        # we can add the partial word to the current line
        # and the rest on the next lines until we have the full word
        while [[ wordLength -gt 0 ]]; do
          partialWordLength="${wordLength}"
          if [[ partialWordLength -gt spaceLeft ]]; then
            partialWordLength="${spaceLeft}"
          fi
          wrappedText+="${word:0:${partialWordLength}}"
          word="${word:${partialWordLength}}"
          wordLength=$((wordLength - partialWordLength))
          spaceLeft=$((spaceLeft - partialWordLength))
          if [[ spaceLeft -eq 0 && wordLength -gt 0 ]]; then
            wrappedText+="${newLine}"
            spaceLeft="${width}"
          fi
        done
      fi
    fi
  done

  LAST_RETURNED_VALUE="${wrappedText}"
}

# Allows to fuzzy match a line against a given pattern.
# Returns the best match from all lines.
# Or an empty string if no match is found.
# $1: the pattern to match
# $2: the text (multiple lines) to match against
#
# Usage:
#   string::fuzzyMatch "pattern" "line1\nline2\nline3" && local bestMatch="${LAST_RETURNED_VALUE}"
#
# Note:
#   This function is written in pure bash and is faster than the fzf command.
#   All characters in the pattern must be found in the same order in the matched line.
#   The function is case sensitive.
#   We prioritize the lines that start with the pattern.
#   Then we prioritize the lines that have the less distance between characters in the pattern.
function string::fuzzyMatch() {
  local pattern text
  pattern="${1}"
  text="${2}"

  local bestMatch
  local -i patternLength lineLength bestIndex bestDistance
  patternLength="${#pattern}"
  bestIndex=999999
  bestDistance=999999

  local IFS=$'\n'
  local line patternChar lineChar
  local -i lineCharIndex patternCharIndex lastLineCharIndex distance patternFirstCharIndex
  for line in ${text}; do
    # shortcut, exact match
    if [[ ${line} == "${pattern}" ]]; then
      LAST_RETURNED_VALUE="${line}"
      return 0
    fi
    lineLength="${#line}"

    # for each character in the pattern
    patternCharIndex=0
    lineCharIndex=0
    lastLineCharIndex=0
    while [[ patternCharIndex -lt patternLength ]]; do
      patternChar="${pattern:${patternCharIndex}:1}"

      # find the character in the line
      while [[ lineCharIndex -lt lineLength ]]; do
        lineChar="${line:${lineCharIndex}:1}"

        if [[ ${lineChar} == "${patternChar}" ]]; then
          # if we find the character, mark the distance
          distance=$((lineCharIndex - lastLineCharIndex))
          lastLineCharIndex=${lineCharIndex}

          # if it is the first char of the pattern, remmember the index
          if [[ patternCharIndex -eq 0 ]]; then
            patternFirstCharIndex=${lineCharIndex}
          fi

          # loop on the next pattern character
          break;
        fi

        lineCharIndex+=1
      done

      # if we don't find the character in the line, the line is not a match
      if [[ lineCharIndex -ge lineLength ]]; then
        break;
      else
        lineCharIndex+=1
      fi

      patternCharIndex+=1
    done

    # if we found all the characters in the pattern
    if [[ patternCharIndex -ge patternLength ]]; then

      # we found the pattern at a lower index or we found the pattern at the same index but with less distance
      if [[ patternFirstCharIndex -lt bestIndex || (patternFirstCharIndex -eq bestIndex && distance -lt bestDistance) ]]; then
        bestIndex="${patternFirstCharIndex}"
        bestDistance="${distance}"
        bestMatch="${line}"
      fi
    fi

  done

  LAST_RETURNED_VALUE="${bestMatch:-}"
}

#===============================================================
# >>> Valet files and directories
#===============================================================

# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Usage:
#   core::getConfigurationDirectory && local directory="${LAST_RETURNED_VALUE}"
function core::getConfigurationDirectory() {
  local directory
  directory="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-$HOME/.config}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  LAST_RETURNED_VALUE="${directory}"
}

# Returns the path to the valet locla state directory.
# The base directory relative to which user-specific state files should be stored.
# Creates it if missing.
#
# Usage:
#   core::getLocalStateDirectory && local directory="${LAST_RETURNED_VALUE}"
function core::getLocalStateDirectory() {
  local directory
  directory="${VALET_LOCAL_STATE_DIRECTORY:-${XDG_STATE_HOME:-$HOME/.local/share}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  LAST_RETURNED_VALUE="${directory}"
}

# Returns the path to the valet user directory.
# Does not create it if missing.
#
# Usage:
#   core::getUserDirectory && local directory="${LAST_RETURNED_VALUE}"
function core::getUserDirectory() {
  LAST_RETURNED_VALUE="${VALET_USER_DIRECTORY:-${HOME}/.valet.d}"
}

#===============================================================
# >>> Parser and interactive mode
#===============================================================

# Show the help for the current function.
# This should be called from a command function for which you want to display the help text.
#
# Usage:
#   core::showHelp
function core::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::printHelp funtion "${functionName}"
}

# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# Usage:
#   core::parseArguments "$@" && eval "${LAST_RETURNED_VALUE}"
#
# Notes:
#   - It will return a string that can be evaluated to set the variables
#     corresponding to the arguments and options; e.g.:
#       local arg1 option1
#       arg1="xxx"
#       option1="xxx"
#       ...
#   - It will also set the variable parsingErrors if there are any errors.
#   - Variable name for an option is taken from the first --long version of the option.
#   - If the function expects arguments or options but none are provided, it will
#     automatically go into interactive mode and ask the user inputs.
#   - It will set the variable as an array if the (last) argument name ends with '...'
function core::parseArguments() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::parseFunctionArgumentsOrmain::goInteractive "${functionName}" "$@"
}

# A convenience function to check the parsing results and display an error message if needed.
# Will also display the help if the help option is true.
# This should be called from a command function for which you want to check the parsing results.
#
# Usage:
#   core::checkParseResults "${help:-}" "${parsingErrors:-}"
#   core::checkParseResults "${help:-}" "${parsingErrors:-}" "myFunctionName"
function core::checkParseResults() {
  local functionName help parsingErrors
  functionName="${3:-${FUNCNAME[1]}}"

  help="${1:-}"
  parsingErrors="${2:-}"

  if [[ -n "${help}" ]]; then
    main::printHelp function "${functionName}"
    exit 0
  fi

  if [[ -n "${parsingErrors:-}" ]]; then
    local -n commandName="CMD_COMMAND_${functionName}"
    core::fail "${parsingErrors}"$'\n'"Use valet ${commandName} --help to get help."
  fi
}

#===============================================================
# >>> Include main
#===============================================================

if [[ -z "${_MAIN_INCLUDED:-}" ]]; then
  # shellcheck source=main
  source "${VALET_HOME}/valet.d/main"
fi