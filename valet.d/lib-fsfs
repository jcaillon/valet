#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# fsfs stands for full srceen fuzzy search.
# This script uses a lot of "private" variables (starting with _).

# shellcheck source=lib-ansi-codes
source ansi-codes
# shellcheck source=lib-interactive
source interactive
# shellcheck source=lib-io
source io

#===============================================================
# >>> Customization
#===============================================================

_LEFT_PANE_HELP_TEXT="↑/↓: Move | Enter: Select | Esc: Quit"
_RIGHT_PANE_HELP_TEXT="←/→: Scroll"
_RIGHT_PANE_TITLE="Details"

# arrays of current items and their details (if any and if already computed)
declare -a _ITEMS
declare -a _ITEMS_DETAILS
declare -a FSFS_FETCHED_DETAILS_INDEXES

# width of the left pane when the right pane is on
declare -i _LEFT_PANE_WIDTH
# current item selected
declare -i _SELECTED_ITEM_INDEX=0
# index of the first item displayed in the left pane
declare -i _LEFT_PANE_START_INDEX=0
# screen line at which to start to display the left pane
declare -i _LEFT_PANE_FIRST_LINE=1
# number of lines for the left pane
declare -i _LEFT_LINES

# width of the right pane
declare -i _RIGHT_PANE_WIDTH
# index of the first line displayed in the right pane
declare -i _RIGHT_PANE_START_INDEX=0
# screen line at which to start to display the right pane
declare -i _RIGHT_PANE_FIRST_LINE=1
# number of lines for the right pane
declare -i _RIGHT_LINES

# contains the current search string of the user
declare _SEARCH_STRING

# true when the user asked to close the interactive session
declare _CLOSE_INTERACTIVE_SESSION

#===============================================================
# >>> Custom drawing functions
#===============================================================

# Displays a menu where the user can search and select an item.
# The menu is displayed in full screen.
# Each item can optionally have a description/details shown in a right panel.
# The user can search for an item by typing.
#
# $1: The title of the menu.
# $2: The items to display.
# $3: The function to call when an item is selected (the 1st param is the current item
#     2nd param is the item number; 3rd is the current panel width; it should return
#     the details of the item in the LAST_RETURNED_VALUE variable).
function fsfs::menu() {
  _HEADER="${1}"
  local items="${2}"
  _ITEM_SELECTED_CALLBACK="${3}"

  # wrap the header
  string::wrapText "${_HEADER}" "${GLOBAL_COLUMNS}"
  _HEADER="${LAST_RETURNED_VALUE}"

  # extract items into an array
  local line IFS
  while IFS= read -r line; do
    _ITEMS+=("${line}")
  done <<<"${items}"

  _SELECTED_ITEM_INDEX=0
  _LEFT_PANE_START_INDEX=0
  _RIGHT_PANE_START_INDEX=0
  FSFS_FETCHED_DETAILS_INDEXES=()

  _CLOSE_INTERACTIVE_SESSION=false
  _SEARCH_STRING=""

  # save the original traps so we can restore them later
  local originalTraps
  io::captureOutput trap -p SIGWINCH EXIT SIGINT SIGQUIT
  originalTraps="${LAST_RETURNED_VALUE}"

  # we still need to export the terminal size but in addition, we need to _drawScreen.
  # Note: SIGWINCH does not interrupt a read command and wait for it to complete so we need
  # to set a timeout on read to allow this refresh.
  trap 'onResize;' SIGWINCH

  # still need to handle the exit, but we also need to reset the terminal when exiting.
  trap '_resetTerminal; main::onExitInternal;' EXIT

  # interrupting closes the interactive session
  trap '_interruptSession;' SIGINT SIGQUIT

  _setupTerminal
  _drawScreen full

  # main loop
  while true; do
    read -t 0.05 -srn 1 && key "${REPLY}"

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 || ${_CLOSE_INTERACTIVE_SESSION} == "true" ]]; then break; fi

    # # redraw the screen if the terminal was resized
    if [[ ${FSFS_REDRAW_REQUIRED:-false} == "true" ]]; then
      _drawScreen full
    fi
  done

  # restore the initial traps
  eval "${originalTraps}"
  _resetTerminal
}

function onResize() {
  # export terminal size does not work if
  exec 2>&4 4>&-
  system::exportTerminalSize
  exec 4>&2 2>"${FSFS_TEMPORARY_ERROR_FILE}"
  FSFS_REDRAW_REQUIRED=true
}

function fuuuuck() {
  return 0
}

function _drawScreen() {
  local drawMode="${1:-full}"

  FSFS_REDRAW_REQUIRED=false

  if [[ ${drawMode} == "full" ]]; then
    # compute the potential width of the right panel
    _RIGHT_PANE_WIDTH=$((GLOBAL_COLUMNS * 9 / 20))
    FSFS_FETCHED_DETAILS_INDEXES=()

    _drawStaticScreen

    drawMode="left-right"
  fi

  # get the details for the current item; this will tell us if we need a right pane
  # or not
  local hasDetails=${FSFS_FETCHED_DETAILS_INDEXES[${_SELECTED_ITEM_INDEX}]:-unknown}
  if [[ ${hasDetails} == "unknown" && -n ${_ITEM_SELECTED_CALLBACK:-} ]]; then
    "${_ITEM_SELECTED_CALLBACK}" "${_ITEMS[${_SELECTED_ITEM_INDEX}]}" "${_SELECTED_ITEM_INDEX}" "$((_RIGHT_PANE_WIDTH - 4))"
    _ITEMS_DETAILS[_SELECTED_ITEM_INDEX]="${LAST_RETURNED_VALUE}"
    if [[ -n ${LAST_RETURNED_VALUE} ]]; then
      hasDetails=true
    else
      hasDetails=false
    fi
    FSFS_FETCHED_DETAILS_INDEXES[_SELECTED_ITEM_INDEX]="${hasDetails}"
  fi

  # if we have details, we need to draw the right pane and
  # adjust the left pane width
  if [[ ${hasDetails} == "true" ]]; then
    _LEFT_PANE_WIDTH=$((GLOBAL_COLUMNS - _RIGHT_PANE_WIDTH))
  else
    _LEFT_PANE_WIDTH=${GLOBAL_COLUMNS}
  fi

  if [[ ${drawMode} == *"right"* && ${hasDetails} == "true" ]]; then
    _drawRightPane
  fi

  if [[ ${drawMode} == *"left"* ]]; then
    _drawLeftPane
  fi
}

function _drawRightPane() {
  local details="${_ITEMS_DETAILS[_SELECTED_ITEM_INDEX]}"
  local IFS

  # draw the title
  local titleWidth=$((${#_RIGHT_PANE_TITLE} + 2))
  local title=" ${_RIGHT_PANE_TITLE} "
  if ((titleWidth > _RIGHT_PANE_WIDTH - 6)); then
    titleWidth=0
    title=""
  fi
  local titlePadding=$(((_RIGHT_PANE_WIDTH - titleWidth) / 2 - 3))
  printf '%s%s\n' \
    "${AC__CURSOR_MOVE__}${_RIGHT_PANE_FIRST_LINE};$((_LEFT_PANE_WIDTH + 1))${__AC__TO}" \
    "┌─${AC__REPEAT__}${titlePadding}${__AC__LAST_CHAR}${title}─${AC__REPEAT__}$((_RIGHT_PANE_WIDTH - titleWidth - titlePadding - 2 - 2))${__AC__LAST_CHAR}┐"

  # draw the details
  local -i currentLine=1
  local -i currentIndex=0
  local line
  while IFS= read -r line; do
    currentIndex+=1
    if ((currentIndex < _RIGHT_PANE_START_INDEX + 1)); then
      continue
    fi
    printf "%s%s%s%s\n" "${AC__CURSOR_MOVE__}$((_RIGHT_PANE_FIRST_LINE + currentLine));$((_LEFT_PANE_WIDTH + 1))${__AC__TO}${AC__ERASE_CHARS_RIGHT}" "│ " "${line}" "${AC__CURSOR_MOVE__}$((GLOBAL_COLUMNS))${__AC__COLUMN}│"
    currentLine+=1
    if ((currentLine >= _RIGHT_LINES - 1)); then
      break
    fi
  done <<<"${details}"

  # draw last line with help text
  local helpWidth=$((${#_RIGHT_PANE_HELP_TEXT} + 2))
  local help=" ${_RIGHT_PANE_HELP_TEXT} "
  if ((helpWidth > _RIGHT_PANE_WIDTH - 6)); then
    helpWidth=0
    help=""
  fi
  printf '%s%s' \
    "${AC__CURSOR_MOVE__}$((GLOBAL_LINES));$((_LEFT_PANE_WIDTH + 1))${__AC__TO}" \
    "└─${AC__REPEAT__}$((_RIGHT_PANE_WIDTH - helpWidth - 4))${__AC__LAST_CHAR}${help}─┘"

}

function _drawLeftPane() {
  return 0
}

function _drawStaticScreen() {
  local IFS

  # clear the screen, move to the top left corner
  printf '%s' "${AC__ERASE_SCREEN}${AC__CURSOR_MOVE__}1;1${__AC__TO}"

  local leftPaneWidth=$((GLOBAL_COLUMNS - _RIGHT_PANE_WIDTH))

  # draw the header
  _LEFT_PANE_FIRST_LINE=1
  _RIGHT_PANE_FIRST_LINE=1
  local line headerOverflowing=false
  while IFS= read -r line; do
    printf '%s\n' "${line}"
    _LEFT_PANE_FIRST_LINE+=1
    if ((${#line} > leftPaneWidth)); then
      headerOverflowing=true
    fi
  done <<<"${_HEADER}"
  # if the header is too long, we can't start the right pane at line 1
  if [[ ${headerOverflowing} == "true" ]]; then
    _RIGHT_PANE_FIRST_LINE=${_LEFT_PANE_FIRST_LINE}
  fi

  _LEFT_LINES=$((GLOBAL_LINES - _LEFT_PANE_FIRST_LINE))
  _LEFT_LINES=$((_LEFT_LINES > 0 ? _LEFT_LINES : 1))
  _RIGHT_LINES=$((GLOBAL_LINES - _RIGHT_PANE_FIRST_LINE + 1))
  _RIGHT_LINES=$((_RIGHT_LINES > 0 ? _RIGHT_LINES : 1))

  # draw the left help text
  printf '%s' "${AC__CURSOR_MOVE__}$((GLOBAL_LINES));1${__AC__TO}${AC__ERASE_LINE}${_LEFT_PANE_HELP_TEXT}"

  writeToStatusBar "Screen is ${GLOBAL_LINES}x${GLOBAL_COLUMNS}."
}

function _setupTerminal() {
  # disable echoing when we type something
  if command -v stty &>/dev/null; then
    stty -echo &>/dev/null || true
  fi
  # switch to the alternate screen, hide the cursor and clear the screen
  printf '%s' "${AC__ENABLE_ALTERNATE_BUFFER_SCREEN}${AC__DISABLE_LINE_WRAPPING}${AC__CURSOR_HIDE}${AC__ERASE_SCREEN}"

  # in full screen mode, we don't see the error messages so we capture them somewhere else
  FSFS_TEMPORARY_ERROR_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-interactive.err"
  while [[ -e "${FSFS_TEMPORARY_ERROR_FILE}" ]]; do FSFS_TEMPORARY_ERROR_FILE+="x"; done
  exec 4>&2 2>"${FSFS_TEMPORARY_ERROR_FILE}"
}

function _resetTerminal() {
  # restore the terminal state
  printf '%s' "${AC__ENABLE_LINE_WRAPPING}${AC__CURSOR_SHOW}${AC__DISABLE_ALTERNATE_BUFFER_SCREEN}"
  # restore the key echoing
  if command -v stty &>/dev/null; then
    stty echo &>/dev/null || true
  fi

  # restore the error output and display them if any
  exec 2>&4 4>&-
  if [[ -s "${FSFS_TEMPORARY_ERROR_FILE}" ]]; then
    io::readFile "${FSFS_TEMPORARY_ERROR_FILE}"
    log::error "Error messages during the interactive session:"$'\n'"${LAST_RETURNED_VALUE%$'\n'}"
  fi
}

function _interruptSession() {
  _CLOSE_INTERACTIVE_SESSION=true
  return 0
}

STATUS_LINE=0
# Write a message to the status bar.
function writeToStatusBar() {
  printf '%s' "${AC__CURSOR_MOVE__}$((GLOBAL_LINES - 1 - STATUS_LINE));1${__AC__TO}${AC__ERASE_LINE}${AC__TEXT_BOLD}${1}${AC__TEXT_RESET}"
  STATUS_LINE=$((STATUS_LINE + 1))
}

function key() {
  local keyPressed="${1}"
  local specialKeyPress=false

  # Special key detection.
  if [[ ${keyPressed} == $'\e' ]]; then
    read -t 0.1 -rsn 2
    keyPressed="${keyPressed}${REPLY}"
    specialKeyPress=true

    local sk2
    printf -v sk2 "%q" "${keyPressed}"
  fi

  case ${keyPressed} in
  $'\e[C' | $'\eOC' | "")
    _RIGHT_PANE_START_INDEX=$((_RIGHT_PANE_START_INDEX + 1))
    _drawRightPane
    ;;
  $'\e[D' | $'\eOD' | $'\177' | $'\b')
    _RIGHT_PANE_START_INDEX=$((_RIGHT_PANE_START_INDEX - 1))
    _drawRightPane
    ;;
  $'\e[B' | $'\eOB')
    writeToStatusBar down
    ;;
  $'\e[A' | $'\eOA')
    writeToStatusBar up
    ;;
  s)
    writeToStatusBar Start search
    search "search"
    ;;
  q)
    _CLOSE_INTERACTIVE_SESSION=true
    ;;
  *)
    if [[ ${specialKeyPress} == "false" ]]; then
      writeToStatusBar "Normal key pressed: ⌜${keyPressed}⌝."
    fi
    ;;
  esac
}

function search() {
  local keyPressed
  local searchString=""

  printf '%s' "${AC__CURSOR_SHOW}${AC__CURSOR_MOVE__}$((GLOBAL_LINES));1${__AC__TO}${AC__ERASE_LINE}"

  while IFS= read -rsn 1 -p "${AC__CURSOR_HIDE}${_drawScreenPrompt}${AC__CURSOR_SHOW}${AC__TEXT_BOLD}SEARCH:${AC__TEXT_RESET} ${searchString}" keyPressed; do
    case ${keyPressed} in
    # Backspace.
    $'\177' | $'\b')
      searchString=${searchString%?}
      ;;
    # Escape key.
    $'\e')
      read -t 0.1 -rsn 2
      searchString=
      break
      ;;
    # Enter/Return.
    "")
      writeToStatusBar "You searched: ${searchString}"
      break
      ;;
    *)
      searchString+=$keyPressed
      ;;
    esac
  done

  printf '%s' "${AC__CURSOR_HIDE}${AC__ERASE_LINE}"
}
