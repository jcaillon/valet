#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# fsfs stands for full srceen fuzzy search.
# This script uses a lot of "private" variables (starting with _).

# shellcheck source=lib-ansi-codes
source ansi-codes
# shellcheck source=lib-interactive
source interactive
# shellcheck source=lib-io
source io

#===============================================================
# >>> Customization
#===============================================================

HAS_PREVIEW=true
_LEFT_PANE_HELP_TEXT="↑/↓: Move | Enter: Select | Esc: Quit"
_RIGHT_PANE_HELP_TEXT="←/→: Scroll | Page up/down: Scroll x3"
_RIGHT_PANE_TITLE="Details"

# arrays of current items and their details (if any and if already computed)
declare -a _ITEMS
declare -a _ITEMS_DETAILS
declare -a FSFS_FETCHED_DETAILS_INDEXES

# width of the left pane when the right pane is on
declare -i _LEFT_PANE_WIDTH
# current item selected
declare -i _SELECTED_ITEM_INDEX=0
# index of the first item displayed in the left pane
declare -i _LEFT_PANE_START_INDEX=0
# screen line at which to start to display the left pane
declare -i _LEFT_PANE_FIRST_LINE=1
# number of lines for the left pane
declare -i _LEFT_LINES

# width of the right pane
declare -i _RIGHT_PANE_WIDTH
# index of the first line displayed in the right pane
declare -i _RIGHT_PANE_START_INDEX=0
# screen line at which to start to display the right pane
declare -i _RIGHT_PANE_FIRST_LINE=1
# number of lines for the right pane
declare -i _RIGHT_LINES

# true when the user asked to close the interactive session
declare _CLOSE_INTERACTIVE_SESSION

#===============================================================
# >>> Custom drawing functions
#===============================================================

# Displays a menu where the user can search and select an item.
# The menu is displayed in full screen.
# Each item can optionally have a description/details shown in a right panel.
# The user can search for an item by typing.
#
# $1: The title of the menu.
# $2: The items to display.
# $3: The function to call when an item is selected (the 1st param is the current item
#     2nd param is the item number; 3rd is the current panel width; it should return
#     the details of the item in the LAST_RETURNED_VALUE variable).
function fsfs::menu() {
  _HEADER="${1}"
  local items="${2}"
  _ITEM_SELECTED_CALLBACK="${3}"

  # wrap the header
  string::wrapText "${_HEADER}" "${GLOBAL_COLUMNS}"
  _HEADER="${LAST_RETURNED_VALUE}"

  # extract items into an array
  local line IFS
  while IFS= read -r line; do
    _ITEMS+=("${line}")
  done <<<"${items}"

  _SELECTED_ITEM_INDEX=0
  _LEFT_PANE_START_INDEX=0
  _RIGHT_PANE_START_INDEX=0
  FSFS_FETCHED_DETAILS_INDEXES=()

  # contains the current search string of the user
  declare _SEARCH_STRING

  _CLOSE_INTERACTIVE_SESSION=false
  _SEARCH_STRING=""

  # save the original traps so we can restore them later
  local originalTraps
  io::captureOutput trap -p SIGWINCH EXIT SIGINT SIGQUIT
  originalTraps="${LAST_RETURNED_VALUE}"

  # we still need to export the terminal size but in addition, we need to drawScreen.
  # Note: SIGWINCH does not interrupt a read command and wait for it to complete so we need
  # to set a timeout on read to allow this refresh.
  trap 'onResize;' SIGWINCH

  # still need to handle the exit, but we also need to reset the terminal when exiting.
  trap 'interactive::switchBackFromFullScreen; main::onExitInternal;' EXIT

  # interrupting closes the interactive session
  trap 'onSessionInterrupted;' SIGINT SIGQUIT

  interactive::switchToFullScreen
  drawScreen full

  # main loop
  while true; do
    if interactive::waitForKey -t 0.05; then
      onKeyPressed "${LAST_KEY_PRESSED}"
    fi

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 || ${_CLOSE_INTERACTIVE_SESSION} == "true" ]]; then break; fi

    # # redraw the screen if the terminal was resized
    if [[ ${FSFS_REDRAW_REQUIRED:-false} == "true" ]]; then
      drawScreen full
    fi
  done

  # restore the initial traps
  eval "${originalTraps}"
  interactive::switchBackFromFullScreen
}

function drawScreen() {
  local drawMode="${1:-full}"

  # hide the cursor
  printf '%s' "${AC__CURSOR_HIDE}"

  FSFS_REDRAW_REQUIRED=false

  if [[ ${drawMode} == "full" ]]; then
    # compute the potential width of the right panel
    _RIGHT_PANE_WIDTH=$((GLOBAL_COLUMNS * 9 / 20))
    FSFS_FETCHED_DETAILS_INDEXES=()

    _drawStaticScreen

    drawMode="left-right"
  fi

  # get the details for the current item; this will tell us if we need a right pane
  # or not
  local hasDetails=${FSFS_FETCHED_DETAILS_INDEXES[${_SELECTED_ITEM_INDEX}]:-unknown}
  if [[ ${hasDetails} == "unknown" && -n ${_ITEM_SELECTED_CALLBACK:-} ]]; then
    "${_ITEM_SELECTED_CALLBACK}" "${_ITEMS[${_SELECTED_ITEM_INDEX}]}" "${_SELECTED_ITEM_INDEX}" "$((_RIGHT_PANE_WIDTH - 4))"
    _ITEMS_DETAILS[_SELECTED_ITEM_INDEX]="${LAST_RETURNED_VALUE}"
    if [[ -n ${LAST_RETURNED_VALUE} ]]; then
      hasDetails=true
    else
      hasDetails=false
    fi
    FSFS_FETCHED_DETAILS_INDEXES[_SELECTED_ITEM_INDEX]="${hasDetails}"
  fi

  # if we have details, we need to draw the right pane and
  # adjust the left pane width
  if [[ ${hasDetails} == "true" ]]; then
    _LEFT_PANE_WIDTH=$((GLOBAL_COLUMNS - _RIGHT_PANE_WIDTH))
  else
    _LEFT_PANE_WIDTH=${GLOBAL_COLUMNS}
  fi

  if [[ ${drawMode} == *"right"* && ${hasDetails} == "true" ]]; then
    _drawRightPane
  fi

  if [[ ${drawMode} == *"left"* ]]; then
    _drawLeftPane
  fi

  # finish with the prompt line has we show the cursor again
  drawPrompt
}

function _drawRightPane() {
  local details="${_ITEMS_DETAILS[_SELECTED_ITEM_INDEX]}"
  local IFS

  # draw the title
  local titleWidth=$((${#_RIGHT_PANE_TITLE} + 2))
  local title=" ${_RIGHT_PANE_TITLE} "
  if ((titleWidth > _RIGHT_PANE_WIDTH - 6)); then
    titleWidth=0
    title=""
  fi
  local titlePadding=$(((_RIGHT_PANE_WIDTH - titleWidth) / 2 - 3))
  printf '%s%s\n' \
    "${AC__CURSOR_MOVE__}${_RIGHT_PANE_FIRST_LINE};$((_LEFT_PANE_WIDTH + 1))${__AC__TO}" \
    "┌─${AC__REPEAT__}${titlePadding}${__AC__LAST_CHAR}${title}─${AC__REPEAT__}$((_RIGHT_PANE_WIDTH - titleWidth - titlePadding - 2 - 2))${__AC__LAST_CHAR}┐"

  # draw the details
  local -i currentLine=1
  local -i currentIndex=0
  local line
  while IFS= read -r line; do
    currentIndex+=1
    if ((currentIndex < _RIGHT_PANE_START_INDEX + 1)); then
      continue
    fi
    printf "%s%s%s%s\n" "${AC__CURSOR_MOVE__}$((_RIGHT_PANE_FIRST_LINE + currentLine));$((_LEFT_PANE_WIDTH + 1))${__AC__TO}${AC__ERASE_CHARS_RIGHT}" "│ " "${line}" "${AC__CURSOR_MOVE__}$((GLOBAL_COLUMNS))${__AC__COLUMN}│"
    currentLine+=1
    if ((currentLine >= _RIGHT_LINES - 1)); then
      break
    fi
  done <<<"${details}"

  # draw last line with help text
  local helpWidth=$((${#_RIGHT_PANE_HELP_TEXT} + 2))
  local help=" ${_RIGHT_PANE_HELP_TEXT} "
  if ((helpWidth > _RIGHT_PANE_WIDTH - 6)); then
    helpWidth=0
    help=""
  fi
  printf '%s%s' \
    "${AC__CURSOR_MOVE__}$((GLOBAL_LINES));$((_LEFT_PANE_WIDTH + 1))${__AC__TO}" \
    "└─${AC__REPEAT__}$((_RIGHT_PANE_WIDTH - helpWidth - 4))${__AC__LAST_CHAR}${help}─┘"

}

function _drawLeftPane() {
  local IFS
  # separator
  local title=" 10/10"
  local titleWidth=${#title}
  if ((titleWidth > _LEFT_PANE_WIDTH)); then
    titleWidth=0
    title=""
  fi
  printf '%s%s\n' \
    "${AC__CURSOR_MOVE__}$((_LEFT_PANE_FIRST_LINE + 1));1${__AC__TO}" \
    "─${AC__REPEAT__}$((_LEFT_PANE_WIDTH - titleWidth - 2))${__AC__LAST_CHAR}${title} "

  # draw the items
  local -i currentLine=1
  local -i currentIndex=0
  local line
  for line in "${_ITEMS[@]}"; do
    currentIndex+=1
    if ((currentIndex < _LEFT_PANE_START_INDEX + 1)); then
      continue
    fi
    printf "%s\r%s%s\n" "${AC__CURSOR_MOVE__}$((_LEFT_PANE_FIRST_LINE + 1 + currentLine));$((_LEFT_PANE_WIDTH))${__AC__TO}${AC__ERASE_CHARS_LEFT}" "  " "${line}"
    currentLine+=1
    if ((currentLine >= _LEFT_LINES - 1)); then
      break
    fi
  done
}

function drawPrompt() {
  printf '%s\r%s' "${AC__CURSOR_MOVE__}$((_LEFT_PANE_FIRST_LINE));$((_LEFT_PANE_WIDTH))${__AC__TO}${AC__ERASE_CHARS_LEFT}" "▶ ${_SEARCH_STRING}${AC__CURSOR_SHOW}"
}

function _drawStaticScreen() {
  local IFS

  # clear the screen, move to the top left corner
  printf '%s' "${AC__ERASE_SCREEN}${AC__CURSOR_MOVE__}1;1${__AC__TO}"

  local leftPaneWidth=$((GLOBAL_COLUMNS - _RIGHT_PANE_WIDTH))

  # draw the header
  _LEFT_PANE_FIRST_LINE=1
  _RIGHT_PANE_FIRST_LINE=1
  local line headerOverflowing=false
  while IFS= read -r line; do
    printf '%s\n' "${line}"
    _LEFT_PANE_FIRST_LINE=$((_LEFT_PANE_FIRST_LINE + 1))
    if ((${#line} > leftPaneWidth)); then
      headerOverflowing=true
    fi
  done <<<"${_HEADER}"
  # if the header is too long, we can't start the right pane at line 1
  if [[ ${headerOverflowing} == "true" ]]; then
    _RIGHT_PANE_FIRST_LINE=${_LEFT_PANE_FIRST_LINE}
  fi

  _LEFT_LINES=$((GLOBAL_LINES - _LEFT_PANE_FIRST_LINE - 2))
  _LEFT_LINES=$((_LEFT_LINES > 0 ? _LEFT_LINES : 1))
  _RIGHT_LINES=$((GLOBAL_LINES - _RIGHT_PANE_FIRST_LINE + 1))
  _RIGHT_LINES=$((_RIGHT_LINES > 0 ? _RIGHT_LINES : 1))

  # draw the left help text
  printf '%s' "${AC__CURSOR_MOVE__}$((GLOBAL_LINES));1${__AC__TO}${AC__ERASE_LINE}${_LEFT_PANE_HELP_TEXT}"
}

# Called when a key is pressed.
function onKeyPressed() {
  case ${LAST_KEY_PRESSED} in
  RIGHT)
    _RIGHT_PANE_START_INDEX=$((_RIGHT_PANE_START_INDEX + 1))
    _drawRightPane
    ;;
  LEFT)
    _RIGHT_PANE_START_INDEX=$((_RIGHT_PANE_START_INDEX - 1))
    _drawRightPane
    ;;
  BACKSPACE)
    _SEARCH_STRING="${_SEARCH_STRING%?}"
    drawPrompt
    ;;
  $'\n')
    printf '%s' "${AC__CURSOR_MOVE__}$((GLOBAL_LINES - 2));1${__AC__TO}${AC__ERASE_LINE}${AC__TEXT_BOLD}You searched: ${_SEARCH_STRING}${AC__TEXT_RESET}"
    ;;
  # any special key
  $'\e') ;;
  # normal key
  ?)
    _SEARCH_STRING+="${LAST_KEY_PRESSED}"
    drawPrompt
    ;;
  esac
}

# Called when the user interrupts the session (CTRL+C).
function onSessionInterrupted() {
  _CLOSE_INTERACTIVE_SESSION=true
  # interactive::switchBackFromFullScreen
  # main::onInterruptInternal
}

# Called when the user resizes the terminal.
function onResize() {
  # export terminal size does not work if both 1 and 2 fd
  # are not the terminal. We need to temporarily redirect
  exec 2>&4 4>&-
  system::exportTerminalSize
  exec 4>&2 2>"${FSFS_TEMPORARY_ERROR_FILE}"
  FSFS_REDRAW_REQUIRED=true
}
