#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-ansi-codes
source ansi-codes

#===============================================================
# >>> Interactive prompts
#===============================================================

# Ask the user to press the button to continue.
#
# $1: the prompt to display
#
# Returns:
#   Returns 0 if the user pressed enter, 1 otherwise.
#
# Usage:
#  interactive::askForConfirmation "Press enter to continue."
function interactive::askForConfirmation() {
  interactive::displayQuestion "${1}"
  interactive::askForConfirmationRaw
  interactive::displayAnswer "Ok."
  return 0
}

# Ask the user to press the button to continue.
#
# Returns:
#   Returns 0 if the user pressed enter, 1 otherwise.
#
# Usage:
#  interactive::askForConfirmationRaw
function interactive::askForConfirmationRaw() {
  # colors
  local styleActiveButton
  if [[ "${VALET_CONFIG_ENABLE_COLORS:-}" == "true" ]]; then
    styleActiveButton="${AC__TEXT_INVERSE}${VALET_CONFIG_COLOR_ACTIVE_BUTTON:-${AC__FG_MAGENTA}}"
  else
    styleActiveButton="${AC__TEXT_INVERSE}"
  fi

  interactive::createSpace 2

  # print the current state (then move to column 1 to be ready to rewrite)
  printf '%s%s%s' \
    "${AC__CURSOR_HIDE}${styleActiveButton}" \
    "   (O)K   " \
    "${AC__TEXT_RESET}${AC__CURSOR_MOVE__}1${__AC__COLUMN}"

  local keyPressed
  while true; do
    # wait and handle key press
    if interactive::waitForKey -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ' | o)
        break
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      esac
    fi

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 ]]; then break; fi
  done

  printf '%s' "${AC__ERASE_CHARS_RIGHT}${AC__CURSOR_SHOW}"

  return 0
}

# Ask the user to yes or no.
# The user can switch between the two options with the arrow keys or space.
# The user can validate the choice with the enter key.
# The user can also validate immediately with the y or n key.
#
# $1: the prompt to display
# $2: (optional) the default value (true or false) - defaults to true
#
# Returns:
#   Returns 0 if true, 1 if false.
#   True or false in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  interactive::promptYesNo "Do you want to continue?" && local answer="${LAST_RETURNED_VALUE}"
function interactive::promptYesNo() {
  interactive::displayQuestion "${1}"
  interactive::promptYesNoRaw "${2:-true}"

  if [[ ${LAST_RETURNED_VALUE} == "true" ]]; then
    interactive::displayAnswer "Yes."
    LAST_RETURNED_VALUE=true
    return 0
  fi

  interactive::displayAnswer "No."
  LAST_RETURNED_VALUE=false
  return 1
}

# Ask the user to yes or no.
# The user can switch between the two options with the arrow keys or space.
# The user can validate the choice with the enter key.
# The user can also validate immediately with the y or n key.
#
# $1: (optional) the default value (true or false) - defaults to true
#
# Returns:
#   Returns 0 if true, 1 if false.
#   True or false in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  interactive::promptYesNoRaw "Do you want to continue?" && local answer="${LAST_RETURNED_VALUE}"
function interactive::promptYesNoRaw() {
  local state=${1:-true}

  # colors
  local styleActiveButton
  local styleUnactiveButton
  if [[ "${VALET_CONFIG_ENABLE_COLORS:-}" == "true" ]]; then
    styleActiveButton="${AC__TEXT_INVERSE}${VALET_CONFIG_COLOR_ACTIVE_BUTTON:-${AC__FG_MAGENTA}}"
    styleUnactiveButton="${AC__TEXT_INVERSE}${VALET_CONFIG_COLOR_UNACTIVE_BUTTON:-}"
  else
    styleActiveButton="${AC__TEXT_INVERSE}"
    styleUnactiveButton=""
  fi

  interactive::createSpace 2

  printf '%s' "${AC__CURSOR_HIDE}"

  local keyPressed yesColor noColor
  while true; do
    if [[ ${state} == "true" ]]; then
      yesColor="${styleActiveButton}"
      noColor="${styleUnactiveButton}"
    else
      yesColor="${styleUnactiveButton}"
      noColor="${styleActiveButton}"
    fi

    # print the current state (then move to column 1 to be ready to rewrite)
    printf '%s%s%s   %s%s%s' \
      "${yesColor}" \
      "   (Y)ES   " \
      "${AC__TEXT_RESET}" \
      "${noColor}" \
      "   (N)O   " \
      "${AC__TEXT_RESET}${AC__CURSOR_MOVE__}1${__AC__COLUMN}"

    # wait and handle key press
    if interactive::waitForKey -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ')
        break
        ;;
      y)
        state=true
        break
        ;;
      n)
        state=false
        break
        ;;
      UP | LEFT | RIGHT | DOWN)
        if [[ ${state} == "true" ]]; then state=false; else state=true; fi
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      esac
    fi

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 ]]; then break; fi
  done

  printf '%s' "${AC__ERASE_CHARS_RIGHT}${AC__CURSOR_SHOW}"

  if [[ ${state} == "true" ]]; then
    LAST_RETURNED_VALUE=${state}
    return 0
  fi

  LAST_RETURNED_VALUE=${state}
  return 1
}

# Displays a question to the user.
#
# $1: the prompt to display
# $2: (optional) the maximum width of the dialog box
#
# Usage:
#  interactive::displayPrompt "Do you want to continue?"
#
# Notes:
#   The text is wrapped and put inside a box like so:
#
#   ┌────────────┐
#   │ My prompt. │
#   └────────────┘\
interactive::displayQuestion() {
  interactive::displayDialogBox "system" "${1}" "${2:-}"
}

# Displays an answer to a previous question.
#
# $1: the answer to display
# $2: (optional) the maximum width of the dialog box
#
# Usage:
#  interactive::displayPrompt "Do you want to continue?"
#
# Notes:
#   The text is wrapped and put inside a box like so:
#
#  ┌────────────┐
#  │ My answer. │
# /└────────────┘
interactive::displayAnswer() {
  interactive::displayDialogBox "user" "${1}" "${2:-}"
}

# Displays a dialog box with a speaker and a text.
#
# $1: the speaker (system or user)
# $2: the text to display
# $3: (optional) the maximum width of the dialog box
#
# Usage:
#   interactive::displayDialogBox "system" "This is a system message."
interactive::displayDialogBox() {
  local speaker="${1}"
  local text="${2}"
  local dialogMaxWidth="${3:-180}"

  local -i maxWidth=$((GLOBAL_COLUMNS - 5))
  if [[ ${#text} -lt ${maxWidth} ]]; then
    maxWidth=${#text}
  fi
  if [[ ${#text} -gt dialogMaxWidth ]]; then
    maxWidth="${dialogMaxWidth}"
  fi

  local leftChar="   "
  local lastLeftChar="   "
  local lastRightChar=""
  if [[ ${speaker} == "system" ]]; then
    lastRightChar="\\"
  elif [[ ${speaker} == "user" ]]; then
    leftChar=" "
    lastLeftChar="/"
  fi

  string::wrapText "${text}" "${maxWidth}"
  local wrappedText="${LAST_RETURNED_VALUE}"

  local finalString="${AC__TEXT_FAINT}${leftChar}┌─${AC__REPEAT__}${maxWidth}${__AC__LAST_CHAR}─┐${AC__TEXT_RESET}"$'\n'

  local line
  while read -r line; do
    finalString+="${AC__TEXT_FAINT}${leftChar}│${AC__TEXT_RESET} ${line} ${AC__TEXT_FAINT}│${AC__TEXT_RESET}"$'\n'
  done <<<"${wrappedText}"

  finalString+="${AC__TEXT_FAINT}${lastLeftChar}└─${AC__REPEAT__}${maxWidth}${__AC__LAST_CHAR}─┘${lastRightChar}${AC__TEXT_RESET}"

  printf '%s\n' "${finalString}"
}

#===============================================================
# >>> Interactive utilities
#===============================================================

# Wait for a user input and prints the character that bash sees.
# Useful to program key bindings.
#
# Usage:
#   interactive::testKeys
function interactive::testKeys() {
  echo "Press any key to see the character that bash sees (CTRL + C to interrupt).${AC__CURSOR_HIDE}"
  while true; do
    if interactive::waitForKey -t 1; then
      printf "%sYou pressed: ⌜%q⌝%s" "${AC__ERASE_LINE}" "${LAST_KEY_PRESSED}" "${AC__CURSOR_MOVE__}1${__AC__COLUMN}"
    fi
    if [[ ! -t 1 ]]; then break; fi
  done
}

# Wait for a user input (single key).
# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).
# Some special keys are translated into more readable strings:
# UP, DOWN, RIGHT, LEFT, BACKSPACE, DEL, PAGE_UP, PAGE_DOWN, HOME, END, ESC, F1-F12, ALT+...
#
# Returns:
#   Returns 0 if a key was pressed, 1 otherwise.
#   The key pressed in the global variable LAST_KEY_PRESSED.
#
# Usage:
#   interactive::waitForKey
#   interactive::waitForKey -t 0.1
#
# Notes:
#   https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences
function interactive::waitForKey() {
  IFS='' read "$@" -d '' -srn 1 LAST_KEY_PRESSED || return 1
  # special key detection, need to read more characters (up to 4 for F1-F12 keys)
  if [[ ${LAST_KEY_PRESSED} == $'\e' ]]; then
    IFS='' read -t 0.001 -d '' -rsn 4
    LAST_KEY_PRESSED+="${REPLY}"
    # translate some common inputs into more readable strings
    case ${LAST_KEY_PRESSED} in
    $'\e[A' | $'\eOA') LAST_KEY_PRESSED="UP" ;;
    $'\e[B' | $'\eOA') LAST_KEY_PRESSED="DOWN" ;;
    $'\e[C' | $'\eOA') LAST_KEY_PRESSED="RIGHT" ;;
    $'\e[D' | $'\eOA') LAST_KEY_PRESSED="LEFT" ;;
    $'\e[2~') LAST_KEY_PRESSED="INSERT" ;;
    $'\e[3~') LAST_KEY_PRESSED="DEL" ;;
    $'\e[5~') LAST_KEY_PRESSED="PAGE_UP" ;;
    $'\e[6~') LAST_KEY_PRESSED="PAGE_DOWN" ;;
    $'\e[H') LAST_KEY_PRESSED="HOME" ;;
    $'\e[F') LAST_KEY_PRESSED="END" ;;
    $'\e') LAST_KEY_PRESSED="ESC" ;;
    $'\eOP') LAST_KEY_PRESSED="F1" ;;
    $'\e'?) LAST_KEY_PRESSED="ALT+${LAST_KEY_PRESSED#$'\e'}" ;;
    esac
  else
    case ${LAST_KEY_PRESSED} in
    $'\177' | $'\b') LAST_KEY_PRESSED="BACKSPACE" ;;
    esac
  fi
  return 0
}

# This function creates some new lines after the current cursor position.
# Then it moves back to its original position.
# This effectively creates a space in the terminal (scroll up if we are at the bottom).
# It does not create more space than the number of lines in the terminal.
#
# $1: the number of lines to create
#
# Usage:
#   interactive::createSpace 5
function interactive::createSpace() {
  local -i lines="${1}"
  lines=$((lines - 1 > GLOBAL_LINES ? GLOBAL_LINES : lines - 1))
  local -i loop
  local newLines
  for ((loop = 0; loop < lines; loop++)); do newLines+=$'\n'; done
  printf '%s' "${AC__CURSOR_MOVE__}1${__AC__COLUMN}${AC__ERASE_LINES_BELOW}${newLines}${AC__CURSOR_MOVE__}${lines}${__AC__START_OF_LINE_UP}"
}

# Get the current cursor position.
#
# Returns:
#   The cursor position in the global variables CURSOR_LINE and CURSOR_COLUMN.
#
# Usage:
#   interactive::getCursorPosition
function interactive::getCursorPosition() {
  local escapeCode IFS
  # we request the position and first read \e[
  IFS='' read -d '' -p "${AC__REQUEST_CURSOR_POSITION}" -n 2 -sr escapeCode || true
  # then read line;colR
  IFS=';' read -d 'R' -sr CURSOR_LINE CURSOR_COLUMN || true
}

# Call this function to start an interactive session in full screen mode.
# This function will switch to the alternate screen, hide the cursor and clear the screen.
# It will also disable echoing when we type something.
# You should call interactive::switchBackFromFullScreen at the end of the interactive session.
# In the alternate screen, we don't see the error messages so we capture them somewhere else.
#
# Usage:
#   interactive::switchToFullScreen
function interactive::switchToFullScreen() {
  if [[ ! -t 2 ]]; then
    core::fail "This function can only be used in an interactive session. Did you already called interactive::switchBackFromFullScreen?"
  fi

  # disable echoing when we type something
  if command -v stty &>/dev/null; then
    stty -echo &>/dev/null || true
  fi
  # switch to the alternate screen, hide the cursor and clear the screen
  printf '%s' "${AC__ENABLE_ALTERNATE_BUFFER_SCREEN}${AC__CURSOR_HIDE}${AC__ERASE_SCREEN}"

  # in full screen mode, we don't see the error messages so we capture them somewhere else
  FSFS_TEMPORARY_ERROR_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-interactive.err"
  while [[ -e "${FSFS_TEMPORARY_ERROR_FILE}" ]]; do FSFS_TEMPORARY_ERROR_FILE+="x"; done
  exec 4>&2 2>"${FSFS_TEMPORARY_ERROR_FILE}"
}

# Call this function to switch back from the full screen mode.
# This function will restore the terminal state, show the cursor and clear the screen.
# It will also restore the key echoing.
# If there were error messages during the interactive session, they will be displayed at the end.
#
# Usage:
#   interactive::switchBackFromFullScreen
function interactive::switchBackFromFullScreen() {
  if [[ -t 2 ]]; then
    # already in the normal terminal mode
    return
  fi

  # restore the terminal state
  printf '%s' "${AC__CURSOR_SHOW}${AC__DISABLE_ALTERNATE_BUFFER_SCREEN}"
  # restore the key echoing
  if command -v stty &>/dev/null; then
    stty echo &>/dev/null || true
  fi

  # restore the error output and display them if any
  exec 2>&4 4>&-
  if [[ -s "${FSFS_TEMPORARY_ERROR_FILE}" ]]; then
    io::readFile "${FSFS_TEMPORARY_ERROR_FILE}"
    log::error "Error messages during the interactive session:"$'\n'"${LAST_RETURNED_VALUE%$'\n'}"
  fi
}