#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-ansi-codes
source ansi-codes


#===============================================================
# >>> Events
#===============================================================

# if interactive shell, make sure to restore the cursor and echo when exiting
if [[ $- == *i* ]]; then
  trap "main::onExitInternal; printf '%s' $'\e[?25h'; stty echo" EXIT
fi

#===============================================================
# >>> Interactive prompts
#===============================================================

# Ask the user to press the button to continue.
#
# $1: the prompt to display
#
# Returns:
#   Returns 0 if the user pressed enter, 1 otherwise.
function interactive::askForConfirmation() {
  interactive::displayQuestion "${1}"

  local colorActiveButton="${VALET_CONFIG_COLOR_ACTIVE_BUTTON:-${fgMagenta}}"

  # print the current state (then move to column 1 to be ready to rewrite)
  printf '%s%s%s' \
    "${cursorHide}${textBold}${textInverse}${colorActiveButton}" \
    "   (O)K   " \
    "${textReset}${cursorMove}1${_column}"

  local keyPressed
  while true; do
    # wait and handle key press
    if interactive::waitForKey -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ' | o)
        break
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      esac
    fi

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 ]]; then break; fi
  done

  printf '%s' "${eraseCharsRight}${cursorShow}"

  interactive::displayAnswer "Ok."
  return 0
}


# Ask the user to yes or no.
# The user can switch between the two options with the arrow keys or space.
# The user can validate the choice with the enter key.
# The user can also validate immediately with the y or n key.
#
# $1: the prompt to display
#
# Returns:
#   Returns 0 if true, 1 if false.
#   True or false in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  interactive::promptYesNo "Do you want to continue?" && local answer="${LAST_RETURNED_VALUE}"
function interactive::promptYesNo() {
  interactive::displayQuestion "${1}"

  local state=true
  local colorActiveButton="${VALET_CONFIG_COLOR_ACTIVE_BUTTON:-${fgMagenta}}"
  local colorUnactiveButton="${VALET_CONFIG_COLOR_UNACTIVE_BUTTON:-}"

  printf '%s' "${cursorHide}"

  local keyPressed yesColor noColor
  while true; do
    if [[ ${state} == "true" ]]; then
      yesColor="${colorActiveButton}"
      noColor="${colorUnactiveButton}"
    else
      yesColor="${colorUnactiveButton}"
      noColor="${colorActiveButton}"
    fi

    # print the current state (then move to column 1 to be ready to rewrite)
    printf '%s%s%s   %s%s%s' \
      "${textBold}${textInverse}${yesColor}" \
      "   (Y)ES   " \
      "${textReset}" \
      "${textBold}${textInverse}${noColor}" \
      "   (N)O   " \
      "${textReset}${cursorMove}1${_column}"

    # wait and handle key press
    if interactive::waitForKey -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ')
        break
        ;;
      y)
        state=true
        break
        ;;
      n)
        state=false
        break
        ;;
      UP | LEFT | RIGHT | DOWN)
        if [[ ${state} == "true" ]]; then state=false; else state=true; fi
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      esac
    fi

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 ]]; then break; fi
  done

  printf '%s' "${eraseCharsRight}${cursorShow}"

  if [[ ${state} == "true" ]]; then
    interactive::displayAnswer "Yes."
    LAST_RETURNED_VALUE=${state}
    return 0
  fi

  interactive::displayAnswer "No."
  LAST_RETURNED_VALUE=${state}
  return 1
}


#===============================================================
# >>> Custom drawing functions
#===============================================================

function setupTerminal() {
  stty -echo
  printf '%s' "${switchScreenBuffer}${disableLineWrapping}${cursorHide}${eraseScreen}${limitScrolling}$((_LINES - 1))${_lines}"
}

function resetTerminal() {
  printf '%s' "${enableLineWrapping}${cursorShow}${eraseScreen}${limitScrolling}${_lines}${switchScreenBuffer}"
  stty echo
}

# Write a message to the status bar.
function writeToStatusBar() {
  printf '%s' "${cursorSavePos}${cursorMove}$((_LINES - 1));1${_to}${eraseLine}${textBold}${1}${textReset}${cursorRestorePos}"
}

function key() {
  local keyPressed="${1}"
  local specialKeyPress=false

  # Special key detection.
  if [[ ${keyPressed} == $'\e' ]]; then
    read -t 0.1 -rsn 2
    keyPressed="${keyPressed}${REPLY}"
    specialKeyPress=true

    local sk2
    printf -v sk2 "%q" "${keyPressed}"
    writeToStatusBar "Special key pressed: ⌜${sk2}⌝."
  fi

  case ${keyPressed} in
  $'\e[C' | $'\eOC' | "")
    writeToStatusBar right or enter
    ;;
  $'\e[D' | $'\eOD' | $'\177' | $'\b')
    writeToStatusBar left or backspace
    ;;
  $'\e[B' | $'\eOB')
    writeToStatusBar down
    ;;
  $'\e[A' | $'\eOA')
    writeToStatusBar up
    ;;
  s)
    writeToStatusBar Start search
    search "search"
    ;;
  q)
    CLOSE_INTERACTIVE_SESSION=true
    ;;
  *)
    if [[ ${specialKeyPress} == "false" ]]; then
      writeToStatusBar "Normal key pressed: ⌜${keyPressed}⌝."
    fi
    ;;
  esac
}

function search() {
  local keyPressed
  local searchString=""

  printf '%s' "${cursorShow}${cursorMove}$((_LINES));1${_to}${eraseLine}"

  while IFS= read -rsn 1 -p "${cursorHide}${redrawPrompt}${cursorShow}${textBold}SEARCH:${textReset} ${searchString}" keyPressed; do
    case ${keyPressed} in
    # Backspace.
    $'\177' | $'\b')
      searchString=${searchString%?}
      ;;
    # Escape key.
    $'\e')
      read -t 0.1 -rsn 2
      searchString=
      break
      ;;
    # Enter/Return.
    "")
      writeToStatusBar "You searched: ${searchString}"
      break
      ;;
    *)
      searchString+=$keyPressed
      ;;
    esac
  done

  printf '%s' "${cursorHide}${eraseLine}"
}

function redraw() {
  writeToStatusBar "Terminal size is: ${_COLUMNS}x${_LINES}"
}

function fullScreenInteractive() {

  # TODO: also need to custom trap interrupt because we will use it to close the interactive session in full screen
  # Need to figure out how to properly restore the screen buffer and cursor position exactly as it was

  # we still need to export the terminal size but in addition, we need to redraw.
  # Note: SIGWINCH does not interrupt a read command and wait for it to complete so we need
  # to set a timeout on read to allow this refresh.
  trap 'system::exportTerminalSize; redraw' SIGWINCH

  # still need to handle the exit, but we also need to reset the terminal when exiting.
  trap 'resetTerminal; main::onExitInternal' EXIT

  setupTerminal
  redraw

  CLOSE_INTERACTIVE_SESSION=false

  while true; do
    read -t 0.1 -srn 1 && key "$REPLY"

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 || ${CLOSE_INTERACTIVE_SESSION} == "true" ]]; then break; fi
  done

  trap 'system::exportTerminalSize' SIGWINCH
  trap 'main::onExitInternal' EXIT
  resetTerminal

  log::info "Bye!"
}

# Wait for a user input and prints the character that bash sees.
# Useful to program key bindings.
#
# Usage:
#   interactive::testKeys
function interactive::testKeys() {
  local keyPressed

  echo "Press any key to see the character that bash sees (CTRL + C to interrupt).${cursorHide}"
  while true; do
    if interactive::waitForKey -t 1; then
      printf "You pressed: %q        %s" "⌜${LAST_KEY_PRESSED}⌝" "${cursorMove}1${_column}"
    fi
    if [[ ! -t 1 ]]; then break; fi
  done
}

# Wait for a user input (single key).
# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).
# Some special keys are translated into more readable strings.
#
# Returns:
#   Returns 0 if a key was pressed, 1 otherwise.
#   The key pressed in the global variable LAST_KEY_PRESSED.
#
# Usage:
#   interactive::waitForKey
#   interactive::waitForKey -t 0.1
function interactive::waitForKey() {
  IFS='' read "$@" -d '' -srn 1 LAST_KEY_PRESSED || return 1
  # special key detection, need to read more characters (up to 4 for F1-F12 keys)
  if [[ ${LAST_KEY_PRESSED} == $'\e' ]]; then
    IFS='' read -t 0.01 -d '' -rsn 4
    LAST_KEY_PRESSED+="${REPLY}"
    # translate some common inputs into more readable strings
    case ${LAST_KEY_PRESSED} in
    $'\e[A' | $'\eOA') LAST_KEY_PRESSED="UP" ;;
    $'\e[B' | $'\eOA') LAST_KEY_PRESSED="DOWN" ;;
    $'\e[C' | $'\eOA') LAST_KEY_PRESSED="RIGHT" ;;
    $'\e[D' | $'\eOA') LAST_KEY_PRESSED="LEFT" ;;
    $'\177' | $'\b') LAST_KEY_PRESSED="BACKSPACE" ;;
    $'\e[3~') LAST_KEY_PRESSED="DEL" ;;
    $'\e[5~') LAST_KEY_PRESSED="PAGE_UP" ;;
    $'\e[6~') LAST_KEY_PRESSED="PAGE_DOWN" ;;
    $'\e[H') LAST_KEY_PRESSED="HOME" ;;
    $'\e[F') LAST_KEY_PRESSED="END" ;;
    $'\e') LAST_KEY_PRESSED="ESC" ;;
    $'\eOP') LAST_KEY_PRESSED="F1" ;;
    $'\e'?) LAST_KEY_PRESSED="ALT+${LAST_KEY_PRESSED#$'\e'}" ;;
    esac
  fi
  return 0
}

# Displays a question to the user.
#
# $1: the prompt to display
# $2: (optional) the maximum width of the dialog box
#
# Usage:
#  interactive::displayPrompt "Do you want to continue?"
#
# Notes:
#   Frames: https://gist.github.com/dsample/79a97f38bf956f37a0f99ace9df367b9
#   The text is wrapped and put inside a box like so:
#
#   ┌────────────┐
#   │ My prompt. │
#   └────────────┘\
interactive::displayQuestion() {
  interactive::displayDialogBox "system" "${1}" "${2:-}"
}

# Displays an answer to a previous question.
#
# $1: the answer to display
# $2: (optional) the maximum width of the dialog box
#
# Usage:
#  interactive::displayPrompt "Do you want to continue?"
#
# Notes:
#   Frames: https://gist.github.com/dsample/79a97f38bf956f37a0f99ace9df367b9
#   The text is wrapped and put inside a box like so:
#
#  ┌────────────┐
#  │ My answer. │
# /└────────────┘
interactive::displayAnswer() {
  interactive::displayDialogBox "user" "${1}" "${2:-}"
}

# Displays a dialog box with a speaker and a text.
#
# $1: the speaker (system or user)
# $2: the text to display
# $3: (optional) the maximum width of the dialog box
#
# Usage:
#   interactive::displayDialogBox "system" "This is a system message."
interactive::displayDialogBox() {
  local speaker="${1}"
  local text="${2}"
  local dialogMaxWidth="${3:-180}"

  local -i maxWidth=$((_COLUMNS - 5))
  if [[ ${#text} -lt ${maxWidth} ]]; then
    maxWidth=${#text}
  fi
  if [[ ${#text} -gt dialogMaxWidth ]]; then
    maxWidth="${dialogMaxWidth}"
  fi

  local leftChar="   "
  local lastLeftChar="   "
  local lastRightChar=""
  if [[ ${speaker} == "system" ]]; then
    lastRightChar="\\"
  elif [[ ${speaker} == "user" ]]; then
    leftChar=" "
    lastLeftChar="/"
  fi

  string::wrapText "${text}" "${maxWidth}"
  local wrappedText="${LAST_RETURNED_VALUE}"

  local finalString="${textFaint}${leftChar}┌─${repeat}${maxWidth}${_lastChar}─┐${textReset}"$'\n'

  local line
  while read -r line; do
    finalString+="${textFaint}${leftChar}│${textReset} ${line} ${textFaint}│${textReset}"$'\n'
  done <<<"${wrappedText}"

  finalString+="${textFaint}${lastLeftChar}└─${repeat}${maxWidth}${_lastChar}─┘${lastRightChar}${textReset}"

  printf '%s\n' "${finalString}"
}

