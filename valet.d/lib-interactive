#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

#===============================================================
# >>> Ansi escape sequences
#===============================================================

# Notes:
# While it could be very handy to define a function for each of these instructions,
# it would also be slower to execute (function overhead + multiple printf calls).
#
# Reference:
# - https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_
# - https://en.wikipedia.org/wiki/ANSI_escape_code
# - https://vt100.net/docs/vt102-ug/chapter5.html
# - https://vt100.net/docs/vt100-ug/chapter3.html#S3.3.1

# Text colors
fgBlack=$'\e[30m'
fgBlackIntense=$'\e[90m'
fgBlue=$'\e[34m'
fgBlueIntense=$'\e[94m'
fgCyan=$'\e[36m'
fgCyanIntense=$'\e[96m'
fgGreen=$'\e[32m'
fgGreenIntense=$'\e[92m'
fgMagenta=$'\e[35m'
fgMagentaIntense=$'\e[95m'
fgRed=$'\e[31m'
fgRedIntense=$'\e[91m'
fgWhite=$'\e[37m'
fgWhiteIntense=$'\e[97m'
fgYellow=$'\e[33m'
fgYellowIntense=$'\e[93m'
fgReset=$'\e[39m'
fgColor=$'\e[38;5;'
_code=$'m' # "${fgColor}2${_code}"

# background colors
bgBlack=$'\e[40m'
bgBlackIntense=$'\e[100m'
bgBlue=$'\e[44m'
bgBlueIntense=$'\e[104m'
bgCyan=$'\e[46m'
bgCyanIntense=$'\e[106m'
bgGreen=$'\e[42m'
bgGreenIntense=$'\e[102m'
bgMagenta=$'\e[45m'
bgMagentaIntense=$'\e[105m'
bgRed=$'\e[41m'
bgRedIntense=$'\e[101m'
bgWhite=$'\e[47m'
bgWhiteIntense=$'\e[107m'
bgYellow=$'\e[43m'
bgYellowIntense=$'\e[103m'
bgReset=$'\e[49m'
resetColor=$'\e[0m'
bgColor=$'\e[48;5;' # "${bgColor}2${_code}"

# text attributes
textBold=$'\e[1m'
textNoBold=$'\e[21m'
textFaint=$'\e[2m'
textNoFaint=$'\e[22m'
textItalic=$'\e[3m'
textNoItalic=$'\e[23m'
textUnderline=$'\e[4m'
textNoUnderline=$'\e[24m'
textBlink=$'\e[5m'
textNoBlink=$'\e[25m'
textInverse=$'\e[7m'
textNoInverse=$'\e[27m'
textInvisible=$'\e[8m'
textVisible=$'\e[28m'
textStrike=$'\e[9m'
textNoStrike=$'\e[29m'
textReset=$'\e[0m'
textResetAttributes=$'\e[21;22;23;24;25;26;27;28;29m'

# cursor
cursorRestorePos=$'\e[u'
cursorSavePos=$'\e[s'
cursorHide=$'\e[?25l'
cursorShow=$'\e[?25h'
ringBell=$'\007'

# display
switchScreenBuffer=$'\e[?1049h'
disableLineWrapping=$'\e[?7l'
enableLineWrapping=$'\e[?7h'
eraseLinesBelow=$'\e[0J'
eraseLinesAbove=$'\e[1J'
eraseScreen=$'\e[2J'
eraseCharsRight=$'\e[0K'
eraseCharsLeft=$'\e[1K'
eraseLine=$'\e[2K'
repeatLastChar=$'\e[1b' # 1 can be x
echoOff=$'\e[2h' # does not seem to work, better rely on stty -echo
echoOn=$'\e[2l'
redrawPrompt=$'\r\e[K'

# cursor movement
cursorMove=$'\e['
_to=$'H'          # "${cursorMove}1;1${_to}" (row;col)
_left=$'D'        # "${cursorMove}2${_left}"
_right=$'C'       # "${cursorMove}2${_right}"
_down=$'B'        # "${cursorMove}2${_down}"
_up=$'A'          # "${cursorMove}2${_up}"
_column=$'G'      # "${cursorMove}2${_column}"
_line=$'d'        # "${cursorMove}2${_line}"
_tabBackward=$'Z' # "${cursorMove}2${_tabBackward}"
_tabForward=$'I'  # "${cursorMove}2${_tabForward}"
_scrollDown=$'T'  # "${cursorMove}2${_scrollDown}"
_scrollUp=$'S'    # "${cursorMove}2${_scrollUp}"

limitScrolling=$'\e[1;'
_lines=$'r' # "${limitScrolling}20${_lines}"

#===============================================================
# >>> Custom drawing functions
#===============================================================

setupTerminal() {
  stty -echo
  printf '%s' "${switchScreenBuffer}${disableLineWrapping}${cursorHide}${eraseScreen}${limitScrolling}$((_LINES - 1))${_lines}"
}

resetTerminal() {
  printf '%s' "${enableLineWrapping}${cursorShow}${eraseScreen}${limitScrolling}${_lines}${switchScreenBuffer}"
  stty echo
}

# Write a message to the status bar.
writeToStatusBar() {
  printf '%s' "${cursorSavePos}${cursorMove}$((_LINES - 1));1${_to}${eraseLine}${textBold}${1}${textReset}${cursorRestorePos}"
}

key() {
  local keyPressed="${1}"
  local specialKeyPress=false

  # Special key detection.
  if [[ ${keyPressed} == $'\e' ]]; then
    read -t 0.1 -rsn 2
    keyPressed="${keyPressed}${REPLY}"
    specialKeyPress=true

    local sk2
    printf -v sk2 "%q" "${keyPressed}"
    writeToStatusBar "Special key pressed: ⌜${sk2}⌝."
  fi

  case ${keyPressed} in
  $'\e[C' | $'\eOC' | "")
    writeToStatusBar right or enter
    ;;
  $'\e[D' | $'\eOD' | $'\177' | $'\b')
    writeToStatusBar left or backspace
    ;;
  $'\e[B' | $'\eOB')
    writeToStatusBar down
    ;;
  $'\e[A' | $'\eOA')
    writeToStatusBar up
    ;;
  s)
    writeToStatusBar Start search
    search "search"
    ;;
  q)
    CLOSE_INTERACTIVE_SESSION=true
    ;;
  *)
    if [[ ${specialKeyPress} == "false" ]]; then
      writeToStatusBar "Normal key pressed: ⌜${keyPressed}⌝."
    fi
    ;;
  esac
}

search() {
  local keyPressed
  local searchString=""

  printf '%s' "${cursorShow}${cursorMove}$((_LINES));1${_to}${eraseLine}"

  while IFS= read -rsn 1 -p "${cursorHide}${redrawPrompt}${cursorShow}${textBold}SEARCH:${textReset} ${searchString}" keyPressed; do
    case ${keyPressed} in
    # Backspace.
    $'\177' | $'\b')
      searchString=${searchString%?}
      ;;
    # Escape key.
    $'\e')
      read -t 0.1 -rsn 2
      searchString=
      break
      ;;
    # Enter/Return.
    "")
      writeToStatusBar "You searched: ${searchString}"
      break
      ;;
    *)
      searchString+=$keyPressed
      ;;
    esac
  done

  printf '%s' "${cursorHide}${eraseLine}"
}

function redraw() {
  writeToStatusBar "Terminal size is: ${_COLUMNS}x${_LINES}"
}

function fullScreenInteractive() {

  # TODO: also need to custom trap interrupt because we will use it to close the interactive session in full screen

  # we still need to export the terminal size but in addition, we need to redraw.
  # Note: SIGWINCH does not interrupt a read command and wait for it to complete so we need
  # to set a timeout on read to allow this refresh.
  trap 'exportTerminalSize; redraw' SIGWINCH

  # still need to handle the exit, but we also need to reset the terminal when exiting.
  trap 'resetTerminal; onExitInternal' EXIT

  setupTerminal
  redraw

  CLOSE_INTERACTIVE_SESSION=false

  while true; do
    read -t 0.1 -srn 1 && key "$REPLY"

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 || ${CLOSE_INTERACTIVE_SESSION} == "true" ]]; then break; fi
  done

  trap 'exportTerminalSize' SIGWINCH
  trap 'onExitInternal' EXIT
  resetTerminal

  inform "Bye!"
}

#===============================================================
# >>> Fzf glorious functions
#===============================================================

# Open fzf with the given mode, history id, header and body.
#
# $1: the mode to use, can be "menu", "search", "options"
# $2: the history id to use (used in the name of the fzf history file)
# $3: the header to display
# $4: the body to display
# $5+: additional options to pass to fzf
#
# Returns:
#  The choices made by the user in the global variable LAST_RETURNED_VALUE.
#  The first line is the query (can be empty), the next lines are the choices.
#
# Usage:
#  showFzf "menu" "my-command" "Choose an option" "option1"$'\n'"option2"$'\n'"option3"
function showFzf() {
  local mode historyId header body
  mode="${1}"
  historyId="${2}"
  header="${3}"
  body="${4}"
  shift 4

  include io

  # in CI mode, we do not allow to display fzf because it would make the job hang forever
  if [[ ${VALET_CI_MODE:-false} == "true" ]]; then
    fail "CI/CD mode is activated, interactive mode has been started but we cannot run fzf or we would make the job hang forever."
  fi

  getCommandFullPath "fzf"
  local fzfExecutable="${LAST_RETURNED_VALUE}"

  debug "Running fzf from ⌜${fzfExecutable}⌝."

  local -a defaultOptions
  local -a modeOptions

  # get the history file
  getLocalStateDirectory && local stateDirectory="${LAST_RETURNED_VALUE}"
  local historyFile
  if [[ -n "${historyId}" ]]; then
    historyFile="${stateDirectory}/fzf-history-${historyId}"
    if [[ ! -e "${historyFile}" ]]; then
      : >"${historyFile}"
    fi
    defaultOptions+=(
      --history="${historyFile}"
      --history-size=50
      --bind "alt-up:prev-history"
      --bind "alt-down:next-history"
    )
  fi

  # compute preview width
  local previewWidth=$((_COLUMNS / 2 - 10))
  if [[ previewWidth -le 15 ]]; then
    previewWidth=15
  fi

  local headerHelp="${COLOR_ERROR}Press ALT+H to display the help and keybindings.${COLOR_DEFAULT}"$'\n'

  local helpPreview
  case "${mode}" in
  "options" | "menu")
    helpPreview="${COLOR_INFO}HELP${COLOR_DEFAULT}"$'\n'$'\n'"Navigate through the options with the ${COLOR_ERROR}UP${COLOR_DEFAULT}/${COLOR_ERROR}DOWN${COLOR_DEFAULT} keys."$'\n'$'\n'"Validate your choice with ${COLOR_ERROR}ENTER${COLOR_DEFAULT}."
    modeOptions+=(
      --no-multi
    )
    if [[ ${mode} == "options" ]]; then
      modeOptions+=(
        --height=~100%
        --min-height=10
      )
    fi
    ;;
  "multi-options")
    helpPreview="${COLOR_INFO}HELP${COLOR_DEFAULT}"$'\n'$'\n'"Navigate through the options with the ${COLOR_ERROR}UP${COLOR_DEFAULT}/${COLOR_ERROR}DOWN${COLOR_DEFAULT} keys."$'\n'$'\n'"Opt-in and out of an option using ${COLOR_ERROR}TAB${COLOR_DEFAULT}."$'\n'$'\n'"Validate with ${COLOR_ERROR}ENTER${COLOR_DEFAULT}."
    modeOptions+=(
      --multi
      --height=~100%
      --min-height=10
    )
    ;;
  "yes-no")
    helpPreview="${COLOR_INFO}HELP${COLOR_DEFAULT}"$'\n'$'\n'"Navigate through the options with the ${COLOR_ERROR}UP${COLOR_DEFAULT}/${COLOR_ERROR}DOWN${COLOR_DEFAULT} keys."$'\n'$'\n'"Validate your choice with ${COLOR_ERROR}ENTER${COLOR_DEFAULT}."
    modeOptions+=(
      --height=~100%
      --min-height=10
      --no-multi
      --no-info
      --no-separator
    )
    body="Yes"$'\n'"No"
    headerHelp=""
    helpPreview=""
    ;;
  "query")
    helpPreview="${COLOR_INFO}HELP${COLOR_DEFAULT}"$'\n'$'\n'"Type your answer in the prompt."$'\n'$'\n'"Validate with ${COLOR_ERROR}ENTER${COLOR_DEFAULT}."
    modeOptions+=(
      --height=~100%
    )
    if [[ -z "${body}" ]]; then
      modeOptions+=(
        --no-mouse
        --no-info
        --no-separator
        --no-scrollbar
        --pointer=' '
        --color=pointer:-1
        --color=fg+:-1
        --color=bg+:-1
      )
      headerHelp=""
      helpPreview=""
    else
      modeOptions+=(
        --bind "tab:replace-query"
        --min-height=10
      )
      headerHelp="${COLOR_ERROR}Type your answer, press TAB to replace with the selection (ALT+H for help).${COLOR_DEFAULT}"$'\n'
      helpPreview+=$'\n'$'\n'"Use ${COLOR_ERROR}TAB${COLOR_DEFAULT} to replace your answer with the current selection."
    fi
    ;;
  "command-options")
    helpPreview="${COLOR_INFO}HELP${COLOR_DEFAULT}"$'\n'$'\n'"Navigate through the options with the ${COLOR_ERROR}UP${COLOR_DEFAULT}/${COLOR_ERROR}DOWN${COLOR_DEFAULT} keys."$'\n'$'\n'"Opt-in and out of an option using ${COLOR_ERROR}TAB${COLOR_DEFAULT} or ${COLOR_ERROR}SPACE${COLOR_DEFAULT}."$'\n'$'\n'"Modify the value of an option by pressing ${COLOR_ERROR}M${COLOR_DEFAULT}."$'\n'$'\n'"Validate with ${COLOR_ERROR}ENTER${COLOR_DEFAULT}."
    modeOptions+=(
      --multi
      --bind "tab:toggle"
      --bind "space:toggle"
      --bind "m:execute(echo {} | fzf)"
    )
    ;;
  *)
    fail "Unknown fzf mode ⌜${mode}⌝."
    ;;
  esac

  helpPreview+="

Cancel with ${COLOR_ERROR}ESC${COLOR_DEFAULT} or ${COLOR_ERROR}CTRL+C${COLOR_DEFAULT}.

${COLOR_INFO}ADDITIONAL KEY BINDINGS${COLOR_DEFAULT}

${COLOR_ERROR}ALT+H${COLOR_DEFAULT}: Show this help.
${COLOR_ERROR}ALT+/${COLOR_DEFAULT}: Rotate through the preview options (this pane).
${COLOR_ERROR}ALT+UP${COLOR_DEFAULT}/${COLOR_ERROR}ALT+DOWN${COLOR_DEFAULT}: Previous/next query in the history.
${COLOR_ERROR}SHIFT+UP${COLOR_DEFAULT}/${COLOR_ERROR}SHIFT+DOWN${COLOR_DEFAULT}: Scroll the preview up and down.
"

  if [[ -n "${helpPreview}" ]]; then
    wrapText "${helpPreview}" "${previewWidth}"
    helpPreview="${LAST_RETURNED_VALUE}"
    defaultOptions+=(
      "--bind=alt-h:preview(echo -e '${helpPreview}')"
      "--preview-window=right,${previewWidth}"
      --bind 'alt-/:change-preview-window(right,70%|down,40%,border-horizontal|hidden|)'
    )
  fi

  # shellcheck disable=SC2054
  defaultOptions+=(
    --layout=reverse
    --info=right
    --pointer=◆
    --marker=✓
    --cycle
    --tiebreak=begin,index
    --margin=0
    --padding=0
    --delimiter=$'\n'
    --tabstop=3
    --header-first
    --header="${headerHelp}${header}"
    --print-query
  )

  # reset the output file, but only if it already exist
  if [[ -s "${_TEMPORARY_STDOUT_FILE}" ]]; then : >"${_TEMPORARY_STDOUT_FILE}"; fi

  "${fzfExecutable}" "${defaultOptions[@]}" "${modeOptions[@]}" "$@" <<<"${body}" 1>"${_TEMPORARY_STDOUT_FILE}" || true

  local choice
  if [[ -s "${_TEMPORARY_STDOUT_FILE}" ]]; then
    IFS= read -rd '' choice <"${_TEMPORARY_STDOUT_FILE}" || true
  else
    choice=""
  fi

  # if any, append the query to the history file
  if [[ -n "${historyId}" ]]; then
    local query=${choice%%$'\n'*}
    if [[ -n "${query}" ]]; then
      echo "${query}" >>"${historyFile}"
    fi
  fi

  LAST_RETURNED_VALUE="${choice}"
}

# Ask the user for a string input.
#
# $1: the prompt to display
# $2: a list of options that the user can select with TAB (can be empty, separated by new lines)
#
# Returns:
#  The value entered by the user in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  promptString "What is your name?" "John" && local name="${LAST_RETURNED_VALUE}"
function promptString() {
  local prompt autocompletionValues
  prompt="${1}"
  autocompletionValues="${2}"

  showFzf "query" "" "${prompt}" "${autocompletionValues:-}"

  # we keep only the query, i.e. the first line
  LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE%%$'\n'*}"
}

# Ask the user to yes or no.
#
# $1: the prompt to display
#
# Returns:
#  True or false in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  promptYesNo "Do you want to continue?" && local answer="${LAST_RETURNED_VALUE}"
function promptYesNo() {
  local prompt
  prompt="${1}"

  showFzf "yes-no" "" "${prompt}" ''

  # we keep only the selected value, i.e. the 2nd line
  LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE#*$'\n'}"
  LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE%%$'\n'*}"
  if [[ ${LAST_RETURNED_VALUE} == "Yes" ]]; then LAST_RETURNED_VALUE=true; else LAST_RETURNED_VALUE=false; fi
}
