#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# in CI mode, we do not allow to go interactive because it would make the job hang forever
if [[ ${VALET_CI_MODE:-false} == "true" ]]; then
  fail "CI/CD mode is activated, interactive mode has been started but we cannot run fzf or we would make the job hang forever."
fi

# shellcheck source=lib-ansi-codes
source ansi-codes

#===============================================================
# >>> Custom drawing functions
#===============================================================

setupTerminal() {
  stty -echo
  printf '%s' "${switchScreenBuffer}${disableLineWrapping}${cursorHide}${eraseScreen}${limitScrolling}$((_LINES - 1))${_lines}"
}

resetTerminal() {
  printf '%s' "${enableLineWrapping}${cursorShow}${eraseScreen}${limitScrolling}${_lines}${switchScreenBuffer}"
  stty echo
}

# Write a message to the status bar.
writeToStatusBar() {
  printf '%s' "${cursorSavePos}${cursorMove}$((_LINES - 1));1${_to}${eraseLine}${textBold}${1}${textReset}${cursorRestorePos}"
}

key() {
  local keyPressed="${1}"
  local specialKeyPress=false

  # Special key detection.
  if [[ ${keyPressed} == $'\e' ]]; then
    read -t 0.1 -rsn 2
    keyPressed="${keyPressed}${REPLY}"
    specialKeyPress=true

    local sk2
    printf -v sk2 "%q" "${keyPressed}"
    writeToStatusBar "Special key pressed: ⌜${sk2}⌝."
  fi

  case ${keyPressed} in
  $'\e[C' | $'\eOC' | "")
    writeToStatusBar right or enter
    ;;
  $'\e[D' | $'\eOD' | $'\177' | $'\b')
    writeToStatusBar left or backspace
    ;;
  $'\e[B' | $'\eOB')
    writeToStatusBar down
    ;;
  $'\e[A' | $'\eOA')
    writeToStatusBar up
    ;;
  s)
    writeToStatusBar Start search
    search "search"
    ;;
  q)
    CLOSE_INTERACTIVE_SESSION=true
    ;;
  *)
    if [[ ${specialKeyPress} == "false" ]]; then
      writeToStatusBar "Normal key pressed: ⌜${keyPressed}⌝."
    fi
    ;;
  esac
}

search() {
  local keyPressed
  local searchString=""

  printf '%s' "${cursorShow}${cursorMove}$((_LINES));1${_to}${eraseLine}"

  while IFS= read -rsn 1 -p "${cursorHide}${redrawPrompt}${cursorShow}${textBold}SEARCH:${textReset} ${searchString}" keyPressed; do
    case ${keyPressed} in
    # Backspace.
    $'\177' | $'\b')
      searchString=${searchString%?}
      ;;
    # Escape key.
    $'\e')
      read -t 0.1 -rsn 2
      searchString=
      break
      ;;
    # Enter/Return.
    "")
      writeToStatusBar "You searched: ${searchString}"
      break
      ;;
    *)
      searchString+=$keyPressed
      ;;
    esac
  done

  printf '%s' "${cursorHide}${eraseLine}"
}

function redraw() {
  writeToStatusBar "Terminal size is: ${_COLUMNS}x${_LINES}"
}

function fullScreenInteractive() {

  # TODO: also need to custom trap interrupt because we will use it to close the interactive session in full screen

  # we still need to export the terminal size but in addition, we need to redraw.
  # Note: SIGWINCH does not interrupt a read command and wait for it to complete so we need
  # to set a timeout on read to allow this refresh.
  trap 'exportTerminalSize; redraw' SIGWINCH

  # still need to handle the exit, but we also need to reset the terminal when exiting.
  trap 'resetTerminal; onExitInternal' EXIT

  setupTerminal
  redraw

  CLOSE_INTERACTIVE_SESSION=false

  while true; do
    read -t 0.1 -srn 1 && key "$REPLY"

    # break if fd 1 is closed or does not refer to a terminal.
    if [[ ! -t 1 || ${CLOSE_INTERACTIVE_SESSION} == "true" ]]; then break; fi
  done

  trap 'exportTerminalSize' SIGWINCH
  trap 'onExitInternal' EXIT
  resetTerminal

  inform "Bye!"
}

# Ask the user to yes or no.
#
# $1: the prompt to display
#
# Returns:
#  True or false in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#  promptYesNo "Do you want to continue?" && local answer="${LAST_RETURNED_VALUE}"
function promptYesNo() {
  local prompt
  prompt="${1}"

  showFzf "yes-no" "" "${prompt}" ''

  # we keep only the selected value, i.e. the 2nd line
  LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE#*$'\n'}"
  LAST_RETURNED_VALUE="${LAST_RETURNED_VALUE%%$'\n'*}"
  if [[ ${LAST_RETURNED_VALUE} == "Yes" ]]; then LAST_RETURNED_VALUE=true; else LAST_RETURNED_VALUE=false; fi
}
