#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# This function returns the absolute path of a file.
# The file must exists for this function to work.
#
# $1: The file to get the absolute path.
#
# Returns:
#   LAST_RETURNED_VALUE: The absolute path of the file.
#
# Usage:
#   io::toAbsolutePath "myFile" && local myFileAbsolutePath="${LAST_RETURNED_VALUE}"
function io::toAbsolutePath() {
  local file="${1%/}"

  if [[ ${file} == "/"* ]]; then
    LAST_RETURNED_VALUE="${file}"
    return 0
  fi

  LAST_RETURNED_VALUE="${PWD}/${file##*/}"
  if [[ -f "${LAST_RETURNED_VALUE}" ]]; then
    return 0
  fi

  if pushd "${file%/*}" &>/dev/null; then
    LAST_RETURNED_VALUE="${PWD}/${file##*/}"
    popd &>/dev/null
    return 0
  fi

  LAST_RETURNED_VALUE="${file}"
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# $4: the stdin (can be empty)
# $5: the executable to io::invoke
# $6+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The stdout file of the executable in the global variable LAST_RETURNED_VALUE.
#   The stderr file of the executable in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke5 "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
#   stdoutFilePath="${LAST_RETURNED_VALUE}"
#   stderrFilePath="${LAST_RETURNED_VALUE2}"
function io::invoke5() {
  local failIfFails acceptableErrorCodes stdInFromFile stdIn executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  stdInFromFile="${3}"
  stdIn="${4}"
  executable="${5}"
  shift 5

  # if debug mode is on, print some info
  if log::isDebugEnabled; then
    local debugMessage="Executing the command ⌜${executable}⌝."$'\n'
    debugMessage+="Fail if it fails: ⌜${failIfFails}⌝"$'\n'
    debugMessage+="Acceptable error codes: ⌜${acceptableErrorCodes}⌝"$'\n'
    debugMessage+="Standard stream from file: ⌜${stdInFromFile}⌝"$'\n'
    debugMessage+="Standard stream: ⌜${stdIn}⌝"$'\n'
    debugMessage+="Extra parameters: ⌜${*}⌝"
    log::debug "${debugMessage}"
  fi

  # execute the executable
  local -i exitCode=0
  if [[ -n "${stdIn}" ]]; then
    if [[ ${stdInFromFile} == "true" ]]; then
      "${executable}" "$@" < "${stdIn}" 1> "${GLOBAL_TEMPORARY_STDOUT_FILE}" 2> "${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
    else
      "${executable}" "$@" <<< "${stdIn}" 1> "${GLOBAL_TEMPORARY_STDOUT_FILE}" 2> "${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
    fi
  else
    "${executable}" "$@" 1> "${GLOBAL_TEMPORARY_STDOUT_FILE}" 2> "${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
  fi

  local debugMessage="The command ⌜${executable}⌝ originally ended with exit code ⌜${exitCode}⌝."

  # if the error code is acceptable, then we set it to 0
  if [[ ,${acceptableErrorCodes}, == *",${exitCode},"* ]]; then
    exitCode=0
    debugMessage+=$'\n'"The error code ⌜${exitCode}⌝ is acceptable and has been reset to 0."
  fi

  local shouldFail=false
  if [[ ${failIfFails} == "true" && exitCode -ne 0 ]]; then shouldFail=true; fi

  # fail if needed or we are debug mode; display all the debug information that could be useful
  if log::isDebugEnabled || [[ ${shouldFail} == "true" ]]; then

    # append std out
    if [[ -s "${GLOBAL_TEMPORARY_STDOUT_FILE}" ]]; then
      io::readFile "${GLOBAL_TEMPORARY_STDOUT_FILE}" 5000
      if [[ "${#LAST_RETURNED_VALUE}" -ge 5000 ]]; then LAST_RETURNED_VALUE+="... (truncated)"; fi
      debugMessage+=$'\n'"Standard output:"$'\n'"⌜${LAST_RETURNED_VALUE}⌝"
    fi
    # append stderr
    if [[ -s "${GLOBAL_TEMPORARY_STDERR_FILE}" ]]; then
      io::readFile "${GLOBAL_TEMPORARY_STDERR_FILE}" 5000
      if [[ "${#LAST_RETURNED_VALUE}" -ge 5000 ]]; then LAST_RETURNED_VALUE+="... (truncated)"; fi
      debugMessage+=$'\n'"Error output:"$'\n'"⌜${LAST_RETURNED_VALUE}⌝"
    fi

    if [[ ${shouldFail} == "true" ]]; then
      core::fail "${debugMessage}"
    else
      log::debug "${debugMessage}"
    fi
  fi

  LAST_RETURNED_VALUE="${GLOBAL_TEMPORARY_STDOUT_FILE}"
  LAST_RETURNED_VALUE2="${GLOBAL_TEMPORARY_STDERR_FILE}"
  return ${exitCode}
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: the executable to io::invoke
# $4+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The stdout file of the executable in the global variable LAST_RETURNED_VALUE.
#   The stderr file of the executable in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke3 "false" "false" "stuff" "--height=10" || core::fail "stuff failed."
#   stdoutFilePath="${LAST_RETURNED_VALUE}"
#   stderrFilePath="${LAST_RETURNED_VALUE2}"
function io::invoke3() {
  local failIfFails acceptableErrorCodes executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  shift 2

  io::invoke5 "${failIfFails}" "${acceptableErrorCodes}" "" "" "$@" || return $?
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# $4: the stdin (can be empty)
# $5: the executable to io::invoke
# $6+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The content of stdout in the global variable LAST_RETURNED_VALUE.
#   The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke5var "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
#   stdout="${LAST_RETURNED_VALUE}"
#   stderr="${LAST_RETURNED_VALUE2}"
function io::invoke5var() {
  local -i exitCode=0
  io::invoke5 "$@" || exitCode=$?
  local stdOutFile="${LAST_RETURNED_VALUE}"
  local stdErrFile="${LAST_RETURNED_VALUE2}"

  io::readFile "${stdErrFile}"
  LAST_RETURNED_VALUE2="${LAST_RETURNED_VALUE}"
  io::readFile "${stdOutFile}"

  return ${exitCode}
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: the executable to io::invoke
# $4+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The content of stdout in the global variable LAST_RETURNED_VALUE.
#   The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke3var "false" "130,2" "stuff" "--height=10" || core::fail "stuff failed."
#   stdout="${LAST_RETURNED_VALUE}"
#   stderr="${LAST_RETURNED_VALUE2}"
function io::invoke3var() {
  local failIfFails acceptableErrorCodes executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  shift 2

  io::invoke5var "${failIfFails}" "${acceptableErrorCodes}" "" "" "$@" || return $?
}

# This function call an executable and its arguments.
# If the execution fails, it will fail the script and show the std/err output.
# Otherwise it hides both streams, effectively rendering the execution silent unless it fails.
#
# Returns:
#  The content of stdout in the global variable LAST_RETURNED_VALUE.
#  The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#  io::invoke git add --all
function io::invoke() {
  io::invoke5var "true" "0" "" "" "$@"
}

# Execute the given command and return the output in the global variable LAST_RETURNED_VALUE.
# In windows, this is tremendously faster than doing myvar="$(mycommand)".
# On linux, it is slighly faster (but it might be slower if you don't have SSD?).
# On linux, you can use a tmpfs directory for massive gains over subshells.
#
# $1+: the command to execute (with args)
#
# Returns:
#   exit with code 1 if the command fails.
#   The output of the command in the global variable LAST_RETURNED_VALUE.
#   The error output of the command in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::captureOutput "ls -l" && local lsOutput="${LAST_RETURNED_VALUE}"
function io::captureOutput() {
  local -i exitCode=0
  "$@" 1> "${GLOBAL_TEMPORARY_STDOUT_FILE}" 2> "${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?

  io::readFile "${GLOBAL_TEMPORARY_STDERR_FILE}"
  LAST_RETURNED_VALUE2="${LAST_RETURNED_VALUE}"

  io::readFile "${GLOBAL_TEMPORARY_STDOUT_FILE}"

  return ${exitCode}
}

# Reads the content of a file and returns it in the global variable LAST_RETURNED_VALUE.
# Uses pure bash.
#
# $1: the file path to read
# $2: (optional) the maximum number of characters to read
#
# Notes:
#   If the file does not exist, the function will return an empty string instead of failing.
#
# Returns:
#   The content of the file in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#   io::readFile "/path/to/file" && local fileContent="${LAST_RETURNED_VALUE}"
#   io::readFile "/path/to/file" 500 && local fileContent="${LAST_RETURNED_VALUE}"
function io::readFile() {
  local filePath="${1}"
  local -i maxCharacters="${2:-0}"

  if [[ ! -s "${filePath}" ]]; then
    LAST_RETURNED_VALUE=""
    return 0
  fi

  local IFS=
  if [[ "${maxCharacters}" -gt 0 ]]; then
    read -rd '' -n "${maxCharacters}" LAST_RETURNED_VALUE < "${filePath}" || true
  else
    read -rd '' LAST_RETURNED_VALUE < "${filePath}" || true
  fi
}

# Check last return code and fail (exit) if it is an error
# $1: the return code
# $2+ : the error message to display in case of error
#
# Usage:
#   command_that_could_fail || checkAndcore::fail "$?" "The command that could fail has failed!"
function io::checkAndFail() {
  if [[ "${1:-}" != "0" ]]; then
    shift
    core::fail "$*"
  fi
  return 0
}

# Check last return code and return an error code if error
# $1: the last return code
# $2+ : the warning message to display in case of error
#
# Usage:
#   command_that_could_fail || checkAndlog::warning "$?" "The command that could fail has failed!" || return "0"
function io::checkAndWarn() {
  if [[ "${1:-}" != "0" ]]; then
    shift
    log::warning "$*"
    return 1
  fi
  return 0
}