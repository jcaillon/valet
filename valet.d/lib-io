#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# This function returns the absolute path of a file.
# The file must exists for this function to work.
#
# $1: The file to get the absolute path.
#
# Returns:
#   LAST_RETURNED_VALUE: The absolute path of the file.
#
# Usage:
#   io::toAbsolutePath "myFile" && local myFileAbsolutePath="${LAST_RETURNED_VALUE}"
function io::toAbsolutePath() {
  local file="${1%/}"

  if [[ ${file} == "/"* ]]; then
    LAST_RETURNED_VALUE="${file}"
    return 0
  fi

  LAST_RETURNED_VALUE="${PWD}/${file##*/}"
  if [[ -f "${LAST_RETURNED_VALUE}" ]]; then
    return 0
  fi

  if pushd "${file%/*}" &>/dev/null; then
    LAST_RETURNED_VALUE="${PWD}/${file##*/}"
    popd &>/dev/null
    return 0
  fi

  LAST_RETURNED_VALUE="${file}"
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# $4: the stdin (can be empty)
# $5: the executable to io::invoke
# $6+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The stdout file of the executable in the global variable LAST_RETURNED_VALUE.
#   The stderr file of the executable in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke5 "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
#   stdoutFilePath="${LAST_RETURNED_VALUE}"
#   stderrFilePath="${LAST_RETURNED_VALUE2}"
function io::invoke5() {
  local failIfFails acceptableErrorCodes stdInFromFile stdIn executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  stdInFromFile="${3}"
  stdIn="${4}"
  executable="${5}"
  shift 5

  # if debug mode is on, print some info
  if log::isDebugEnabled; then
    local debugMessage="Executing the command ⌜${executable}⌝."$'\n'
    debugMessage+="Fail if it fails: ⌜${failIfFails}⌝"$'\n'
    debugMessage+="Acceptable error codes: ⌜${acceptableErrorCodes}⌝"$'\n'
    debugMessage+="Standard stream from file: ⌜${stdInFromFile}⌝"$'\n'
    debugMessage+="Standard stream: ⌜${stdIn}⌝"$'\n'
    debugMessage+="Extra parameters: ⌜${*}⌝"
    log::debug "${debugMessage}"
  fi

  # execute the executable
  local -i exitCode=0
  if [[ -n "${stdIn}" ]]; then
    if [[ ${stdInFromFile} == "true" ]]; then
      "${executable}" "$@" <"${stdIn}" 1>"${GLOBAL_TEMPORARY_STDOUT_FILE}" 2>"${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
    else
      "${executable}" "$@" <<<"${stdIn}" 1>"${GLOBAL_TEMPORARY_STDOUT_FILE}" 2>"${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
    fi
  else
    "${executable}" "$@" 1>"${GLOBAL_TEMPORARY_STDOUT_FILE}" 2>"${GLOBAL_TEMPORARY_STDERR_FILE}" || exitCode=$?
  fi

  local debugMessage="The command ⌜${executable}⌝ originally ended with exit code ⌜${exitCode}⌝."

  # if the error code is acceptable, then we set it to 0
  if [[ ,${acceptableErrorCodes}, == *",${exitCode},"* ]]; then
    exitCode=0
    debugMessage+=$'\n'"The error code ⌜${exitCode}⌝ is acceptable and has been reset to 0."
  fi

  local shouldFail=false
  if [[ ${failIfFails} == "true" && exitCode -ne 0 ]]; then shouldFail=true; fi

  # fail if needed or we are debug mode; display all the debug information that could be useful
  if log::isDebugEnabled || [[ ${shouldFail} == "true" ]]; then

    # append std out
    debugMessage+=$'\n'"________"$'\n'"Standard output:"$'\n'
    if [[ -s "${GLOBAL_TEMPORARY_STDOUT_FILE}" ]]; then
      io::readFile "${GLOBAL_TEMPORARY_STDOUT_FILE}" 5000
      if [[ "${#LAST_RETURNED_VALUE}" -ge 5000 ]]; then LAST_RETURNED_VALUE+="... (truncated)"; fi
      debugMessage+="⌜${LAST_RETURNED_VALUE}⌝"
    else
      debugMessage+="⌜(empty)⌝"
    fi

    # append stderr
    debugMessage+=$'\n'"________"$'\n'"Error output:"$'\n'
    if [[ -s "${GLOBAL_TEMPORARY_STDERR_FILE}" ]]; then
      io::readFile "${GLOBAL_TEMPORARY_STDERR_FILE}" 5000
      if [[ "${#LAST_RETURNED_VALUE}" -ge 5000 ]]; then LAST_RETURNED_VALUE+="... (truncated)"; fi
      debugMessage+="⌜${LAST_RETURNED_VALUE}⌝"
    else
      debugMessage+="⌜(empty)⌝"
    fi

    if [[ ${shouldFail} == "true" ]]; then
      core::fail "${debugMessage}"
    else
      log::debug "${debugMessage}"
    fi
  fi

  LAST_RETURNED_VALUE="${GLOBAL_TEMPORARY_STDOUT_FILE}"
  LAST_RETURNED_VALUE2="${GLOBAL_TEMPORARY_STDERR_FILE}"
  return ${exitCode}
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: the executable to io::invoke
# $4+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The stdout file of the executable in the global variable LAST_RETURNED_VALUE.
#   The stderr file of the executable in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke3 "false" "false" "stuff" "--height=10" || core::fail "stuff failed."
#   stdoutFilePath="${LAST_RETURNED_VALUE}"
#   stderrFilePath="${LAST_RETURNED_VALUE2}"
function io::invoke3() {
  local failIfFails acceptableErrorCodes executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  shift 2

  io::invoke5 "${failIfFails}" "${acceptableErrorCodes}" "" "" "$@" || return $?
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# $4: the stdin (can be empty)
# $5: the executable to io::invoke
# $6+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The content of stdout in the global variable LAST_RETURNED_VALUE.
#   The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke5var "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
#   stdout="${LAST_RETURNED_VALUE}"
#   stderr="${LAST_RETURNED_VALUE2}"
function io::invoke5var() {
  local -i exitCode=0
  io::invoke5 "$@" || exitCode=$?
  local stdOutFile="${LAST_RETURNED_VALUE}"
  local stdErrFile="${LAST_RETURNED_VALUE2}"

  io::readFile "${stdErrFile}"
  LAST_RETURNED_VALUE2="${LAST_RETURNED_VALUE}"
  io::readFile "${stdOutFile}"

  return ${exitCode}
}

# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
#
# $1: true/false to indicate if the function should fail in case the execution fails
# $2: the acceptable error codes, comma separated (if the error code is matched, then set the output error code to 0)
# $3: the executable to io::invoke
# $4+: the arguments to pass to the executable
#
# Returns:
#   The exit code of the function is the exit code of the executable.
#   The content of stdout in the global variable LAST_RETURNED_VALUE.
#   The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#   io::invoke3var "false" "130,2" "stuff" "--height=10" || core::fail "stuff failed."
#   stdout="${LAST_RETURNED_VALUE}"
#   stderr="${LAST_RETURNED_VALUE2}"
function io::invoke3var() {
  local failIfFails acceptableErrorCodes executable
  failIfFails="${1}"
  acceptableErrorCodes="${2}"
  shift 2

  io::invoke5var "${failIfFails}" "${acceptableErrorCodes}" "" "" "$@" || return $?
}

# This function call an executable and its arguments.
# If the execution fails, it will fail the script and show the std/err output.
# Otherwise it hides both streams, effectively rendering the execution silent unless it fails.
#
# In windows, this is tremendously faster to do
# io::invoke && myvar="${LAST_RETURNED_VALUE}"
# than doing:
# myvar="$(mycommand)".
# On linux, it is slighly faster (but it might be slower if you don't have SSD?).
# On linux, you can use a tmpfs directory for massive gains over subshells.
#
# $@: the command and its arguments
#
# Returns:
#  The content of stdout in the global variable LAST_RETURNED_VALUE.
#  The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#  io::invoke git add --all
function io::invoke() {
  io::invoke5var true 0 '' '' "$@"
}

# This function call an executable and its arguments and input a given string as stdin.
# If the execution fails, it will fail the script and show the std/err output.
# Otherwise it hides both streams, effectively rendering the execution silent unless it fails.
#
# This is the equivalent of:
# myvar="$(echo "mystring" | mycommand)"
# In windows, this is tremendously faster that the example above.
# On linux, it is slighly faster (but it might be slower if you don't have SSD?).
# On linux, you can use a tmpfs directory for massive gains over subshells.
#
# $1: the stdin to pass to the executable
# $2+: the command and its arguments
#
# Returns:
#  The content of stdout in the global variable LAST_RETURNED_VALUE.
#  The content of stderr in the global variable LAST_RETURNED_VALUE2.
#
# Usage:
#  io::invoke git add --all
function io::invokePiped() {
  local stdIn="${1}"
  shift
  io::invoke5var true 0 false "${stdIn}" "$@"
}

# Reads the content of a file and returns it in the global variable LAST_RETURNED_VALUE.
# Uses pure bash.
#
# $1: the file path to read
# $2: (optional) the maximum number of characters to read
#
# Notes:
#   If the file does not exist, the function will return an empty string instead of failing.
#
# Returns:
#   The content of the file in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#   io::readFile "/path/to/file" && local fileContent="${LAST_RETURNED_VALUE}"
#   io::readFile "/path/to/file" 500 && local fileContent="${LAST_RETURNED_VALUE}"
function io::readFile() {
  local filePath="${1}"
  local -i maxCharacters="${2:-0}"

  if [[ ! -s "${filePath}" ]]; then
    LAST_RETURNED_VALUE=""
    return 0
  fi

  local IFS=''
  if [[ "${maxCharacters}" -gt 0 ]]; then
    read -rd '' -n "${maxCharacters}" LAST_RETURNED_VALUE <"${filePath}" || true
  else
    read -rd '' LAST_RETURNED_VALUE <"${filePath}" || true
    # fail safe for cases where the file is suppose to not be empty but we get null string
    if [[ -z "${LAST_RETURNED_VALUE}" ]]; then
      LAST_RETURNED_VALUE="$(<"${filePath}")"
    fi
  fi
}

# Check last return code and fail (exit) if it is an error.
#
# $1: the return code
# $2+ : the error message to display in case of error
#
# Usage:
#   command_that_could_fail || io::checkAndFail "$?" "The command that could fail has failed!"
function io::checkAndFail() {
  if [[ "${1:-}" != "0" ]]; then
    shift
    core::fail "$*"
  fi
  return 0
}

# Check last return code and warn the user + return an error code if error.
#
# $1: the last return code
# $2+ : the warning message to display in case of error
#
# Usage:
#   command_that_could_fail || io::checkAndWarn "$?" "The command that could fail has failed!" || return "0"
function io::checkAndWarn() {
  if [[ "${1:-}" != "0" ]]; then
    shift
    log::warning "$*"
    return 1
  fi
  return 0
}

# Make sure that the given file path exists.
# Create the directory tree and the file if needed.
#
# $1: the file path to create
#
# Returns:
#   The absolute path of the file in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#   io::createFilePathIfNeeded "myFile"
function io::createFilePathIfNeeded() {
  io::toAbsolutePath "${1}"
  local filePath="${LAST_RETURNED_VALUE}"
  local parentDir="${filePath%/*}"

  if [[ ! -d "${parentDir}" ]]; then
    mkdir -p "${parentDir}" 1>/dev/null || core::fail "Failed to create the directory ⌜${parentDir}⌝ for the file ⌜${filePath}⌝."
  fi

  if [[ ! -f "${filePath}" ]]; then
    : >"${filePath}"
  fi

  LAST_RETURNED_VALUE="${filePath}"
}

# Sleep for the given amount of time.
# This is a pure bash replacement of sleep.
#
# $1: the time to sleep in seconds (can be a float)
#
# Usage:
#   io:sleep 1.5
function io::sleep() {
  local timeout="${1}"
  # when connected to a terminal, we can just read the stdout
  # which will never be written to, and use a timeout on read
  if [[ -t 2 ]]; then
    read -rt "${timeout}" -u 2 || :
    return 0
  elif command -v mkfifo 1>/dev/null; then
    if [[ -z ${IO_SLEEP_FIFO:-} ]]; then
      io::createTempFile && IO_SLEEP_FIFO="${LAST_RETURNED_VALUE}"
      rm "${IO_SLEEP_FIFO}"
      mkfifo -m 700 "${IO_SLEEP_FIFO}"
      exec 9<>"${IO_SLEEP_FIFO}"
      rm "${IO_SLEEP_FIFO}"
    fi
    read -rt "${timeout}" -u 9 || :
  else
    # when everything else failed...
    sleep "${timeout}"
  fi
}

# Print the content of a file to stdout.
# This is a pure bash equivalent of cat.
#
# $1: the file to print
#
# Usage:
#   io::cat "myFile"
function io::cat() {
  io::readFile "${1}"
  echo "${LAST_RETURNED_VALUE}"
}

# Read the content of the standard input.
#
# Returns:
#   The content of the standard input in the global variable LAST_RETURNED_VALUE.
#
# Usage:
#   io::readStdIn && local stdIn="${LAST_RETURNED_VALUE}"
function io::readStdIn() {
  LAST_RETURNED_VALUE=""
  local IFS=''
  read -rd '' LAST_RETURNED_VALUE <&0 || :
}