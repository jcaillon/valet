#!/usr/bin/env bash
set -Eeu -o pipefail
# Title:          valet.d/main
# Description:    this script contains the main code for our bash programs and
#                 it should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
GLOBAL_MAIN_INCLUDED=1

if [[ -z "${GLOBAL_CORE_INCLUDED:-}" ]]; then
  # shellcheck source=core
  source "${BASH_SOURCE[0]%/*}/core"
fi

#===============================================================
# >>> Event handling
#===============================================================

function main::onErrorInternal() {
  if [[ ${GLOBAL_ERROR_DISPLAYED:-0} == "1" ]]; then
    return 0
  fi
  log::error "Error code ${1} in ${FUNCNAME[1]}(), stack:"
  log::printCallStack 2
  GLOBAL_ERROR_DISPLAYED=1
}

trap 'main::onErrorInternal $?' ERR

function main::onExitInternal() {
  local rc=$?

  # disable the profiler if still on
  if [[ ${PROFILING:-} == "1" ]]; then main::disableProfiler; fi

  log::debug "Exiting with code ${rc} after ${SECONDS}s."
  if command -v onExitTest 1>/dev/null 2>&1; then
    # this is for the self test command, we need to inform the user in case of an
    # unexpected exit because they would not see the logs otherwise
    onExitTest "${rc}"
  fi
  if command -v onExit 1>/dev/null 2>&1; then
    onExit
  fi
  # if we ran an interactive function, make sure to restore the cursor
  if [[ -n ${cursorShow:-} ]]; then
    printf '%s' "${cursorShow}"
  fi
  # always call cleanUp before exiting
  main::onCleanUpInternal
  if [[ "${GLOBAL_ERROR_DISPLAYED:-0}" != "1" && "${rc}" != "0" ]]; then
    log::print "ERROR" "${VALET_CONFIG_ICON_EXIT:-$'\uf14c'}" "EXIT" "Exiting with code ${rc}, stack:"
    log::printCallStack 2
    GLOBAL_ERROR_DISPLAYED=1
  fi
}

trap main::onExitInternal EXIT

function main::onInterruptInternal() {
  printf '\n' # Set cursor to the next line of '^C'
  log::print "WARNING" "${VALET_CONFIG_ICON_STOPPED:-$'\uf256'}" "STOPPED" "Program interrupted by the user."

  if log::isDebugEnabled; then
    log::debug "Is your command stuck? Consider using the ⌜-x⌝ option to activate the profiler and identify what's wrong. Here is the current stack:"
    log::printCallStack 2
  fi

  # check if the function exists
  if command -v onInterrupt 1>/dev/null 2>&1; then
    if onInterrupt; then
      # if onInterrupt returns 0, then we cancel the interrupt
      return 0
    fi
  fi
  exit 1
}

# Register CTRL+C SIGINT (interrupt) and CTRL+\ QUIT (interrupt with a coredump) event handler
trap main::onInterruptInternal SIGINT SIGQUIT

function main::onTerminateInternal() {
  log::print "ERROR" "${VALET_CONFIG_ICON_KILLED:-$'\uf05e'}" "KILLED" "Program killed."
  # check if the function exists
  if command -v onTerminate 1>/dev/null 2>&1; then
    if onTerminate; then
      # if onTerminate returns 0, then we cancel the termination
      return 0
    fi
  fi
  exit 1
}

# Register SIGHUP (hang up, terminal disconnected) and TERM (terminate the program) event handler
trap main::onTerminateInternal SIGHUP SIGTERM

function main::onCleanUpInternal() {
  io::cleanupTempFiles
  if command -v cleanUp 1>/dev/null 2>&1; then
    cleanUp
  fi
}

# Introducing our own function to handle commands not found, so we can display a better message
function command_not_found_handle() {
  if [[ ${1:-} == "curl" ]]; then
    core::fail "This command requires ⌜curl⌝ to make https request to the internet."$'\n'"Please install it in your path and run this command again."
  fi
  # if the command contains :: it is one of our function, we can suggest to source the 'package'
  if [[ ${1} == *::* ]]; then
    core::fail "Command not found: ⌜${1}⌝."$'\n'"Did you forget to source the package? ⌜source ${1%%::*}⌝"
  fi
  core::fail "Command not found: ⌜${1}⌝."$'\n'"Please check your ⌜PATH⌝ variable."
}

#===============================================================
# >>> Profiler
#===============================================================
# Enables the profiler and start writing to the given file.
#
# $1: the file to write to.
#
# Usage:
#   main::enableProfiler "${HOME}/valet-profiler-${BASHPID}.txt"
function main::enableProfiler() {
  local file
  file="${1}"

  # Nested profiling not supported
  if [[ -n "${PROFILING:-}" ]]; then return 0; fi
  PROFILING=1

  # create the directory for file and reset it
  mkdir -p "${file%/*}"
  : "${file}"

  log::info "Starting profiler, writing in ⌜${file}⌝. ${FUNCNAME[3]:-}"

  # we can only get the function depth if we call the main::enableProfiler from a function
  if [[ -n "${FUNCNAME[3]:-}" ]]; then
    functionDepthExpression='${#FUNCNAME[@]}'
  else
    functionDepthExpression='0'
  fi

  PS4='+'$'\011''$(("${EPOCHREALTIME//./}" - PROFILER_START_REALTIME))'$'\011''${BASH_SOURCE[0]:-}'$'\011''${LINENO:-?}'$'\011''${FUNCNAME[0]:-}'$'\011''${BASH_SUBSHELL}'$'\011'"${functionDepthExpression}"$'\011''→'$'\011'

  exec 5>"${file}"

  export PROFILER_FILE="${file}"
  export PROFILER_START_REALTIME="${EPOCHREALTIME//./}"
  export BASH_XTRACEFD=5
  set -x
}

# Disable the profiler.
#
# Usage:
#   main::disableProfiler
function main::disableProfiler() {
  log::info "Disabling profiler."
  set +x
  unset BASH_XTRACEFD PS4 PROFILING
  exec 5>&-
  main::cleanProfilerFile
}

# Allows to pretty format the profiler file and remove stuff the user does not need.
#
# Usage:
#   main::cleanProfilerFile
function main::cleanProfilerFile() {
  io::createTempFile && local newProfilerFile="${RETURNED_VALUE}"

  local timePrecision=${EPOCHREALTIME#*.}
  timePrecision=${#timePrecision}

  local clearLine
  if [[ ${VALET_CONFIG_KEEP_ALL_PROFILER_LINES:-false} == "true" ]]; then
    clearLine=false
  fi
  if [[ -z "${clearLine:-}" && "${VALET_CONFIG_STARTUP_PROFILING:-false}" == "true" ]]; then
    clearLine=false
  fi
  if [[ -z "${clearLine:-}" ]]; then
    clearLine=true
  fi

  # we do this one in awk for now because it was a good place to learn awk
  # TODO: could be replaced with bash later but im not sure how to do decimal math in bash
  if ! command -v awk 1>/dev/null 2>&1; then
    log::warning "The awk command is required to clean the profiler file. It was not found on the PATH so we skip the cleaning."
    return 0
  fi

  awk -F $'\t' -v timePrecision="${timePrecision}" -v clearCoreLine="${clearLine}" '
  BEGIN {
    printf "%s\n\n", "(D=function depth, I=level of indirection, S=subshell level, timer=elapsed time in seconds, delta=delta between the last command in seconds, caller source:line=the source file and line number of the caller of the function, function=the name of the function in which the command is executed, command=the executed command)";
    printf "%s\n", "D  I  S  timer  delta                           source:line function                                 → command";
    lastLineWasSkipped = 0;
    lastLineLength = 0;
    lastTimer = 0;
    baseStackLength = 99999;
  }
  {
    if (clearCoreLine == "true" && $3 ~ /(valet.d\/core|valet.d\/main|valet.d\/lib-[a-z0-9])$/) {
      lastLineWasSkipped = 1;
      next;
    }
    if ($0 ~ /^\+/) {
      if (clearCoreLine == "true") {
        lastLineWasSkipped = 0;
      }
    } else {
      if (lastLineWasSkipped == 1) {
        next;
      }
      printf "%103s%s\n", "", $0;
      next;
    }
    if (baseStackLength == 99999) {
      baseStackLength = $7;
    }

    indirectionLevel = length($1);
    timer = $2 / (10 ^ timePrecision);
    program = $3;
    lineNumber = $4;
    if (length(program) > 30) {
      programShorten = "..." substr(program, length(program)-27);
    } else {
      programShorten = program;
    }
    fun = $5 "()";
    if (length(fun) > 40) {
      funShorten = "..." substr(fun, length(fun)-37);
    } else {
      funShorten = fun;
    }
    subShellLevel = $6;
    stackLength = $7 - baseStackLength;
    theRest = "";
    for (x = 9; x <= NF; x++) {
      theRest = theRest $x;
    }
    deltaTimer = timer - lastTimer;


    printf "%02d %02d %02d %.4f %.4f %30s:%-4d %-40s → %s\n", stackLength, indirectionLevel, subShellLevel, timer, deltaTimer, programShorten, lineNumber, fun, theRest;
    lastTimer = timer;
    lastLineLength = length($0) - length(theRest);
  }
  ' <"${PROFILER_FILE}" >"${newProfilerFile}"

  mv -f "${newProfilerFile}" "${PROFILER_FILE}"
}

if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
  main::enableProfiler "${VALET_CONFIG_STARTUP_PROFILING_FILE:-"${HOME}/valet-profiler-${BASHPID}.txt"}"
fi

#===============================================================
# >>> Help
#===============================================================

# Prints the help text of a function or a command.
#
# $1: the type help to print (function or menu).
# $2: the name of the function or the command in the case of a menu.
# $3: (optional) whether to use colors or not (true to not use color).
# $4: (optional) the maximum columns for the help text.
#
# Usage:
#   main::printHelp function "this" "false" "${GLOBAL_COLUMNS}"
function main::printHelp() {
  main::getHelpText "$@"
  printf '%s' "${RETURNED_VALUE}"
}

# Get the help text of a function or a command.
#
# $1: the type help to print (function or menu).
# $2: the name of the function or the command in the case of a menu.
# $3: (optional) whether to use colors or not (true to not use colors).
# $4: (optional) the maximum columns for the help text.
#
# Usage:
#   main::getHelpText function "this" "false" "${GLOBAL_COLUMNS}"
function main::getHelpText() {
  local type=${1:-function}
  local name="${2:-this}"
  local noColor="${3:-}"
  local maxColumns="${4:-180}"

  if [[ -z ${noColor:-} && ${VALET_CONFIG_ENABLE_COLORS:-false} != true ]]; then
    noColor=true
  fi

  # sudo apt-get install colortest
  # colortest-16b
  local cDefault cTitle cHighlight cOption cArgument cCommand
  if [[ ${noColor} == "true" ]]; then
    cDefault=""
    cTitle=""
    cHighlight=""
    cOption=""
    cArgument=""
    cCommand=""
  else
    cDefault=${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}
    cTitle=${VALET_CONFIG_COLOR_TITLE:-$'\e'"[0;36m"}
    cHighlight=${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[0;35m"}
    cOption=${VALET_CONFIG_COLOR_OPTION:-$'\e'"[0;33m"}
    cArgument=${VALET_CONFIG_COLOR_ARGUMENT:-$'\e'"[0;31m"}
    cCommand=${VALET_CONFIG_COLOR_COMMAND:-$'\e'"[0;32m"}
  fi

  local -i helpWidth
  helpWidth="${maxColumns}"
  if [[ helpWidth -gt ${GLOBAL_COLUMNS} ]]; then helpWidth=${GLOBAL_COLUMNS}; fi

  if [[ ${type} == "function" ]]; then
    # case of a function; we will get the description from CMD_ vars directly
    functionName="${name}"
  else
    # case of a menu; we will the sub commands for it
    functionName="_menu"
    # shellcheck disable=SC2034
    CMD_COMMAND__menu="${name}"
    CMD_COMMANDS_NAME__menu=()
    CMD_COMMANDS_DESCRIPTION__menu=()
    local index subCommand
    for index in "${!CMD_COMMANDS_NAME_this[@]}"; do
      local subCommand="${CMD_COMMANDS_NAME_this[${index}]}"
      if [[ "${subCommand}" != "${name} "* ]]; then continue; fi
      CMD_COMMANDS_NAME__menu+=("${subCommand}")
      CMD_COMMANDS_DESCRIPTION__menu+=("${CMD_COMMANDS_DESCRIPTION_this[${index}]}")
    done
  fi

  local -n command="CMD_COMMAND_${functionName}"
  local -n description="CMD_DESCRIPTION_${functionName}"
  local -n functionOptions="CMD_OPTIONS_NAME_${functionName}"
  local -n functionArguments="CMD_ARGUMENTS_NAME_${functionName}"
  local -n functionCommands="CMD_COMMANDS_NAME_${functionName}"
  local -n functionExamples="CMD_EXAMPLES_NAME_${functionName}"

  # description
  string::wrapText "${description}" "${helpWidth}" 2 "true"
  local wrappedDescription="${RETURNED_VALUE}"

  # usage
  local usage
  if [[ ${functionName} == "this" ]]; then
    usage="valet"
  else
    usage="valet ${command}"
  fi
  if [[ -n "${functionOptions:-}" ]]; then
    usage+=" ${cOption}[options]${cDefault}"
  fi
  if [[ -n "${functionCommands:-}" ]]; then
    usage+=" ${cCommand}[command]${cDefault}"
  else
    if [[ -n "${functionArguments:-}" ]]; then
      for argument in "${functionArguments[@]}"; do
        if [[ ${argument} == *\?* ]]; then
          usage+=" ${cArgument}[${argument//\?/}]${cDefault}"
        else
          usage+=" ${cArgument}<${argument}>${cDefault}"
        fi
      done
    fi
  fi
  string::wrapText "${usage}" "${helpWidth}" 2 "true"
  usage="${RETURNED_VALUE}"

  # options
  local options
  if [[ -n "${functionOptions:-}" ]]; then
    options="${cTitle}OPTIONS${cDefault}"$'\n'$'\n'
    main::writeAsTable "${helpWidth}" "${cOption}" "CMD_OPTIONS" "${functionName}"
    options+="${RETURNED_VALUE}"$'\n'
  fi

  # arguments
  local arguments
  if [[ -z "${functionCommands:-}" && -n "${functionArguments:-}" ]]; then
    arguments="${cTitle}ARGUMENTS${cDefault}"$'\n'$'\n'
    main::writeAsTable "${helpWidth}" "${cArgument}" "CMD_ARGUMENTS" "${functionName}"
    arguments+="${RETURNED_VALUE}"$'\n'
  fi

  # commands
  local commands
  if [[ -n "${functionCommands:-}" ]]; then
    commands="${cTitle}COMMANDS${cDefault}"$'\n'$'\n'
    main::writeAsTable "${helpWidth}" "${cCommand}" "CMD_COMMANDS" "${functionName}"
    commands+="${RETURNED_VALUE}"$'\n'
  fi

  # examples
  local examples
  if [[ -n "${functionExamples:-}" ]]; then
    examples="${cTitle}EXAMPLES${cDefault}"$'\n'$'\n'
    main::writeAsTable "${helpWidth}" "" "CMD_EXAMPLES" "${functionName}"
    examples+="${RETURNED_VALUE}"$'\n'
  fi

  local output="${cTitle}ABOUT${cDefault}

${wrappedDescription}

${cTitle}USAGE${cDefault}

${usage}

${options:-}${arguments:-}${commands:-}${examples:-}"

  # surround "markdown like" _italic_ with italic color
  if [[ ${noColor:-false} == "false" ]]; then
    output="${output//⌜/${cHighlight}⌜}"
    output="${output//⌝/⌝${cDefault}}"
  fi

  RETURNED_VALUE="${output}"
}

# used in show help to write a table of options, commands, arguments...
# transform text1\ttext2 to:
#   text1
#           text2
# text1 can be showed in color and we respect a maximum width
function main::writeAsTable() {
  local width color prefix functionName
  width="${1}"
  color="${2}"
  prefix="${3}"
  functionName="${4}"

  local -n names="${prefix}_NAME_${functionName}"
  local -n descriptions="${prefix}_DESCRIPTION_${functionName}"

  local cDefault output description index
  if [[ -n "${color:-}" ]]; then cDefault=$'\e'"[0m"; fi

  output=""
  for index in "${!names[@]}"; do
    string::wrapText "${names[${index}]}" "${helpWidth}" 2 "true"
    output+="${color}${RETURNED_VALUE}${cDefault:-}"$'\n'

    string::wrapText "${descriptions[${index}]}" "${helpWidth}" 6 "true"
    output+="${RETURNED_VALUE}"$'\n'
  done

  RETURNED_VALUE="${output}"
}


#===============================================================
# >>> Main functions
#===============================================================

# parse the user arguments for the main program.
function main::parseMainArguments() {
  local -a commands=()
  local -a subCommandArgs=()

  local maxNbCommands
  maxNbCommands=$((CMD_MAX_SUB_COMMAND_LEVEL + 1))

  # Parsing the options from environment variables
  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    PROFIL_COMMAND=true
  fi

  # for the main command, we parse the arguments manually
  # this is for performance reasons, we want to stop parsing as soon as possible
  while [[ $# -gt 0 ]]; do
    if [[ ${#commands[@]} -gt 0 && "${1}" == "-"* ]]; then
      # we matched the commands and we found an option for the sub command
      break
    fi
    case "${1}" in
    -x | --profiling)
      PROFIL_COMMAND=true
      ;;
    -l | --log | --log-level)
      shift
      log::setLevel "${1}"
      ;;
    -v | --verbose)
      log::setLevel debug
      ;;
    -w | --very-verbose)
      log::setLevel trace
      ;;
    --version)
      cat "${GLOBAL_VALET_HOME}/valet.d/version"
      exit 0
      ;;
    -h | --help)
      main::printHelp function "this"
      exit 0
      ;;
    -*)
      # shellcheck disable=SC2048 disable=SC2086
      main::fuzzyFindOption "${1}" ${CMD_OPTS_this[*]}
      core::fail "Unknown option ⌜${1}⌝${RETURNED_VALUE:-}."
      ;;
    *)
      commands+=("${1}")
      # we don't expect more than maxNbCommands commands so if we matched enough, break
      if [[ "${#commands[@]}" -ge "${maxNbCommands}" ]]; then
        break
      fi
      # if we matched the first command, we can extract the arguments for the sub command
      if [[ "${#commands[@]}" -eq "1" ]]; then
        subCommandArgs=("$@")
      fi
      ;;
    esac
    shift
  done

  log::debug "Command found ⌜${commands[*]}⌝."

  if [[ ${#commands[@]} -eq 0 ]]; then
    # no command provided, we show the commands menu
    main::showCommandsMenuAndRun "main-menu" CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY
  fi

  local functionName nbArgs exactCommand
  main::fuzzyMatchCommandtoFunctionName "${commands[@]}"
  functionName="${RETURNED_VALUE:-}"
  nbArgs="${RETURNED_VALUE2:-}"
  exactCommand="${RETURNED_VALUE3:-}"
  if [[ -z "${functionName}" ]]; then
    core::fail "Could not find a command for ⌜${commands[*]}⌝."
  fi

  log::debug "Function name found ⌜${functionName}⌝."

  if [[ ${functionName} == "_menu" ]]; then
    # run a menu with the list of sub commands
    main::runMenuWithSubCommands "${exactCommand}" "${subCommandArgs[@]:${nbArgs}}"
  else
    # run the function without the matched commands in the arguments
    main::runFunction "${functionName}" "${subCommandArgs[@]:${nbArgs}}"
  fi
}

# Run a given function
# The first arguments should be the function name,
# the rest of the arguments are the user arguments starting
# from the command name. e.g.:
# sub cmd --opt1 arg1 arg2
#
# $1: the function name
# $2+: the user arguments
function main::runFunction() {
  local functionName
  functionName="${1}"
  shift

  if [[ -z "${functionName}" ]]; then
    core::fail "No function name provided."
  fi

  # get command name of the function
  local -n command="CMD_COMMAND_${functionName}"

  # check for sudo if the function requires it
  local -n requiresSudo="CMD_SUDO_${functionName}"
  if [[ ${requiresSudo:-} == "true" ]]; then
    main::checkSudo
  fi

  # source the file in which the function is located if needed
  core::sourceFunction "${functionName}"

  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    core::fail "The function ⌜${functionName}⌝ associated with the command ⌜${command}⌝ does not exist."
  fi

  log::debug "Running the command ⌜${command}⌝ with the function ⌜${functionName}⌝ and the arguments ⌜$*⌝."

  # disable startup profile and enable command profile, if needed
  if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
    main::disableProfiler
  fi
  if [[ ${PROFIL_COMMAND:-} == "true" ]]; then
    main::enableProfiler "${VALET_CONFIG_COMMAND_PROFILING_FILE:-"${HOME}/valet-profiler-${BASHPID}-command.txt"}"
  fi

  # execute the function
  "${functionName}" "$@"

  if [[ ${PROFIL_COMMAND:-} == "true" ]]; then
    main::disableProfiler
  fi

  exit 0
}

# This function checks if the user has sudo privileges.
# If the user has sudo, it will set the SUDO variable to "sudo".
# If the user does not have sudo, it will set the SUDO variable to "".
#
# Usage:
#  main::checkSudo
function main::checkSudo() {
  # sudo
  if command -v sudo 1>/dev/null 2>&1; then
    log::info "This command requires sudo privileges."
    SUDO="sudo"
    ${SUDO} printf '%s' "alright" 1>/dev/null || core::fail "Could not sudo but the command requires it."
  else
    SUDO=""
  fi
}

# Run the a command that has sub command:
# - either show an interactive menu for a command that has sub commands,
# - or display the help for this menu.
#
# $1: the command name
#
# Usage:
#   main::runMenuWithSubCommands "command"
function main::runMenuWithSubCommands() {
  local command="${1}"
  shift

  local parsedArguments
  main::parseFunctionArguments "_menu" "$@"
  parsedArguments="${RETURNED_VALUE}"
  log::debug "Parsed arguments:"$'\n'"${parsedArguments}"
  eval "${parsedArguments}"

  if [[ -n "${help:-}" ]]; then
    main::printHelp menu "${command}"
    exit 0
  fi

  if [[ -n "${parsingErrors:-}" ]]; then
    core::fail "${parsingErrors}"$'\n'"Use valet ${command} --help to get help."
  fi

  # filter the commands to only keep the sub commands of the function
  local line
  declare -g -a FILTERED_COMMANDS_FOR_SUB_MENU=()
  for line in "${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}"; do
    if [[ ${line} =~ ^(${command} [^ ]+ ) ]]; then
      FILTERED_COMMANDS_FOR_SUB_MENU+=("${line}")
    fi
  done

  if (( ${#FILTERED_COMMANDS_FOR_SUB_MENU[@]} == 0 )); then
    core::fail "No sub commands found for ⌜${command}⌝."
  fi

  main::showCommandsMenuAndRun "${command//[^[:alnum:]]/_}" FILTERED_COMMANDS_FOR_SUB_MENU
}

# Show the given commands in an interactive menu and then
# run the selected command if any.
# $1: the menu id
# $2: the command selection items array name
function main::showCommandsMenuAndRun() {
  local menuId commandSelectionItemsArrayName
  menuId="${1}"
  commandSelectionItemsArrayName="${2}"

  # display the menu
  # TODO: reimplement usage of main::sortCommands

  local commandChoice
  main::showInteractiveCommandsMenu "${menuId}" "Please select the command to run." "${commandSelectionItemsArrayName}"
  commandChoice="${RETURNED_VALUE}"

  log::debug "Command choice ⌜${commandChoice}⌝."

  if [[ -z "${commandChoice}" ]]; then
    # the user pressed escape or ctrl-c
    exit 0
  fi
  # TODO: reimplement usage of main::addLastChoice
  # main::addLastChoice "${menuId}" "${commandChoice}"

  # get the function name from the command by replacing spaces and hyphens with _
  local functionName
  main::getFunctionNameFromCommand "${commandChoice}" && functionName="${RETURNED_VALUE}"

  main::runFunction "${functionName}"
}

# TODO: simplify this by directly storing and sourcing bash arrays
# This function sorts the commands in the menu
# by reading a file that contains the last used commands (last on top).
# The file is located in the configuration directory of the program.
# $1: the id of the menu (used in the file name)
# $2: the menu body
#
# Usage:
#  main::sortCommands "id" "${commands}" && sortedCommands="${RETURNED_VALUE}"
function main::sortCommands() {
  local menuId commands
  menuId="${1}"
  commands="${2}"

  # if the user does not want to remember the last choices, we return
  if [[ "${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}" -eq 0 ]]; then
    RETURNED_VALUE="${commands}"
    return 0
  fi

  local lastChoicesFile
  core::getLocalStateDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ ! -f "${lastChoicesFile}" ]]; then
    RETURNED_VALUE="${commands}"
    return 0
  fi

  local lastChoices
  readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"

  # list all the unplayed commands
  local unplayedCommands line command lastChoice played
  local -a commandsArray
  local IFS=$'\n'
  for line in ${commands}; do
    command="${line%%$'\t'*}"
    command="${command%%  *}"
    # check if the command has not been played yet
    played=false
    for lastChoice in "${lastChoices[@]}"; do
      if [[ ${lastChoice} == "${command}" ]]; then
        played=true
        break
      fi
    done
    # if not played, add it to the list
    if [[ ${played} == "false" ]]; then
      unplayedCommands+="${line}"$'\n'
    fi
    commandsArray+=("${line}")
  done

  # list all the played commands
  local playedCommands
  for lastChoice in "${lastChoices[@]}"; do
    # find the corresponding line in the commands, if any
    for line in "${commandsArray[@]}"; do
      command="${line%%$'\t'*}"
      command="${command%%  *}"
      if [[ ${command} == "${lastChoice}" ]]; then
        playedCommands+="${line}"$'\n'
        break
      fi
    done
  done

  commands="${playedCommands:-}${unplayedCommands:-}"
  RETURNED_VALUE="${commands%$'\n'}"
}

# This function adds the user command choice to the last choices file.
# It allows to sort the commands in the menu by the last used commands.
# $1: the id of the menu (used in the file name)
# $2: the command to add
#
# Usage:
#  main::addLastChoice "id" "command"
function main::addLastChoice() {
  local menuId command
  menuId="${1}"
  command="${2}"

  local maxNumberOfLastChoice=${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}

  # if the user does not want to remember the last choices, we return
  if [[ "${maxNumberOfLastChoice}" -eq 0 ]]; then
    return 0
  fi

  # load last choices from the file into an array
  local lastChoicesFile
  core::getLocalStateDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ ! -f "${lastChoicesFile}" ]]; then
    :>"${lastChoicesFile}"
  fi

  local lastChoices
  readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"

  # write the command first
  printf '%s\n' "${command}" >"${lastChoicesFile}"

  # loop through the last choices and add them to the file, limit to 20 total
  local -i total index
  total="${#lastChoices[@]}"
  if [[ total -gt maxNumberOfLastChoice ]]; then total=$((maxNumberOfLastChoice - 1)); fi
  index=0
  for ((index = 0; index < total; index++)); do
    if [[ "${lastChoices[${index}]}" != "${command}" ]]; then
      printf '%s\n' "${lastChoices[${index}]}" >>"${lastChoicesFile}"
    else
      total+=1
      if [[ total -gt ${#lastChoices[@]} ]]; then total=${#lastChoices[@]}; fi
    fi
  done
}

# show an interactive menu for commands
# returns the selected command in standard output
# $1: the menu id
# $2: the menu header
# $3: the menu items array name (reference)
#
# Usage:
#  main::showInteractiveCommandsMenu "menuId" "header" ARRAY_NAME && choice="${RETURNED_VALUE}"
function main::showInteractiveCommandsMenu() {
  local menuId menuHeader commandSelectionItemsArrayName
  menuId="${1}"
  menuHeader="${2}"
  commandSelectionItemsArrayName="${3}"
  shift 2

  # shellcheck source=lib-fsfs
  source fsfs

  fsfs::itemSelector "${menuHeader}" "${commandSelectionItemsArrayName}" "main::onFsfsItemSelectionChange" "Command help"

  choice="${RETURNED_VALUE}"
  if (( ${#choice} >= CMD_MAX_COMMAND_WIDTH)); then
    choice="${choice:0:${CMD_MAX_COMMAND_WIDTH}}  "
    choice="${choice%%  *}"
  else
    choice=""
  fi

  RETURNED_VALUE="${choice}"
}

function main::onFsfsItemSelectionChange() {
  local item="$1"
  local command="${item:0:${CMD_MAX_COMMAND_WIDTH}}  "
  command="${command%%  *}"
  main::getFunctionNameFromCommand "${command}"
  main::getHelpText function "${RETURNED_VALUE}" "" "${3}"
  return 0
}

#===============================================================
# >>> Find command/function from arguments
#===============================================================

# Get the function name of a command.
#
# Usage:
#  main::getFunctionNameFromCommand "self build" && printf '%s\n' "${RETURNED_VALUE}"
function main::getFunctionNameFromCommand() {
  local -n functionName="CMD_FUNCTION_NAME_${1//[^[:alnum:]]/_}"
  RETURNED_VALUE="${functionName:-}"
}

# Find the function name from arguments that represents the commands.
# If we do not find an exact match, we return try to fuzzy find the command
# and then return its function name.
#
# $@: the commands to find
#
# Returns:
#   the function name in the global variable RETURNED_VALUE
#   the level of the command in the global variable RETURNED_VALUE2
#   the exact command in the global variable RETURNED_VALUE3
#
# Usage:
#  main::fuzzyMatchCommandtoFunctionName "self" "build" && printf '%s\n' "${RETURNED_VALUE}"
function main::fuzzyMatchCommandtoFunctionName() {
  local level loopI functionName command exactCommand
  if [[ $# -eq 0 ]]; then
    return 0
  fi

  main::getMaxPossibleCommandLevel "$@"
  level="${RETURNED_VALUE}"

  # we put the arguments into an array so we can interpret 'my' 'sub'
  # and 'my sub' as the same command (we split everything by space)
  local -a commandArrray
  # shellcheck disable=SC2206
  commandArrray=($*)

  for ((loopI = level; loopI >= 1; loopI--)); do
    command="${commandArrray[*]:0:${loopI}}"

    # case where the command is exact, we can match the function immediately
    main::getFunctionNameFromCommand "${command}" && functionName="${RETURNED_VALUE}"
    if [[ -n "${functionName:-}" ]]; then
      exactCommand="${command}"
      break
    fi

    # case where the command is not exact, we try to fuzzy match it
    array::fuzzyFilter "${command}" CMD_ALL_COMMANDS_ARRAY
    if (( ${#RETURNED_ARRAY[@]} > 1 )); then
      local IFS=$'\n'
      log::debug "Ambiguous matching for the command ⌜${command}⌝:"$'\n'"${RETURNED_ARRAY[*]}"
      unset IFS
    elif (( ${#RETURNED_ARRAY[@]} == 1 )); then
      exactCommand="${RETURNED_ARRAY[0]}"
      main::getFunctionNameFromCommand "${exactCommand}" && functionName="${RETURNED_VALUE}"
      log::info "Fuzzy matching the command ⌜${command}⌝ to ⌜${exactCommand}⌝."
      break
    fi
  done

  RETURNED_VALUE="${functionName:-}"
  RETURNED_VALUE2="${loopI}"
  RETURNED_VALUE3="${exactCommand:-}"
}

# Return the maximum level of subcommands
# if in valet with have at max 2 level of commands
# e.g. cmd subcmd
# then there is no need to try to match a command with 5 arguments
# Same thing, if we provide only 1 argument to the cli, we
# can only match a simple command
# $@: the arguments
#
# Usage:
#  main::getMaxPossibleCommandLevel "cmd1" "subcmd2" "subsubcmd3" && level="${RETURNED_VALUE}"
function main::getMaxPossibleCommandLevel() {
  local command commandPart level maxLevel
  # count the number of spaces
  command="${*}"
  level=0
  # shellcheck disable=SC2034
  for commandPart in ${command}; do
    level=$((level + 1))
  done
  maxLevel=$((CMD_MAX_SUB_COMMAND_LEVEL + 1))
  if [[ "${level}" -gt "${maxLevel}" ]]; then
    level="${maxLevel}"
  fi

  RETURNED_VALUE="${level}"
}

#===============================================================
# >>> Parsers
#===============================================================

# Parses the arguments and options of a function.
# Usage:
#  main::parseFunctionArguments "functionName" "$@" && eval "${RETURNED_VALUE}"
#
# Notes:
# - It will return a string that can be evaluated to set the variables
#   corresponding to the arguments and options; e.g.:
#     "local arg1 option1
#     arg1=\"\"
#     option1=\"\"
#     ..."
# - It will also set the variable parsingErrors if there are any errors.
# - Variable name for an option is taken from the first --long version of the option.
# - It will set the variable as an array if the (last) argument name ends with '...'
function main::parseFunctionArguments() {
  local functionName
  functionName="${1}"
  shift

  local -n argumentsName="CMD_ARGS_NAME_${functionName}"
  local -i totalNbArguments
  if [[ -v argumentsName && ${#argumentsName[@]} -gt 0 ]]; then
    totalNbArguments=${#argumentsName[@]};
  else
    totalNbArguments=0;
  fi
  local -n isLastArgumentAnArray="CMD_ARGS_LAST_IS_ARRAY_${functionName}"
  local -n nbOptionalArgsStr="CMD_ARGS_NB_OPTIONAL_${functionName}"
  local -i nbOptionalArgs="${nbOptionalArgsStr:-0}"
  if [[ -z "${isLastArgumentAnArray:-}" ]]; then isLastArgumentAnArray=false; fi
  local -i argumentPosition=0

  local -n options="CMD_OPTS_${functionName}"
  local -i totalNbOptions
  if [[ -v options && ${#options[@]} -gt 0 ]]; then
    totalNbOptions=${#options[@]};
  else
    totalNbOptions=0;
  fi
  local -n optionsHasValue="CMD_OPTS_HAS_VALUE_${functionName}"
  local -n optionsName="CMD_OPTS_NAME_${functionName}"
  local -n optionsNameSc="CMD_OPTS_NAME_SC_${functionName}"

  # shortcut if the function expect no arguments and no options
  if [[ totalNbArguments -eq 0 && totalNbOptions -eq 0 ]]; then
    RETURNED_VALUE=""
    return 0
  fi

  local -a lastArgumentValues=()
  local -a outputErrors
  local -a outputSetLine
  local -a matchedOptionsIndex

  # parse each arguments
  local -i optionIndex matchedIndex
  local option startedArguments optionValue optionName argumentName
  startedArguments="false"
  while [[ $# -gt 0 ]]; do

    if [[ ${1} == "-"* ]]; then
      matchedIndex=-1

      # we are matching an option
      # try to match the argument with one of the option name
      if [[ totalNbOptions -gt 0 ]]; then
        for optionIndex in "${!options[@]}"; do
          for option in ${options[${optionIndex}]}; do
            if [[ ${option} == "${1}" ]]; then
              matchedIndex="${optionIndex}"
              break 2
            fi
          done
        done
      fi

      if [[ matchedIndex -ne -1 ]]; then
        # it's a match!
        if [[ ${startedArguments} == "true" ]]; then
          outputErrors+=("Option ⌜${1}⌝ was given after the first argument, it should come before that.")
        else
          optionValue="${optionsHasValue[${matchedIndex}]:-}"
          optionName="${optionsName[${matchedIndex}]}"
          matchedOptionsIndex+=("${matchedIndex}")

          if [[ ${optionValue} == "true" ]]; then
            shift
            if [[ $# -eq 0 ]]; then
              outputErrors+=("Missing value for option ⌜${optionName}⌝.")
            else
              outputSetLine+=("${optionName}=\"${1//\"/\\\"}\"")
            fi
          else
            outputSetLine+=("${optionName}=\"true\"")
          fi
        fi

      else
        # if we didn't match any option, flag it as unknown option and add it to the leftOver
        # shellcheck disable=SC2048 disable=SC2086
        main::fuzzyFindOption "${1}" ${options[*]}
        outputErrors+=("Unknown option ⌜${1}⌝${RETURNED_VALUE:-}.")
      fi

    else

      # we are matching an argument
      startedArguments="true"

      if [[ argumentPosition -ge totalNbArguments ]]; then
        outputErrors+=("Expecting ${totalNbArguments} argument(s), got extra argument ⌜${1}⌝.")
      else
        argumentName="${argumentsName[${argumentPosition}]}"

        if [[ argumentPosition -eq $((totalNbArguments - 1)) && "${isLastArgumentAnArray}" = "true" ]]; then
          # if the arg ends with ... we expect an infinite amount of arguments
          lastArgumentValues+=("${1}")
        else
          argumentPosition=+1
          outputSetLine+=("${argumentName}=\"${1//\"/\\\"}\"")
        fi

      fi
    fi

    shift
  done

  # increase argument position if the last arg is an array because we don't do it in the loop
  if [[ ${#lastArgumentValues[@]} -gt 0 ]]; then
    argumentPosition=$((argumentPosition + 1))
  fi

  # check if we have missing arguments
  local -i nbExpectedArgs=$((totalNbArguments - nbOptionalArgs))
  if [[ argumentPosition -lt nbExpectedArgs ]]; then
    outputErrors+=("Expecting ⌜${nbExpectedArgs}⌝ argument(s) but got ⌜$((argumentPosition))⌝.")
  fi

  local outputString

  # define all the possible local variables for options and arguments
  local option argumentIndex nbScalarArguments
  outputString="local parsingErrors"
  for option in "${optionsName[@]}"; do
    outputString+=" ${option}"
  done
  nbScalarArguments="${totalNbArguments}"
  if [[ ${isLastArgumentAnArray} == "true" ]]; then nbScalarArguments=$((nbScalarArguments - 1)); fi
  for ((argumentIndex = 0; argumentIndex < nbScalarArguments; argumentIndex++)); do
    outputString+=" ${argumentsName[${argumentIndex}]}"
  done
  outputString+=$'\n'
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    outputString+="local -a ${argumentsName[${nbScalarArguments}]}"$'\n'
  fi

  # assign all unmatched options to the corresponding global variable
  local optionIndex optionName optionMatched matchedIndex optionNameSc
  for optionIndex in "${!options[@]}"; do
    optionMatched="false"
    for matchedIndex in "${matchedOptionsIndex[@]}"; do
      if [[ ${optionIndex} == "${matchedIndex}" ]]; then
        optionMatched="true"
        break
      fi
    done
    if [[ ${optionMatched} == "false" ]]; then
      optionName="${optionsName[${optionIndex}]}"
      optionNameSc="${optionsNameSc[${optionIndex}]:-}"
      if [[ -n "${optionNameSc}" ]]; then
        outputString+="${optionsName[${optionIndex}]}=\"\${${optionNameSc}:-}\""$'\n'
      fi
    fi
  done

  # output the parsing errors
  local -i outputErrorIndex
  outputString+="parsingErrors=\""
  for outputErrorIndex in "${!outputErrors[@]}"; do
    if [[ outputErrorIndex -gt 0 ]]; then
      outputString+=$'\n'
    fi
    outputString+="${outputErrors[${outputErrorIndex}]}"
  done
  outputString+="\""$'\n'

  # output the matched arguments/options values
  local outputSet
  for outputSet in "${outputSetLine[@]}"; do
    outputString+="${outputSet}"$'\n'
  done

  # output the last argument values
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    local lastArgumentValue
    outputString+="${argumentsName[${nbScalarArguments}]}=("$'\n'
    for lastArgumentValue in "${lastArgumentValues[@]}"; do
      outputString+="\"${lastArgumentValue//\"/\\\"}\""$'\n'
    done
    outputString+=")"
  fi

  RETURNED_VALUE="${outputString}"
}

# Tries to help the user by suggesting a fix for an unknown option
# we receive the function options and the unknown option string
#
# $1: the user string to match
# $2+: options to match against
#
# Usage:
#  main::fuzzyFindOption opt1 option1 option2 option3 && fuzzyOption="${RETURNED_VALUE}"
function main::fuzzyFindOption() {
  local unknownOption suggestedOption
  unknownOption="${1}"
  shift
  _OPTIONS_TO_MATCH=("$@")

  # split to get one possible option per line
  array::fuzzyFilter "${unknownOption}" _OPTIONS_TO_MATCH
  if (( ${#RETURNED_ARRAY[@]} == 1 )); then
    suggestedOption=" (did you mean ⌜${RETURNED_ARRAY[0]}⌝?)"
  elif (( ${#RETURNED_ARRAY[@]} > 1 )); then
    suggestedOption=" (did you mean one of ⌜${RETURNED_ARRAY[*]}⌝?)"
  fi

  RETURNED_VALUE="${suggestedOption:-}"
}

# Parse the arguments and options of a function.
# If no arguments are provided but some are expected, it will enter interactive mode.
# See the @core::parseArguments function for more details on parsing.
#
# Usage:
#   main::parseFunctionArgumentsOrmain::goInteractive "functionName" "$@" && eval "${RETURNED_VALUE}"
function main::parseFunctionArgumentsOrmain::goInteractive() {
  local functionName
  functionName="${1}"
  shift

  main::parseFunctionArguments "${functionName}" "$@"
  local parsedArguments="${RETURNED_VALUE}"
  log::debug "Parsed arguments:"$'\n'"${parsedArguments}"

  # check if the function is expecting arguments and/or options
  local expectArguments
  local -n arguments="CMD_ARGUMENTS_NAME_${functionName}"
  if [[ -v arguments && "${#arguments[@]}" -gt 0 ]]; then
    expectArguments="true"
  fi

  if [[ ("${expectArguments:-false}" == "true" && $# -eq 0) || "${VALET_FORCE_INTERACTIVE_MODE:-false}" == "true" ]]; then
    main::goInteractive "${functionName}" "${parsedArguments}"
  fi

  RETURNED_VALUE="${parsedArguments}"
}

function main::goInteractive() {
  local functionName parsedArguments
  functionName="${1}"
  parsedArguments="${2}"

  # TODO: go interactive
  log::warning "Entering interactive mode for the function ⌜${functionName}⌝. This is not yet implemented."

  # at the end, printf '%s\n' to the user the complete command that will be run
}

#===============================================================
# >>> Load the commands
#===============================================================
core::sourceUserCommands
