#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# Title:         valet.d/build
# Description:   This script is called during development to build the valet.d/cmd script.
#                It reads all the about_xxx functions and generates the valet.d/cmd script.
#                You can call this script directly if cmd is broken:
#                $ ./valet.d/commands.d/self-build

_CMD_INCLUDED=1

if [ -z "${_MAIN_INCLUDED:-}" ]; then
  NOT_EXECUTED_FROM_VALET=true

  VALETD_DIR="${BASH_SOURCE[0]}"
  VALETD_DIR="${VALETD_DIR%/*}" # strip file name
  VALETD_DIR="${VALETD_DIR%/*}" # strip directory
  # shellcheck source=../main
  source "${VALETD_DIR}/main"
fi
# --- END OF COMMAND COMMON PART

# shellcheck source=self-build-utils
source "${VALET_HOME}/valet.d/commands.d/self-build-utils"

#===============================================================
# >>> command: self build
#===============================================================
: "---
command: self build
function: selfBuild
author: github.com/jcaillon
fileToSource: ${BASH_SOURCE[0]}
shortDescription: Re-build the menu of valet from your commands.
description: |-
  This command can be used to re-build the menu / help / options / arguments in case you have modified, added or removed a Valet command definition.

  Please check https://github.com/jcaillon/valet/blob/main/docs/create-new-command.md or check the examples in ⌜examples.d⌝ directory to learn how to create and modified your commands.

  This scripts:
    - Makes a list of all the elligible files in which we could find command definitions.
    - For each file in this list, extract the command definitions.
    - Build your commands file (in your valet user directory) from these definitions.

  You can call this script directly in case calling ⌜valet self build⌝ is broken:

  → ./valet.d/commands.d/self-build
options:
- name: -d, --user-directory <path>
  description: |-
    Specify the directory in which to look for your command scripts.

    This defaults to the path defined in the environment variable VALET_USER_DIRECTORY=\"my/path\" or to ⌜~/.valet.d⌝.
---"
function selfBuild() {
  local userDirectory

  # need the real path of VALET_HOME because we will use it to build the file
  invoke realpath "${VALET_HOME}" && VALET_HOME="${LAST_RETURNED_VALUE}"

  # parse arguments manually otherwise we have to count on cmd to be valid
  while [[ $# -gt 0 ]]; do
    case "${1}" in
    -d | --user-directory)
      shift
      userDirectory="${1}"
      ;;
    -*) fail "Unknown option ⌜${1}⌝." ;;
    *) fail "Unknown command ⌜${1}⌝." ;;
    esac
    shift
  done

  getUserDirectory && userDirectory="${userDirectory:-${LAST_RETURNED_VALUE}}"

  # list all the files in which we need to find command definitions
  local -a commandDefinitionFiles
  commandDefinitionFiles=(
    "${VALET_HOME}/valet"
    "${VALET_HOME}/valet.d/main"
    "${VALET_HOME}/valet.d/commands.d"/self-build
    "${VALET_HOME}/valet.d/commands.d"/*.sh
  )
  if [[ -d "${userDirectory}" ]]; then
    shopt -s globstar
    local file
    for file in "${userDirectory}"/**; do
      # if directory, skip
      [ -d "${file}" ] && continue
      debug "Considering file: ⌜${file}⌝."
      # skip all files not ending with .sh
      [[ "${file}" != *".sh" ]] && continue
      # skip everything under tests.d
      [[ "${file}" == *"/tests.d/"* ]] && continue
      commandDefinitionFiles+=("${file}")
    done
    shopt -u globstar
  else
    warn "Skipping user directory ⌜${userDirectory}⌝ because it does not exist."
  fi

  if isDebugEnabled; then
    local IFS=$'\n'
    debug "Will extract command definitions from the following files:"$'\n'"${commandDefinitionFiles[*]}"
    unset IFS
  fi

  # extract the command definitions to variables
  extractCommandDefinitionsToVariables "${commandDefinitionFiles[@]}"

  succeed "The valet user commands have been successfully built"
}

#===============================================================
# >>> Internal functions
#===============================================================

# This function extracts the command definitions from the files and stores them in
# CMD_BUILD_* global variables.
#
# $@: The files to extract from.
function extractCommandDefinitionsToVariables() {
  while [[ $# -gt 0 ]]; do
    local file="$1"
    shift
    inform "Extracting commands from ⌜${file}⌝."
    extractCommandYamls "${file}"
    local content
    for content in "${LAST_RETURNED_VALUE_ARRAY[@]}"; do
      if isDebugEnabled; then debug "Extracting command definition for: ⌜${content%%$'\n'*}...⌝."; fi
      extractCommandDefinitionToVariables "${content}"
      inform "                         ├── ⌜${TEMP_CMD_BUILD_command:-Undefined command}⌝."
      verifyCommandDefinition
      declareFinalCommandDefinitionVariables
    done
  done

  declareOtherCommmandVariables
}

# This function verifies the global TEMP_CMD_BUILD_* variables to make sure that the command
# definition is valid.
#
# Usage:
#   verifyCommandDefinition
function verifyCommandDefinition() {
  if [[ -z "${TEMP_CMD_BUILD_command:-}" ]]; then
    fail "The command definition is missing the command name."
  fi
  if [[ -z "${TEMP_CMD_BUILD_function:-}" ]]; then
    fail "The command definition is missing the function name."
  fi
  if [[ -z "${TEMP_CMD_BUILD_shortDescription:-}" ]]; then
    fail "The command definition is missing the short description."
  fi
  if [[ -z "${TEMP_CMD_BUILD_description:-}" ]]; then
    fail "The command definition is missing the description."
  fi
}

# This function uses the global TEMP_CMD_BUILD_* variables to declare the final
# command definition variables that are needed in the commands file.
#
# Usage:
#   declareFinalCommandDefinitionVariables
function declareFinalCommandDefinitionVariables() {
  local function command
  trimAll "${TEMP_CMD_BUILD_function}" && function="${LAST_RETURNED_VALUE}"
  trimAll "${TEMP_CMD_BUILD_command}" && command="${LAST_RETURNED_VALUE}"

  # trim the leading "valet" from the command
  command="${command#valet }"

  # add to the list of all the functions
  CMD_ALL_FUNCTIONS+=("${function}")

  # add to the list of all the commands
  if [[ -n "${command}" ]]; then
    CMD_ALL_COMMANDS+=("${command}")
  fi

  # get the function name from a command
  local commandNameUnderscored="${command//-/_}"
  commandNameUnderscored="${commandNameUnderscored// /_}"
  declare -g "CMD_FUNCTION_NAME_${commandNameUnderscored}"="${function}"

  # get the maximum number of sub command levels; e.g. 'command subcommand subsubcommand' has 2 levels,
  # we cound the number of spaces in the command name
  local -i level=0
  local word
  # shellcheck disable=SC2034
  for word in ${command}; do
    level+=1
  done
  if [[ "${level}" -gt "${CMD_MAX_SUB_COMMAND_LEVEL:-0}" ]]; then
    CMD_MAX_SUB_COMMAND_LEVEL="${level}"
  fi

  # get the maximum width (nb characters) among all commands
  local -i width="${#command}"
  if [[ "${width}" -gt "${CMD_MAX_COMMAND_WIDTH:-0}" ]]; then
    CMD_MAX_COMMAND_WIDTH="${width}"
  fi

}

# This function declare additional variables that are needed in the commands file.
# It is executed after all the command definitions have been extracted.
#
# Usage:
#   declareOtherCommmandVariables
function declareOtherCommmandVariables() {
  # declare the main menu body
  CMD_COMMANDS_MENU_BODY=""
}

#===============================================================
# >>> Main
#===============================================================

# if this script is run directly, execute the function, otherwise valet will do it
if [ "${NOT_EXECUTED_FROM_VALET:-false}" == "true" ]; then
  selfBuild "$@"
fi
