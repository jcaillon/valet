#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: Utility functions for the self-build script.

# This function extracts each content between the valet front matter tags.
#
# $1: The file to extract from.
#
# Returns:
#   LAST_RETURNED_VALUE_ARRAY: Each extracted content in an array.
#
# Usage:
#   extractCommandYamls "myfile"
function extractCommandYamls() {
  local file="${1}"

  local firstLine=": \"---"
  local lastLine="---\""

  declare -a contentArray

  local line content
  local -i firstLineMatched=0 lastLineMatched=1
  while IFS= read -r line; do
    if [[ firstLineMatched -eq 0 ]]; then
      if [[ ${line} == "${firstLine}" ]]; then
        firstLineMatched=1
        lastLineMatched=0
        content=""
        continue
      fi
    elif [[ lastLineMatched -eq 0 ]]; then
      if [[ ${line} == "${lastLine}" ]]; then
        lastLineMatched=1
        firstLineMatched=0
        contentArray+=("${content}")
        continue
      fi
      content+="${line}"$'\n'
    fi
  done <"${file}"

  LAST_RETURNED_VALUE_ARRAY=("${contentArray[@]}")
}

# This function extracts properties from a command definition and stores them in
# TEMP_CMD_BUILD_* global variables.
# This is basically a parser for yaml-like content that supports only one level of properties
# (including an array with properties at level 1).
#
# $1: The command definition (yaml text) to extract from.
#
# Usage:
#   extractCommandDefinitionToVariables "commandDefinition Yaml content"
function extractCommandDefinitionToVariables() {
  local commandDefinition="${1}"

  # make sure to unset all previous TEMP_CMD_BUILD_* variables
  unset -v ${!TEMP_CMD_BUILD_*}

  # loop through lines
  local multiLineIndentation=""
  local newIndentation=""
  local -i newIndentationLevel=0
  local -a propertyNames=()
  local propertyName
  local propertyValue=""
  local -i arrayLength=-1
  local -i currentArrayLength
  local -i readingMultiLine=0
  local newPropertyName newPropertyValue
  local -i lineNumber=0
  local line
  local IFS
  while IFS=$'\n' read -rd $'\n' line; do
    lineNumber+=1
    if [[ readingMultiLine -eq 0 || (-n "${line}" && "${line}" != "${multiLineIndentation}"*) ]]; then
      # we are matching a new property
      newPropertyName="${line%%:*}"
      newPropertyName="${newPropertyName// /}"
      newPropertyValue="${line#*:}"
      newPropertyValue="${newPropertyValue/# /}"
      newIndentation="${line%%[![:space:]]*}"

      # skip if property name is empty
      if [[ -z "${newPropertyName}" ]]; then continue; fi

      # if we were on a multi line property, we store it
      if [[ readingMultiLine -eq 1 ]]; then
        IFS=_ propertyName="${propertyNames[*]}"; IFS=' '
        createGlobalVariable "${propertyName}" "${propertyValue%$'\n'}" "${arrayLength}"
        readingMultiLine=0
        unset "propertyNames[-1]"
      fi

      # we are on an item of an array
      if [[ ${newPropertyName} == "-"* ]]; then
        if [[ arrayLength -le -1 ]]; then
          core::fail "Array item (starts with '- ') defined outside of an array [line ${lineNumber}]."
        fi
        arrayLength+=1
        newPropertyName="${newPropertyName:1}"
        newIndentation="${newIndentation}  "
        log::debug "Processing new array item."
      fi

      # check that property name only contains alphanumeric characters
      if [[ ! "${newPropertyName}" =~ ^[[:alnum:]]+$ ]]; then
        core::fail "Property name ⌜${newPropertyName}⌝ contains invalid characters (should be alphanumeric) [line ${lineNumber}]."
      fi

      propertyNames+=("${newPropertyName}")

      if [[ -z "${newPropertyValue// /}" ]]; then
        # we are on a new array property
        log::debug "Starting new array property: ⌜${newPropertyName}⌝."
        arrayLength=0
        newIndentation="  "
        propertyNames=("${newPropertyName}")
      elif [[ ${newPropertyValue} == "|-"* ]]; then
        # we are on an a multi line property
        log::debug "Starting new multi line property: ⌜${newPropertyName}⌝."
        readingMultiLine=1
        propertyValue=""
        newIndentation="${newIndentation}  "
        multiLineIndentation="${newIndentation}"
      else
        # we are on a single line value property
        if [[ ${#newIndentation} -eq 0 ]]; then
          propertyName="${newPropertyName}"
        else
          IFS=_ propertyName="${propertyNames[*]}"; IFS=' '
        fi
        createGlobalVariable "${propertyName}" "${newPropertyValue}" "${arrayLength}"
      fi

      newIndentationLevel="${#newIndentation}"

      # if the indentation level has decreased, we un stack the property names
      if [[ newIndentationLevel -eq 0 ]]; then
        propertyNames=()
        arrayLength=-1
      elif [[ newIndentationLevel -eq 2 ]]; then
        while [[ ${#propertyNames[@]} -gt 1 ]]; do
          unset "propertyNames[-1]"
        done
      fi
    else
      # continuation of a multi lines value
      propertyValue+="${line#"${multiLineIndentation}"}"$'\n'
    fi

  done <<<"${commandDefinition}"$'\n'"end:"
}

function createGlobalVariable() {
  local name="${1}"
  local value="${2}"
  local arrayLength="${3}"

  log::debug "Setting variable ⌜TEMP_CMD_BUILD_${name}⌝ (array length=${arrayLength})."
  if [[ arrayLength -le -1 ]]; then
    # simple variable
    declare -g "TEMP_CMD_BUILD_${name}"="${value}"
  else
    # array variable
    local -n array="TEMP_CMD_BUILD_${name}"
    if [[ -v array && "${#array[@]}" -gt 0 ]]; then
      currentArrayLength=${#array[@]}
    else
      currentArrayLength=0
      eval "TEMP_CMD_BUILD_${name}=()"
    fi
    log::debug "currentArrayLength: ${currentArrayLength}."
    arrayLength=$((arrayLength - 1))
    while [[ arrayLength -gt currentArrayLength ]]; do
      log::debug "Adding empty string to array TEMP_CMD_BUILD_${name}."
      eval "TEMP_CMD_BUILD_${name}+=(\"\")"
      currentArrayLength+=1
    done
    eval "TEMP_CMD_BUILD_${name}+=(\"${value//\"/\\\"}\")"
  fi
}

# This function extract the first long name of an option from an option string formatted as:
# --option -o --other-long-name
#
# $1: The option string.
#
# Returns:
#   LAST_RETURNED_VALUE: The first long name of the option.
#
# Usage:
#   extractFirstLongNameFromOptionString "--option -o" && local firstLongName="${LAST_RETURNED_VALUE}"
function extractFirstLongNameFromOptionString() {
  local optionString="${1}"
  local word
  # shellcheck disable=SC2034
  for word in ${optionString}; do
    if [[ ${word} == "--"* ]]; then
      LAST_RETURNED_VALUE="${word}"
      return 0
    fi
  done
  LAST_RETURNED_VALUE=""
}


# This function writes the command definition variables to a file.
# It will write a header with the description of each variable.
# It will write the variables in the same format as the declare -p command.
#
# $1: The file to write to.
#
# Usage:
#   writeCommandDefinitionVariablesToFile "myfile"
function writeCommandDefinitionVariablesToFile() {
  local outputFile="${1}"
  local content

  if [[ ! -d "${outputFile%/*}" ]]; then
    mkdir -p "${outputFile%/*}"
  fi

  {
    # write the header
    echo "#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script declares global variables used in valet to manage commands.
# shellcheck disable=SC2034

_CMD_INCLUDED=1

# /!\ This file is auto-generated by the 'self-build' script. Do not edit it manually

# For the rest of this document:
# - xxx represents a function name
# - yyy represents a command name

# ====================
# Common variables
# ====================
# CMD_ALL_FUNCTIONS_ARRAY = array of all the functions callable with a command
# CMD_ALL_FUNCTIONS = list all the functions callable with a command
# CMD_ALL_COMMANDS_ARRAY = array of all the commands
# CMD_ALL_COMMANDS = list all the commands
# CMD_MAX_SUB_COMMAND_LEVEL = maximum number of sub command levels; e.g. 'command subcommand subsubcommand' has 2 levels
# CMD_ALL_MENU_COMMANDS_ARRAY = array of all the commands that should open a sub menu to show a list of sub commands
# CMD_MAX_COMMAND_WIDTH = get the maximum width (nb characters) among all commands
# CMD_FUNCTION_NAME_yyy = the function name for the given yyy command
# CMD_COMMAND_xxx = the command of the function
# CMD_FILETOSOURCE_xxx = the file to source for the function
# CMD_HIDEINMENU_xxx = true to hide the command in the menu
#
# CMD_COMMANDS_MENU_BODY = the input used to display the commands menu

# ====================
# Variables used to show the help of each command
# ====================
# CMD_SHORTDESCRIPTION_xxx = the short description of the function
# CMD_DESCRIPTION_xxx = the description of the function
# CMD_SUDO_xxx = true if the function requires sudo
# CMD_EXAMPLES_NAME_xxx = array with each example name
# CMD_EXAMPLES_DESCRIPTION_xxx = array with each example description
# CMD_OPTIONS_NAME_xxx = array with each option name
# CMD_OPTIONS_DESCRIPTION_xxx = array with each option description
# CMD_ARGUMENTS_NAME_xxx = array with each argument name
# CMD_ARGUMENTS_DESCRIPTION_xxx = array with each argument description
#
# CMD_COMMANDS_NAME_xxx = array with each sub command name
# CMD_COMMANDS_SHORTDESCRIPTION_xxx = array with each sub commmand short description

# ====================
# Variables used during the arguments parsing of each command
# ====================
# Get the options of a given function xxx.
# CMD_OPTS_xxx = array with each option separated by a space
# CMD_OPTS_HAS_VALUE_xxx = array which indicates for each option if it has a value or not
# CMD_OPTS_NAME_xxx = array with each option names in camel case
# CMD_OPTS_NAME_SC_xxx = array with each option names in snake case
# CMD_ARGS_NAME_xxx = array with each argument names in camel case
# CMD_ARGS_LAST_IS_ARRAY_xxx = true/false to indicate if the last argument of the function is an array (contains ...)
# CMD_ARGS_NB_OPTIONAL_xxx = integer to indicate the number of optional arguments (contains ?)

"
    io::captureOutput declare -p ${!CMD_*}
    local IFS=$'\n'
    local line
    for line in ${LAST_RETURNED_VALUE}; do
      echo "${line#declare -? }"
    done

  } >"${outputFile}"
}