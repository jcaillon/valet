#!/usr/bin/env bash
set -Eeu -o pipefail
# author: github.com/jcaillon
# description: Utility functions for the self-test script.

#===============================================================
# >>> Functions that can be used in the test scripts
#===============================================================

# Call this function to add a paragraph in the report file.
#
# $1: the text to add in the report file
#
# Usage:
#   commentTest "This is a comment."
function commentTest() {
  printf "%s\n\n" "${1:-}" >>"${_TEST_REPORT_FILE}"
}

# Call this function after each test to write the test results to the report file.
# This create a new H3 section in the report file with the test description and the exit code.
#
# $1: the title of the test
# $2: the exit code of the test
# $3: (optional) a text to explain what is being tested
#
# Usage:
#   endTest "Testing something" $?
function endTest() {
  local testTitle="${1:-}"
  local exitCode="${2:-}"
  local testDescription="${3:-}"

  resetFdRedirection

  {
    log::debug "Ended test ⌜${testTitle}⌝ with exit code ⌜${exitCode}⌝."

    # write the test title
    printf "%s\n\n" "### ${testTitle:-test}"

    # write the test description if any
    if [[ -n "${testDescription}" ]]; then
      printf "%s\n\n" "${testDescription}"
    fi

    # write the exit code
    printf "%s\n\n" "Exit code: \`${exitCode}\`"

    # write the standard output if any
    if [[ -s "${_TEST_STANDARD_OUTPUT_FILE}" ]]; then
      printf "%s\n\n%s\n" "**Standard** output:" "\`\`\`plaintext"
      echoFileSubstitutingPath "${_TEST_STANDARD_OUTPUT_FILE}"
      printf "\n%s\n\n" "\`\`\`"
    fi

    # write the error output if any
    if [[ -s "${_TEST_STANDARD_ERROR_FILE}" ]]; then
      printf "%s\n\n%s\n" "**Error** output:" "\`\`\`log"
      echoFileSubstitutingPath "${_TEST_STANDARD_ERROR_FILE}"
      printf "\n%s\n\n" "\`\`\`"
    fi

  } >>"${_TEST_REPORT_FILE}"

  # reset the standard output and error output files
  : >"${_TEST_STANDARD_OUTPUT_FILE}"
  : >"${_TEST_STANDARD_ERROR_FILE}"

  setFdRedirection

  set +Eeu +o pipefail
}

# This function allows to set the temp files and directories
# numbers so we can have consistent results.
#
# $1: the new number for temp files and directories
#
# Usage:
#   setTempFilesNumber 3
function setTempFilesNumber() {
  TEMPORARY_FILE_NUMBER=${1}
  TEMPORARY_DIRECTORY_NUMBER=${1}
}


#===============================================================
# >>> Internal tests functions
#===============================================================

# Allows to run the core tests of Valet (tests.d directory in the repo) as
# well as the examples (examples.d in the repo).
function runCoreTests() {
  if [[ ! -d "${GLOBAL_VALET_HOME}/tests.d" ]]; then
    core::fail "The valet core tests directory ⌜${GLOBAL_VALET_HOME}/tests.d⌝ does not exist, cannot run core tests."
  fi

  # we need to rebuild the commands for the core commands only
  rebuildCommands ""

  log::info "Running all test suites in directory ⌜${GLOBAL_VALET_HOME}/tests.d⌝."
  runTestSuites "${GLOBAL_VALET_HOME}/tests.d"

  # now we can also test the commands in examples.d if the directory is there
  if [[ ! -d "${GLOBAL_VALET_HOME}/examples.d" ]]; then
    log::warning "The valet examples directory ⌜${GLOBAL_VALET_HOME}/examples.d⌝ does not exist, cannot run the tests on the core examples."
  else
    # we need to rebuild the commands for the examples only
    rebuildCommands "${GLOBAL_VALET_HOME}/examples.d"

    log::info "Running all test suites in directory ⌜${GLOBAL_VALET_HOME}/examples.d⌝."
    runTestSuites "${GLOBAL_VALET_HOME}/examples.d"
  fi

  # reload the orignal commands
  core::reloadUserCommands
}

function rebuildCommands() {
  local originalLogLevel
  log::getLevel && originalLogLevel="${LAST_RETURNED_VALUE}"
  log::setLevel warning true
  core::sourceForFunction selfBuild
  selfBuild --output "" --user-directory "${1:-}"
  log::setLevel "${originalLogLevel}" true
}

# Run all the test suites in the given directory.
# A test suite is a folder that contains a test.sh file.
# This test.sh allows to run multiple tests.
#
# $1: the directory containing the test suites
#
# Returns:
#   the number of test suites run (increments the global variable NB_TEST_SUITES)
#   the number of failed test suites (increments the global variable NB_FAILED_TEST_SUITES)
#
# Usage:
#   runTestSuites "${GLOBAL_VALET_HOME}/tests.d"
function runTestSuites() {
  local testsDirectory="${1}"

  io::createTempFile && _TEST_STANDARD_OUTPUT_FILE="${LAST_RETURNED_VALUE}"
  io::createTempFile && _TEST_STANDARD_ERROR_FILE="${LAST_RETURNED_VALUE}"
  io::createTempFile && _TEST_REPORT_FILE="${LAST_RETURNED_VALUE}"
  io::createTempFile && _TEST_TEMP_FILE="${LAST_RETURNED_VALUE}"

  local -i failedTestSuites nbTestSuites
  failedTestSuites=0
  nbTestSuites=0

  # for each test file in the test directory
  local testDirectory exitCode testDirectoryName testScript
  for testDirectory in "${testsDirectory}/"*; do
    testDirectoryName="${testDirectory##*/}"

    # skip if not a directory
    if [[ ! -d "${testDirectory}" ]]; then continue; fi

    # skip if the test directory does not match the include pattern
    if [[ -n "${INCLUDE_PATTERN:-}" && ! ("${testDirectoryName}" =~ ${INCLUDE_PATTERN}) ]]; then
      log::debug "Skipping test ⌜${testDirectoryName##*/}⌝ because it does not match the include pattern."
      continue
    fi
    # skip if the test directory matches the exclude pattern
    if [[ -n "${EXCLUDE_PATTERN:-}" && "${testDirectoryName}" =~ ${EXCLUDE_PATTERN} ]]; then
      log::debug "Skipping test ⌜${testDirectoryName##*/}⌝ because it matches the exclude pattern."
      continue
    fi

    log::info "Running test suite ⌜${testDirectory##*/}⌝."

    # write the test suite title
    printf "%s\n\n" "# Test suite ${testDirectory##*/}" >"${_TEST_REPORT_FILE}"

    # for each .sh script in the test directory, run the test
    for testScript in "${testDirectory}"/*.sh; do
      # skip if not a file
      if [[ ! -f "${testScript}" ]]; then continue; fi

      log::info "Running test       ├── ⌜${testScript##*/}⌝."

      runTest "${testDirectory}" "${testScript}"
    done

    exitCode=0
    compareWithApproved "${testDirectory}" "${_TEST_REPORT_FILE}" || exitCode=$?
    nbTestSuites+=1

    if [[ "${exitCode}" -eq 0 ]]; then
      log::success "Test suite ${testDirectory##*/} passed."
    else
      log::error "Test suite ${testDirectory##*/} failed."
      failedTestSuites+=1
    fi
  done

  NB_TEST_SUITES=$((NB_TEST_SUITES + nbTestSuites))
  NB_FAILED_TEST_SUITES=$((NB_FAILED_TEST_SUITES + failedTestSuites))
}

function runTest() {
  local testDirectory="${1}"
  local testScript="${2}"

  # redirect the standard output and error output to files
  setFdRedirection

  # make sure that, if we exit in the test, we catch that and explain to the user
  # why this should not happen
  eval "function onExitTest() { onExitTestInternal; }"

  # used in echoFileSubstitutingPath to replace this path with .
  CURRENT_DIRECTORY="${PWD}"

  # write the test script name
  local scriptName="${testScript##*/}"
  scriptName="${scriptName%.sh}"
  printf "%s\n\n" "## Test script ${scriptName}" >>"${_TEST_REPORT_FILE}"

  # run the test
  pushd "${testDirectory}" >/dev/null
  # shellcheck disable=SC1091
  set +Eeu +o pipefail
  # shellcheck disable=SC1090
  source "${testScript}"
  set -Eeu -o pipefail
  popd >/dev/null

  # remove the onExitTest function, we can exit safely now
  unset -f onExitTest

  resetFdRedirection

  # test if the user forgot to call endTest
  if [[ -s "${_TEST_STANDARD_OUTPUT_FILE}" || -s "${_TEST_STANDARD_ERROR_FILE}" ]]; then
    core::fail "The test script ⌜${testScript}⌝ did not call endTest OR it had outputs after the last endTest call."
  fi

}

function compareWithApproved() {
  local testDirectory exitCode approvedFile receivedFile receivedFileToCopy
  testDirectory="${1}"
  receivedFileToCopy="${2}"
  testName="${testDirectory##*/}"

  approvedFile="${testDirectory}/results.approved.md"
  receivedFile="${testDirectory}/results.received.md"

  if [[ ! -f "${approvedFile}" ]]; then
    log::debug "🧪 ${testName}: no approved file, creating one."
    : >"${approvedFile}"
  fi

  if diff --color -u "${approvedFile}" "${receivedFileToCopy}" 1>&2; then
    log::debug "🧪 ${testName}: OK, equal to approved file."
    rm -f "${receivedFile}" 2>/dev/null || true
    return 0
  else
    echo "${receivedFile} is different than ${approvedFile} (see above)" 1>&2
    log::error "🧪 ${testName}: KO, differs from approved file (see difference above)." | tee >(cat >&2)
  fi

  # if the option is activated, we approve the received file
  if [[ ${AUTO_APPROVE:-false} == "true" ]]; then
    log::info "🧪 ${testName}: Auto-approving"
    cp -f "${receivedFileToCopy}" "${approvedFile}"
    rm -f "${receivedFile}" 2>/dev/null || true
  else
    cp -f "${receivedFileToCopy}" "${receivedFile}"
  fi

  return 1
}

# Allows to explicitly warn the user that a test made Valet exit (it should not).
# Give guidance on what to do to fix this.
function onExitTestInternal() {
  local rc=$?

  resetFdRedirection

  source io

  local message="The program has exit during a test with code ${rc}."$'\n'
  io::readFile "${_TEST_STANDARD_ERROR_FILE}"
  message+="Current test error output:"$'\n'"⌜${LAST_RETURNED_VALUE}⌝"$'\n'
  message+="If you expect the tested function/program to exit/fail, then run it in a subshell like that:"$'\n'"(myFunctionThatFails)"

  log::error "${message}"

  GLOBAL_ERROR_DISPLAYED=1
}

# After this function call, everything written to stdout and stderr will be redirected
# to the test output files.
# Call resetFdRedirection to reset the redirection.
function setFdRedirection() {
  # redirect the standard output and error output to files
  exec 3>&1 1>"${_TEST_STANDARD_OUTPUT_FILE}"
  exec 4>&2 2>"${_TEST_STANDARD_ERROR_FILE}"

  # sets up a simpler log function for the tests
  # so we can have consistent results independent of the environment
  if [[ -z "${ORIGINAL_LOG_LINE_FUNCTION:-}" ]]; then
    ORIGINAL_LOG_LINE_FUNCTION="${LOG_LINE_FUNCTION}"
    ORIGINAL_VALET_CONFIG_DISABLE_COLORS="${VALET_CONFIG_DISABLE_COLORS:-}"
    ORIGINAL_LOG_LEVEL="${VALET_LOG_LEVEL:-}"
    ORIGINAL_VALET_CONFIG_DISABLE_LOCAL_BIN="${VALET_CONFIG_DISABLE_LOCAL_BIN:-}"
  fi
  export VALET_LOG_LEVEL="info"
  log::setLevel info &>/dev/null
  export VALET_CONFIG_DISABLE_COLORS="true"
  log::setColors
  export VALET_CONFIG_DISABLE_LOG_TIMESTAMP="true"
  export VALET_CONFIG_DISABLE_NERDFONT_ICONS="true"
  export VALET_CONFIG_DISABLE_LOG_WRAP="true"
  export VALET_CONFIG_ENABLE_CI_MODE="false"
  export VALET_CONFIG_LOGGLOBAL_COLUMNS=9999
  export GLOBAL_COLUMNS=9999
  export VALET_CONFIG_DISABLE_LOCAL_BIN="true"
  if [[ -z "${SIMPLIFIED_LOG_LINE_FUNCTION:-}" ]]; then
    log::createPrintFunction
    SIMPLIFIED_LOG_LINE_FUNCTION="${LOG_LINE_FUNCTION}"
  fi
  eval "${SIMPLIFIED_LOG_LINE_FUNCTION}"
}

# Restores the standard output and error output.
# Call this function after setFdRedirection.
function resetFdRedirection() {
  # reset the standard output and error output
  exec 1>&3 3>&-
  exec 2>&4 4>&-

  # reset the original logs
  export VALET_LOG_LEVEL="${ORIGINAL_LOG_LEVEL}"
  log::setLevel "${ORIGINAL_LOG_LEVEL}" &>/dev/null
  export VALET_CONFIG_DISABLE_COLORS="${ORIGINAL_VALET_CONFIG_DISABLE_COLORS}"
  export VALET_CONFIG_DISABLE_LOCAL_BIN="${ORIGINAL_VALET_CONFIG_DISABLE_LOCAL_BIN}"
  log::setColors
  eval "${ORIGINAL_LOG_LINE_FUNCTION}"
}

function setGlobalOptions() {
  unset AUTO_APPROVE INCLUDE_PATTERN EXCLUDE_PATTERN
  if [[ -n "${autoApprove:-}" ]]; then
    AUTO_APPROVE="true"
  fi
  if [[ -n "${include:-}" ]]; then
    log::info "Including only test suites that match the pattern ⌜${include}⌝."
    INCLUDE_PATTERN="${include}"
  fi
  if [[ -n "${exclude:-}" ]]; then
    log::info "Excluding all test suites that match the pattern ⌜${exclude}⌝."
    EXCLUDE_PATTERN="${exclude}"
  fi
}

# This function is used to echo the content of a file with some substitutions.
# The substitutions are:
# - replace the GLOBAL_VALET_HOME with $GLOBAL_VALET_HOME
# - replace the current test directory with a dot
# - replace a line with ${TMPDIR}/valet-*/ (temp directory) by /valet/
#
# This allows to have consistent results accross different execution environments for the tests.
#
# Usage:
#   myCommandThatProducesLinesWithValetDirectoryPath 2> "${_TEST_TEMP_FILE}"
#   echoFileSubstitutingPath "${_TEST_TEMP_FILE}" 1>&2
function echoFileSubstitutingPath() {
  local file="${1}"
  local line
  local IFS=$'\n'
  local -i firstLine=1
  while read -rd $'\n' line; do
    if [[ firstLine -eq 1 ]]; then
      firstLine=0
    else
      echo
    fi
    line="${line//${GLOBAL_VALET_HOME}/\$GLOBAL_VALET_HOME}"
    line="${line//${CURRENT_DIRECTORY}/.}"
    line="${line//${GLOBAL_TEMPORARY_PREFIX}*.valet/\/tmp/valet}"
    line="${line//${GLOBAL_TEMPORARY_IN_MEM_PREFIX}*.valet/\/tmp/valet}"
    if [[ ${line} =~ "after "[0-9]{1,}s.$ ]]; then
      line="${line/%after */after Xs.}"
    fi
    echo -n "${line}"
  done <"${file}"
}