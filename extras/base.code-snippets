{
	"[[:digit:]]": {
		"prefix": "[[:digit:]]",
		"description": "Regex digits, similar to [0-9]",
		"scope": "",
		"body": [
			"[[:digit:]]"
		]
	},
	"[[:xdigit:]]": {
		"prefix": "[[:xdigit:]]",
		"description": "Regex hexadecimal digits, similar to [0-9A-Fa-f]",
		"scope": "",
		"body": [
			"[[:xdigit:]]"
		]
	},
	"[[:punct:]]": {
		"prefix": "[[:punct:]]",
		"description": "Regex punctuation, similar to [.,!?:…]",
		"scope": "",
		"body": [
			"[[:punct:]]"
		]
	},
	"[[:blank:]]": {
		"prefix": "[[:blank:]]",
		"description": "Regex space and TAB characters only, similar to [ \\t]",
		"scope": "",
		"body": [
			"[[:blank:]]"
		]
	},
	"[[:space:]]": {
		"prefix": "[[:space:]]",
		"description": "Regex blank (whitespace) characters, similar to [ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:space:]]"
		]
	},
	"[[:cntrl:]]": {
		"prefix": "[[:cntrl:]]",
		"description": "Regex control characters",
		"scope": "",
		"body": [
			"[[:cntrl:]]"
		]
	},
	"[[:graph:]]": {
		"prefix": "[[:graph:]]",
		"description": "Regex printed characters, similar to [^\\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:graph:]]"
		]
	},
	"[[:print:]]": {
		"prefix": "[[:print:]]",
		"description": "Regex printed characters and space, similar to [^ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:print:]]"
		]
	},
	"[[:alnum:]]": {
		"prefix": "[[:alnum:]]",
		"description": "Regex digits, upper- and lowercase letters, similar to [[:alpha:][:digit:]]",
		"scope": "",
		"body": [
			"[[:alnum:]]$0"
		]
	},
	"[[:alpha:]]": {
		"prefix": "[[:alpha:]]",
		"description": "Regex upper- and lowercase letters, similar to [[:upper:][:lower:]]",
		"scope": "",
		"body": [
			"[[:alpha:]]$0"
		]
	},
	"[[:lower:]]": {
		"prefix": "[[:lower:]]",
		"description": "Regex lowercase letters, similar to [a-z]",
		"scope": "",
		"body": [
			"[[:lower:]]$0"
		]
	},
	"[[:upper:]]": {
		"prefix": [
			"[[:upper:]]",
			"regex [[:upper:]]"
		],
		"description": "Regex uppercase letters , similar to [A-Z]",
		"scope": "",
		"body": [
			"[[:upper:]]$0"
		]
	},
	"set bash options": {
		"prefix": "set bash options",
		"description": "Set good bash options",
		"scope": "",
		"body": [
			"set -Eeu -o pipefail$0"
		]
	},
	"new command alt": {
		"prefix": "new command alt",
		"description": "A new command alternative definition for Valet",
		"scope": "",
		"body": [
			"##<<VALET_COMMAND",
			"# command: $1",
			"# function: $2",
			"# shortDescription: A short sentence.",
			"# description: |-",
			"#   A long description that can use ⌜quotes⌝.",
			"# sudo: false",
			"# hideInMenu: false",
			"# arguments:",
			"# - name: firstArg",
			"#   description: |-",
			"#     First argument.",
			"# - name: more...",
			"#   description: |-",
			"#     Will be an an array of strings.",
			"# options:",
			"# - name: -o, --option1",
			"#   description: |-",
			"#     First option.",
			"#   noEnvironmentVariable: true",
			"# - name: -2, --this-is-option2 <level>",
			"#   description: |-",
			"#     An option with a value.",
			"#   noEnvironmentVariable: false",
			"# examples:",
			"# - name: command -o -2 value1 arg1 more1 more2",
			"#   description: |-",
			"#     Call command with option1, option2 and some arguments.",
			"##VALET_COMMAND",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${REPLY}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"new command": {
		"prefix": "new command",
		"description": "A new command definition for Valet",
		"scope": "",
		"body": [
			": \"---",
			"command: $1",
			"function: $2",
			"shortDescription: A short sentence.",
			"description: |-",
			"  A long description that can use ⌜quotes⌝.",
			"sudo: false",
			"hideInMenu: false",
			"arguments:",
			"- name: firstArg",
			"  description: |-",
			"    First argument.",
			"- name: more...",
			"  description: |-",
			"    Will be an an array of strings.",
			"options:",
			"- name: -o, --option1",
			"  description: |-",
			"    First option.",
			"  noEnvironmentVariable: true",
			"- name: -2, --this-is-option2 <level>",
			"  description: |-",
			"    An option with a value.",
			"  noEnvironmentVariable: false",
			"examples:",
			"- name: command -o -2 value1 arg1 more1 more2",
			"  description: |-",
			"    Call command with option1, option2 and some arguments.",
			": \"---",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${REPLY}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"comment section": {
		"prefix": "comment section",
		"description": "",
		"scope": "",
		"body": [
			"#===============================================================",
			"# >>> $1",
			"#===============================================================",
			"$0"
		]
	},
	"quote": {
		"prefix": "quote",
		"description": "",
		"scope": "",
		"body": [
			"⌜$1⌝$0"
		]
	},
	"read file to array and loop": {
		"prefix": "read file to array and loop",
		"description": "Read file to array and loop",
		"scope": "",
		"body": [
			"readarray -d $'\\n' fileLines < file",
			"for myString in \"${fileLines[@]}\"; do",
			"  # the difference is also that myString will end with the delimiter, so you might want to remove it",
			"  # Alternatively, you can run readarray with -t but in that case you will not have an array element for empty lines",
			"  echo \"${myString%$'\\n'}\"",
			"done"
		]
	},
	"loop through lines of string": {
		"prefix": "loop through lines of string",
		"description": "Loop through each line of a string (keep empty lines)",
		"scope": "",
		"body": [
			"while read -r line; do",
			"  echo \"${line}\"",
			"done <<< \"${var1}\""
		]
	},
	"loop through lines of string (for)": {
		"prefix": "loop through lines of string (for)",
		"description": "Loop through each line of a string (does not keep empty lines)",
		"scope": "",
		"body": [
			"local IFS=$'\\n'",
			"for line in ${var1}; do",
			"  echo \"${line}\"",
			"done"
		]
	},
	"read file loop on all lines": {
		"prefix": "read file loop on all lines",
		"description": "Read a file, line by line",
		"scope": "",
		"body": [
			"while IFS=$'\\n' read -rd $'\\n' line || [[ -n ${line:-} ]]; do",
			"  echo \"${line}\"",
			"done < file"
		]
	},
	"source": {
		"prefix": "source",
		"description": "Source a file for Valet, add the necessary comment for shellcheck.",
		"scope": "",
		"body": [
			"# shellcheck source=../lib-valet",
			"source $1",
			"$0",
			""
		]
	},
	"REPLY_CODE": {
		"prefix": "REPLY_CODE",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_CODE$0"
		]
	},
	"REPLY": {
		"prefix": "REPLY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY$0"
		]
	},
	"REPLY2": {
		"prefix": "REPLY2",
		"description": "",
		"scope": "",
		"body": [
			"REPLY2$0"
		]
	},
	"REPLY3": {
		"prefix": "REPLY3",
		"description": "",
		"scope": "",
		"body": [
			"REPLY3$0"
		]
	},
	"REPLY_ARRAY": {
		"prefix": "REPLY_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY$0"
		]
	},
	"REPLY_ARRAY2": {
		"prefix": "REPLY_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY2$0"
		]
	},
	"REPLY_ARRAY3": {
		"prefix": "REPLY_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY3$0"
		]
	},
	"REPLY_ASSOCIATIVE_ARRAY": {
		"prefix": "REPLY_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ASSOCIATIVE_ARRAY$0"
		]
	},
	"IFS": {
		"prefix": "IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"IFS$0"
		]
	},
	"$GLOBAL_COLUMNS": {
		"prefix": "$GLOBAL_COLUMNS",
		"description": "The current number or columns displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_COLUMNS}$0"
		]
	},
	"$GLOBAL_LINES": {
		"prefix": "$GLOBAL_LINES",
		"description": "The current number or lines displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_LINES}$0"
		]
	},
	"$GLOBAL_CURSOR_LINE": {
		"prefix": "$GLOBAL_CURSOR_LINE",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_LINE}$0"
		]
	},
	"$GLOBAL_CURSOR_COLUMN": {
		"prefix": "$GLOBAL_CURSOR_COLUMN",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_COLUMN}$0"
		]
	},
	"$GLOBAL_TEST_TEMP_FILE": {
		"prefix": "$GLOBAL_TEST_TEMP_FILE",
		"description": "The path to a temporary file that can be used during tests.",
		"scope": "",
		"body": [
			"\\${GLOBAL_TEST_TEMP_FILE}$0"
		]
	},
	"$GLOBAL_SCREEN_REDRAW_REQUIRED": {
		"prefix": "$GLOBAL_SCREEN_REDRAW_REQUIRED",
		"description": "Set to true when the terminal size changes, set it to false when you handle this event.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SCREEN_REDRAW_REQUIRED}$0"
		]
	},
	"$GLOBAL_SESSION_INTERRUPTED": {
		"prefix": "$GLOBAL_SESSION_INTERRUPTED",
		"description": "Set to true when the user presses CTRL+C during an interactive experience.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SESSION_INTERRUPTED}$0"
		]
	},
	"$LAST_KEY_PRESSED": {
		"prefix": "$LAST_KEY_PRESSED",
		"description": "",
		"scope": "",
		"body": [
			"\\${LAST_KEY_PRESSED}$0"
		]
	},
	"$REPLY_CODE": {
		"prefix": "$REPLY_CODE",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_CODE}$0"
		]
	},
	"$REPLY": {
		"prefix": "$REPLY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY}$0"
		]
	},
	"$REPLY2": {
		"prefix": "$REPLY2",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY2}$0"
		]
	},
	"$REPLY3": {
		"prefix": "$REPLY3",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY3}$0"
		]
	},
	"$REPLY_ARRAY": {
		"prefix": "$REPLY_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY}$0"
		]
	},
	"$REPLY_ARRAY2": {
		"prefix": "$REPLY_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY2}$0"
		]
	},
	"$REPLY_ARRAY3": {
		"prefix": "$REPLY_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY3}$0"
		]
	},
	"$REPLY_ASSOCIATIVE_ARRAY": {
		"prefix": "$REPLY_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ASSOCIATIVE_ARRAY}$0"
		]
	},
	"$BASHOPTS": {
		"prefix": "$BASHOPTS",
		"body": [
			"\\${BASHOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -s option to the shopt builtin command (see The Shopt Builtin). The options appearing in BASHOPTS are those reported as ‘on’ by ‘shopt’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$BASHPID": {
		"prefix": "$BASHPID",
		"body": [
			"\\${BASHPID}$0"
		],
		"scope": "",
		"description": "Expands to the process ID of the current Bash process. This differs from $$ under certain circumstances, such as subshells that do not require Bash to be re-initialized. Assignments to BASHPID have no effect. If BASHPID is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ALIASES": {
		"prefix": "$BASH_ALIASES",
		"body": [
			"\\${BASH_ALIASES}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal list of aliases as maintained by the alias builtin. (see Bourne Shell Builtins). Elements added to this array appear in the alias list; however, unsetting array elements currently does not cause aliases to be removed from the alias list. If BASH_ALIASES is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ARGC": {
		"prefix": "$BASH_ARGC",
		"body": [
			"\\${BASH_ARGC}$0"
		],
		"scope": "",
		"description": "An array variable whose values are the number of parameters in each frame of the current bash execution call stack. The number of parameters to the current subroutine (shell function or script executed with . or source) is at the top of the stack. When a subroutine is executed, the number of parameters passed is pushed onto BASH_ARGC. The shell sets BASH_ARGC only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV": {
		"prefix": "$BASH_ARGV",
		"body": [
			"\\${BASH_ARGV}$0"
		],
		"scope": "",
		"description": "An array variable containing all of the parameters in the current bash execution call stack. The final parameter of the last subroutine call is at the top of the stack; the first parameter of the initial call is at the bottom. When a subroutine is executed, the parameters supplied are pushed onto BASH_ARGV. The shell sets BASH_ARGV only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV0": {
		"prefix": "$BASH_ARGV0",
		"body": [
			"\\${BASH_ARGV0}$0"
		],
		"scope": "",
		"description": "When referenced, this variable expands to the name of the shell or shell script (identical to $0; See Special Parameters, for the description of special parameter 0). Assignment to BASH_ARGV0 causes the value assigned to also be assigned to $0. If BASH_ARGV0 is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_CMDS": {
		"prefix": "$BASH_CMDS",
		"body": [
			"\\${BASH_CMDS}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal hash table of commands as maintained by the hash builtin (see Bourne Shell Builtins). Elements added to this array appear in the hash table; however, unsetting array elements currently does not cause command names to be removed from the hash table. If BASH_CMDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMMAND": {
		"prefix": "$BASH_COMMAND",
		"body": [
			"\\${BASH_COMMAND}$0"
		],
		"scope": "",
		"description": "The command currently being executed or about to be executed, unless the shell is executing a command as the result of a trap, in which case it is the command executing at the time of the trap. If BASH_COMMAND is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMPAT": {
		"prefix": "$BASH_COMPAT",
		"body": [
			"\\${BASH_COMPAT}$0"
		],
		"scope": "",
		"description": "The value is used to set the shell’s compatibility level. See Shell Compatibility Mode, for a description of the various compatibility levels and their effects. The value may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the desired compatibility level. If BASH_COMPAT is unset or set to the empty string, the compatibility level is set to the default for the current version. If BASH_COMPAT is set to a value that is not one of the valid compatibility levels, the shell prints an error message and sets the compatibility level to the default for the current version. The valid values correspond to the compatibility levels described below (see Shell Compatibility Mode). For example, 4.2 and 42 are valid values that correspond to the compat42 shopt option and set the compatibility level to 42. The current version is also a valid value."
	},
	"$BASH_ENV": {
		"prefix": "$BASH_ENV",
		"body": [
			"\\${BASH_ENV}$0"
		],
		"scope": "",
		"description": "If this variable is set when Bash is invoked to execute a shell script, its value is expanded and used as the name of a startup file to read before executing the script. See Bash Startup Files."
	},
	"$BASH_EXECUTION_STRING": {
		"prefix": "$BASH_EXECUTION_STRING",
		"body": [
			"\\${BASH_EXECUTION_STRING}$0"
		],
		"scope": "",
		"description": "The command argument to the -c invocation option."
	},
	"$BASH_LINENO": {
		"prefix": "$BASH_LINENO",
		"body": [
			"\\${BASH_LINENO}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the line numbers in source files where each corresponding member of FUNCNAME was invoked. ${BASH_LINENO[$i]} is the line number in the source file (${BASH_SOURCE[$i+1]}) where ${FUNCNAME[$i]} was called (or ${BASH_LINENO[$i-1]} if referenced within another shell function). Use LINENO to obtain the current line number."
	},
	"$BASH_LOADABLES_PATH": {
		"prefix": "$BASH_LOADABLES_PATH",
		"body": [
			"\\${BASH_LOADABLES_PATH}$0"
		],
		"scope": "",
		"description": "A colon-separated list of directories in which the shell looks for dynamically loadable builtins specified by the enable command."
	},
	"$BASH_REMATCH": {
		"prefix": "$BASH_REMATCH",
		"body": [
			"\\${BASH_REMATCH}$0"
		],
		"scope": "",
		"description": "An array variable whose members are assigned by the ‘=~’ binary operator to the [[ conditional command (see Conditional Constructs). The element with index 0 is the portion of the string matching the entire regular expression. The element with index n is the portion of the string matching the nth parenthesized subexpression."
	},
	"$BASH_SOURCE": {
		"prefix": "$BASH_SOURCE",
		"body": [
			"\\${BASH_SOURCE}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the source filenames where the corresponding shell function names in the FUNCNAME array variable are defined. The shell function ${FUNCNAME[$i]} is defined in the file ${BASH_SOURCE[$i]} and called from ${BASH_SOURCE[$i+1]}"
	},
	"$BASH_SUBSHELL": {
		"prefix": "$BASH_SUBSHELL",
		"body": [
			"\\${BASH_SUBSHELL}$0"
		],
		"scope": "",
		"description": "Incremented by one within each subshell or subshell environment when the shell begins executing in that environment. The initial value is 0. If BASH_SUBSHELL is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_VERSINFO": {
		"prefix": "$BASH_VERSINFO",
		"body": [
			"\\${BASH_VERSINFO}$0"
		],
		"scope": "",
		"description": "A readonly array variable (see Arrays) whose members hold version information for this instance of Bash. The values assigned to the array members are as follows:"
	},
	"$BASH_VERSINFO[0]": {
		"prefix": "$BASH_VERSINFO[0]",
		"body": [
			"\\${BASH_VERSINFO[0]}$0"
		],
		"scope": "",
		"description": "The major version number (the release)."
	},
	"$BASH_VERSINFO[1]": {
		"prefix": "$BASH_VERSINFO[1]",
		"body": [
			"\\${BASH_VERSINFO[1]}$0"
		],
		"scope": "",
		"description": "The minor version number (the version)."
	},
	"$BASH_VERSINFO[2]": {
		"prefix": "$BASH_VERSINFO[2]",
		"body": [
			"\\${BASH_VERSINFO[2]}$0"
		],
		"scope": "",
		"description": "The patch level."
	},
	"$BASH_VERSINFO[3]": {
		"prefix": "$BASH_VERSINFO[3]",
		"body": [
			"\\${BASH_VERSINFO[3]}$0"
		],
		"scope": "",
		"description": "The build version."
	},
	"$BASH_VERSINFO[4]": {
		"prefix": "$BASH_VERSINFO[4]",
		"body": [
			"\\${BASH_VERSINFO[4]}$0"
		],
		"scope": "",
		"description": "The release status (e.g., beta1)."
	},
	"$BASH_VERSINFO[5]": {
		"prefix": "$BASH_VERSINFO[5]",
		"body": [
			"\\${BASH_VERSINFO[5]}$0"
		],
		"scope": "",
		"description": "The value of MACHTYPE. "
	},
	"$BASH_VERSION": {
		"prefix": "$BASH_VERSION",
		"body": [
			"\\${BASH_VERSION}$0"
		],
		"scope": "",
		"description": "The version number of the current instance of Bash."
	},
	"$BASH_XTRACEFD": {
		"prefix": "$BASH_XTRACEFD",
		"body": [
			"\\${BASH_XTRACEFD}$0"
		],
		"scope": "",
		"description": "If set to an integer corresponding to a valid file descriptor, Bash will write the trace output generated when ‘set -x’ is enabled to that file descriptor. This allows tracing output to be separated from diagnostic and error messages. The file descriptor is closed when BASH_XTRACEFD is unset or assigned a new value. Unsetting BASH_XTRACEFD or assigning it the empty string causes the trace output to be sent to the standard error. Note that setting BASH_XTRACEFD to 2 (the standard error file descriptor) and then unsetting it will result in the standard error being closed."
	},
	"$CHILD_MAX": {
		"prefix": "$CHILD_MAX",
		"body": [
			"\\${CHILD_MAX}$0"
		],
		"scope": "",
		"description": "Set the number of exited child status values for the shell to remember. Bash will not allow this value to be decreased below a POSIX-mandated minimum, and there is a maximum value (currently 8192) that this may not exceed. The minimum value is system-dependent."
	},
	"$COLUMNS": {
		"prefix": "$COLUMNS",
		"body": [
			"\\${COLUMNS}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the terminal width when printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$COMP_CWORD": {
		"prefix": "$COMP_CWORD",
		"body": [
			"\\${COMP_CWORD}$0"
		],
		"scope": "",
		"description": "An index into ${COMP_WORDS} of the word containing the current cursor position. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_LINE": {
		"prefix": "$COMP_LINE",
		"body": [
			"\\${COMP_LINE}$0"
		],
		"scope": "",
		"description": "The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_POINT": {
		"prefix": "$COMP_POINT",
		"body": [
			"\\${COMP_POINT}$0"
		],
		"scope": "",
		"description": "The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to ${#COMP_LINE}. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_TYPE": {
		"prefix": "$COMP_TYPE",
		"body": [
			"\\${COMP_TYPE}$0"
		],
		"scope": "",
		"description": "Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called: TAB, for normal completion, ‘?’, for listing completions after successive tabs, ‘!’, for listing alternatives on partial word completion, ‘@’, to list completions if the word is not unmodified, or ‘%’, for menu completion. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_KEY": {
		"prefix": "$COMP_KEY",
		"body": [
			"\\${COMP_KEY}$0"
		],
		"scope": "",
		"description": "The key (or final key of a key sequence) used to invoke the current completion function."
	},
	"$COMP_WORDBREAKS": {
		"prefix": "$COMP_WORDBREAKS",
		"body": [
			"\\${COMP_WORDBREAKS}$0"
		],
		"scope": "",
		"description": "The set of characters that the Readline library treats as word separators when performing word completion. If COMP_WORDBREAKS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$COMP_WORDS": {
		"prefix": "$COMP_WORDS",
		"body": [
			"\\${COMP_WORDS}$0"
		],
		"scope": "",
		"description": "An array variable consisting of the individual words in the current command line. The line is split into words as Readline would split it, using COMP_WORDBREAKS as described above. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMPREPLY": {
		"prefix": "$COMPREPLY",
		"body": [
			"\\${COMPREPLY}$0"
		],
		"scope": "",
		"description": "An array variable from which Bash reads the possible completions generated by a shell function invoked by the programmable completion facility (see Programmable Completion). Each array element contains one possible completion."
	},
	"$COPROC": {
		"prefix": "$COPROC",
		"body": [
			"\\${COPROC}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the file descriptors for output from and input to an unnamed coprocess (see Coprocesses)."
	},
	"$DIRSTACK": {
		"prefix": "$DIRSTACK",
		"body": [
			"\\${DIRSTACK}$0"
		],
		"scope": "",
		"description": "An array variable containing the current contents of the directory stack. Directories appear in the stack in the order they are displayed by the dirs builtin. Assigning to members of this array variable may be used to modify directories already in the stack, but the pushd and popd builtins must be used to add and remove directories. Assignment to this variable will not change the current directory. If DIRSTACK is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EMACS": {
		"prefix": "$EMACS",
		"body": [
			"\\${EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts with value ‘t’, it assumes that the shell is running in an Emacs shell buffer and disables line editing."
	},
	"$ENV": {
		"prefix": "$ENV",
		"body": [
			"\\${ENV}$0"
		],
		"scope": "",
		"description": "Expanded and executed similarly to BASH_ENV (see Bash Startup Files) when an interactive shell is invoked in POSIX Mode (see Bash POSIX Mode)."
	},
	"$EPOCHREALTIME": {
		"prefix": "$EPOCHREALTIME",
		"body": [
			"\\${EPOCHREALTIME}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch as a floating point value with micro-second granularity (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHREALTIME are ignored. If EPOCHREALTIME is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EPOCHSECONDS": {
		"prefix": "$EPOCHSECONDS",
		"body": [
			"\\${EPOCHSECONDS}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHSECONDS are ignored. If EPOCHSECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EUID": {
		"prefix": "$EUID",
		"body": [
			"\\${EUID}$0"
		],
		"scope": "",
		"description": "The numeric effective user id of the current user. This variable is readonly."
	},
	"$EXECIGNORE": {
		"prefix": "$EXECIGNORE",
		"body": [
			"\\${EXECIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of shell patterns (see Pattern Matching) defining the list of filenames to be ignored by command search using PATH. Files whose full pathnames match one of these patterns are not considered executable files for the purposes of completion and command execution via PATH lookup. This does not affect the behavior of the [, test, and [[ commands. Full pathnames in the command hash table are not subject to EXECIGNORE. Use this variable to ignore shared library files that have the executable bit set, but are not executable files. The pattern matching honors the setting of the extglob shell option."
	},
	"$FCEDIT": {
		"prefix": "$FCEDIT",
		"body": [
			"\\${FCEDIT}$0"
		],
		"scope": "",
		"description": "The editor used as a default by the -e option to the fc builtin command."
	},
	"$FIGNORE": {
		"prefix": "$FIGNORE",
		"body": [
			"\\${FIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of suffixes to ignore when performing filename completion. A filename whose suffix matches one of the entries in FIGNORE is excluded from the list of matched filenames. A sample value is ‘.o:~’"
	},
	"$FUNCNAME": {
		"prefix": "$FUNCNAME",
		"body": [
			"\\${FUNCNAME}$0"
		],
		"scope": "",
		"description": "An array variable containing the names of all shell functions currently in the execution call stack. The element with index 0 is the name of any currently-executing shell function. The bottom-most element (the one with the highest index) is main. This variable exists only when a shell function is executing. Assignments to FUNCNAME have no effect. If FUNCNAME is unset, it loses its special properties, even if it is subsequently reset. This variable can be used with BASH_LINENO and BASH_SOURCE. Each element of FUNCNAME has corresponding elements in BASH_LINENO and BASH_SOURCE to describe the call stack. For instance, ${FUNCNAME[$i]} was called from the file ${BASH_SOURCE[$i+1]} at line number ${BASH_LINENO[$i]}. The caller builtin displays the current call stack using this information."
	},
	"$FUNCNEST": {
		"prefix": "$FUNCNEST",
		"body": [
			"\\${FUNCNEST}$0"
		],
		"scope": "",
		"description": "If set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed this nesting level will cause the current command to abort."
	},
	"$GLOBIGNORE": {
		"prefix": "$GLOBIGNORE",
		"body": [
			"\\${GLOBIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns defining the set of file names to be ignored by filename expansion. If a file name matched by a filename expansion pattern also matches one of the patterns in GLOBIGNORE, it is removed from the list of matches. The pattern matching honors the setting of the extglob shell option."
	},
	"$GROUPS": {
		"prefix": "$GROUPS",
		"body": [
			"\\${GROUPS}$0"
		],
		"scope": "",
		"description": "An array variable containing the list of groups of which the current user is a member. Assignments to GROUPS have no effect. If GROUPS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$histchars": {
		"prefix": "$histchars",
		"body": [
			"\\${histchars}$0"
		],
		"scope": "",
		"description": "Up to three characters which control history expansion, quick substitution, and tokenization (see History Expansion). The first character is the history expansion character, that is, the character which signifies the start of a history expansion, normally ‘!’. The second character is the character which signifies ‘quick substitution’ when seen as the first character on a line, normally ‘^’. The optional third character is the character which indicates that the remainder of the line is a comment when found as the first character of a word, usually ‘#’. The history comment character causes history substitution to be skipped for the remaining words on the line. It does not necessarily cause the shell parser to treat the rest of the line as a comment."
	},
	"$HISTCMD": {
		"prefix": "$HISTCMD",
		"body": [
			"\\${HISTCMD}$0"
		],
		"scope": "",
		"description": "The history number, or index in the history list, of the current command. Assignments to HISTCMD are ignored. If HISTCMD is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$HISTCONTROL": {
		"prefix": "$HISTCONTROL",
		"body": [
			"\\${HISTCONTROL}$0"
		],
		"scope": "",
		"description": "A colon-separated list of values controlling how commands are saved on the history list. If the list of values includes ‘ignorespace’, lines which begin with a space character are not saved in the history list. A value of ‘ignoredups’ causes lines which match the previous history entry to not be saved. A value of ‘ignoreboth’ is shorthand for ‘ignorespace’ and ‘ignoredups’. A value of ‘erasedups’ causes all previous lines matching the current line to be removed from the history list before that line is saved. Any value not in the above list is ignored. If HISTCONTROL is unset, or does not include a valid value, all lines read by the shell parser are saved on the history list, subject to the value of HISTIGNORE. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTCONTROL."
	},
	"$HISTFILE": {
		"prefix": "$HISTFILE",
		"body": [
			"\\${HISTFILE}$0"
		],
		"scope": "",
		"description": "The name of the file to which the command history is saved. The default value is ~/.bash_history."
	},
	"$HISTFILESIZE": {
		"prefix": "$HISTFILESIZE",
		"body": [
			"\\${HISTFILESIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of lines contained in the history file. When this variable is assigned a value, the history file is truncated, if necessary, to contain no more than that number of lines by removing the oldest entries. The history file is also truncated to this size after writing it when a shell exits. If the value is 0, the history file is truncated to zero size. Non-numeric values and numeric values less than zero inhibit truncation. The shell sets the default value to the value of HISTSIZE after reading any startup files."
	},
	"$HISTIGNORE": {
		"prefix": "$HISTIGNORE",
		"body": [
			"\\${HISTIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns used to decide which command lines should be saved on the history list. Each pattern is anchored at the beginning of the line and must match the complete line (no implicit ‘*’ is appended). Each pattern is tested against the line after the checks specified by HISTCONTROL are applied. In addition to the normal shell pattern matching characters, ‘&’ matches the previous history line. ‘&’ may be escaped using a backslash; the backslash is removed before attempting a match. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTIGNORE. The pattern matching honors the setting of the extglob shell option. HISTIGNORE subsumes the function of HISTCONTROL. A pattern of ‘&’ is identical to ignoredups, and a pattern of ‘[ ]*’ is identical to ignorespace. Combining these two patterns, separating them with a colon, provides the functionality of ignoreboth."
	},
	"$HISTSIZE": {
		"prefix": "$HISTSIZE",
		"body": [
			"\\${HISTSIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of commands to remember on the history list. If the value is 0, commands are not saved in the history list. Numeric values less than zero result in every command being saved on the history list (there is no limit). The shell sets the default value to 500 after reading any startup files."
	},
	"$HISTTIMEFORMAT": {
		"prefix": "$HISTTIMEFORMAT",
		"body": [
			"\\${HISTTIMEFORMAT}$0"
		],
		"scope": "",
		"description": "If this variable is set and not null, its value is used as a format string for strftime to print the time stamp associated with each history entry displayed by the history builtin. If this variable is set, time stamps are written to the history file so they may be preserved across shell sessions. This uses the history comment character to distinguish timestamps from other history lines."
	},
	"$HOSTFILE": {
		"prefix": "$HOSTFILE",
		"body": [
			"\\${HOSTFILE}$0"
		],
		"scope": "",
		"description": "Contains the name of a file in the same format as /etc/hosts that should be read when the shell needs to complete a hostname. The list of possible hostname completions may be changed while the shell is running; the next time hostname completion is attempted after the value is changed, Bash adds the contents of the new file to the existing list. If HOSTFILE is set, but has no value, or does not name a readable file, Bash attempts to read /etc/hosts to obtain the list of possible hostname completions. When HOSTFILE is unset, the hostname list is cleared."
	},
	"$HOSTNAME": {
		"prefix": "$HOSTNAME",
		"body": [
			"\\${HOSTNAME}$0"
		],
		"scope": "",
		"description": "The name of the current host."
	},
	"$HOSTTYPE": {
		"prefix": "$HOSTTYPE",
		"body": [
			"\\${HOSTTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the machine Bash is running on."
	},
	"$IGNOREEOF": {
		"prefix": "$IGNOREEOF",
		"body": [
			"\\${IGNOREEOF}$0"
		],
		"scope": "",
		"description": "Controls the action of the shell on receipt of an EOF character as the sole input. If set, the value denotes the number of consecutive EOF characters that can be read as the first character on an input line before the shell will exit. If the variable exists but does not have a numeric value, or has no value, then the default is 10. If the variable does not exist, then EOF signifies the end of input to the shell. This is only in effect for interactive shells."
	},
	"$INPUTRC": {
		"prefix": "$INPUTRC",
		"body": [
			"\\${INPUTRC}$0"
		],
		"scope": "",
		"description": "The name of the Readline initialization file, overriding the default of ~/.inputrc."
	},
	"$INSIDE_EMACS": {
		"prefix": "$INSIDE_EMACS",
		"body": [
			"\\${INSIDE_EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts, it assumes that the shell is running in an Emacs shell buffer and may disable line editing depending on the value of TERM."
	},
	"$LANG": {
		"prefix": "$LANG",
		"body": [
			"\\${LANG}$0"
		],
		"scope": "",
		"description": "Used to determine the locale category for any category not specifically selected with a variable starting with LC_."
	},
	"$LC_ALL": {
		"prefix": "$LC_ALL",
		"body": [
			"\\${LC_ALL}$0"
		],
		"scope": "",
		"description": "This variable overrides the value of LANG and any other LC_ variable specifying a locale category."
	},
	"$LC_COLLATE": {
		"prefix": "$LC_COLLATE",
		"body": [
			"\\${LC_COLLATE}$0"
		],
		"scope": "",
		"description": "This variable determines the collation order used when sorting the results of filename expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_CTYPE": {
		"prefix": "$LC_CTYPE",
		"body": [
			"\\${LC_CTYPE}$0"
		],
		"scope": "",
		"description": "This variable determines the interpretation of characters and the behavior of character classes within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_MESSAGES": {
		"prefix": "$LC_MESSAGES",
		"body": [
			"\\${LC_MESSAGES}$0"
		],
		"scope": "",
		"description": "This variable determines the locale used to translate double-quoted strings preceded by a ‘$’ (see Locale-Specific Translation)."
	},
	"$LC_NUMERIC": {
		"prefix": "$LC_NUMERIC",
		"body": [
			"\\${LC_NUMERIC}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for number formatting."
	},
	"$LC_TIME": {
		"prefix": "$LC_TIME",
		"body": [
			"\\${LC_TIME}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for data and time formatting."
	},
	"$LINENO": {
		"prefix": "$LINENO",
		"body": [
			"\\${LINENO}$0"
		],
		"scope": "",
		"description": "The line number in the script or shell function currently executing. If LINENO is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$LINES": {
		"prefix": "$LINES",
		"body": [
			"\\${LINES}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the column length for printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$MACHTYPE": {
		"prefix": "$MACHTYPE",
		"body": [
			"\\${MACHTYPE}$0"
		],
		"scope": "",
		"description": "A string that fully describes the system type on which Bash is executing, in the standard GNU cpu-company-system format."
	},
	"$MAILCHECK": {
		"prefix": "$MAILCHECK",
		"body": [
			"\\${MAILCHECK}$0"
		],
		"scope": "",
		"description": "How often (in seconds) that the shell should check for mail in the files specified in the MAILPATH or MAIL variables. The default is 60 seconds. When it is time to check for mail, the shell does so before displaying the primary prompt. If this variable is unset, or set to a value that is not a number greater than or equal to zero, the shell disables mail checking."
	},
	"$MAPFILE": {
		"prefix": "$MAPFILE",
		"body": [
			"\\${MAPFILE}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the text read by the mapfile builtin when no variable name is supplied."
	},
	"$OLDPWD": {
		"prefix": "$OLDPWD",
		"body": [
			"\\${OLDPWD}$0"
		],
		"scope": "",
		"description": "The previous working directory as set by the cd builtin."
	},
	"$OPTERR": {
		"prefix": "$OPTERR",
		"body": [
			"\\${OPTERR}$0"
		],
		"scope": "",
		"description": "If set to the value 1, Bash displays error messages generated by the getopts builtin command."
	},
	"$OSTYPE": {
		"prefix": "$OSTYPE",
		"body": [
			"\\${OSTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the operating system Bash is running on."
	},
	"$PIPESTATUS": {
		"prefix": "$PIPESTATUS",
		"body": [
			"\\${PIPESTATUS}$0"
		],
		"scope": "",
		"description": "An array variable (see Arrays) containing a list of exit status values from the processes in the most-recently-executed foreground pipeline (which may contain only a single command)."
	},
	"$POSIXLY_CORRECT": {
		"prefix": "$POSIXLY_CORRECT",
		"body": [
			"\\${POSIXLY_CORRECT}$0"
		],
		"scope": "",
		"description": "If this variable is in the environment when Bash starts, the shell enters POSIX mode (see Bash POSIX Mode) before reading the startup files, as if the --posix invocation option had been supplied. If it is set while the shell is running, Bash enables POSIX mode, as if the command set -o posix had been executed. When the shell enters POSIX mode, it sets this variable if it was not already set."
	},
	"$PPID": {
		"prefix": "$PPID",
		"body": [
			"\\${PPID}$0"
		],
		"scope": "",
		"description": "The process ID of the shell’s parent process. This variable is readonly."
	},
	"$PROMPT_COMMAND": {
		"prefix": "$PROMPT_COMMAND",
		"body": [
			"\\${PROMPT_COMMAND}$0"
		],
		"scope": "",
		"description": "If this variable is set, and is an array, the value of each set element is interpreted as a command to execute before printing the primary prompt ($PS1). If this is set but not an array variable, its value is used as a command to execute instead."
	},
	"$PROMPT_DIRTRIM": {
		"prefix": "$PROMPT_DIRTRIM",
		"body": [
			"\\${PROMPT_DIRTRIM}$0"
		],
		"scope": "",
		"description": "If set to a number greater than zero, the value is used as the number of trailing directory components to retain when expanding the \\w and \\W prompt string escapes (see Controlling the Prompt). Characters removed are replaced with an ellipsis."
	},
	"$PS0": {
		"prefix": "$PS0",
		"body": [
			"\\${PS0}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and displayed by interactive shells after reading a command and before the command is executed."
	},
	"$PS3": {
		"prefix": "$PS3",
		"body": [
			"\\${PS3}$0"
		],
		"scope": "",
		"description": "The value of this variable is used as the prompt for the select command. If this variable is not set, the select command prompts with ‘#? ’"
	},
	"$PS4": {
		"prefix": "$PS4",
		"body": [
			"\\${PS4}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and the expanded value is the prompt printed before the command line is echoed when the -x option is set (see The Set Builtin). The first character of the expanded value is replicated multiple times, as necessary, to indicate multiple levels of indirection. The default is ‘+ ’."
	},
	"$PWD": {
		"prefix": "$PWD",
		"body": [
			"\\${PWD}$0"
		],
		"scope": "",
		"description": "The current working directory as set by the cd builtin."
	},
	"$RANDOM": {
		"prefix": "$RANDOM",
		"body": [
			"\\${RANDOM}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to a random integer between 0 and 32767. Assigning a value to this variable seeds the random number generator. If RANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$READLINE_ARGUMENT": {
		"prefix": "$READLINE_ARGUMENT",
		"body": [
			"\\${READLINE_ARGUMENT}$0"
		],
		"scope": "",
		"description": "Any numeric argument given to a Readline command that was defined using ‘bind -x’ (see Bash Builtin Commands when it was invoked."
	},
	"$READLINE_LINE": {
		"prefix": "$READLINE_LINE",
		"body": [
			"\\${READLINE_LINE}$0"
		],
		"scope": "",
		"description": "The contents of the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$READLINE_MARK": {
		"prefix": "$READLINE_MARK",
		"body": [
			"\\${READLINE_MARK}$0"
		],
		"scope": "",
		"description": "The position of the mark (saved insertion point) in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands). The characters between the insertion point and the mark are often called the region."
	},
	"$READLINE_POINT": {
		"prefix": "$READLINE_POINT",
		"body": [
			"\\${READLINE_POINT}$0"
		],
		"scope": "",
		"description": "The position of the insertion point in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$REPLY": {
		"prefix": "$REPLY",
		"body": [
			"\\${REPLY}$0"
		],
		"scope": "",
		"description": "The default variable for the read builtin."
	},
	"$SECONDS": {
		"prefix": "$SECONDS",
		"body": [
			"\\${SECONDS}$0"
		],
		"scope": "",
		"description": "This variable expands to the number of seconds since the shell was started. Assignment to this variable resets the count to the value assigned, and the expanded value becomes the value assigned plus the number of seconds since the assignment. The number of seconds at shell invocation and the current time are always determined by querying the system clock. If SECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$SHELL": {
		"prefix": "$SHELL",
		"body": [
			"\\${SHELL}$0"
		],
		"scope": "",
		"description": "This environment variable expands to the full pathname to the shell. If it is not set when the shell starts, Bash assigns to it the full pathname of the current user’s login shell."
	},
	"$SHELLOPTS": {
		"prefix": "$SHELLOPTS",
		"body": [
			"\\${SHELLOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -o option to the set builtin command (see The Set Builtin). The options appearing in SHELLOPTS are those reported as ‘on’ by ‘set -o’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$SHLVL": {
		"prefix": "$SHLVL",
		"body": [
			"\\${SHLVL}$0"
		],
		"scope": "",
		"description": "Incremented by one each time a new instance of Bash is started. This is intended to be a count of how deeply your Bash shells are nested."
	},
	"$SRANDOM": {
		"prefix": "$SRANDOM",
		"body": [
			"\\${SRANDOM}$0"
		],
		"scope": "",
		"description": "This variable expands to a 32-bit pseudo-random number each time it is referenced. The random number generator is not linear on systems that support /dev/urandom or arc4random, so each returned number has no relationship to the numbers preceding it. The random number generator cannot be seeded, so assignments to this variable have no effect. If SRANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$TIMEFORMAT": {
		"prefix": "$TIMEFORMAT",
		"body": [
			"\\${TIMEFORMAT}$0"
		],
		"scope": "",
		"description": "The value of this parameter is used as a format string specifying how the timing information for pipelines prefixed with the time reserved word should be displayed. The ‘%’ character introduces an escape sequence that is expanded to a time value or other information. If the value is null, no timing information is displayed. A trailing newline is added when the format string is displayed."
	},
	"$TMOUT": {
		"prefix": "$TMOUT",
		"body": [
			"\\${TMOUT}$0"
		],
		"scope": "",
		"description": "If set to a value greater than zero, TMOUT is treated as the default timeout for the read builtin (see Bash Builtin Commands). The select command (see Conditional Constructs) terminates if input does not arrive after TMOUT seconds when input is coming from a terminal. In an interactive shell, the value is interpreted as the number of seconds to wait for a line of input after issuing the primary prompt. Bash terminates after waiting for that number of seconds if a complete line of input does not arrive."
	},
	"$TMPDIR": {
		"prefix": "$TMPDIR",
		"body": [
			"\\${TMPDIR}$0"
		],
		"scope": "",
		"description": "If set, Bash uses its value as the name of a directory in which Bash creates temporary files for the shell’s use."
	},
	"$UID": {
		"prefix": "$UID",
		"body": [
			"\\${UID}$0"
		],
		"scope": "",
		"description": "The numeric real user id of the current user. This variable is readonly."
	},
	"$BASH": {
		"prefix": "$BASH",
		"description": "The full pathname used to execute the current instance of Bash. ",
		"scope": "",
		"body": [
			"\\${BASH}$0"
		]
	},
	"$_": {
		"prefix": "$_",
		"description": "",
		"scope": "",
		"body": [
			"\\${_}$0"
		]
	},
	"$CDPATH": {
		"prefix": "$CDPATH",
		"description": "A colon-separated list of directories used as a search path for the cd builtin command.",
		"scope": "",
		"body": [
			"\\${CDPATH}$0"
		]
	},
	"$PS2": {
		"prefix": "$PS2",
		"description": "The secondary prompt string. The default value is ‘> ’. PS2 is expanded in the same way as PS1 before being displayed.",
		"scope": "",
		"body": [
			"\\${PS2}$0"
		]
	},
	"$PS1": {
		"prefix": "$PS1",
		"description": "The primary prompt string. The default value is ‘\\s-\\v\\${ ’}. See Controlling the Prompt, for the complete list of escape sequences that are expanded before PS1 is displayed. ",
		"scope": "",
		"body": [
			"\\${PS1}$0"
		]
	},
	"$PATH": {
		"prefix": "$PATH",
		"description": "A colon-separated list of directories in which the shell looks for commands. A zero-length (null) directory name in the value of PATH indicates the current directory. A null directory name may appear as two adjacent colons, or as an initial or trailing colon. ",
		"scope": "",
		"body": [
			"\\${PATH}$0"
		]
	},
	"$OPTIND": {
		"prefix": "$OPTIND",
		"description": "The index of the last option argument processed by the getopts builtin. ",
		"scope": "",
		"body": [
			"\\${OPTIND}$0"
		]
	},
	"$OPTARG": {
		"prefix": "$OPTARG",
		"description": "The value of the last option argument processed by the getopts builtin.",
		"scope": "",
		"body": [
			"\\${OPTARG}$0"
		]
	},
	"$MAILPATH": {
		"prefix": "$MAILPATH",
		"description": "A colon-separated list of filenames which the shell periodically checks for new mail. Each list entry can specify the message that is printed when new mail arrives in the mail file by separating the filename from the message with a ‘?’. When used in the text of the message, $_ expands to the name of the current mail file.",
		"scope": "",
		"body": [
			"\\${MAILPATH}$0"
		]
	},
	"$MAIL": {
		"prefix": "$MAIL",
		"description": "If this parameter is set to a filename or directory name and the MAILPATH variable is not set, Bash informs the user of the arrival of mail in the specified file or Maildir-format directory.",
		"scope": "",
		"body": [
			"\\${MAIL}$0"
		]
	},
	"$IFS": {
		"prefix": "$IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"\\${IFS}$0"
		]
	},
	"$HOME": {
		"prefix": "$HOME",
		"description": "The current user’s home directory; the default for the cd builtin command. The value of this variable is also used by tilde expansion.",
		"scope": "",
		"body": [
			"\\${HOME}$0"
		]
	}
}