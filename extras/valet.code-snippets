{
// Documentation generated for the version 0.35.114 (2025-10-03).

"array::appendIfNotPresent": {
  "prefix": "array::appendIfNotPresent",
  "description": "Add a value to an array if it is not already present...",
  "scope": "",
  "body": [ "array::appendIfNotPresent \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::appendIfNotPresent#withdoc": {
  "prefix": "array::appendIfNotPresent#withdoc",
  "description": "Add a value to an array if it is not already present...",
  "scope": "",
  "body": [ "# ## array::appendIfNotPresent\n# \n# Add a value to an array if it is not already present.\n# Works for normal and associative arrays.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array.\n# - \\$2: **value variable name** _as any_:\n#       The variable name containing the value to add.\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the value was added\n#   - 1 if it was already present\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" )\n# declare myValue=\"b\"\n# array::appendIfNotPresent myArray myValue\n# printf '%s\\n' \"\\${myArray[@]}\"\n# ```\n# \narray::appendIfNotPresent \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::contains": {
  "prefix": "array::contains",
  "description": "Check if a value is in an array...",
  "scope": "",
  "body": [ "array::contains \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::contains#withdoc": {
  "prefix": "array::contains#withdoc",
  "description": "Check if a value is in an array...",
  "scope": "",
  "body": [ "# ## array::contains\n# \n# Check if a value is in an array.\n# It uses pure bash.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array.\n# - \\$2: **value variable name** _as any_:\n#       The variable name containing the value to check.\n# \n# Returns:\n# \n# - \\$?: 0 if the value is in the array, 1 otherwise.\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" )\n# declare myValue=\"b\"\n# if array::contains myArray myValue; then \"b is in the array\"; fi\n# ```\n# \narray::contains \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::fuzzyFilterSort": {
  "prefix": "array::fuzzyFilterSort",
  "description": "Allows to fuzzy sort an array against a given searched string...",
  "scope": "",
  "body": [ "array::fuzzyFilterSort \"${1:array name}\" \"${2:search string}\"$0" ]
},

"array::fuzzyFilterSort#withdoc": {
  "prefix": "array::fuzzyFilterSort#withdoc",
  "description": "Allows to fuzzy sort an array against a given searched string...",
  "scope": "",
  "body": [ "# ## array::fuzzyFilterSort\n# \n# Allows to fuzzy sort an array against a given searched string.\n# Returns an array containing only the lines matching the searched string.\n# The array is sorted by (in order):\n# \n# - the index of the first matched character in the line\n# - the distance between the first and last matched characters in the line\n# - the original order in the list\n# \n# Also returns an array containing the indexes of the matched items in the original array.\n# \n# - \\$1: **array name** _as string_:\n#       The array name to fuzzy filter and sort.\n# - \\$2: **search string** _as string_:\n#       The variable name containing the search string to match.\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array containing the items sorted and filtered\n# - \\${REPLY_ARRAY2[@]}: An array containing the indexes of the matched items in the original array\n# \n# ```bash\n# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING\n# echo \"\\${REPLY_ARRAY[*]}\"\n# ```\n# \n# > - All characters in the searched string must be found in the same order in the matched line.\n# > - Use `shopt -s nocasematch` to make this function is case insensitive.\n# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.\n# \narray::fuzzyFilterSort \"${1:array name}\" \"${2:search string}\"$0" ]
},

"array::makeArraysSameSize": {
  "prefix": "array::makeArraysSameSize",
  "description": "This function makes sure that all the arrays have the same size...",
  "scope": "",
  "body": [ "array::makeArraysSameSize \"${1:array names}\"$0" ]
},

"array::makeArraysSameSize#withdoc": {
  "prefix": "array::makeArraysSameSize#withdoc",
  "description": "This function makes sure that all the arrays have the same size...",
  "scope": "",
  "body": [ "# ## array::makeArraysSameSize\n# \n# This function makes sure that all the arrays have the same size.\n# It will add empty strings to the arrays that are too short.\n# \n# - \\$@: **array names** _as string_:\n#       The variable names of each array to transform.\n# \n# ```bash\n# array::makeArraysSameSize \"array1\" \"array2\" \"array3\"\n# ```\n# \narray::makeArraysSameSize \"${1:array names}\"$0" ]
},

"array::remove": {
  "prefix": "array::remove",
  "description": "Remove a value from an array...",
  "scope": "",
  "body": [ "array::remove \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::remove#withdoc": {
  "prefix": "array::remove#withdoc",
  "description": "Remove a value from an array...",
  "scope": "",
  "body": [ "# ## array::remove\n# \n# Remove a value from an array.\n# Works for normal and associative arrays.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array.\n# - \\$2: **value variable name** _as any_:\n#       The variable name containing the value to remove.\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the value was removed\n#   - 1 if it was not present\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" )\n# declare myValue=\"b\"\n# array::remove myArray myValue\n# printf '%s\\n' \"\\${myArray[@]}\"\n# ```\n# \narray::remove \"${1:array name}\" \"${2:value variable name}\"$0" ]
},

"array::reverse": {
  "prefix": "array::reverse",
  "description": "Reverse an array...",
  "scope": "",
  "body": [ "array::reverse \"${1:array name}\"$0" ]
},

"array::reverse#withdoc": {
  "prefix": "array::reverse#withdoc",
  "description": "Reverse an array...",
  "scope": "",
  "body": [ "# ## array::reverse\n# \n# Reverse an array.\n# Will not work for associative arrays.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array to reverse  (it will be reversed in place).\n# \n# ```bash\n# declare myArray=(z f b h a j)\n# array::reverse myArray\n# echo \"\\${myArray[*]}\"\n# ```\n# \narray::reverse \"${1:array name}\"$0" ]
},

"array::sort": {
  "prefix": "array::sort",
  "description": "Sorts an array using the > bash operator (lexicographic order)...",
  "scope": "",
  "body": [ "array::sort \"${1:array name}\"$0" ]
},

"array::sort#withdoc": {
  "prefix": "array::sort#withdoc",
  "description": "Sorts an array using the > bash operator (lexicographic order)...",
  "scope": "",
  "body": [ "# ## array::sort\n# \n# Sorts an array using the > bash operator (lexicographic order).\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array to sort  (it will be sorted in place).\n# \n# ```bash\n# declare myArray=(z f b h a j)\n# array::sort myArray\n# echo \"\\${myArray[*]}\"\n# ```\n# \n# > - This function uses a quicksort algorithm (hoarse partition).\n# > - The sorting is not stable (the order of equal elements is not preserved).\n# > - It is not appropriate for large array, use the `sort` binary for such cases.\n# \narray::sort \"${1:array name}\"$0" ]
},

"array::sortWithCriteria": {
  "prefix": "array::sortWithCriteria",
  "description": "Sorts an array using multiple criteria...",
  "scope": "",
  "body": [ "array::sortWithCriteria \"${1:array name}\" \"${2:criteria array names}\"$0" ]
},

"array::sortWithCriteria#withdoc": {
  "prefix": "array::sortWithCriteria#withdoc",
  "description": "Sorts an array using multiple criteria...",
  "scope": "",
  "body": [ "# ## array::sortWithCriteria\n# \n# Sorts an array using multiple criteria.\n# Excepts multiple arrays. The first array is the one to sort.\n# The other arrays are used as criteria. Criteria are used in the order they are given.\n# Each criteria array must have the same size as the array to sort.\n# Each criteria array must containing integers representing the order of the elements.\n# We first sort using the first criteria (from smallest to biggest), then the second, etc.\n# \n# - \\$1: **array name** _as string_:\n#       The name of the array to sort (it will be sorted in place).\n# - \\$@: **criteria array names** _as string_:\n#       The names of the arrays to use as criteria.\n#       Each array must have the same size as the array to sort and contain only numbers.\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array that contains the corresponding indexes of the sorted array in the original array\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" \"c\" )\n# declare criteria1=( 3 2 2 )\n# declare criteria2=( 1 3 2 )\n# array::sortWithCriteria myArray criteria1 criteria2\n# echo \"\\${myArray[@]}\"\n# # c b a\n# echo \"\\${REPLY_ARRAY[@]}\"\n# # 3 2 1\n# ```\n# \n# > - This function uses a quicksort algorithm (hoarse partition).\n# > - The sorting is not stable (the order of equal elements is not preserved).\n# > - It is not appropriate for large array, use the `sort` binary for such cases.\n# \narray::sortWithCriteria \"${1:array name}\" \"${2:criteria array names}\"$0" ]
},

"bash::catchErrors": {
  "prefix": "bash::catchErrors",
  "description": "This function runs a command and will catch any error that occurs instead of failing the program...",
  "scope": "",
  "body": [ "bash::catchErrors \"${1:command with args}\"$0" ]
},

"bash::catchErrors#withdoc": {
  "prefix": "bash::catchErrors#withdoc",
  "description": "This function runs a command and will catch any error that occurs instead of failing the program...",
  "scope": "",
  "body": [ "# ## bash::catchErrors\n# \n# This function runs a command and will catch any error that occurs instead of failing the program.\n# The execution will continue if an error occurs in the command, but each error will be stored for later processing.\n# For a function closer to a try/catch block, see `bash::runInSubshell`.\n# \n# - \\$@: **command with args** _as string_:\n#       The command to run.\n# \n# Returns:\n# \n# - \\${GLOBAL_ERROR_TRAP_LAST_ERROR_CODE}: the last error code encountered (or zero if none).\n# - \\${GLOBAL_ERROR_TRAP_ERROR_CODES}: the list of error codes that occurred during the execution of the command.\n# - \\${GLOBAL_ERROR_TRAP_ERROR_STACKS}: the list of error stacks that occurred during the execution of the command.\n# \n# ```bash\n# bash::catchErrors myFunction \"arg1\" \"arg2\"\n# if (( GLOBAL_ERROR_TRAP_LAST_ERROR_CODE != 0 )); then\n#   core::fail \"The command failed with code \\${GLOBAL_ERROR_TRAP_LAST_ERROR_CODE}.\"\n# fi\n# ```\n# \n# > While you can also put the execution of a command in an `if` (or in a pipeline) statement to effectively\n# > discard any errors happening in that command, the advantage of using this function is that the ERR trap\n# > is still triggered and you can use trace level debugging to see the caught issues.\n# > Additionally, it will report all the errors that occurred during the execution of the command.\n# \nbash::catchErrors \"${1:command with args}\"$0" ]
},

"bash::clearCachedVariables": {
  "prefix": "bash::clearCachedVariables",
  "description": "Clear the cached variables used by bash::isVariableCachedWithValue...",
  "scope": "",
  "body": [ "bash::clearCachedVariables$0" ]
},

"bash::clearCachedVariables#withdoc": {
  "prefix": "bash::clearCachedVariables#withdoc",
  "description": "Clear the cached variables used by bash::isVariableCachedWithValue...",
  "scope": "",
  "body": [ "# ## bash::clearCachedVariables\n# \n# Clear the cached variables used by bash::isVariableCachedWithValue.\n# This will unset all variables starting with _TUI_CACHED_.\n# \n# - \\$@ : **variable names** _as any_:\n#       (optional) the names of the variables to clear\n#       (defaults to all cached variables)\n# \n# ```bash\n# bash::clearCachedVariables\n# bash::clearCachedVariables \"MY_VAR\" \"ANOTHER_VAR\"\n# ```\n# \nbash::clearCachedVariables$0" ]
},

"bash::countArgs": {
  "prefix": "bash::countArgs",
  "description": "Returns the number of arguments passed...",
  "scope": "",
  "body": [ "bash::countArgs \"${1:arguments}\"$0" ]
},

"bash::countArgs#withdoc": {
  "prefix": "bash::countArgs#withdoc",
  "description": "Returns the number of arguments passed...",
  "scope": "",
  "body": [ "# ## bash::countArgs\n# \n# Returns the number of arguments passed.\n# \n# A convenient function that can be used to:\n# \n# - count the files/directories in a directory:\n#   `bash::countArgs \"\\${PWD}\"/* && local numberOfFiles=\"\\${REPLY}\"`\n# - count the number of variables starting with VALET_\n#   `bash::countArgs \"\\${!VALET_@}\" && local numberOfVariables=\"\\${REPLY}\"`\n# \n# Inputs:\n# \n# - \\$@: **arguments** _as any_:\n#       the arguments to count\n# \n# Returns:\n# \n# - \\${REPLY}: The number of arguments passed.\n# \n# ```bash\n# bash::countArgs 1 2 3\n# ```\n# \nbash::countArgs \"${1:arguments}\"$0" ]
},

"bash::getBuiltinOutput": {
  "prefix": "bash::getBuiltinOutput",
  "description": "Capture the output of a builtin command...",
  "scope": "",
  "body": [ "bash::getBuiltinOutput \"${1:command with arguments}\"$0" ]
},

"bash::getBuiltinOutput#withdoc": {
  "prefix": "bash::getBuiltinOutput#withdoc",
  "description": "Capture the output of a builtin command...",
  "scope": "",
  "body": [ "# ## bash::getBuiltinOutput\n# \n# Capture the output of a builtin command. Can be used on bash builtins that produce output.\n# It captures the stdout and stderr of said command.\n# \n# This function is a lot more basic than `exe::invoke` and does not support all its features.\n# \n# - \\$@: **command with arguments** _as string_:\n#       The command to run.\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${REPLY}: The captured output.\n# \n# ```bash\n# bash::getBuiltinOutput declare -f bash::getBuiltinOutput\n# echo \"\\${REPLY}\"\n# ```\n# \nbash::getBuiltinOutput \"${1:command with arguments}\"$0" ]
},

"bash::getMissingCommands": {
  "prefix": "bash::getMissingCommands",
  "description": "This function returns the list of not existing commands for the given names...",
  "scope": "",
  "body": [ "bash::getMissingCommands \"${1:command names}\"$0" ]
},

"bash::getMissingCommands#withdoc": {
  "prefix": "bash::getMissingCommands#withdoc",
  "description": "This function returns the list of not existing commands for the given names...",
  "scope": "",
  "body": [ "# ## bash::getMissingCommands\n# \n# This function returns the list of not existing commands for the given names.\n# \n# - \\$@: **command names** _as string_:\n#       the list of command names to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if there are not existing commands\n#   - 1 otherwise.\n# - \\${REPLY_ARRAY[@]}: the list of not existing commands.\n# \n# ```bash\n# if bash::getMissingCommands \"command1\" \"command2\"; then\n#   printf 'The following commands do not exist: %s' \"\\${REPLY_ARRAY[*]}\"\n# fi\n# ```\n# \nbash::getMissingCommands \"${1:command names}\"$0" ]
},

"bash::getMissingVariables": {
  "prefix": "bash::getMissingVariables",
  "description": "This function returns the list of undeclared variables for the given names...",
  "scope": "",
  "body": [ "bash::getMissingVariables \"${1:variable names}\"$0" ]
},

"bash::getMissingVariables#withdoc": {
  "prefix": "bash::getMissingVariables#withdoc",
  "description": "This function returns the list of undeclared variables for the given names...",
  "scope": "",
  "body": [ "# ## bash::getMissingVariables\n# \n# This function returns the list of undeclared variables for the given names.\n# \n# - \\$@: **variable names** _as string_:\n#       the list of variable names to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if there are variable undeclared\n#   - 1 otherwise.\n# - \\${REPLY_ARRAY[@]}: the list of undeclared variables.\n# \n# ```bash\n# if bash::getMissingVariables \"var1\" \"var2\"; then\n#   printf 'The following variables are not declared: %s' \"\\${REPLY_ARRAY[*]}\"\n# fi\n# ```\n# \nbash::getMissingVariables \"${1:variable names}\"$0" ]
},

"bash::injectCodeInFunction": {
  "prefix": "bash::injectCodeInFunction",
  "description": "This function injects code at the beginning or the end of a function and returns the modified function to be evaluated...",
  "scope": "",
  "body": [ "bash::injectCodeInFunction \"${1:function name}\" \"${2:code}\" injectAtBeginning=${3:false}$0" ]
},

"bash::injectCodeInFunction#withdoc": {
  "prefix": "bash::injectCodeInFunction#withdoc",
  "description": "This function injects code at the beginning or the end of a function and returns the modified function to be evaluated...",
  "scope": "",
  "body": [ "# ## bash::injectCodeInFunction\n# \n# This function injects code at the beginning or the end of a function and\n# returns the modified function to be evaluated.\n# \n# Creates an empty function if the function does not exist initially.\n# \n# - \\$1: **function name** _as string_:\n#       The name of the function to inject the code into.\n# - \\$2: **code** _as string_:\n#       The code to inject.\n# - \\${injectAtBeginning} _as bool_:\n#       (optional) Whether to inject the code at the beginning of the function (or at the end).\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: the modified function.\n# - \\${REPLY2}: the original function.\n# \n# ```bash\n# bash::injectCodeInFunction myFunction \"echo 'Hello!'\" injectAtBeginning=true\n# bash::injectCodeInFunction myFunction \"echo 'world!'\"\n# eval \"\\${REPLY}\"\n# myFunction\n# ```\n# \nbash::injectCodeInFunction \"${1:function name}\" \"${2:code}\" injectAtBeginning=${3:false}$0" ]
},

"bash::isCommand": {
  "prefix": "bash::isCommand",
  "description": "Check if the given command exists...",
  "scope": "",
  "body": [ "bash::isCommand \"${1:command name}\"$0" ]
},

"bash::isCommand#withdoc": {
  "prefix": "bash::isCommand#withdoc",
  "description": "Check if the given command exists...",
  "scope": "",
  "body": [ "# ## bash::isCommand\n# \n# Check if the given command exists.\n# \n# - \\$1: **command name** _as string_:\n#       the command name to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the command exists\n#   - 1 otherwise.\n# \n# ```bash\n# if bash::isCommand \"command1\"; then\n#   printf 'The command exists.'\n# fi\n# ```\n# \nbash::isCommand \"${1:command name}\"$0" ]
},

"bash::isFdValid": {
  "prefix": "bash::isFdValid",
  "description": "Check if the given file descriptor is valid...",
  "scope": "",
  "body": [ "bash::isFdValid \"${1:file descriptor}\"$0" ]
},

"bash::isFdValid#withdoc": {
  "prefix": "bash::isFdValid#withdoc",
  "description": "Check if the given file descriptor is valid...",
  "scope": "",
  "body": [ "# ## bash::isFdValid\n# \n# Check if the given file descriptor is valid.\n# \n# - \\$1: **file descriptor** _as string_:\n#       The file descriptor to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the file descriptor is valid\n#   - 1 otherwise.\n# \n# ```bash\n# if bash::isFdValid 1; then\n#   echo \"File descriptor 1 is valid.\"\n# fi\n# ```\n# \nbash::isFdValid \"${1:file descriptor}\"$0" ]
},

"bash::isFunction": {
  "prefix": "bash::isFunction",
  "description": "Check if the given function exists...",
  "scope": "",
  "body": [ "bash::isFunction \"${1:function name}\"$0" ]
},

"bash::isFunction#withdoc": {
  "prefix": "bash::isFunction#withdoc",
  "description": "Check if the given function exists...",
  "scope": "",
  "body": [ "# ## bash::isFunction\n# \n# Check if the given function exists.\n# \n# - \\$1: **function name** _as string_:\n#       the function name to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the function exists\n#   - 1 otherwise.\n# \n# ```bash\n# if bash::isFunction \"function1\"; then\n#   printf 'The function exists.'\n# fi\n# ```\n# \nbash::isFunction \"${1:function name}\"$0" ]
},

"bash::isVariableCachedWithValue": {
  "prefix": "bash::isVariableCachedWithValue",
  "description": "Check if one or more variables are cached with the given value...",
  "scope": "",
  "body": [ "bash::isVariableCachedWithValue \"${1:variable name}\" \"${2:value}\" \"${3:variable/value pair}\"$0" ]
},

"bash::isVariableCachedWithValue#withdoc": {
  "prefix": "bash::isVariableCachedWithValue#withdoc",
  "description": "Check if one or more variables are cached with the given value...",
  "scope": "",
  "body": [ "# ## bash::isVariableCachedWithValue\n# \n# Check if one or more variables are cached with the given value.\n# If all the variables given already have the same value cached,\n# the function will return true.\n# Otherwise, it will return false and cache the given value in the variables.\n# \n# - \\$1: **variable name** _as string_:\n#       the name of the variable to check\n# - \\$2: **value** _as any_:\n#       the value to check against the variable\n# - \\$@: **variable/value pair** _as any_:\n#       additional variable/value pairs to check\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if all the variables have the same value as the given value\n#   - 1 otherwise\n# \n# ```bash\n# if bash::isVariableCachedWithValue \"MY_VAR\" \"my_value\"; then\n#   echo \"MY_VAR is cached with the value 'my_value'\"\n# else\n#   echo \"MY_VAR is not cached with the value 'my_value'\"\n# fi\n# ```\n# \nbash::isVariableCachedWithValue \"${1:variable name}\" \"${2:value}\" \"${3:variable/value pair}\"$0" ]
},

"bash::readStdIn": {
  "prefix": "bash::readStdIn",
  "description": "Read the content of the standard input...",
  "scope": "",
  "body": [ "bash::readStdIn$0" ]
},

"bash::readStdIn#withdoc": {
  "prefix": "bash::readStdIn#withdoc",
  "description": "Read the content of the standard input...",
  "scope": "",
  "body": [ "# ## bash::readStdIn\n# \n# Read the content of the standard input.\n# Will immediately return if the standard input is empty.\n# \n# Returns:\n# \n# - \\${REPLY}: The content of the standard input.\n# \n# ```bash\n# bash::readStdIn\n# echo \"\\${REPLY}\"\n# ```\n# \nbash::readStdIn$0" ]
},

"bash::runInSubshell": {
  "prefix": "bash::runInSubshell",
  "description": "This functions runs a command in a subshell...",
  "scope": "",
  "body": [ "bash::runInSubshell \"${1:command with args}\"$0" ]
},

"bash::runInSubshell#withdoc": {
  "prefix": "bash::runInSubshell#withdoc",
  "description": "This functions runs a command in a subshell...",
  "scope": "",
  "body": [ "# ## bash::runInSubshell\n# \n# This functions runs a command in a subshell.\n# The command can fail and can trigger errors; it will be caught and this function will return\n# the exit code of the subshell.\n# This function can almost be considered as a try/catch block for bash as the execution will stop on error\n# but the error will be caught and stored for later processing instead of exiting the program.\n# \n# - \\$@: **command with args** _as string_:\n#       The command to run in the subshell.\n# - \\$_OPTION_EXIT_ON_FAIL _as bool_:\n#       (optional) If set to true, the main program will exit with code 1 if the command fails.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY_CODE}: the exit code of the subshell.\n# \n# ```bash\n# bash::runInSubshell myFunction\n# if (( REPLY_CODE != 0 )); then\n#   core::fail \"The subshell failed with code \\${REPLY_CODE}\"\n# fi\n# _OPTION_EXIT_ON_FAIL=true bash::runInSubshell myFunction\n# ```\n# \n# > This function exists because the behavior of bash subshells are not what you would expect.\n# > This function ensures that errors are properly handled and make the command list fail,\n# > it ensures that we run the exit trap and it gives you the correct exit code of the subshell.\n# > As a reminder, the error trap is not triggered for commands part of until while if ! || && tests,\n# > see <https://www.gnu.org/software/bash/manual/bash.html#index-trap> and\n# > <https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin-1>.\n# \nbash::runInSubshell \"${1:command with args}\"$0" ]
},

"bash::sleep": {
  "prefix": "bash::sleep",
  "description": "Sleep for the given amount of time...",
  "scope": "",
  "body": [ "bash::sleep \"${1:time}\"$0" ]
},

"bash::sleep#withdoc": {
  "prefix": "bash::sleep#withdoc",
  "description": "Sleep for the given amount of time...",
  "scope": "",
  "body": [ "# ## bash::sleep\n# \n# Sleep for the given amount of time.\n# This is a pure bash replacement of sleep.\n# \n# - \\$1: **time** _as float_:\n#       the time to sleep in seconds (can be a float)\n#       If 0, waits indefinitely.\n# \n# ```bash\n# bash::sleep 1.5\n# ```\n# \n# > The sleep command is not a built-in command in bash, but a separate executable. When you use sleep, you are creating a new process.\n# \nbash::sleep \"${1:time}\"$0" ]
},

"benchmark::run": {
  "prefix": "benchmark::run",
  "description": "This function runs a benchmark on given functions...",
  "scope": "",
  "body": [ "benchmark::run \"${1:baseline}\" \"${2:functions}\" --- baselineTimeInSeconds=${3:3} maxRuns=${4:-1}$0" ]
},

"benchmark::run#withdoc": {
  "prefix": "benchmark::run#withdoc",
  "description": "This function runs a benchmark on given functions...",
  "scope": "",
  "body": [ "# ## benchmark::run\n# \n# This function runs a benchmark on given functions.\n# \n# First, it will run the 1st function (the baseline) for a given amount of time and\n# mark the number of times it was able to run it.\n# \n# Then, it will run all the functions for the same number of time and\n# print the difference between the baseline and the other functions.\n# \n# - \\$1: **baseline** _as string_:\n#       the name of the function to use as baseline\n# - \\$@: functions _as string_:\n#       The names of the functions to benchmark, comma separated.\n# - \\${baselineTimeInSeconds} _as int_:\n#       (optional) The time in seconds for which to run the baseline.\n#       (defaults to 3)\n# - \\${maxRuns} _as int_:\n#       (optional) The maximum number of runs to do for each function.\n#       Set to -1 to run until the baseline time is reached.\n#       (defaults to -1)\n# \n# ```bash\n# benchmark::run baseline function1 function2\n# benchmark::run baseline function1 function2 --- baselineTimeInSeconds=5 maxRuns=100\n# ```\n# \nbenchmark::run \"${1:baseline}\" \"${2:functions}\" --- baselineTimeInSeconds=${3:3} maxRuns=${4:-1}$0" ]
},

"command::checkParsedResults": {
  "prefix": "command::checkParsedResults",
  "description": "A convenience function to check the parsing results and fails with an error message if there are parsing errors...",
  "scope": "",
  "body": [ "command::checkParsedResults$0" ]
},

"command::checkParsedResults#withdoc": {
  "prefix": "command::checkParsedResults#withdoc",
  "description": "A convenience function to check the parsing results and fails with an error message if there are parsing errors...",
  "scope": "",
  "body": [ "# ## command::checkParsedResults\n# \n# A convenience function to check the parsing results and fails with an error message if there are\n# parsing errors.\n# Will also display the help if the help option is true.\n# \n# This should be called from a command function for which you want to check the parsing results.\n# \n# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed\n# and if there are parsing errors.\n# \n# ```bash\n# command::checkParsedResults\n# ```\n# \ncommand::checkParsedResults$0" ]
},

"command::parseArguments": {
  "prefix": "command::parseArguments",
  "description": "Parse the arguments and options of a function and return a string that can be evaluated to set the variables...",
  "scope": "",
  "body": [ "command::parseArguments \"${1:arguments}\"$0" ]
},

"command::parseArguments#withdoc": {
  "prefix": "command::parseArguments#withdoc",
  "description": "Parse the arguments and options of a function and return a string that can be evaluated to set the variables...",
  "scope": "",
  "body": [ "# ## command::parseArguments\n# \n# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.\n# This should be called from a command function for which you want to parse the arguments.\n# \n# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.\n# \n# \n# - \\$@: **arguments** _as any_:\n#       the arguments to parse\n# \n# Returns:\n# \n# - \\${REPLY}: a string that can be evaluated to set the parsed variables\n# \n# Output example:\n# \n# ```\n# local arg1 option1\n# arg1=\"xxx\"\n# option1=\"xxx\"\n# ```\n# \n# ```bash\n# command::parseArguments \"\\$@\"; eval \"\\${REPLY}\"\n# ```\n# \ncommand::parseArguments \"${1:arguments}\"$0" ]
},

"command::showHelp": {
  "prefix": "command::showHelp",
  "description": "Show the help for the current function...",
  "scope": "",
  "body": [ "command::showHelp$0" ]
},

"command::showHelp#withdoc": {
  "prefix": "command::showHelp#withdoc",
  "description": "Show the help for the current function...",
  "scope": "",
  "body": [ "# ## command::showHelp\n# \n# Show the help for the current function.\n# This should be called directly from a command function for which you want to display the help text.\n# \n# ```bash\n# command::showHelp\n# ```\n# \ncommand::showHelp$0" ]
},

"command::sourceFunction": {
  "prefix": "command::sourceFunction",
  "description": "Source the file associated with a command function...",
  "scope": "",
  "body": [ "command::sourceFunction \"${1:function name}\"$0" ]
},

"command::sourceFunction#withdoc": {
  "prefix": "command::sourceFunction#withdoc",
  "description": "Source the file associated with a command function...",
  "scope": "",
  "body": [ "# ## command::sourceFunction\n# \n# Source the file associated with a command function.\n# This allows you to call a command function without having to source the file manually.\n# \n# - \\$1: **function name** _as string_:\n#       the function name\n# \n# ```bash\n# command::sourceFunction \"functionName\"\n# ```\n# \ncommand::sourceFunction \"${1:function name}\"$0" ]
},

"coproc::isRunning": {
  "prefix": "coproc::isRunning",
  "description": "This function checks if a coproc is running...",
  "scope": "",
  "body": [ "coproc::isRunning \"${1:coproc variable name}\"$0" ]
},

"coproc::isRunning#withdoc": {
  "prefix": "coproc::isRunning#withdoc",
  "description": "This function checks if a coproc is running...",
  "scope": "",
  "body": [ "# ## coproc::isRunning\n# \n# This function checks if a coproc is running.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the coproc is running\n#   - 1 if it is not\n# \n# ```bash\n# if coproc::isRunning \"myCoproc\"; then\n#   echo \"The coproc is running.\"\n# fi\n# ```\n# \ncoproc::isRunning \"${1:coproc variable name}\"$0" ]
},

"coproc::kill": {
  "prefix": "coproc::kill",
  "description": "This function kills a coproc...",
  "scope": "",
  "body": [ "coproc::kill \"${1:coproc variable name}\"$0" ]
},

"coproc::kill#withdoc": {
  "prefix": "coproc::kill#withdoc",
  "description": "This function kills a coproc...",
  "scope": "",
  "body": [ "# ## coproc::kill\n# \n# This function kills a coproc.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# \n# ```bash\n# coproc::kill \"myCoproc\"\n# ```\n# \ncoproc::kill \"${1:coproc variable name}\"$0" ]
},

"coproc::receiveMessage": {
  "prefix": "coproc::receiveMessage",
  "description": "This function receives a message from a given coproc...",
  "scope": "",
  "body": [ "coproc::receiveMessage \"${1:coproc variable name}\"$0" ]
},

"coproc::receiveMessage#withdoc": {
  "prefix": "coproc::receiveMessage#withdoc",
  "description": "This function receives a message from a given coproc...",
  "scope": "",
  "body": [ "# ## coproc::receiveMessage\n# \n# This function receives a message from a given coproc.\n# It expects the message to end with a \\$'\\0' character.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a message was received successfully.\n#   - 1 if the coproc is not running or no message could be received.\n# - \\${REPLY}: The received message.\n# \n# ```bash\n# if coproc::receiveMessage \"myCoproc\"; then\n#   echo \"Received message: \\${REPLY}\"\n# fi\n# ```\n# \ncoproc::receiveMessage \"${1:coproc variable name}\"$0" ]
},

"coproc::receiveMessageWithTimeOut": {
  "prefix": "coproc::receiveMessageWithTimeOut",
  "description": "This function receives a message from a given coproc...",
  "scope": "",
  "body": [ "coproc::receiveMessageWithTimeOut \"${1:coproc variable name}\" \"${2:time out}\"$0" ]
},

"coproc::receiveMessageWithTimeOut#withdoc": {
  "prefix": "coproc::receiveMessageWithTimeOut#withdoc",
  "description": "This function receives a message from a given coproc...",
  "scope": "",
  "body": [ "# ## coproc::receiveMessageWithTimeOut\n# \n# This function receives a message from a given coproc.\n# It expects the message to be placed after a \\$'\\0' string and end with a \\$'\\0' character.\n# This is because the read timeout can prevent to read the whole message if it is sent too slowly.\n# So we read until we get the \\$'\\0', then we read the message until the \\$'\\0' character.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# - \\$2: **time out** _as int_:\n#       The time out in seconds to wait for a message.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a message was received successfully.\n#   - 1 if the coproc is not running or no message could be received.\n# - \\${REPLY}: The received message.\n# \n# ```bash\n# if coproc::receiveMessageWithTimeOut \"myCoproc\" 0.05; then\n#   echo \"Received message: \\${REPLY}\"\n# fi\n# ```\n# \ncoproc::receiveMessageWithTimeOut \"${1:coproc variable name}\" \"${2:time out}\"$0" ]
},

"coproc::run": {
  "prefix": "coproc::run",
  "description": "This function runs commands in a coproc:  - Run a main command (mainCommand) that is run once at the start of the coproc...",
  "scope": "",
  "body": [ "coproc::run \"${1:coproc variable name}\" mainCommand=${2:\":\"} loopCommand=${3:\":\"} onMessageCommand=${4:\"\"} endCommand=${5:\":\"} waitForMainEnd=${6:false} keepOnlyLastMessage=${7:false} redirectLogsToFile=${8:\"\"}$0" ]
},

"coproc::run#withdoc": {
  "prefix": "coproc::run#withdoc",
  "description": "This function runs commands in a coproc:  - Run a main command (mainCommand) that is run once at the start of the coproc...",
  "scope": "",
  "body": [ "# ## coproc::run\n# \n# This function runs commands in a coproc:\n# \n# - Run a main command (mainCommand) that is run once at the start of the coproc.\n# - Loop until the main thread or the coproc exits. Inside the loop, the coproc can receive messages\n#   from the main thread, and more commands are run:\n#   - A loop command (loopCommand) is run at the beginning of each iteration of the loop.\n#   - An on message command (onMessageCommand) is run when a message is received from the main thread.\n# - Finally, it runs an end command (endCommand) once at the end of the coproc.\n# \n# Each command is optional and will do nothing by default.\n# It returns the PID of the coproc.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n#       It will be used to store the coproc file descriptors and PID.\n#       <coproc_variable_name>[0] will be the input pipe file descriptor,\n#       <coproc_variable_name>[1] will be the output pipe file descriptor,\n#       <coproc_variable_name>_PID will be the PID of the coproc.\n# - \\${mainCommand} _as string_:\n#       (optional) The main command (will be evaluated) to run in the coproc.\n#       Can exit to stop the coproc.\n#       Set to \":\" to do nothing.\n#       (defaults to \":\")\n# - \\${loopCommand} _as string_:\n#       (optional) The command (will be evaluated) to run in the coproc loop.\n#       Can exit to stop the coproc, can break or continue the loop.\n#       Set to \":\" to do nothing.\n#       (defaults to \":\")\n# - \\${onMessageCommand} _as string_:\n#       (optional) The command (will be evaluated) to run in the coproc loop when a message\n#       is received from the main thread.\n#       The command can expect to use the variable REPLY which contains\n#       the message (string) received from the main thread.\n#       The command can send messages to the main thread using the syntax\n#       printf \"%s\\0\" \"message\"\n#       Can exit to stop the coproc, can break or continue the loop.\n#       Set to an empty string to not run any command on message.\n#       (defaults to \"\")\n# - \\${endCommand} _as string_:\n#       (optional) The command (will be evaluated) to run at the end of the coproc.\n#       Set to \":\" to do nothing.\n#       (defaults to \":\")\n# - \\${waitForMainEnd} _as bool_:\n#       (optional) If true, the main thread will wait for the main command to finish\n#       before returning from this function.\n#       (defaults to false)\n# - \\${keepOnlyLastMessage} _as bool_:\n#       (optional) If true, the coproc will only keep the last message received\n#       from the main thread to evaluate the on message command.\n#       (defaults to false)\n# - \\${redirectLogsToFile} _as string_:\n#       (optional) The path to a file where the logs of the coproc will be redirected.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY}: The PID of the coproc.\n# \n# ```bash\n# waitForMainEnd=true coproc::run \"_MY_COPROC\" mainCommand loopCommand onMessageCommand\n# ```\n# \ncoproc::run \"${1:coproc variable name}\" mainCommand=${2:\":\"} loopCommand=${3:\":\"} onMessageCommand=${4:\"\"} endCommand=${5:\":\"} waitForMainEnd=${6:false} keepOnlyLastMessage=${7:false} redirectLogsToFile=${8:\"\"}$0" ]
},

"coproc::runInParallel": {
  "prefix": "coproc::runInParallel",
  "description": "This function runs a list of commands in parallel with a maximum number of parallel coprocs...",
  "scope": "",
  "body": [ "coproc::runInParallel \"${1:job commands array name}\" maxInParallel=${2:8} completedCallback=${3:\"\"} redirectLogs=${4:false} printRedirectedLogs=${5:false} simulateSequentialRun=${6:false} coprocNamePrefix=${7:\"_COPROC_PARALLEL_\"}$0" ]
},

"coproc::runInParallel#withdoc": {
  "prefix": "coproc::runInParallel#withdoc",
  "description": "This function runs a list of commands in parallel with a maximum number of parallel coprocs...",
  "scope": "",
  "body": [ "# ## coproc::runInParallel\n# \n# This function runs a list of commands in parallel with a maximum number of parallel coprocs.\n# \n# - \\$1: **job commands array name** _as string_:\n#       The name of the array containing the commands to run.\n#       Each command string will be evaluated in a subshell.\n#       Each command should explicitly exit with a non-zero code if it fails and with zero if it succeeds.\n# - \\${maxInParallel} _as int_:\n#       (optional) The maximum number of parallel coprocs to run.\n#       (defaults to 8)\n# - \\${completedCallback} _as string_:\n#       (optional) The name of the function to call when a coproc is completed (successfully or not).\n#       The function will receive the following arguments:\n#       - \\$1 the coproc index\n#       - \\$2 the coproc exit code\n#       - \\$3 the percentage of coprocs already completed\n#       - \\$4 the path of the file containing the accumulated logs of the coproc\n#       If the function sets REPLY to 1, the script will exit early. Otherwise it should set REPLY to 0.\n#       Set to an empty string to not call any callback function.\n#       (defaults to \"\")\n# - \\${redirectLogs} _as bool_:\n#       (optional) Redirect the logs of the coproc instead of printing them in the current file descriptor.\n#       The accumulated logs of the coproc will be available in the completed callback function.\n#       (defaults to false)\n# - \\${printRedirectedLogs} _as bool_:\n#       (optional) This option allows to automatically redirect the logs of the coproc to a file and\n#       print the accumulated logs of a coproc when it is completed (successfully or not).\n#       (defaults to false)\n# - \\${simulateSequentialRun} _as bool_:\n#       (optional) If true, this will:\n#       - redirect the logs of each task to a file\n#       - at the end of all execution, print the logs of each task, in natural order (not as they finish)\n#       - exit at the first error, showing the logs of the task in error\n#       Tasks will run as if they are called in a for loop; except they actually run in parallel.\n#       (defaults to false)\n# - \\${coprocNamePrefix} _as string_:\n#       (optional) The prefix to use for the coproc variable names.\n#       This is useful to avoid conflicts with other coproc variables.\n#       (defaults to \"_COPROC_PARALLEL_\")\n# \n# Returns:\n# \n# - \\${REPLY}: The number of jobs that did not completed (i.e. not executed until the end, successfully or not)\n# - \\${REPLY2}: The number of successfully completed jobs.\n# - \\${REPLY_ARRAY[@]}: an array containing the exit codes of the jobs.\n# \n# ```bash\n# declare -a jobCommands=(\"sleep 1\" \"sleep 2\" \"sleep 3\")\n# coproc::runInParallel jobCommands maxParallelCoprocs=2\n# ```\n# TODO: implement unit tests for this function\n# \ncoproc::runInParallel \"${1:job commands array name}\" maxInParallel=${2:8} completedCallback=${3:\"\"} redirectLogs=${4:false} printRedirectedLogs=${5:false} simulateSequentialRun=${6:false} coprocNamePrefix=${7:\"_COPROC_PARALLEL_\"}$0" ]
},

"coproc::sendMessage": {
  "prefix": "coproc::sendMessage",
  "description": "This function sends a message to a given coproc...",
  "scope": "",
  "body": [ "coproc::sendMessage \"${1:coproc variable name}\" \"${2:message}\"$0" ]
},

"coproc::sendMessage#withdoc": {
  "prefix": "coproc::sendMessage#withdoc",
  "description": "This function sends a message to a given coproc...",
  "scope": "",
  "body": [ "# ## coproc::sendMessage\n# \n# This function sends a message to a given coproc.\n# The message will be sent with a \\$'\\0' character at the end.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# - \\$2: **message** _as string_:\n#       The message to send to the coproc.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the message was sent successfully.\n#   - 1 if the coproc is not running or the message could not be sent.\n# \n# ```bash\n# coproc::sendMessage \"myCoproc\" \"Hello, coproc!\"\n# ```\n# \n# > This printf call can cause the whole shell to exit with code 141 if there is an issue with the coproc.\n# > You will want to run this in a subshell to avoid exiting the main shell if your coproc is unstable.\n# \ncoproc::sendMessage \"${1:coproc variable name}\" \"${2:message}\"$0" ]
},

"coproc::wait": {
  "prefix": "coproc::wait",
  "description": "This function waits for a coproc to finish...",
  "scope": "",
  "body": [ "coproc::wait \"${1:coproc variable name}\"$0" ]
},

"coproc::wait#withdoc": {
  "prefix": "coproc::wait#withdoc",
  "description": "This function waits for a coproc to finish...",
  "scope": "",
  "body": [ "# ## coproc::wait\n# \n# This function waits for a coproc to finish.\n# \n# - \\$1: **coproc variable name** _as string_:\n#       The variable name to use for the coproc.\n# \n# Returns:\n# - \\${REPLY_CODE}: The exit status of the coproc (or -1 if the coproc is not running).\n# \n# ```bash\n# coproc::wait \"myCoproc\"\n# ```\n# \ncoproc::wait \"${1:coproc variable name}\"$0" ]
},

"core::createSavedFilePath": {
  "prefix": "core::createSavedFilePath",
  "description": "Returns the path to a new file stored in the user state directory under `saved-files`...",
  "scope": "",
  "body": [ "core::createSavedFilePath suffix=${1:\"\"}$0" ]
},

"core::createSavedFilePath#withdoc": {
  "prefix": "core::createSavedFilePath#withdoc",
  "description": "Returns the path to a new file stored in the user state directory under `saved-files`...",
  "scope": "",
  "body": [ "# ## core::createSavedFilePath\n# \n# Returns the path to a new file stored in the user state directory under `saved-files`.\n# Can be used to save the state of important temporary files generated during a program\n# execution.\n# \n# - \\${suffix} _as string_:\n#       (optional) The suffix for the file to create.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY}: The path to the created file.\n# \n# ```bash\n# core::createSavedFilePath\n# core::createSavedFilePath suffix=\"my-file\"\n# printf '%s\\n' \"The file is ⌜\\${REPLY}⌝.\"\n# ```\n# \ncore::createSavedFilePath suffix=${1:\"\"}$0" ]
},

"core::dump": {
  "prefix": "core::dump",
  "description": "Dumps information about the current bash session into a new file...",
  "scope": "",
  "body": [ "core::dump dumpSuffix=${1:\"\"}$0" ]
},

"core::dump#withdoc": {
  "prefix": "core::dump#withdoc",
  "description": "Dumps information about the current bash session into a new file...",
  "scope": "",
  "body": [ "# ## core::dump\n# \n# Dumps information about the current bash session into a new file.\n# \n# - \\${dumpSuffix} _as string_:\n#       (optional) The suffix for the file to create.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the created file.\n# \n# ```bash\n# core::dump\n# ```\n# \ncore::dump dumpSuffix=${1:\"\"}$0" ]
},

"core::exit": {
  "prefix": "core::exit",
  "description": "Exits the program with the given exit code...",
  "scope": "",
  "body": [ "core::exit \"${1:exit code}\" silent=${2:false}$0" ]
},

"core::exit#withdoc": {
  "prefix": "core::exit#withdoc",
  "description": "Exits the program with the given exit code...",
  "scope": "",
  "body": [ "# ## core::exit\n# \n# Exits the program with the given exit code.\n# \n# We replace the builtin exit command to make sure that we can correctly capture where\n# the exit was called and print the call stack.\n# \n# - \\$1: exit code _as int_:\n#       (optional) the exit code to use, should be between 0 and 255\n#       (defaults to 0)\n# - \\${silent} _as bool_:\n#       (optional) If true, will not print the exit message and call stack for non zero exit codes.\n#       (defaults to false)\n# \n# ```bash\n# core::exit 0\n# core::exit 0 silent=true\n# ```\n# \ncore::exit \"${1:exit code}\" silent=${2:false}$0" ]
},

"core::fail": {
  "prefix": "core::fail",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "core::fail \"${1:message}\" exitCode=${2:1}$0" ]
},

"core::fail#withdoc": {
  "prefix": "core::fail#withdoc",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "# ## core::fail\n# \n# Displays an error message and then exit the program with error.\n# \n# - \\$1: **message** _as string_:\n#       The error message to display\n# - \\${exitCode} _as int_:\n#       (optional) the exit code to use, should be between 1 and 255\n#       (defaults to 1)\n# \n# ```bash\n# core::fail \"This is an error message.\"\n# core::fail \"This is an error message.\" exitCode=255\n# ```\n# \ncore::fail \"${1:message}\" exitCode=${2:1}$0" ]
},

"core::getConfigurationDirectory": {
  "prefix": "core::getConfigurationDirectory",
  "description": "Returns the path to the valet configuration directory...",
  "scope": "",
  "body": [ "core::getConfigurationDirectory$0" ]
},

"core::getConfigurationDirectory#withdoc": {
  "prefix": "core::getConfigurationDirectory#withdoc",
  "description": "Returns the path to the valet configuration directory...",
  "scope": "",
  "body": [ "# ## core::getConfigurationDirectory\n# \n# Returns the path to the valet configuration directory.\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the valet configuration directory\n# \n# ```bash\n# core::getConfigurationDirectory\n# local directory=\"\\${REPLY}\"\n# ```\n# \n# > The default configuration directory is `~/.config/valet`.\n# \ncore::getConfigurationDirectory$0" ]
},

"core::getExtensionsDirectory": {
  "prefix": "core::getExtensionsDirectory",
  "description": "Returns the path to the user extensions directory...",
  "scope": "",
  "body": [ "core::getExtensionsDirectory$0" ]
},

"core::getExtensionsDirectory#withdoc": {
  "prefix": "core::getExtensionsDirectory#withdoc",
  "description": "Returns the path to the user extensions directory...",
  "scope": "",
  "body": [ "# ## core::getExtensionsDirectory\n# \n# Returns the path to the user extensions directory.\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the valet user directory\n# \n# ```bash\n# core::getExtensionsDirectory\n# local directory=\"\\${REPLY}\"\n# ```\n# \n# > The default extensions directory is `~/.valet.d`.\n# \ncore::getExtensionsDirectory$0" ]
},

"core::getUserCacheDirectory": {
  "prefix": "core::getUserCacheDirectory",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "core::getUserCacheDirectory$0" ]
},

"core::getUserCacheDirectory#withdoc": {
  "prefix": "core::getUserCacheDirectory#withdoc",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "# ## core::getUserCacheDirectory\n# \n# Returns the path to the valet local cache directory.\n# Where user-specific non-essential (cached) data should be written (analogous to /var/cache).\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserCacheDirectory\n# local directory=\"\\${REPLY}\"\n# ```\n# \n# > The default cache directory is `~/.cache/valet`.\n# \ncore::getUserCacheDirectory$0" ]
},

"core::getUserDataDirectory": {
  "prefix": "core::getUserDataDirectory",
  "description": "Returns the path to the valet local data directory...",
  "scope": "",
  "body": [ "core::getUserDataDirectory$0" ]
},

"core::getUserDataDirectory#withdoc": {
  "prefix": "core::getUserDataDirectory#withdoc",
  "description": "Returns the path to the valet local data directory...",
  "scope": "",
  "body": [ "# ## core::getUserDataDirectory\n# \n# Returns the path to the valet local data directory.\n# Where user-specific data files should be written (analogous to /usr/share).\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserDataDirectory\n# local directory=\"\\${REPLY}\"\n# ```\n# \n# > The default data directory is `~/.local/share/valet`.\n# \ncore::getUserDataDirectory$0" ]
},

"core::getUserStateDirectory": {
  "prefix": "core::getUserStateDirectory",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "core::getUserStateDirectory$0" ]
},

"core::getUserStateDirectory#withdoc": {
  "prefix": "core::getUserStateDirectory#withdoc",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "# ## core::getUserStateDirectory\n# \n# Returns the path to the valet local cache directory.\n# Where user-specific state files should be written (analogous to /var/lib).\n# Ideal location for storing runtime information, logs, etc...\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${REPLY}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserStateDirectory\n# local directory=\"\\${REPLY}\"\n# ```\n# \n# > The default state directory is `~/.local/state/valet`.\n# \ncore::getUserStateDirectory$0" ]
},

"core::getVersion": {
  "prefix": "core::getVersion",
  "description": "Returns the version of Valet...",
  "scope": "",
  "body": [ "core::getVersion$0" ]
},

"core::getVersion#withdoc": {
  "prefix": "core::getVersion#withdoc",
  "description": "Returns the version of Valet...",
  "scope": "",
  "body": [ "# ## core::getVersion\n# \n# Returns the version of Valet.\n# \n# Returns:\n# \n# - \\${REPLY}: The version of Valet.\n# \n# ```bash\n# core::getVersion\n# printf '%s\\n' \"The version of Valet is ⌜\\${REPLY}⌝.\"\n# ```\n# \ncore::getVersion$0" ]
},

"core::initSubshell": {
  "prefix": "core::initSubshell",
  "description": "Do the necessary initialization for a new subshell, ensuring coherent behavior:  - Set the correct traps...",
  "scope": "",
  "body": [ "core::initSubshell$0" ]
},

"core::initSubshell#withdoc": {
  "prefix": "core::initSubshell#withdoc",
  "description": "Do the necessary initialization for a new subshell, ensuring coherent behavior:  - Set the correct traps...",
  "scope": "",
  "body": [ "# ## core::initSubshell\n# \n# Do the necessary initialization for a new subshell, ensuring coherent behavior:\n# \n# - Set the correct traps.\n# - Initialize specific temporary files/directories location.\n# - Reset the elapsed time to 0.\n# - Reset the background processes.\n# \n# ```bash\n# core::initSubshell\n# ```\n# \ncore::initSubshell$0" ]
},

"core::parseFunctionOptions": {
  "prefix": "core::parseFunctionOptions",
  "description": "Parses the shell parameters passed as arguments and sets the REPLY variable to a string that can be evaluated to set the local variables required in the calling function...",
  "scope": "",
  "body": [ "core::parseFunctionOptions \"${1:arguments}\"$0" ]
},

"core::parseFunctionOptions#withdoc": {
  "prefix": "core::parseFunctionOptions#withdoc",
  "description": "Parses the shell parameters passed as arguments and sets the REPLY variable to a string that can be evaluated to set the local variables required in the calling function...",
  "scope": "",
  "body": [ "# ## core::parseFunctionOptions\n# \n# Parses the shell parameters passed as arguments and sets the REPLY variable to a string that can be\n# evaluated to set the local variables required in the calling function.\n# \n# This should be called when you need to parse the arguments of a function that has a finite number of arguments\n# (i.e. that uses \\$@ or \\$*) in which case we expect the shell parameters to be passed after a separator `---`.\n# \n# - \\$@: arguments _as any_:\n#       The arguments to parse.\n# \n# Returns:\n# \n# - \\${REPLY}: The string to evaluate to set the local variables.\n# \n# ```bash\n# core::parseFunctionOptions 1 2 3 --- myOption=one\n# eval \"\\${REPLY}\"\n# # REPLY will be: local myOption=\"one\"; set -- \"\\${@:1:3}\"\n# ```\n# \ncore::parseFunctionOptions \"${1:arguments}\"$0" ]
},

"curl::download": {
  "prefix": "curl::download",
  "description": "This function is a wrapper around curl to save a request result in a file...",
  "scope": "",
  "body": [ "curl::download \"${1:url}\" \"${2:curl arguments}\" --- output=${3:\"\"} failOnError=${4:false} acceptableCodes=${5:200,201,202,204,301,304,308}$0" ]
},

"curl::download#withdoc": {
  "prefix": "curl::download#withdoc",
  "description": "This function is a wrapper around curl to save a request result in a file...",
  "scope": "",
  "body": [ "# ## curl::download\n# \n# This function is a wrapper around curl to save a request result in a file.\n# It allows you to check the http status code and return 1 if it is not acceptable.\n# It invokes curl with the following options (do not repeat them): -sSL -w \"%{response_code}\" -o \\${2}.\n# \n# - \\$1: **url** _as string_:\n#       The url to download\n# - \\$@: **curl arguments** _as any_:\n#       options for curl\n# - \\${output} _as string_:\n#       (optional) the file in which to save the output of curl.\n#       Set to an empty string to create a temporary file instead.\n#       (defaults to \"\")\n# - \\${failOnError} _as bool_:\n#       (optional) true/false to indicate if the function should fail in case the execution fails\n#       (defaults to false)\n# - \\${acceptableCodes} _as string_:\n#       (optional) list of http status codes that are acceptable, comma separated\n#       (defaults to 200,201,202,204,301,304,308)\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the http status code is acceptable\n#   - 1 otherwise\n# - \\${REPLY}: the path to the file where the content was saved\n# - \\${REPLY2}: the content of curl stderr\n# - \\${REPLY3}: the http status code\n# \n# ```bash\n# curl::download https://example.com --- output=/filePath\n# curl::download https://example2.com -H \"header: value\" --- failOnError=true acceptableCodes=200,201 output=/filePath\n# echo \"The curl command ended with exit code ⌜\\${REPLY_CODE}⌝, the http return code was ⌜\\${REPLY2}⌝: \\${REPLY}\"\n# ```\n# \ncurl::download \"${1:url}\" \"${2:curl arguments}\" --- output=${3:\"\"} failOnError=${4:false} acceptableCodes=${5:200,201,202,204,301,304,308}$0" ]
},

"curl::request": {
  "prefix": "curl::request",
  "description": "This function is a wrapper around curl to save the content of a request in a variable...",
  "scope": "",
  "body": [ "curl::request \"${1:url}\" \"${2:curl arguments}\" --- failOnError=${3:false} acceptableCodes=${4:200,201,202,204,301,304,308}$0" ]
},

"curl::request#withdoc": {
  "prefix": "curl::request#withdoc",
  "description": "This function is a wrapper around curl to save the content of a request in a variable...",
  "scope": "",
  "body": [ "# ## curl::request\n# \n# This function is a wrapper around curl to save the content of a request in a variable.\n# It allows you to check the http status code and return 1 if it is not acceptable.\n# It invokes curl with the following options (do not repeat them): -sSL -w \"%{response_code}\" -o \"tempfile\".\n# \n# - \\$1: **url** _as string_:\n#       The url to request\n# - \\$@: **curl arguments** _as any_:\n#       options for curl\n# - \\${failOnError} _as bool_:\n#       (optional) true/false to indicate if the function should fail in case the execution fails\n#       (defaults to false)\n# - \\${acceptableCodes} _as string_:\n#       (optional) list of http status codes that are acceptable, comma separated\n#       (defaults to 200,201,202,204,301,304,308)\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the http status code is acceptable\n#   - 1 otherwise\n# - \\${REPLY}: the content of the request\n# - \\${REPLY2}: the content of curl stderr\n# - \\${REPLY3}: the http status code\n# \n# ```bash\n# curl::request https://example.com\n# curl::request https://example.com -X POST -H 'Authorization: token' --- failOnError=true\n# echo \"The curl command ended with exit code ⌜\\${REPLY_CODE}⌝, the http return code was ⌜\\${REPLY2}⌝: \\${REPLY}\"\n# ```\n# \ncurl::request \"${1:url}\" \"${2:curl arguments}\" --- failOnError=${3:false} acceptableCodes=${4:200,201,202,204,301,304,308}$0" ]
},

"esc-codes::*": {
  "prefix": "esc-codes::*",
  "description": "ANSI codes for text attributes, colors, cursor control, and other common escape sequences...",
  "scope": "",
  "body": [ "esc-codes::*$0" ]
},

"esc-codes::*#withdoc": {
  "prefix": "esc-codes::*#withdoc",
  "description": "ANSI codes for text attributes, colors, cursor control, and other common escape sequences...",
  "scope": "",
  "body": [ "# ## esc-codes::*\n# \n# ANSI codes for text attributes, colors, cursor control, and other common escape sequences.\n# These codes can be used to format text in the terminal.\n# \n# These codes were selected because they are widely supported by terminals and they\n# probably will cover all use cases. It is also advised to stick to the 4-bit colors\n# which allows your application to adopt the color scheme of the terminal.\n# \n# They are defined as variables and not as functions. Please check the content of the esc-codes to learn more:\n# <https://github.com/jcaillon/valet/blob/latest/libraries.d/esc-codes>\n# \n# References:\n# \n# - https://jvns.ca/blog/2025/03/07/escape-code-standards/\n# - https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n# - https://en.wikipedia.org/wiki/ANSI_escape_code\n# - https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797\n# - https://paulbourke.net/dataformats/ascii/\n# - https://www.aivosto.com/articles/control-characters.html\n# - https://github.com/tmux/tmux/blob/master/tools/ansicode.txt\n# - https://vt100.net/docs/vt102-ug/chapter5.html\n# - https://vt100.net/docs/vt100-ug/chapter3.html#S3.3\n# - https://github.com/tmux/tmux/blob/882fb4d295deb3e4b803eb444915763305114e4f/tools/ansicode.txt\n# \n# Ascii graphics:\n# \n# - https://gist.github.com/dsample/79a97f38bf956f37a0f99ace9df367b9\n# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Box_Drawing\n# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Block_Elements\n# \n# An interesting read: https://sw.kovidgoyal.net/kitty/keyboard-protocol/\n# \n# > While it could be very handy to define a function for each of these instructions,\n# > it would also be slower to execute (function overhead + multiple printf calls).\n# \nesc-codes::*$0" ]
},

"exe::invoke": {
  "prefix": "exe::invoke",
  "description": "This function call an executable with its optional arguments...",
  "scope": "",
  "body": [ "exe::invoke \"${1:executable}\" \"${2:arguments}\" --- noFail=${3:false} replyPathOnly=${4:false} stdoutPath=${5:\"\"} stderrPath=${6:\"\"} stdinFile=${7:\"\"} stdin=${8:\"\"} acceptableCodes=${9:\"0\"} failMessage=${10:\"\"} warnOnFailure=${11:false} appendRedirect=${12:false} groupRedirect=${13:false} noRedirection=${14:false}$0" ]
},

"exe::invoke#withdoc": {
  "prefix": "exe::invoke#withdoc",
  "description": "This function call an executable with its optional arguments...",
  "scope": "",
  "body": [ "# ## exe::invoke\n# \n# This function call an executable with its optional arguments.\n# \n# By default it redirects the stdout and stderr and captures them to output variables.\n# This makes the executes silent unless the executable fails.\n# By default, it will exit (core::fail) if the executable returns a non-zero exit code.\n# \n# This function should be used as a wrapper around any external program as it allows to easily\n# mock the program during tests and facilitates debugging with trace level log.\n# \n# - \\$1: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# - \\${noFail} _as bool_:\n#       (optional) A boolean to indicate if the function should call core::fail (exit) in case the execution fails.\n#       If true and the execution fails, the script will exit.\n#       (defaults to false)\n# - \\${replyPathOnly} _as bool_:\n#       (optional) If set to true, the function will return the file path of the stdout and stderr files\n#       instead of their content. This will make the function faster.\n#       (defaults to false)\n# - \\${stdoutPath} _as string_:\n#       (optional) The file path to use for the stdout of the executable. Otherwise a temporary work file will be used.\n#       (defaults to \"\")\n# - \\${stderrPath} _as string_:\n#       (optional) The file path to use for the stderr of the executable. Otherwise a temporary work file will be used.\n#       (defaults to \"\")\n# - \\${stdinFile} _as bool_:\n#       (optional) The file path to use as stdin for the executable.\n#       (defaults to \"\")\n# - \\${stdin} _as string_:\n#       (optional) The stdin content to pass to the executable.\n#       Can be empty if not used.\n#       (defaults to \"\")\n# - \\${acceptableCodes} _as string_:\n#       (optional) The acceptable error codes, comma separated.\n#       If the error code is matched, then REPLY_CODE is set to 0)\n#       (defaults to \"0\")\n# - \\${failMessage} _as string_:\n#       (optional) The message to display on failure.\n#       (defaults to \"\")\n# - \\${warnOnFailure} _as bool_:\n#       (optional) If true, a warning message (uses failMessage) will be displayed on failure but\n#       it will not cause the function to exit.\n#       Contrary to noFail, it will display a warning message (noFail is silent).\n#       (defaults to false)\n# - \\${appendRedirect} _as bool_:\n#       (optional) If true will append the output to the stdout/stderr files instead of overwriting them (>> redirect).\n#       This is useful when you want to run the same command multiple times and keep the previous output.\n#       The stderr and stdout REPLY variables will both have the same content.\n#       (defaults to false)\n# - \\${groupRedirect} _as bool_:\n#       (optional) If true will output stdout/stderr to the same file (&> redirect).\n#       (defaults to false)\n# - \\${noRedirection} _as bool_:\n#       (optional) If set to true, the function will not redirect the stdout and stderr to temporary files.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY_CODE}: The exit code of the executable.\n# - \\${REPLY}: The content of stdout (or file path to stdout if `replyPathOnly=true`).\n# - \\${REPLY2}: The content of stderr (or file path to stdout if `replyPathOnly=true`).\n# \n# ```bash\n# # basic usage with some arguments:\n# exe::invoke git branch --list --sort=-committerdate\n# echo \"\\${REPLY}\"\n# \n# # invoke a command that is allowed to return an error code:\n# exe::invoke risky-command --- noFail=true\n# echo \"\\${REPLY_CODE}\"\n# \n# # invoke a command with custom stdout / stderr files and do not read the output into REPLY vars:\n# exe::invoke thing --- stdoutPath=/path/to/stdout stderrPath=/path/to/stderr replyPathOnly=true\n# \n# # invoke a command and let the outputs go to the console:\n# exe::invoke cat file --- noRedirection=true\n# \n# # invoke a command with stdin from a string:\n# exe::invoke cat --- stdin=\"Hello World\"\n# ```\n# \n# > - In windows, this is tremendously faster to do:\n# >   `exe::invoke mycommand; myvar=\"\\${REPLY}\"`\n# >   than doing:\n# >   `myvar=\"\\$(mycommand)\".`\n# > - On linux, it is slightly faster (but it might be slower if you don't have SSD?).\n# > - On linux, you can use a tmpfs directory for massive gains over subshells.\n# \nexe::invoke \"${1:executable}\" \"${2:arguments}\" --- noFail=${3:false} replyPathOnly=${4:false} stdoutPath=${5:\"\"} stderrPath=${6:\"\"} stdinFile=${7:\"\"} stdin=${8:\"\"} acceptableCodes=${9:\"0\"} failMessage=${10:\"\"} warnOnFailure=${11:false} appendRedirect=${12:false} groupRedirect=${13:false} noRedirection=${14:false}$0" ]
},

"fs::cat": {
  "prefix": "fs::cat",
  "description": "Print the content of a file to stdout...",
  "scope": "",
  "body": [ "fs::cat \"${1:path}\"$0" ]
},

"fs::cat#withdoc": {
  "prefix": "fs::cat#withdoc",
  "description": "Print the content of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::cat\n# \n# Print the content of a file to stdout.\n# This is a pure bash equivalent of cat.\n# \n# - \\$1: **path** _as string_:\n#       the file to print\n# \n# ```bash\n# fs::cat myFile\n# ```\n# \n# > Also see log::printFile if you want to print a file for a user.\n# \nfs::cat \"${1:path}\"$0" ]
},

"fs::cleanTempFiles": {
  "prefix": "fs::cleanTempFiles",
  "description": "Removes all the temporary files and directories that were created by the `fs::createTempFile` and `fs::createTempDirectory` functions...",
  "scope": "",
  "body": [ "fs::cleanTempFiles$0" ]
},

"fs::cleanTempFiles#withdoc": {
  "prefix": "fs::cleanTempFiles#withdoc",
  "description": "Removes all the temporary files and directories that were created by the `fs::createTempFile` and `fs::createTempDirectory` functions...",
  "scope": "",
  "body": [ "# ## fs::cleanTempFiles\n# \n# Removes all the temporary files and directories that were created by the\n# `fs::createTempFile` and `fs::createTempDirectory` functions.\n# \n# ```bash\n# fs::cleanTempFiles\n# ```\n# \nfs::cleanTempFiles$0" ]
},

"fs::createDirectoryIfNeeded": {
  "prefix": "fs::createDirectoryIfNeeded",
  "description": "Create the directory tree if needed...",
  "scope": "",
  "body": [ "fs::createDirectoryIfNeeded \"${1:path}\"$0" ]
},

"fs::createDirectoryIfNeeded#withdoc": {
  "prefix": "fs::createDirectoryIfNeeded#withdoc",
  "description": "Create the directory tree if needed...",
  "scope": "",
  "body": [ "# ## fs::createDirectoryIfNeeded\n# \n# Create the directory tree if needed.\n# \n# - \\$1: **path** _as string_:\n#       The directory path to create.\n# \n# Returns:\n# \n# - \\${REPLY}: The absolute path to the directory.\n# \n# ```bash\n# fs::createDirectoryIfNeeded \"/my/directory\"\n# echo \"\\${REPLY}\"\n# ```\n# \nfs::createDirectoryIfNeeded \"${1:path}\"$0" ]
},

"fs::createFileIfNeeded": {
  "prefix": "fs::createFileIfNeeded",
  "description": "Make sure that the given file exists...",
  "scope": "",
  "body": [ "fs::createFileIfNeeded \"${1:path}\"$0" ]
},

"fs::createFileIfNeeded#withdoc": {
  "prefix": "fs::createFileIfNeeded#withdoc",
  "description": "Make sure that the given file exists...",
  "scope": "",
  "body": [ "# ## fs::createFileIfNeeded\n# \n# Make sure that the given file exists.\n# Create the directory tree and the file if needed.\n# \n# - \\$1: **path** _as string_:\n#       the file path to create\n# \n# Returns:\n# \n# - \\${REPLY}: The absolute path of the file.\n# \n# ```bash\n# fs::createFileIfNeeded \"myFile\"\n# echo \"\\${REPLY}\"\n# ```\n# \nfs::createFileIfNeeded \"${1:path}\"$0" ]
},

"fs::createLink": {
  "prefix": "fs::createLink",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "fs::createLink \"${1:linked path}\" \"${2:link path}\" hardlink=${3:false} force=${4:false}$0" ]
},

"fs::createLink#withdoc": {
  "prefix": "fs::createLink#withdoc",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "# ## fs::createLink\n# \n# Create a soft or hard link (original ← link).\n# \n# Reminder:\n# \n# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the\n#   form of an absolute or relative path.\n# - A hard link is a directory entry that associates a new pathname with an existing\n#   file (inode + data block) on a file system.\n# \n# See `windows::createLink` for Windows.\n# \n# - \\$1: **linked path** _as string_:\n#       the path to link to (the original file)\n# - \\$2: **link path** _as string_:\n#       the path where to create the link\n# - \\${hardlink} _as boolean_:\n#       (optional) True to create a hard link, false to create a symbolic link\n#       (defaults to false)\n# - \\${force} _as boolean_:\n#       (optional) True to overwrite the link or file if it already exists.\n#       Otherwise, the function will fail on an existing link.\n#       (defaults to false)\n# \n# ```bash\n# fs::createLink \"/path/to/link\" \"/path/to/linked\"\n# fs::createLink \"/path/to/link\" \"/path/to/linked\" hardlink=true force=true\n# ```\n# \n# > The function uses the `ln` command.\n# \nfs::createLink \"${1:linked path}\" \"${2:link path}\" hardlink=${3:false} force=${4:false}$0" ]
},

"fs::createTempDirectory": {
  "prefix": "fs::createTempDirectory",
  "description": "Creates a temporary directory...",
  "scope": "",
  "body": [ "fs::createTempDirectory pathOnly=${1:false}$0" ]
},

"fs::createTempDirectory#withdoc": {
  "prefix": "fs::createTempDirectory#withdoc",
  "description": "Creates a temporary directory...",
  "scope": "",
  "body": [ "# ## fs::createTempDirectory\n# \n# Creates a temporary directory.\n# \n# - \\${pathOnly} _as bool_:\n#       (optional) If true, does not create the file, only returns the path.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: The created path.\n# \n# ```bash\n# fs::createTempDirectory\n# echo \"\\${REPLY}\"\n# fs::createTempDirectory pathOnly=true\n# ```\n# \n# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nfs::createTempDirectory pathOnly=${1:false}$0" ]
},

"fs::createTempFile": {
  "prefix": "fs::createTempFile",
  "description": "Creates a temporary file and return its path...",
  "scope": "",
  "body": [ "fs::createTempFile pathOnly=${1:false}$0" ]
},

"fs::createTempFile#withdoc": {
  "prefix": "fs::createTempFile#withdoc",
  "description": "Creates a temporary file and return its path...",
  "scope": "",
  "body": [ "# ## fs::createTempFile\n# \n# Creates a temporary file and return its path.\n# \n# - \\${pathOnly} _as bool_:\n#       (optional) If true, does not create the file, only returns the path.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: The created path.\n# \n# ```bash\n# fs::createTempFile\n# echo \"\\${REPLY}\"\n# fs::createTempFile pathOnly=true\n# ```\n# \n# > Files created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nfs::createTempFile pathOnly=${1:false}$0" ]
},

"fs::getAbsolutePath": {
  "prefix": "fs::getAbsolutePath",
  "description": "This function returns the absolute path of a path...",
  "scope": "",
  "body": [ "fs::getAbsolutePath \"${1:path}\" realpath=${2:false}$0" ]
},

"fs::getAbsolutePath#withdoc": {
  "prefix": "fs::getAbsolutePath#withdoc",
  "description": "This function returns the absolute path of a path...",
  "scope": "",
  "body": [ "# ## fs::getAbsolutePath\n# \n# This function returns the absolute path of a path.\n# \n# If the path exists, it can be resolved to the real path, following symlinks,\n# using the option `realpath=true`.\n# \n# - \\$1: **path** _as string_:\n#       The path to translate to absolute path.\n# - \\${realpath} _as bool_:\n#       (optional) true to resolve the path to the real path, following symlinks.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: The absolute path of the path.\n# \n# ```bash\n# fs::getAbsolutePath \"myPath\"\n# fs::getAbsolutePath \"myPath\" realpath=true\n# echo \"\\${REPLY}\"\n# ```\n# \n# > This is a pure bash alternative to `realpath` or `readlink`.\n# > The `..` will be processed before following any symlinks, by removing\n# > the immediate pathname component.\n# \nfs::getAbsolutePath \"${1:path}\" realpath=${2:false}$0" ]
},

"fs::getCommandPath": {
  "prefix": "fs::getCommandPath",
  "description": "Get the absolute path of a command...",
  "scope": "",
  "body": [ "fs::getCommandPath \"${1:command}\"$0" ]
},

"fs::getCommandPath#withdoc": {
  "prefix": "fs::getCommandPath#withdoc",
  "description": "Get the absolute path of a command...",
  "scope": "",
  "body": [ "# ## fs::getCommandPath\n# \n# Get the absolute path of a command.\n# \n# - \\$1: **command** _as string_:\n#       the command to find\n# \n# Returns:\n# \n# - \\${REPLY}: The absolute path of the command (or empty if command not found).\n# \n# ```bash\n# fs::getCommandPath \"command\"\n# echo \"\\${REPLY}\"\n# ```\n# \nfs::getCommandPath \"${1:command}\"$0" ]
},

"fs::getFileLineCount": {
  "prefix": "fs::getFileLineCount",
  "description": "Get the number of lines in a file...",
  "scope": "",
  "body": [ "fs::getFileLineCount \"${1:path}\"$0" ]
},

"fs::getFileLineCount#withdoc": {
  "prefix": "fs::getFileLineCount#withdoc",
  "description": "Get the number of lines in a file...",
  "scope": "",
  "body": [ "# ## fs::getFileLineCount\n# \n# Get the number of lines in a file.\n# \n# - \\$1: **path** _as string_:\n#       the file path to read\n# \n# Returns:\n# \n# - \\${REPLY}: The number of lines in the file.\n# \n# ```bash\n# fs::getFileLineCount \"/path/to/file\"\n# echo \"\\${REPLY}\"\n# ```\n# \n# TODO: fails to count the last line if empty\n# \nfs::getFileLineCount \"${1:path}\"$0" ]
},

"fs::getPwdRealPath": {
  "prefix": "fs::getPwdRealPath",
  "description": "Get the real path of the current directory...",
  "scope": "",
  "body": [ "fs::getPwdRealPath$0" ]
},

"fs::getPwdRealPath#withdoc": {
  "prefix": "fs::getPwdRealPath#withdoc",
  "description": "Get the real path of the current directory...",
  "scope": "",
  "body": [ "# ## fs::getPwdRealPath\n# \n# Get the real path of the current directory.\n# By default, the `\\${PWD}` variable is the logical path, which may contain symlinks.\n# \n# ```bash\n# fs::getPwdRealPath\n# echo \"\\${REPLY}\"\n# ```\n# \n# Returns:\n# \n# - \\${REPLY}: The realpath for the current directory.\n# \n# > This is a pure bash alternative to `realpath` or `readlink`.\n# \nfs::getPwdRealPath$0" ]
},

"fs::getScriptDirectory": {
  "prefix": "fs::getScriptDirectory",
  "description": "This function returns the absolute path of the directory of the script that called it...",
  "scope": "",
  "body": [ "fs::getScriptDirectory$0" ]
},

"fs::getScriptDirectory#withdoc": {
  "prefix": "fs::getScriptDirectory#withdoc",
  "description": "This function returns the absolute path of the directory of the script that called it...",
  "scope": "",
  "body": [ "# ## fs::getScriptDirectory\n# \n# This function returns the absolute path of the directory of the script that called it.\n# \n# Returns:\n# \n# - \\${REPLY}: the directory of the script that called it.\n# \n# ```bash\n# fs::getScriptDirectory\n# echo \"\\${REPLY}\"\n# ```\n# \nfs::getScriptDirectory$0" ]
},

"fs::head": {
  "prefix": "fs::head",
  "description": "Print the first lines of a file to stdout...",
  "scope": "",
  "body": [ "fs::head \"${1:path}\" \"${2:number of lines}\" toArray=${3:false}$0" ]
},

"fs::head#withdoc": {
  "prefix": "fs::head#withdoc",
  "description": "Print the first lines of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::head\n# \n# Print the first lines of a file to stdout.\n# This is a pure bash equivalent of head.\n# \n# - \\$1: **path** _as string_:\n#       The file to print.\n# - \\$2: **number of lines** _as int_:\n#       The number of lines to print.\n# - \\${toArray} _as bool_:\n#       (optional) If true, the output will be stored in the variable `REPLY_ARRAY`\n#       instead of being printed to stdout.\n#       (defaults to false)\n# \n# ```bash\n# fs::head myFile 10\n# fs::head myFile 10 toArray=true\n# ```\n# \n# > #TODO: faster with mapfile + quantum?\n# \nfs::head \"${1:path}\" \"${2:number of lines}\" toArray=${3:false}$0" ]
},

"fs::isDirectoryWritable": {
  "prefix": "fs::isDirectoryWritable",
  "description": "Check if the directory is writable...",
  "scope": "",
  "body": [ "fs::isDirectoryWritable \"${1:directory}\" testFileName=${2:\"writable-test-\\${BASHPID}\"}$0" ]
},

"fs::isDirectoryWritable#withdoc": {
  "prefix": "fs::isDirectoryWritable#withdoc",
  "description": "Check if the directory is writable...",
  "scope": "",
  "body": [ "# ## fs::isDirectoryWritable\n# \n# Check if the directory is writable. Creates the directory if it does not exist.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to check\n# - \\${testFileName} _as string_:\n#       (optional) The name of the file to create in the directory to test the write access\n#       (defaults to \"writable-test-\\${BASHPID}\")\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the directory is writable\n#   - 1 otherwise\n# \n# ```bash\n# if fs::isDirectoryWritable \"/path/to/directory\"; then\n#   echo \"The directory is writable.\"\n# fi\n# ```\n# \nfs::isDirectoryWritable \"${1:directory}\" testFileName=${2:\"writable-test-\\${BASHPID}\"}$0" ]
},

"fs::listDirectories": {
  "prefix": "fs::listDirectories",
  "description": "List all the directories in the given directory...",
  "scope": "",
  "body": [ "fs::listDirectories \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::listDirectories#withdoc": {
  "prefix": "fs::listDirectories#withdoc",
  "description": "List all the directories in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listDirectories\n# \n# List all the directories in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\${recursive} _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\${includeHidden} _as bool_:\n#       (optional) true to list hidden directories, false otherwise\n#       (defaults to false)\n# - \\${filter} _as string_:\n#       (optional) A function name that is called to filter the directories that will be listed\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# - \\${filterDirectory} _as string_:\n#       (optional) A function name that is called to filter the directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array with the list of all the files.\n# \n# ```bash\n# fs::listDirectories \"/path/to/directory\" true true myFilterFunction\n# for path in \"\\${REPLY_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \nfs::listDirectories \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::listFiles": {
  "prefix": "fs::listFiles",
  "description": "List all the files in the given directory...",
  "scope": "",
  "body": [ "fs::listFiles \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::listFiles#withdoc": {
  "prefix": "fs::listFiles#withdoc",
  "description": "List all the files in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listFiles\n# \n# List all the files in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\${recursive} _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\${includeHidden} _as bool_:\n#       (optional) true to list hidden files, false otherwise\n#       (defaults to false)\n# - \\${filter} _as string_:\n#       (optional) A function name that is called to filter the files that will be listed\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# - \\${filterDirectory} _as string_:\n#       (optional) A function name that is called to filter the directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array with the list of all the files.\n# \n# ```bash\n# fs::listFiles \"/path/to/directory\" true true myFilterFunction\n# for path in \"\\${REPLY_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \nfs::listFiles \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::listPaths": {
  "prefix": "fs::listPaths",
  "description": "List all the paths in the given directory...",
  "scope": "",
  "body": [ "fs::listPaths \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::listPaths#withdoc": {
  "prefix": "fs::listPaths#withdoc",
  "description": "List all the paths in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listPaths\n# \n# List all the paths in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\${recursive} _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\${includeHidden} _as bool_:\n#       (optional) true to list hidden paths, false otherwise\n#       (defaults to false)\n# - \\${filter} _as string_:\n#       (optional) A function name that is called to filter the paths that will be listed\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# - \\${filterDirectory} _as string_:\n#       (optional) A function name that is called to filter the directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to \"\")\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array with the list of all the paths.\n# \n# ```bash\n# fs::listPaths \"/path/to/directory\" true true myFilterFunction myFilterDirectoryFunction\n# for path in \"\\${REPLY_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \n# > - It will correctly list files under symbolic link directories.\n# > - #TODO: see if we are faster with ** and then looping over dirs to check for symbolic links\n# > - #TODO: introduce an optional (with default 10k) parameter to limit the number of results to avoid looping for too long\n# \nfs::listPaths \"${1:directory}\" recursive=${2:false} includeHidden=${3:false} filter=${4:\"\"} filterDirectory=${5:\"\"}$0" ]
},

"fs::readFile": {
  "prefix": "fs::readFile",
  "description": "Reads the content of a file and returns it in the global variable REPLY...",
  "scope": "",
  "body": [ "fs::readFile \"${1:path}\" maxCharacters=${2:0}$0" ]
},

"fs::readFile#withdoc": {
  "prefix": "fs::readFile#withdoc",
  "description": "Reads the content of a file and returns it in the global variable REPLY...",
  "scope": "",
  "body": [ "# ## fs::readFile\n# \n# Reads the content of a file and returns it in the global variable REPLY.\n# Uses pure bash.\n# \n# - \\$1: **path** _as string_:\n#       the file path to read\n# - \\${maxCharacters} _as int_:\n#       (optional) the maximum number of characters to read\n#       If set to 0, the whole file will be read.\n#       (defaults to 0)\n# \n# > If the file does not exist, the function will return an empty string instead of failing.\n# \n# Returns:\n# \n# - \\${REPLY}: The content of the file.\n# \n# ```bash\n# fs::readFile /path/to/file\n# fs::readFile /path/to/file maxCharacters=100\n# echo \"\\${REPLY}\"\n# ```\n# \nfs::readFile \"${1:path}\" maxCharacters=${2:0}$0" ]
},

"fs::tail": {
  "prefix": "fs::tail",
  "description": "Print the last lines of a file to stdout...",
  "scope": "",
  "body": [ "fs::tail \"${1:path}\" \"${2:number of lines}\" toArray=${3:false}$0" ]
},

"fs::tail#withdoc": {
  "prefix": "fs::tail#withdoc",
  "description": "Print the last lines of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::tail\n# \n# Print the last lines of a file to stdout.\n# This is a pure bash equivalent of tail.\n# However, because we have to read the whole file, it is not efficient for large files.\n# \n# - \\$1: **path** _as string_:\n#       The file to print.\n# - \\$2: **number of lines** _as int_:\n#       The number of lines to print from the end of the file.\n# - \\${toArray} _as bool_:\n#       (optional) If true, the output will be stored in the variable `REPLY_ARRAY`\n#       instead of being printed to stdout.\n#       (defaults to false)\n# \n# ```bash\n# fs::tail myFile 10\n# ```\n# \n# > #TODO: use mapfile quantum to not have to read the whole file in a single go.\n# \nfs::tail \"${1:path}\" \"${2:number of lines}\" toArray=${3:false}$0" ]
},

"include": {
  "prefix": "include",
  "description": "Allows to include multiple library files...",
  "scope": "",
  "body": [ "include \"${1:libraries}\"$0" ]
},

"include#withdoc": {
  "prefix": "include#withdoc",
  "description": "Allows to include multiple library files...",
  "scope": "",
  "body": [ "# ## include\n# \n# Allows to include multiple library files.\n# \n# It calls `source` for each argument.\n# Useful if you don't have arguments to pass to the sourced files.\n# \n# - \\$@: **libraries** _as string_:\n#       The names of the libraries (array, interactive, string...) or the file paths to include.\n# \n# ```bash\n# include string array ./my/path\n# ```\n# \ninclude \"${1:libraries}\"$0" ]
},

"interactive::confirm": {
  "prefix": "interactive::confirm",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "interactive::confirm \"${1:prompt}\" default=${2:true}$0" ]
},

"interactive::confirm#withdoc": {
  "prefix": "interactive::confirm#withdoc",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "# ## interactive::confirm\n# \n# Ask the user to yes or no.\n# \n# - The user can switch between the two options with the arrow keys or space.\n# - The user can validate the choice with the enter key.\n# - The user can also validate immediately with the y or n key.\n# \n# Dialog boxes are displayed for the question and answer.\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# - \\${default} _as bool_:\n#       (optional) the default value to select\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user answered yes\n#   - 1 otherwise\n# - \\${REPLY}: true or false.\n# \n# ```bash\n# if interactive::confirm \"Do you want to continue?\"; then echo \"Yes.\"; else echo \"No.\"; fi\n# ```\n# \ninteractive::confirm \"${1:prompt}\" default=${2:true}$0" ]
},

"interactive::confirmRaw": {
  "prefix": "interactive::confirmRaw",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "interactive::confirmRaw default=${1:true}$0" ]
},

"interactive::confirmRaw#withdoc": {
  "prefix": "interactive::confirmRaw#withdoc",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "# ## interactive::confirmRaw\n# \n# Ask the user to yes or no.\n# \n# - The user can switch between the two options with the arrow keys or space.\n# - The user can validate the choice with the enter key.\n# - The user can also validate immediately with the y or n key.\n# \n# This raw version does not display the prompt or the answer.\n# \n# - \\${default} _as bool_:\n#       (optional) the default value to select\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user answered yes\n#   - 1 otherwise\n# - \\${REPLY}: true or false.\n# \n# ```bash\n# interactive::confirmRaw \"Do you want to continue?\" && local answer=\"\\${REPLY}\"\n# ```\n# \ninteractive::confirmRaw default=${1:true}$0" ]
},

"interactive::continue": {
  "prefix": "interactive::continue",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "interactive::continue \"${1:prompt}\"$0" ]
},

"interactive::continue#withdoc": {
  "prefix": "interactive::continue#withdoc",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "# ## interactive::continue\n# \n# Ask the user to press the button to continue.\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user pressed enter\n#   - 1 otherwise\n# \n# ```bash\n# interactive::continue \"Press enter to continue.\"\n# ```\n# \ninteractive::continue \"${1:prompt}\"$0" ]
},

"interactive::continueRaw": {
  "prefix": "interactive::continueRaw",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "interactive::continueRaw$0" ]
},

"interactive::continueRaw#withdoc": {
  "prefix": "interactive::continueRaw#withdoc",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "# ## interactive::continueRaw\n# \n# Ask the user to press the button to continue.\n# \n# This raw version does not display the prompt or the answer.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user pressed enter\n#   - 1 otherwise\n# \n# ```bash\n# interactive::continueRaw\n# ```\n# \ninteractive::continueRaw$0" ]
},

"interactive::displayAnswer": {
  "prefix": "interactive::displayAnswer",
  "description": "Displays an answer to a previous question...",
  "scope": "",
  "body": [ "interactive::displayAnswer \"${1:answer}\" width=${2:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"interactive::displayAnswer#withdoc": {
  "prefix": "interactive::displayAnswer#withdoc",
  "description": "Displays an answer to a previous question...",
  "scope": "",
  "body": [ "# ## interactive::displayAnswer\n# \n# Displays an answer to a previous question.\n# \n# The text is wrapped and put inside a box like so:\n# \n# ```text\n#     ╭─────╮\n#     │ No. ├──░\n#     ╰─────╯\n# ```\n# \n# - \\$1: **answer** _as string_:\n#       the answer to display\n# - \\${width} _as int_:\n#       (optional) the maximum width of the text in the dialog box\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# \n# ```bash\n# interactive::displayAnswer \"My answer.\"\n# ```\n# \ninteractive::displayAnswer \"${1:answer}\" width=${2:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"interactive::displayQuestion": {
  "prefix": "interactive::displayQuestion",
  "description": "Displays a question to the user...",
  "scope": "",
  "body": [ "interactive::displayQuestion \"${1:prompt}\" width=${2:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"interactive::displayQuestion#withdoc": {
  "prefix": "interactive::displayQuestion#withdoc",
  "description": "Displays a question to the user...",
  "scope": "",
  "body": [ "# ## interactive::displayQuestion\n# \n# Displays a question to the user.\n# \n# The text is wrapped and put inside a box like so:\n# \n# ```text\n#    ╭────────────────────────────────╮\n# ░──┤ Is this an important question? │\n#    ╰────────────────────────────────╯\n# ```\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# - \\${width} _as int_:\n#       (optional) the maximum width of the text in the dialog box\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# \n# ```bash\n# interactive::displayPrompt \"Do you want to continue?\"\n# ```\n# \ninteractive::displayQuestion \"${1:prompt}\" width=${2:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"list::onTick": {
  "prefix": "list::onTick",
  "description": "This function must be called regularly (on refresh tick) and is responsible for redrawing the list if necessary...",
  "scope": "",
  "body": [ "list::onTick$0" ]
},

"list::onTick#withdoc": {
  "prefix": "list::onTick#withdoc",
  "description": "This function must be called regularly (on refresh tick) and is responsible for redrawing the list if necessary...",
  "scope": "",
  "body": [ "# ## list::onTick\n# \n# This function must be called regularly (on refresh tick) and is responsible for redrawing the list if necessary.\n# \n# \nlist::onTick$0" ]
},

"list::setItems": {
  "prefix": "list::setItems",
  "description": "Set up the list of items to display...",
  "scope": "",
  "body": [ "list::setItems$0" ]
},

"list::setItems#withdoc": {
  "prefix": "list::setItems#withdoc",
  "description": "Set up the list of items to display...",
  "scope": "",
  "body": [ "# ## list::setItems\n# \n# Set up the list of items to display.\n# \n# - \\$1 _as string_:\n#       The name of the array that contains the items to display.\n# \nlist::setItems$0" ]
},

"log::debug": {
  "prefix": "log::debug",
  "description": "Displays a debug message...",
  "scope": "",
  "body": [ "log::debug \"${1:message}\"$0" ]
},

"log::debug#withdoc": {
  "prefix": "log::debug#withdoc",
  "description": "Displays a debug message...",
  "scope": "",
  "body": [ "# ## log::debug\n# \n# Displays a debug message.\n# \n# - \\$1: **message** _as string_:\n#       the debug messages to display\n# \n# ```bash\n# log::debug \"This is a debug message.\"\n# ```\n# \nlog::debug \"${1:message}\"$0" ]
},

"log::error": {
  "prefix": "log::error",
  "description": "Displays an error message...",
  "scope": "",
  "body": [ "log::error \"${1:message}\"$0" ]
},

"log::error#withdoc": {
  "prefix": "log::error#withdoc",
  "description": "Displays an error message...",
  "scope": "",
  "body": [ "# ## log::error\n# \n# Displays an error message.\n# \n# - \\$1: **message** _as string_:\n#       the error messages to display\n# \n# ```bash\n# log::error \"This is an error message.\"\n# ```\n# \n# > You probably want to exit immediately after an error and should consider using core::fail function instead.\n# \nlog::error \"${1:message}\"$0" ]
},

"log::errorTrace": {
  "prefix": "log::errorTrace",
  "description": "Displays an error trace message...",
  "scope": "",
  "body": [ "log::errorTrace \"${1:message}\"$0" ]
},

"log::errorTrace#withdoc": {
  "prefix": "log::errorTrace#withdoc",
  "description": "Displays an error trace message...",
  "scope": "",
  "body": [ "# ## log::errorTrace\n# \n# Displays an error trace message.\n# This is a trace message that is always displayed, independently of the log level.\n# It can be used before a fatal error to display useful information.\n# \n# - \\$1: **message** _as string_:\n#       the trace messages to display\n# \n# ```bash\n# log::errorTrace \"This is a debug message.\"\n# ```\n# \nlog::errorTrace \"${1:message}\"$0" ]
},

"log::getCallStack": {
  "prefix": "log::getCallStack",
  "description": "This function returns the current function stack...",
  "scope": "",
  "body": [ "log::getCallStack stackToSkip=${1:1} stackToSkipAtEnd=${2:0} wrapWidth=${3:0}$0" ]
},

"log::getCallStack#withdoc": {
  "prefix": "log::getCallStack#withdoc",
  "description": "This function returns the current function stack...",
  "scope": "",
  "body": [ "# ## log::getCallStack\n# \n# This function returns the current function stack.\n# \n# - \\${stackToSkip} _as int_:\n#       (optional) The number of stack to skip.\n#       For instance, a value of 1 will skip this function.\n#       (defaults to 1)\n# - \\${stackToSkipAtEnd} _as int_:\n#       (optional) The number of stack to skip at the end.\n#       (defaults to 0)\n# - \\${wrapWidth} _as int_:\n#       (optional) The width to wrap the call stack.\n#       (defaults to 0)\n# \n# Returns:\n# \n# - \\${REPLY}: The call stack as a string.\n# \n# ```bash\n# log::getCallStack\n# echo \"\\${REPLY}\"\n# log::getCallStack stackToSkip=2 stackToSkipAtEnd=1 wrapWidth=80\n# ```\n# \n# > For test purposes, you can set the `GLOBAL_MOCK_STACK_FUNCTION_NAMES`, `GLOBAL_MOCK_STACK_SOURCE_FILES` and `GLOBAL_MOCK_STACK_LINE_NUMBERS`\n# > variables to simulate a call stack.\n# \nlog::getCallStack stackToSkip=${1:1} stackToSkipAtEnd=${2:0} wrapWidth=${3:0}$0" ]
},

"log::getLevel": {
  "prefix": "log::getLevel",
  "description": "Get the current log level...",
  "scope": "",
  "body": [ "log::getLevel$0" ]
},

"log::getLevel#withdoc": {
  "prefix": "log::getLevel#withdoc",
  "description": "Get the current log level...",
  "scope": "",
  "body": [ "# ## log::getLevel\n# \n# Get the current log level.\n# \n# Returns:\n# \n# - \\${REPLY}: The current log level.\n# \n# ```bash\n# log::getLevel\n# printf '%s\\n' \"The log level is ⌜\\${REPLY}⌝.\"\n# ```\n# \nlog::getLevel$0" ]
},

"log::info": {
  "prefix": "log::info",
  "description": "Displays an info message...",
  "scope": "",
  "body": [ "log::info \"${1:message}\"$0" ]
},

"log::info#withdoc": {
  "prefix": "log::info#withdoc",
  "description": "Displays an info message...",
  "scope": "",
  "body": [ "# ## log::info\n# \n# Displays an info message.\n# \n# - \\$1: **message** _as string_:\n#       the info messages to display\n# \n# ```bash\n# log::info \"This is an info message.\"\n# ```\n# \nlog::info \"${1:message}\"$0" ]
},

"log::isDebugEnabled": {
  "prefix": "log::isDebugEnabled",
  "description": "Check if the debug mode is enabled...",
  "scope": "",
  "body": [ "log::isDebugEnabled$0" ]
},

"log::isDebugEnabled#withdoc": {
  "prefix": "log::isDebugEnabled#withdoc",
  "description": "Check if the debug mode is enabled...",
  "scope": "",
  "body": [ "# ## log::isDebugEnabled\n# \n# Check if the debug mode is enabled.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if debug mode is enabled (log level is debug)\n#   - 1 if disabled\n# \n# ```bash\n# if log::isDebugEnabled; then printf '%s\\n' \"Debug mode is active.\"; fi\n# ```\n# \nlog::isDebugEnabled$0" ]
},

"log::isTraceEnabled": {
  "prefix": "log::isTraceEnabled",
  "description": "Check if the trace mode is enabled...",
  "scope": "",
  "body": [ "log::isTraceEnabled$0" ]
},

"log::isTraceEnabled#withdoc": {
  "prefix": "log::isTraceEnabled#withdoc",
  "description": "Check if the trace mode is enabled...",
  "scope": "",
  "body": [ "# ## log::isTraceEnabled\n# \n# Check if the trace mode is enabled.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if trace mode is enabled (log level is trace)\n#   - 1 if disabled\n# \n# ```bash\n# if log::isTraceEnabled; then printf '%s\\n' \"Debug mode is active.\"; fi\n# ```\n# \nlog::isTraceEnabled$0" ]
},

"log::printCallStack": {
  "prefix": "log::printCallStack",
  "description": "This function prints the current function stack in the logs...",
  "scope": "",
  "body": [ "log::printCallStack stackToSkip=${1:2} stackToSkipAtEnd=${2:0}$0" ]
},

"log::printCallStack#withdoc": {
  "prefix": "log::printCallStack#withdoc",
  "description": "This function prints the current function stack in the logs...",
  "scope": "",
  "body": [ "# ## log::printCallStack\n# \n# This function prints the current function stack in the logs.\n# \n# - \\${stackToSkip} _as int_:\n#       (optional) The number of stack to skip.\n#       For instance, a value of 2 will skip this function and the first calling function.\n#       (defaults to 2)\n# - \\${stackToSkipAtEnd} _as int_:\n#       (optional) The number of stack to skip at the end.\n#       (defaults to 0)\n# \n# ```bash\n# log::printCallStack\n# log::printCallStack stackToSkip=0\n# ```\n# \n# > For test purposes, you can set the `GLOBAL_MOCK_STACK_FUNCTION_NAMES`, `GLOBAL_MOCK_STACK_SOURCE_FILES` and `GLOBAL_MOCK_STACK_LINE_NUMBERS`\n# > variables to simulate a call stack.\n# \nlog::printCallStack stackToSkip=${1:2} stackToSkipAtEnd=${2:0}$0" ]
},

"log::printFile": {
  "prefix": "log::printFile",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "log::printFile \"${1:path}\" maxLines=${2:0}$0" ]
},

"log::printFile#withdoc": {
  "prefix": "log::printFile#withdoc",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "# ## log::printFile\n# \n# Display a file content with line numbers in the logs.\n# The file content will be aligned with the current log output and hard wrapped if necessary.\n# \n# - \\$1: **path** _as string_:\n#       the file path to display.\n# - \\${maxLines} _as int_:\n#       (optional) Max lines to display, can be set to 0 to display all lines.\n#       (defaults to 0)\n# \n# ```bash\n# log::printFile \"/my/file/path\"\n# log::printFile \"/my/file/path\" maxLines=10\n# ```\n# \nlog::printFile \"${1:path}\" maxLines=${2:0}$0" ]
},

"log::printFileString": {
  "prefix": "log::printFileString",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "log::printFileString \"${1:content variable name}\" maxLines=${2:0}$0" ]
},

"log::printFileString#withdoc": {
  "prefix": "log::printFileString#withdoc",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "# ## log::printFileString\n# \n# Display a file content with line numbers in the logs.\n# The file content will be aligned with the current log output and hard wrapped if necessary.\n# \n# - \\$1: **content variable name** _as string_:\n#       The name of the variable containing the file content to print.\n# - \\${maxLines} _as int_:\n#       (optional) Max lines to display, can be set to 0 to display all lines.\n#       (defaults to 0)\n# \n# ```bash\n# log::printFileString \"myvar\"\n# log::printFileString \"myvar\" maxLines=10\n# ```\n# \n# > This function is not at all suited for large strings, print the content to a file instead.\n# \nlog::printFileString \"${1:content variable name}\" maxLines=${2:0}$0" ]
},

"log::printRaw": {
  "prefix": "log::printRaw",
  "description": "Display something in the log stream...",
  "scope": "",
  "body": [ "log::printRaw \"${1:content variable name}\"$0" ]
},

"log::printRaw#withdoc": {
  "prefix": "log::printRaw#withdoc",
  "description": "Display something in the log stream...",
  "scope": "",
  "body": [ "# ## log::printRaw\n# \n# Display something in the log stream.\n# Does not check the log level.\n# \n# - \\$1: **content variable name** _as string_:\n#       The variable name containing the content to print (can contain new lines).\n# \n# ```bash\n# log::printRaw \"my line\"\n# ```\n# \nlog::printRaw \"${1:content variable name}\"$0" ]
},

"log::printString": {
  "prefix": "log::printString",
  "description": "Display a string in the log...",
  "scope": "",
  "body": [ "log::printString \"${1:content}\" newLinePadString=${2:\"\"}$0" ]
},

"log::printString#withdoc": {
  "prefix": "log::printString#withdoc",
  "description": "Display a string in the log...",
  "scope": "",
  "body": [ "# ## log::printString\n# \n# Display a string in the log.\n# The string will be aligned with the current log output and hard wrapped if necessary.\n# Does not check the log level.\n# \n# - \\$1: **content** _as string_:\n#       the content to log (can contain new lines)\n# - \\${newLinePadString} _as string_:\n#       (optional) the string with which to prepend each wrapped line\n#       (defaults to \"\")\n# \n# ```bash\n# log::printString \"my line\"\n# log::printString \"my line\" newLinePadString=\"  \"\n# ```\n# \nlog::printString \"${1:content}\" newLinePadString=${2:\"\"}$0" ]
},

"log::saveFile": {
  "prefix": "log::saveFile",
  "description": "Save the given file by copying it to a new file in the user local state directory (using `core::createSavedFilePath`)...",
  "scope": "",
  "body": [ "log::saveFile \"${1:path}\" suffix=${2:\"\"} silent=${3:false}$0" ]
},

"log::saveFile#withdoc": {
  "prefix": "log::saveFile#withdoc",
  "description": "Save the given file by copying it to a new file in the user local state directory (using `core::createSavedFilePath`)...",
  "scope": "",
  "body": [ "# ## log::saveFile\n# \n# Save the given file by copying it to a new file in the user local state directory\n# (using `core::createSavedFilePath`).\n# Useful for debugging purposes, to save the state of a file during execution.\n# \n# - \\$1: **path** _as string_:\n#       The file path to save.\n# - \\${suffix} _as string_:\n#       (optional) The suffix for the file to create.\n#       (defaults to \"\")\n# - \\${silent} _as bool_:\n#       (optional) if true, do not log the path of the saved file using `log::printString`\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: The path to the saved file.\n# \n# ```bash\n# log::saveFile \"/my/file/path\" \"suffix\" \"important result file\"\n# ```\n# \nlog::saveFile \"${1:path}\" suffix=${2:\"\"} silent=${3:false}$0" ]
},

"log::saveFileString": {
  "prefix": "log::saveFileString",
  "description": "Save the given string to a new file in the user local state directory (using `core::createSavedFilePath`)...",
  "scope": "",
  "body": [ "log::saveFileString \"${1:content variable name}\" suffix=${2:\"\"} silent=${3:false}$0" ]
},

"log::saveFileString#withdoc": {
  "prefix": "log::saveFileString#withdoc",
  "description": "Save the given string to a new file in the user local state directory (using `core::createSavedFilePath`)...",
  "scope": "",
  "body": [ "# ## log::saveFileString\n# \n# Save the given string to a new file in the user local state directory\n# (using `core::createSavedFilePath`).\n# Useful for debugging purposes, to save the state of a string during execution.\n# \n# - \\$1: **content variable name** _as string_:\n#       The variable name of the content to save.\n# - \\${suffix} _as string_:\n#       (optional) The suffix for the file to create.\n#       (defaults to \"\")\n# - \\${silent} _as bool_:\n#       (optional) if true, do not log the path of the saved file using `log::printString`\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: The path to the saved file.\n# \n# ```bash\n# log::saveFileString \"my content\" \"suffix\" \"important result file\"\n# ```\n# \nlog::saveFileString \"${1:content variable name}\" suffix=${2:\"\"} silent=${3:false}$0" ]
},

"log::setLevel": {
  "prefix": "log::setLevel",
  "description": "Set the log level...",
  "scope": "",
  "body": [ "log::setLevel \"${1:log level}\" silent=${2:false}$0" ]
},

"log::setLevel#withdoc": {
  "prefix": "log::setLevel#withdoc",
  "description": "Set the log level...",
  "scope": "",
  "body": [ "# ## log::setLevel\n# \n# Set the log level.\n# \n# - \\$1: **log level** _as string_:\n#       The log level to set (or defaults to info), acceptable values are:\n#   - trace\n#   - debug\n#   - info\n#   - success\n#   - warning\n#   - error\n# - \\${silent} _as bool_:\n#       (optional) true to silently switch log level, i.e. does not print a message\n#       (defaults to false)\n# \n# ```bash\n# log::setLevel debug\n# log::setLevel debug silent=true\n# ```\n# \nlog::setLevel \"${1:log level}\" silent=${2:false}$0" ]
},

"log::success": {
  "prefix": "log::success",
  "description": "Displays a success message...",
  "scope": "",
  "body": [ "log::success \"${1:message}\"$0" ]
},

"log::success#withdoc": {
  "prefix": "log::success#withdoc",
  "description": "Displays a success message...",
  "scope": "",
  "body": [ "# ## log::success\n# \n# Displays a success message.\n# \n# - \\$1: **message** _as string_:\n#       the success messages to display\n# \n# ```bash\n# log::success \"This is a success message.\"\n# ```\n# \nlog::success \"${1:message}\"$0" ]
},

"log::trace": {
  "prefix": "log::trace",
  "description": "Displays a trace message...",
  "scope": "",
  "body": [ "log::trace \"${1:message}\"$0" ]
},

"log::trace#withdoc": {
  "prefix": "log::trace#withdoc",
  "description": "Displays a trace message...",
  "scope": "",
  "body": [ "# ## log::trace\n# \n# Displays a trace message.\n# \n# - \\$1: **message** _as string_:\n#       the trace messages to display\n# \n# ```bash\n# log::trace \"This is a trace message.\"\n# ```\n# \nlog::trace \"${1:message}\"$0" ]
},

"log::warning": {
  "prefix": "log::warning",
  "description": "Displays a warning...",
  "scope": "",
  "body": [ "log::warning \"${1:message}\"$0" ]
},

"log::warning#withdoc": {
  "prefix": "log::warning#withdoc",
  "description": "Displays a warning...",
  "scope": "",
  "body": [ "# ## log::warning\n# \n# Displays a warning.\n# \n# - \\$1: **message** _as string_:\n#       the warning messages to display\n# \n# ```bash\n# log::warning \"This is a warning message.\"\n# ```\n# \nlog::warning \"${1:message}\"$0" ]
},

"profiler::disable": {
  "prefix": "profiler::disable",
  "description": "Disable the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "profiler::disable$0" ]
},

"profiler::disable#withdoc": {
  "prefix": "profiler::disable#withdoc",
  "description": "Disable the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "# ## profiler::disable\n# \n# Disable the profiler if previously activated with profiler::enable.\n# \n# ```bash\n# profiler::disable\n# ```\n# \nprofiler::disable$0" ]
},

"profiler::enable": {
  "prefix": "profiler::enable",
  "description": "Enables the profiler and start writing to the given file...",
  "scope": "",
  "body": [ "profiler::enable \"${1:path}\"$0" ]
},

"profiler::enable#withdoc": {
  "prefix": "profiler::enable#withdoc",
  "description": "Enables the profiler and start writing to the given file...",
  "scope": "",
  "body": [ "# ## profiler::enable\n# \n# Enables the profiler and start writing to the given file.\n# The profiler will also be active in subshells of this current shell.\n# \n# - \\$1: **path** _as string_:\n#       the file to write to.\n# \n# ```bash\n# profiler::enable \"\\${HOME}/valet-profiler-\\${BASHPID}.txt\"\n# ```\n# \n# > There can be only one profiler active at a time.\n# \nprofiler::enable \"${1:path}\"$0" ]
},

"profiler::pause": {
  "prefix": "profiler::pause",
  "description": "Pause the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "profiler::pause$0" ]
},

"profiler::pause#withdoc": {
  "prefix": "profiler::pause#withdoc",
  "description": "Pause the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "# ## profiler::pause\n# \n# Pause the profiler if previously activated with profiler::enable.\n# \n# ```bash\n# profiler::pause\n# ```\n# \nprofiler::pause$0" ]
},

"profiler::resume": {
  "prefix": "profiler::resume",
  "description": "Resume the profiler if previously paused with profiler::pause...",
  "scope": "",
  "body": [ "profiler::resume$0" ]
},

"profiler::resume#withdoc": {
  "prefix": "profiler::resume#withdoc",
  "description": "Resume the profiler if previously paused with profiler::pause...",
  "scope": "",
  "body": [ "# ## profiler::resume\n# \n# Resume the profiler if previously paused with profiler::pause.\n# \n# ```bash\n# profiler::resume\n# ```\n# \nprofiler::resume$0" ]
},

"progress::start": {
  "prefix": "progress::start",
  "description": "Shows a spinner / progress animation with configurable output including a progress bar...",
  "scope": "",
  "body": [ "progress::start size=${1:20} frameDelay=${2:200} maxFrames=${3:9223372036854775807} spinnerFrames=${4:\"⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\"} percent=${5:0} message=${6:\"\"}$0" ]
},

"progress::start#withdoc": {
  "prefix": "progress::start#withdoc",
  "description": "Shows a spinner / progress animation with configurable output including a progress bar...",
  "scope": "",
  "body": [ "# ## progress::start\n# \n# Shows a spinner / progress animation with configurable output including a progress bar.\n# \n# The animation will be displayed until progress::stop is called\n# or if the max number of frames is reached.\n# \n# Outputs to stderr.\n# This will run in the background and will not block the main thread.\n# The main thread can continue to output logs while this animation is running.\n# \n# - \\$1{template} _as string_:\n#       (optional) The template to display. The template can contain the following placeholders:\n# \n#       - `<spinner>`: the spinner animation\n#       - `<percent>`: the percentage of the progress bar\n#       - `<bar>`: the progress bar\n#       - `<message>`: the message to display\n#       - #TODO: add `<cGradient>` and `<cDefault>`: colors the bar with a gradient (if colors enabled)\n# \n#       The default template is defined by the environment variable `VALET_CONFIG_PROGRESS_DEFAULT_TEMPLATE`.\n#       (defaults to \"<spinner> <percent> ░<bar>░ <message>\")\n# - \\${size} _as int_:\n#       (optional) The maximum width of the progress bar.\n#       The default size is defined by the environment variable `VALET_CONFIG_PROGRESS_BAR_DEFAULT_SIZE`.\n#       (defaults to 20)\n# - \\${frameDelay} _as int_:\n#       (optional) The time in milliseconds between each frame of the spinner.\n#       The default frame delay is defined by the environment variable `VALET_CONFIG_PROGRESS_DEFAULT_ANIMATION_DELAY`.\n#       (defaults to 200)\n# - \\${maxFrames} _as int_:\n#       (optional) The maximum number of frames to display.\n#       (defaults to 9223372036854775807)\n# - \\${spinnerFrames} _as string_:\n#       (optional) The spinner to display (each character is a frame).\n#       Examples:\n# \n#       - ◐◓◑◒\n#       - ▖▘▝▗\n#       - ⣾⣽⣻⢿⡿⣟⣯⣷\n#       - ⢄⢂⢁⡁⡈⡐⡠\n#       - ◡⊙◠\n#       - ▌▀▐▄\n#       - ⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆\n# \n#       The default spinner is defined by the environment variable `VALET_CONFIG_SPINNER_CHARACTERS`.\n#       (defaults to \"⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\")\n# - \\${percent} _as int_:\n#       (optional) The default percent to start with.\n#       (defaults to 0)\n# - \\${message} _as string_:\n#       (optional) The default message to start with.\n#       (defaults to \"\")\n# \n# ```bash\n# progress::start template=\"<spinner>\" \"\" 100\n# wait 4\n# progress::stop\n# \n# progress::start template=\"<spinner> <percent> ░<bar>░ <message>\" size=30 spinnerFrames=\"⢄⢂⢁⡁⡈⡐⡠\"\n# IDX=0\n# while [[ \\${IDX} -le 50 ]]; do\n#   progress::update percent=\\$((IDX * 2)) message=\"Doing something \\${IDX}/50...\"\n#   IDX=\\$((IDX + 1))\n#   sleep 0.1\n# done\n# progress::stop\n# ```\n# \n# > Important: all progress functions will only work if called from the same shell\n# > that started the progress bar.\n# \nprogress::start size=${1:20} frameDelay=${2:200} maxFrames=${3:9223372036854775807} spinnerFrames=${4:\"⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\"} percent=${5:0} message=${6:\"\"}$0" ]
},

"progress::stop": {
  "prefix": "progress::stop",
  "description": "Stop the progress bar...",
  "scope": "",
  "body": [ "progress::stop$0" ]
},

"progress::stop#withdoc": {
  "prefix": "progress::stop#withdoc",
  "description": "Stop the progress bar...",
  "scope": "",
  "body": [ "# ## progress::stop\n# \n# Stop the progress bar.\n# \n# ```bash\n# progress::stop\n# ```\n# \nprogress::stop$0" ]
},

"progress::update": {
  "prefix": "progress::update",
  "description": "Update the progress bar with a new percentage and message...",
  "scope": "",
  "body": [ "progress::update percent=${1:0} message=${2:\"\"}$0" ]
},

"progress::update#withdoc": {
  "prefix": "progress::update#withdoc",
  "description": "Update the progress bar with a new percentage and message...",
  "scope": "",
  "body": [ "# ## progress::update\n# \n# Update the progress bar with a new percentage and message.\n# \n# The animation can be started with progress::start for more options.\n# The animation will stop if the updated percentage is 100.\n# \n# - \\${percent} _as int_:\n#       (optional) the percentage of the progress bar (0 to 100)\n#       (defaults to 0)\n# - \\${message} _as string_:\n#       (optional) the message to display\n#       (defaults to \"\")\n# \n# ```bash\n# progress::update percent=50 percent=\"Doing something...\"\n# ```\n# \nprogress::update percent=${1:0} message=${2:\"\"}$0" ]
},

"regex::escapeRegexSpecialChars": {
  "prefix": "regex::escapeRegexSpecialChars",
  "description": "Escapes special characters in a string to be used as a regex...",
  "scope": "",
  "body": [ "regex::escapeRegexSpecialChars \"${1:string to escape}\"$0" ]
},

"regex::escapeRegexSpecialChars#withdoc": {
  "prefix": "regex::escapeRegexSpecialChars#withdoc",
  "description": "Escapes special characters in a string to be used as a regex...",
  "scope": "",
  "body": [ "# ## regex::escapeRegexSpecialChars\n# \n# Escapes special characters in a string to be used as a regex.\n# \n# - \\$1: **string to escape** _as string_:\n#       The string to escape.\n# \n# Returns:\n# \n# - \\${REPLY}: The escaped string.\n# \n# ```bash\n# regex::escapeRegexSpecialChars \"a.(b)\"\n# echo \"\\${REPLY}\"\n# ```\n# \nregex::escapeRegexSpecialChars \"${1:string to escape}\"$0" ]
},

"regex::getFirstGroup": {
  "prefix": "regex::getFirstGroup",
  "description": "Matches a string against a regex and returns the first captured group of the first match...",
  "scope": "",
  "body": [ "regex::getFirstGroup \"${1:string variable name}\" \"${2:regex}\"$0" ]
},

"regex::getFirstGroup#withdoc": {
  "prefix": "regex::getFirstGroup#withdoc",
  "description": "Matches a string against a regex and returns the first captured group of the first match...",
  "scope": "",
  "body": [ "# ## regex::getFirstGroup\n# \n# Matches a string against a regex and returns the first captured group of the first match.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string to match.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# \n# Returns:\n# \n# - \\${REPLY}: The first capture group in the matched string.\n#                      Empty if no match.\n# \n# ```bash\n# MY_STRING=\"name: julien\"\n# regex::getFirstGroup MY_STRING \"name:(.*)\"\n# echo \"\\${REPLY}\"\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::getFirstGroup \"${1:string variable name}\" \"${2:regex}\"$0" ]
},

"regex::getFuzzySearchRegexFromSearchString": {
  "prefix": "regex::getFuzzySearchRegexFromSearchString",
  "description": "Allows to get a regex that can be used to fuzzy search a string...",
  "scope": "",
  "body": [ "regex::getFuzzySearchRegexFromSearchString \"${1:search string}\"$0" ]
},

"regex::getFuzzySearchRegexFromSearchString#withdoc": {
  "prefix": "regex::getFuzzySearchRegexFromSearchString#withdoc",
  "description": "Allows to get a regex that can be used to fuzzy search a string...",
  "scope": "",
  "body": [ "# ## regex::getFuzzySearchRegexFromSearchString\n# \n# Allows to get a regex that can be used to fuzzy search a string.\n# the -> '([^t]*)(t[^h]*h[^e]*e)'\n# \n# - \\$1: **search string** _as string_:\n#       The variable name containing the search string to match.\n# \n# Returns:\n# \n# - \\${_STRING_FUZZY_FILTER_REGEX}: the regex\n# \n# ```bash\n# regex::getFuzzySearchRegexFromSearchString SEARCH_STRING\n# echo \"\\${_STRING_FUZZY_FILTER_REGEX}\"\n# ```\n# \nregex::getFuzzySearchRegexFromSearchString \"${1:search string}\"$0" ]
},

"regex::getMatches": {
  "prefix": "regex::getMatches",
  "description": "Returns an array containing all the matched for a regex in a string...",
  "scope": "",
  "body": [ "regex::getMatches \"${1:string variable name}\" \"${2:regex}\" replacement=${3:\"\"} max=${4:-1}$0" ]
},

"regex::getMatches#withdoc": {
  "prefix": "regex::getMatches#withdoc",
  "description": "Returns an array containing all the matched for a regex in a string...",
  "scope": "",
  "body": [ "# ## regex::getMatches\n# \n# Returns an array containing all the matched for a regex in a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string to match.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# - \\${replacement} _as string_:\n#       (optional) The replacement string to use on each match.\n# \n#       - Use \\x to refer to the x-th capture group.\n#       - Use \\c to refer to replacement counter.\n# \n#       Set to an empty string to keep the matches as they are.\n#       (defaults to \"\")\n# - \\${max} _as int_:\n#       (optional) The number of matches to return.\n#       Set to -1 for unlimited replacements.\n#       (defaults to -1)\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array containing all the matches.\n# \n# ```bash\n# MY_STRING=\"name: julien, name: john\"\n# regex::getMatches MY_STRING \"name: (.*)\"\n# regex::getMatches MY_STRING \"name: (.*)\" max=1\n# for match in \"\\${REPLY_ARRAY[@]}\"; do\n#   echo \"\\${match}\"\n# done\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::getMatches \"${1:string variable name}\" \"${2:regex}\" replacement=${3:\"\"} max=${4:-1}$0" ]
},

"regex::replace": {
  "prefix": "regex::replace",
  "description": "Replaces strings within a string using a regex (replaces in place)...",
  "scope": "",
  "body": [ "regex::replace \"${1:string variable name}\" \"${2:regex}\" \"${3:replacement string}\" max=${4:-1} onlyMatches=${5:false}$0" ]
},

"regex::replace#withdoc": {
  "prefix": "regex::replace#withdoc",
  "description": "Replaces strings within a string using a regex (replaces in place)...",
  "scope": "",
  "body": [ "# ## regex::replace\n# \n# Replaces strings within a string using a regex (replaces in place).\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string in which to do replacements.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# - \\$3: **replacement string** _as string_:\n#       The replacement string.\n#       Use \\x to refer to the x-th capture group.\n#       Use \\c to refer to replacement counter.\n# - \\${max} _as int_:\n#       (optional) The number of replacements to do.\n#       Set to -1 for unlimited replacements.\n#       (defaults to -1)\n# - \\${onlyMatches} _as bool_:\n#       (optional) Instead of replacing with the regex, we keep only the matches.\n#       This can be used to extract information from a string.\n#       (defaults to false)\n# \n# \n# ```bash\n# MY_STRING=\"name: julien\"\n# regex::replace MY_STRING \"name: (.*)\" \"\\1\"\n# regex::replace MY_STRING \"name: (.*)\" \"\\1\" maxCount=1 onlyMatches=true\n# echo \"\\${MY_STRING}\"\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::replace \"${1:string variable name}\" \"${2:regex}\" \"${3:replacement string}\" max=${4:-1} onlyMatches=${5:false}$0" ]
},

"sfzf::show": {
  "prefix": "sfzf::show",
  "description": "Displays a menu where the user can search and select an item...",
  "scope": "",
  "body": [ "sfzf::show \"${1:array name}\" prompt=${2:\"Select an item:\"} itemDetailsCallback=${3:empty, no callback}$0" ]
},

"sfzf::show#withdoc": {
  "prefix": "sfzf::show#withdoc",
  "description": "Displays a menu where the user can search and select an item...",
  "scope": "",
  "body": [ "# ## sfzf::show\n# \n# Displays a menu where the user can search and select an item.\n# The menu is displayed in full screen.\n# Each item can optionally have a description/details shown in a right panel.\n# The user can search for an item by typing.\n# \n# - \\$1: **array name** _as string_:\n#       The items to display (name of a global array).\n# - \\${prompt} _as string_:\n#       (optional) The prompt to display to the user (e.g. Please pick an item).\n#       (defaults to \"Select an item:\")\n# - \\${itemDetailsCallback} _as string_:\n#       (optional) The function to call when an item is selected\n#       this parameter can be left empty to hide the preview right pane;\n#       otherwise the callback function should have the following signature:\n# \n#       - \\$1: the current item\n#       - \\$2: the item number;\n#       - \\$3: the current panel width;\n#       - it should return the details of the item in the `REPLY` variable.\n# \n#       (defaults to empty, no callback)\n# - \\$(previewTitle) _as string_:\n#       (optional) the title of the preview right pane (if any)\n#       (defaults to \"Details\")\n# \n# Returns:\n# \n# - \\${REPLY}: The selected item value (or empty).\n# - \\${REPLY2}: The selected item index (from the original array).\n#                      Or -1 if the user cancelled the selection\n# \n# ```bash\n# declare -g -a SELECTION_ARRAY\n# SELECTION_ARRAY=(\"blue\" \"red\" \"green\" \"yellow\")\n# sfzf::show \"What's your favorite color?\" SELECTION_ARRAY\n# log::info \"You selected: ⌜\\${REPLY}⌝ (index: ⌜\\${REPLY2}⌝)\"\n# ```\n# \nsfzf::show \"${1:array name}\" prompt=${2:\"Select an item:\"} itemDetailsCallback=${3:empty, no callback}$0" ]
},

"source": {
  "prefix": "source",
  "description": "Allows to source/include a library file or sources a file...",
  "scope": "",
  "body": [ "source \"${1:library name or path}\" \"${2:arguments}\"$0" ]
},

"source#withdoc": {
  "prefix": "source#withdoc",
  "description": "Allows to source/include a library file or sources a file...",
  "scope": "",
  "body": [ "# ## source\n# \n# Allows to source/include a library file or sources a file.\n# \n# When sourcing a library, omit the `lib-` prefix.\n# It will source all user and core libraries with the given name.\n# \n# It replaces the builtin source command to make sure that we do not source the same library twice.\n# We replace source instead of creating a new function to allow us to\n# specify the included file for spellcheck.\n# \n# - \\$1: **library name or path** _as string_:\n#       the name of the library (array, interactive, string...) or the file path to include.\n# - \\$@: arguments _as any_:\n#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).\n# - \\$_OPTION_CONTINUE_IF_NOT_FOUND _as bool_:\n#       (optional) Do not fail the program if we do not find a file to source, we simply return 1.\n#       (defaults to false)\n# - \\$_OPTION_RETURN_CODE_IF_ALREADY_INCLUDED _as int_:\n#       (optional) The function return code if the given file or library was already\n#       included.\n#       (defaults to 0)\n# \n# ```bash\n# source string\n# source ./my/path\n# _OPTION_CONTINUE_IF_NOT_FOUND=false _OPTION_RETURN_CODE_IF_ALREADY_INCLUDED=2 source ./my/path\n# ```\n# \n# > - The file can be relative to the current script (script that calls this function).\n# > - Use `builtin source` if you want to include the file even if it was already included.\n# \nsource \"${1:library name or path}\" \"${2:arguments}\"$0" ]
},

"string::count": {
  "prefix": "string::count",
  "description": "Counts the number of occurrences of a substring in a string...",
  "scope": "",
  "body": [ "string::count \"${1:string variable name}\" \"${2:substring}\"$0" ]
},

"string::count#withdoc": {
  "prefix": "string::count#withdoc",
  "description": "Counts the number of occurrences of a substring in a string...",
  "scope": "",
  "body": [ "# ## string::count\n# \n# Counts the number of occurrences of a substring in a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string in which to count occurrences.\n# - \\$2: **substring** _as string_:\n#       the substring to count\n# \n# Returns:\n# \n# - \\${REPLY}: the number of occurrences\n# \n# ```bash\n# MY_STRING=\"name,first_name,address\"\n# string::count MY_STRING \",\"\n# echo \"\\${REPLY}\"\n# ```\n# \n# > This is faster than looping over the string and check the substring.\n# \nstring::count \"${1:string variable name}\" \"${2:substring}\"$0" ]
},

"string::doForEachLine": {
  "prefix": "string::doForEachLine",
  "description": "Execute a callback function for each item (e...",
  "scope": "",
  "body": [ "string::doForEachLine \"${1:string variable name}\" \"${2:callback function}\" separator=${3:\\$'\\n'}$0" ]
},

"string::doForEachLine#withdoc": {
  "prefix": "string::doForEachLine#withdoc",
  "description": "Execute a callback function for each item (e...",
  "scope": "",
  "body": [ "# ## string::doForEachLine\n# \n# Execute a callback function for each item (e.g. line) of a string.\n# The string is split using a separator (default to a new line) and\n# the callback function is called for each item.\n# \n# - \\$1: **string variable name** _as string_:\n#       The name of the variable containing the string.\n# - \\$2: **callback function** _as string_:\n#       The name of the function to execute for each item (line).\n#       The function is called with the following arguments:\n# \n#       - \\$1: the current item (line) content\n# \n#       The function must return 0 if we should continue to the next line, 1 otherwise.\n#       (defaults to \"\")\n# - \\${separator} _as string_:\n#       (optional) The separator character to use.\n#       (defaults to \\$'\\n')\n# \n# ```bash\n# string::doForEachLine myString myCallback\n# ```\n# \n# > This function provides a convenient way to avoid using a \"here string\" and handles extra\n# > newlines (which is not the case with a \"for loop\" using parameter expansion and IFS=\\$'\\n').\n# > Here string is significantly slower than using this.\n# \nstring::doForEachLine \"${1:string variable name}\" \"${2:callback function}\" separator=${3:\\$'\\n'}$0" ]
},

"string::extractBetween": {
  "prefix": "string::extractBetween",
  "description": "Extract the text between two strings within a string...",
  "scope": "",
  "body": [ "string::extractBetween \"${1:string variable name}\" \"${2:start string}\" \"${3:end string}\"$0" ]
},

"string::extractBetween#withdoc": {
  "prefix": "string::extractBetween#withdoc",
  "description": "Extract the text between two strings within a string...",
  "scope": "",
  "body": [ "# ## string::extractBetween\n# \n# Extract the text between two strings within a string.\n# Search for the first occurrence of the start string and the first occurrence\n# (after the start index) of the end string.\n# Both start and end strings are excluded in the extracted text.\n# Both start and end strings must be found to extract something.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to extract a text.\n# - \\$2: **start string** _as string_:\n#       the start string\n#       (if empty, then it will extract from the beginning of the string)\n# - \\$3: **end string** _as string_:\n#       the end string\n#       (if empty, then it will extract until the end of the string)\n# \n# Returns:\n# \n# - \\${REPLY}: the extracted text\n# \n# ```bash\n# MY_STRING=\"This is a long text\"\n# string::extractBetween MY_STRING \"is a \" \" text\"\n# local extractedText=\"\\${REPLY}\"\n# ```\n# \nstring::extractBetween \"${1:string variable name}\" \"${2:start string}\" \"${3:end string}\"$0" ]
},

"string::getCamelCase": {
  "prefix": "string::getCamelCase",
  "description": "This function convert a SNAKE_CASE or kebab-case string to a camelCase string...",
  "scope": "",
  "body": [ "string::getCamelCase \"${1:string variable name}\"$0" ]
},

"string::getCamelCase#withdoc": {
  "prefix": "string::getCamelCase#withdoc",
  "description": "This function convert a SNAKE_CASE or kebab-case string to a camelCase string...",
  "scope": "",
  "body": [ "# ## string::getCamelCase\n# \n# This function convert a SNAKE_CASE or kebab-case string to a camelCase string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${REPLY}: The converted string\n# \n# ```bash\n# MY_STRING=\"my-kebab-case\"\n# string::getCamelCase MY_STRING\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getCamelCase \"${1:string variable name}\"$0" ]
},

"string::getField": {
  "prefix": "string::getField",
  "description": "Allows to get the nth element of a string separated by a given separator...",
  "scope": "",
  "body": [ "string::getField \"${1:string variable name}\" \"${2:field number}\" separator=${3:\\$'\\t'}$0" ]
},

"string::getField#withdoc": {
  "prefix": "string::getField#withdoc",
  "description": "Allows to get the nth element of a string separated by a given separator...",
  "scope": "",
  "body": [ "# ## string::getField\n# \n# Allows to get the nth element of a string separated by a given separator.\n# This is the equivalent of the cut command \"cut -d\"\\${separator}\" -f\"\\${fieldNumber}\"\"\n# but it uses pure bash to go faster.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to extract from.\n# - \\$2: **field number** _as int_:\n#       The field number to get (starting at 0).\n# - \\${separator} _as string_:\n#       The separator to use.\n#       (defaults to \\$'\\t')\n# \n# Returns:\n# \n# - \\${REPLY}: the extracted field\n# \n# ```bash\n# MY_STRING=\"field1 field2 field3\"\n# string::getField MY_STRING 1 separator=\" \"\n# echo \"\\${REPLY}\"\n# ```\n# \n# > This is faster than:\n# >\n# > - using read into an array from a here string\n# > - using bash parameter expansion to remove before/after the separator\n# \nstring::getField \"${1:string variable name}\" \"${2:field number}\" separator=${3:\\$'\\t'}$0" ]
},

"string::getFormattedHeader": {
  "prefix": "string::getFormattedHeader",
  "description": "Get a formatted header string with a given width...",
  "scope": "",
  "body": [ "string::getFormattedHeader \"${1:format}\" width=${2:\"GLOBAL_COLUMNS\"} paddingChar=${3:\" \"} paddingStyle=${4:\"\"} paddingStyleReset=${5:\"\"} partWidths=${6:\"\"} noEllipsis=${7:false}$0" ]
},

"string::getFormattedHeader#withdoc": {
  "prefix": "string::getFormattedHeader#withdoc",
  "description": "Get a formatted header string with a given width...",
  "scope": "",
  "body": [ "# ## string::getFormattedHeader\n# \n# Get a formatted header string with a given width.\n# The header is composed of a left/middle/right part(s).\n# The header is padded with a given character to fit the given width.\n# The parts are trimmed if too long but they are prioritized in this order: middle, left, right\n# (middle will take all the space necessary, then left, then right).\n# \n# - \\$1: **format** _as string_:\n#       The format of the header.\n#       It must include two | characters to separate the left, middle and right parts.\n#       Any part can be empty.\n#       Example: \"left|middle|right\"\n# - \\${width} _as int_:\n#       The total width of the header.\n#       (defaults to \"GLOBAL_COLUMNS\")\n# - \\${paddingChar} _as string_:\n#       (optional) The character to use for padding.\n#       (defaults to \" \")\n# - \\${paddingStyle} _as string_:\n#       (optional) The style (ANSI escape codes) to apply the padding characters.\n#       (defaults to \"\")\n# - \\${paddingStyleReset} _as string_:\n#       (optional) The style (ANSI escape codes) to apply at the end of the padding characters.\n#       (defaults to \"\")\n# - \\${partWidths} _as string_:\n#       (optional) The actual widths of each part separated by |.\n#       If not provided, the actual width of each part will be computed automatically,\n#       not taking into account invisible characters (like ANSI escape codes).\n#       Example: \"10|20|10\"\n#       (defaults to \"\")\n# - \\${noEllipsis} _as bool_:\n#       (optional) If set to true, no ellipsis will be added when a part is trimmed.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: the formatted header string\n# - \\${REPLY2}: the actual widths of each part separated by | (same format as partWidths argument)\n# - \\${REPLY_ARRAY}: the actual widths of each part\n# \n# ```bash\n# string::getFormattedHeader \"Left|Middle|Right\" width=50 paddingChar=\"-\" paddingStyle=\\$'\\e[1;34m' paddingStyleReset=\\$'\\e[0m'\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getFormattedHeader \"${1:format}\" width=${2:\"GLOBAL_COLUMNS\"} paddingChar=${3:\" \"} paddingStyle=${4:\"\"} paddingStyleReset=${5:\"\"} partWidths=${6:\"\"} noEllipsis=${7:false}$0" ]
},

"string::getHexRepresentation": {
  "prefix": "string::getHexRepresentation",
  "description": "Convert a string to its hexadecimal representation...",
  "scope": "",
  "body": [ "string::getHexRepresentation \"${1:string variable name}\"$0" ]
},

"string::getHexRepresentation#withdoc": {
  "prefix": "string::getHexRepresentation#withdoc",
  "description": "Convert a string to its hexadecimal representation...",
  "scope": "",
  "body": [ "# ## string::getHexRepresentation\n# \n# Convert a string to its hexadecimal representation.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${REPLY}: the hexadecimal representation of the string\n# \n# ```bash\n# MY_STRING=\"This is a string\"\n# string::getHexRepresentation MY_STRING\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getHexRepresentation \"${1:string variable name}\"$0" ]
},

"string::getIndexOf": {
  "prefix": "string::getIndexOf",
  "description": "Find the first index of a string within another string...",
  "scope": "",
  "body": [ "string::getIndexOf \"${1:string variable name}\" \"${2:search}\" startingIndex=${3:0}$0" ]
},

"string::getIndexOf#withdoc": {
  "prefix": "string::getIndexOf#withdoc",
  "description": "Find the first index of a string within another string...",
  "scope": "",
  "body": [ "# ## string::getIndexOf\n# \n# Find the first index of a string within another string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to find an index.\n# - \\$2: **search** _as string_:\n#       the string to search\n# - \\${startingIndex} _as int_:\n#       (optional) the starting index\n#       (defaults to 0)\n# \n# Returns:\n# \n# - \\${REPLY}: the index of the substring in the string or -1 if not found.\n# \n# ```bash\n# MY_STRING=\"This is a long text\"\n# string::getIndexOf MY_STRING \"long\" startingIndex=2\n# string::getIndexOf MY_STRING \"long\"\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getIndexOf \"${1:string variable name}\" \"${2:search}\" startingIndex=${3:0}$0" ]
},

"string::getKebabCase": {
  "prefix": "string::getKebabCase",
  "description": "This function convert a camelCase, PascalCase or SNAKE_CASE string to a kebab-case string...",
  "scope": "",
  "body": [ "string::getKebabCase \"${1:string variable name}\"$0" ]
},

"string::getKebabCase#withdoc": {
  "prefix": "string::getKebabCase#withdoc",
  "description": "This function convert a camelCase, PascalCase or SNAKE_CASE string to a kebab-case string...",
  "scope": "",
  "body": [ "# ## string::getKebabCase\n# \n# This function convert a camelCase, PascalCase or SNAKE_CASE string to a kebab-case string.\n# Removes all leading/trailing dashes.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${REPLY}: The converted string\n# \n# ```bash\n# MY_STRING=\"myCamelCaseString\"\n# string::getKebabCase MY_STRING\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getKebabCase \"${1:string variable name}\"$0" ]
},

"string::getSnakeCase": {
  "prefix": "string::getSnakeCase",
  "description": "This function convert a camelCase, PascalCase or kebab-case string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "string::getSnakeCase \"${1:string variable name}\"$0" ]
},

"string::getSnakeCase#withdoc": {
  "prefix": "string::getSnakeCase#withdoc",
  "description": "This function convert a camelCase, PascalCase or kebab-case string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "# ## string::getSnakeCase\n# \n# This function convert a camelCase, PascalCase or kebab-case string to a SNAKE_CASE string.\n# Removes all leading/trailing underscores.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${REPLY}: The converted string\n# \n# ```bash\n# MY_STRING=\"myCamelCaseString\"\n# string::getSnakeCase MY_STRING\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::getSnakeCase \"${1:string variable name}\"$0" ]
},

"string::head": {
  "prefix": "string::head",
  "description": "Get the first nth items (e...",
  "scope": "",
  "body": [ "string::head \"${1:string variable name}\" \"${2:nb items}\" separator=${3:\\$'\\n'}$0" ]
},

"string::head#withdoc": {
  "prefix": "string::head#withdoc",
  "description": "Get the first nth items (e...",
  "scope": "",
  "body": [ "# ## string::head\n# \n# Get the first nth items (e.g. lines) of a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to get the first occurrences.\n# - \\$2: **nb items** _as int_:\n#       The number of items (lines) to extract.\n# - \\${separator} _as string_:\n#       (optional) The separator character to use.\n#       (defaults to \\$'\\n')\n# \n# Returns:\n# \n# - \\${REPLY}: The extracted string.\n# \n# ```bash\n# MY_STRING=\"line1\"\\$'\\n'\"line2\"\\$'\\n'\"line3\"\n# string::head MY_STRING 2\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::head \"${1:string variable name}\" \"${2:nb items}\" separator=${3:\\$'\\n'}$0" ]
},

"string::highlight": {
  "prefix": "string::highlight",
  "description": "Highlight characters in a string...",
  "scope": "",
  "body": [ "string::highlight \"${1:text variable name}\" \"${2:characters variable name}\" highlightCode=${3:\\$'\\e'\"[95m\"}\"} resetCode=${4:\\$'\\e'\"[0m\"}$0" ]
},

"string::highlight#withdoc": {
  "prefix": "string::highlight#withdoc",
  "description": "Highlight characters in a string...",
  "scope": "",
  "body": [ "# ## string::highlight\n# \n# Highlight characters in a string.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to highlight.\n# - \\$2: **characters variable name** _as string_:\n#       The variable name that contains characters to highlight.\n# - \\${highlightCode} _as string_:\n#       (optional) The ANSI code to use for highlighting.\n#       The default value can be set using the variable STYLE_COLOR_ACCENT.\n#       (defaults to \\$'\\e'\"[95m\"}\")\n# - \\${resetCode} _as string_:\n#       (optional) The ANSI code to use for resetting the highlighting.\n#       The default value can be set using the variable STYLE_COLOR_DEFAULT.\n#       (defaults to \\$'\\e'\"[0m\")\n# \n# Returns:\n# \n# - \\${REPLY}: the highlighted text\n# \n# ```bash\n# string::highlight \"This is a text to highlight.\" \"ttttt\"\n# echo \"\\${REPLY}\"\n# ```\n# \n# > - All characters to highlight must be found in the same order in the matched line.\n# > - This functions is case insensitive.\n# \nstring::highlight \"${1:text variable name}\" \"${2:characters variable name}\" highlightCode=${3:\\$'\\e'\"[95m\"}\"} resetCode=${4:\\$'\\e'\"[0m\"}$0" ]
},

"string::numberToUniqueId": {
  "prefix": "string::numberToUniqueId",
  "description": "Converts a number into a unique and human readable string of the same length...",
  "scope": "",
  "body": [ "string::numberToUniqueId \"${1:number}\"$0" ]
},

"string::numberToUniqueId#withdoc": {
  "prefix": "string::numberToUniqueId#withdoc",
  "description": "Converts a number into a unique and human readable string of the same length...",
  "scope": "",
  "body": [ "# ## string::numberToUniqueId\n# \n# Converts a number into a unique and human readable string of the same length.\n# \n# - \\$1: **number** _as int_:\n#       The number to convert.\n# \n# Returns:\n# \n# - \\${REPLY}: the unique string.\n# \n# ```bash\n# string::numberToUniqueId 12345\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::numberToUniqueId \"${1:number}\"$0" ]
},

"string::removeTextFormatting": {
  "prefix": "string::removeTextFormatting",
  "description": "Removes all text formatting from the given string...",
  "scope": "",
  "body": [ "string::removeTextFormatting \"${1:text variable name}\"$0" ]
},

"string::removeTextFormatting#withdoc": {
  "prefix": "string::removeTextFormatting#withdoc",
  "description": "Removes all text formatting from the given string...",
  "scope": "",
  "body": [ "# ## string::removeTextFormatting\n# \n# Removes all text formatting from the given string.\n# This includes colors, bold, underline, etc.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to remove formatting from.\n# \n# ```bash\n# string::removeTextFormatting \"myText\"\n# echo \"\\${myText}\"\n# ```\n# \nstring::removeTextFormatting \"${1:text variable name}\"$0" ]
},

"string::split": {
  "prefix": "string::split",
  "description": "Split a string into an array using a separator...",
  "scope": "",
  "body": [ "string::split \"${1:string variable name}\" \"${2:separators}\"$0" ]
},

"string::split#withdoc": {
  "prefix": "string::split#withdoc",
  "description": "Split a string into an array using a separator...",
  "scope": "",
  "body": [ "# ## string::split\n# \n# Split a string into an array using a separator.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to split.\n# - \\$2: **separators** _as string_:\n#       The separator characters to use.\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: the array of strings\n# \n# ```bash\n# MY_STRING=\"name,first_name,address\"\n# string::split MY_STRING \",\"\n# ARRAY=(\"\\${REPLY_ARRAY[@]}\")\n# ```\n# \n# > This is faster than using read into an array from a here string.\n# \nstring::split \"${1:string variable name}\" \"${2:separators}\"$0" ]
},

"string::trimAll": {
  "prefix": "string::trimAll",
  "description": "Trim all whitespaces and truncate spaces...",
  "scope": "",
  "body": [ "string::trimAll \"${1:string variable name}\"$0" ]
},

"string::trimAll#withdoc": {
  "prefix": "string::trimAll#withdoc",
  "description": "Trim all whitespaces and truncate spaces...",
  "scope": "",
  "body": [ "# ## string::trimAll\n# \n# Trim all whitespaces and truncate spaces.\n# The replacement is done in place, for the given variable.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to trim.\n# \n# ```bash\n# MY_STRING=\"   example \"\\$'\\t'\"  string    \"\\$'\\n'\n# string::trimAll MY_STRING\n# echo \"\\${MY_STRING}\"\n# ```\n# \nstring::trimAll \"${1:string variable name}\"$0" ]
},

"string::trimEdges": {
  "prefix": "string::trimEdges",
  "description": "Trim leading and trailing characters (defaults to whitespaces)...",
  "scope": "",
  "body": [ "string::trimEdges \"${1:string variable name}\" charsToTrim=${2:\\$' \\t\\n'}$0" ]
},

"string::trimEdges#withdoc": {
  "prefix": "string::trimEdges#withdoc",
  "description": "Trim leading and trailing characters (defaults to whitespaces)...",
  "scope": "",
  "body": [ "# ## string::trimEdges\n# \n# Trim leading and trailing characters (defaults to whitespaces).\n# The replacement is done in place, for the given variable.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to trim.\n# - \\${charsToTrim} _as string_:\n#       The characters to trim.\n#       (defaults to \\$' \\t\\n')\n# \n# ```bash\n# MY_STRING=\"   example  string    \"\n# string::trimEdges MY_STRING\n# echo \"\\${MY_STRING}\"\n# ```\n# \nstring::trimEdges \"${1:string variable name}\" charsToTrim=${2:\\$' \\t\\n'}$0" ]
},

"string::truncateWithEllipsis": {
  "prefix": "string::truncateWithEllipsis",
  "description": "Truncate a string to a given length and add an ellipsis if truncated...",
  "scope": "",
  "body": [ "string::truncateWithEllipsis \"${1:string variable name}\" maxLength=${2:\"GLOBAL_COLUMNS\"} noEllipsis=${3:false}$0" ]
},

"string::truncateWithEllipsis#withdoc": {
  "prefix": "string::truncateWithEllipsis#withdoc",
  "description": "Truncate a string to a given length and add an ellipsis if truncated...",
  "scope": "",
  "body": [ "# ## string::truncateWithEllipsis\n# \n# Truncate a string to a given length and add an ellipsis if truncated.\n# This function takes into account invisible characters (ANSI escape codes for text formatting).\n# The truncation is done in place, for the given variable.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to truncate.\n# - \\${maxLength} _as int_:\n#       The maximum length of the string.\n#       (defaults to \"GLOBAL_COLUMNS\")\n# - \\${noEllipsis} _as bool_:\n#       (optional) If set to true, no ellipsis will be added when the string is truncated.\n#       (defaults to false)\n# \n# Returns:\n# - \\${REPLY}: the space left after truncation\n# \n# ```bash\n# MY_STRING=\"This is a long string that might need to be truncated\"\n# string::truncateWithEllipsis MY_STRING maxLength=20\n# echo \"\\${REPLY}\"\n# ```\n# \nstring::truncateWithEllipsis \"${1:string variable name}\" maxLength=${2:\"GLOBAL_COLUMNS\"} noEllipsis=${3:false}$0" ]
},

"string::wrapCharacters": {
  "prefix": "string::wrapCharacters",
  "description": "Allows to hard wrap the given string at the given width...",
  "scope": "",
  "body": [ "string::wrapCharacters \"${1:text variable name}\" width=${2:\"\\${GLOBAL_COLUMNS}\"} newLinePadString=${3:0} firstLineWidth=${4:\"\\${width}\"}$0" ]
},

"string::wrapCharacters#withdoc": {
  "prefix": "string::wrapCharacters#withdoc",
  "description": "Allows to hard wrap the given string at the given width...",
  "scope": "",
  "body": [ "# ## string::wrapCharacters\n# \n# Allows to hard wrap the given string at the given width.\n# Wrapping is done at character boundaries, see string::warpText for word wrapping.\n# Optionally appends padding characters on each new line.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to wrap.\n# - \\${width} _as string_:\n#       (optional) The width to wrap the text at.\n#       Note that length of the new line pad string is subtracted from the\n#       width to make sure the text fits in the given width.\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# - \\${newLinePadString} _as string_:\n#       (optional) The characters to apply as padding on the left of each new line.\n#       E.g. '  ' will add 2 spaces on the left of each new line.\n#       (defaults to 0)\n# - \\${firstLineWidth} _as int_:\n#       (optional) The width to use for the first line.\n#       (defaults to \"\\${width}\")\n# \n# Returns:\n# \n# - \\${REPLY}: the wrapped string\n# - \\${REPLY2}: the length taken on the last line\n# \n# ```bash\n# string::wrapCharacters \"This-is-a-long-text\"\n# string::wrapCharacters \"This-is-a-long-text-that-should-be-wrapped-at-20-characters.\" width=20 newLinePadString=\"---\" firstLineWidth=5\n# echo \"\\${REPLY}\"\n# ```\n# \n# > - This function is written in pure bash and is faster than calling the fold command.\n# > - It considers escape sequence for text formatting and does not count them as visible characters.\n# > - Leading spaces after a newly wrapped line are removed.\n# \nstring::wrapCharacters \"${1:text variable name}\" width=${2:\"\\${GLOBAL_COLUMNS}\"} newLinePadString=${3:0} firstLineWidth=${4:\"\\${width}\"}$0" ]
},

"string::wrapWords": {
  "prefix": "string::wrapWords",
  "description": "Allows to soft wrap the given text at the given width...",
  "scope": "",
  "body": [ "string::wrapWords \"${1:text variable name}\" width=${2:\"\\${GLOBAL_COLUMNS}\"} newLinePadString=${3:0} firstLineWidth=${4:\"\\${width}\"}$0" ]
},

"string::wrapWords#withdoc": {
  "prefix": "string::wrapWords#withdoc",
  "description": "Allows to soft wrap the given text at the given width...",
  "scope": "",
  "body": [ "# ## string::wrapWords\n# \n# Allows to soft wrap the given text at the given width.\n# Wrapping is done at word boundaries.\n# Optionally appends padding characters on each new line.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to wrap.\n# - \\${width} _as string_:\n#       (optional) The width to wrap the text at.\n#       Note that length of the new line pad string is subtracted from the\n#       width to make sure the text fits in the given width.\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# - \\${newLinePadString} _as string_:\n#       (optional) The characters to apply as padding on the left of each new line.\n#       E.g. '  ' will add 2 spaces on the left of each new line.\n#       (defaults to 0)\n# - \\${firstLineWidth} _as int_:\n#       (optional) The width to use for the first line.\n#       (defaults to \"\\${width}\")\n# \n# Returns:\n# \n# - \\${REPLY}: the wrapped text\n# \n# ```bash\n# string::wrapWords \"This is a long text.\"\n# string::wrapWords \"This is a long text wrapped at 20 characters.\" width=20 newLinePadString=\"---\" firstLineWidth=20\n# echo \"\\${REPLY}\"\n# ```\n# \n# > - This function is written in pure bash and is faster than calling the fold command.\n# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).\n# > - It considers escape sequence for text formatting and does not count them as visible characters.\n# \nstring::wrapWords \"${1:text variable name}\" width=${2:\"\\${GLOBAL_COLUMNS}\"} newLinePadString=${3:0} firstLineWidth=${4:\"\\${width}\"}$0" ]
},

"system::addToPath": {
  "prefix": "system::addToPath",
  "description": "Add the given path to the PATH environment variable for various shells, by adding the appropriate export command to the appropriate file...",
  "scope": "",
  "body": [ "system::addToPath \"${1:path}\"$0" ]
},

"system::addToPath#withdoc": {
  "prefix": "system::addToPath#withdoc",
  "description": "Add the given path to the PATH environment variable for various shells, by adding the appropriate export command to the appropriate file...",
  "scope": "",
  "body": [ "# ## system::addToPath\n# \n# Add the given path to the PATH environment variable for various shells,\n# by adding the appropriate export command to the appropriate file.\n# \n# Will also export the PATH variable in the current bash.\n# \n# - \\$1: **path** _as string_:\n#       the path to add to the PATH environment variable.\n# \n# ```bash\n# system::addToPath \"/path/to/bin\"\n# ```\n# \nsystem::addToPath \"${1:path}\"$0" ]
},

"system::getArchitecture": {
  "prefix": "system::getArchitecture",
  "description": "Returns the CPU architecture of the current machine...",
  "scope": "",
  "body": [ "system::getArchitecture$0" ]
},

"system::getArchitecture#withdoc": {
  "prefix": "system::getArchitecture#withdoc",
  "description": "Returns the CPU architecture of the current machine...",
  "scope": "",
  "body": [ "# ## system::getArchitecture\n# \n# Returns the CPU architecture of the current machine.\n# \n# Returns:\n# \n# - \\${REPLY}: the CPU architecture of the current machine.\n# \n# ```bash\n# system::getArchitecture\n# local architecture=\"\\${REPLY}\"\n# ```\n# \nsystem::getArchitecture$0" ]
},

"system::getEnvVars": {
  "prefix": "system::getEnvVars",
  "description": "Get the list of all the environment variables...",
  "scope": "",
  "body": [ "system::getEnvVars$0" ]
},

"system::getEnvVars#withdoc": {
  "prefix": "system::getEnvVars#withdoc",
  "description": "Get the list of all the environment variables...",
  "scope": "",
  "body": [ "# ## system::getEnvVars\n# \n# Get the list of all the environment variables.\n# In pure bash, no need for env or printenv.\n# \n# Returns:\n# \n# - \\${REPLY_ARRAY[@]}: An array with the list of all the environment variables.\n# \n# ```bash\n# system::getEnvVars\n# for var in \"\\${REPLY_ARRAY[@]}\"; do\n#   printf '%s=%s\\n' \"\\${var}\" \"\\${!var}\"\n# done\n# ```\n# \nsystem::getEnvVars$0" ]
},

"system::getOs": {
  "prefix": "system::getOs",
  "description": "Returns the name of the current OS...",
  "scope": "",
  "body": [ "system::getOs$0" ]
},

"system::getOs#withdoc": {
  "prefix": "system::getOs#withdoc",
  "description": "Returns the name of the current OS...",
  "scope": "",
  "body": [ "# ## system::getOs\n# \n# Returns the name of the current OS.\n# \n# Returns:\n# \n# - \\${REPLY}: the name of the current OS: \"darwin\", \"linux\" or \"windows\".\n# \n# ```bash\n# system::getOs\n# local osName=\"\\${REPLY}\"\n# ```\n# \nsystem::getOs$0" ]
},

"system::isDarwin": {
  "prefix": "system::isDarwin",
  "description": "Check if the current OS is macOS...",
  "scope": "",
  "body": [ "system::isDarwin$0" ]
},

"system::isDarwin#withdoc": {
  "prefix": "system::isDarwin#withdoc",
  "description": "Check if the current OS is macOS...",
  "scope": "",
  "body": [ "# ## system::isDarwin\n# \n# Check if the current OS is macOS.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the current OS is macOS\n#   - 1 otherwise.\n# \n# ```bash\n# if system::isDarwin; then\n#   printf 'The current OS is macOS.'\n# fi\n# ```\n# \nsystem::isDarwin$0" ]
},

"system::isLinux": {
  "prefix": "system::isLinux",
  "description": "Check if the current OS is Linux...",
  "scope": "",
  "body": [ "system::isLinux$0" ]
},

"system::isLinux#withdoc": {
  "prefix": "system::isLinux#withdoc",
  "description": "Check if the current OS is Linux...",
  "scope": "",
  "body": [ "# ## system::isLinux\n# \n# Check if the current OS is Linux.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the current OS is Linux\n#   - 1 otherwise.\n# \n# ```bash\n# if system::isLinux; then\n#   printf 'The current OS is Linux.'\n# fi\n# ```\n# \nsystem::isLinux$0" ]
},

"system::isRoot": {
  "prefix": "system::isRoot",
  "description": "Check if the script is running as root...",
  "scope": "",
  "body": [ "system::isRoot$0" ]
},

"system::isRoot#withdoc": {
  "prefix": "system::isRoot#withdoc",
  "description": "Check if the script is running as root...",
  "scope": "",
  "body": [ "# ## system::isRoot\n# \n# Check if the script is running as root.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the script is running as root\n#   - 1 otherwise.\n# \n# ```bash\n# if system::isRoot; then\n#   printf 'The script is running as root.'\n# fi\n# ```\n# \nsystem::isRoot$0" ]
},

"system::isWindows": {
  "prefix": "system::isWindows",
  "description": "Check if the current OS is Windows...",
  "scope": "",
  "body": [ "system::isWindows$0" ]
},

"system::isWindows#withdoc": {
  "prefix": "system::isWindows#withdoc",
  "description": "Check if the current OS is Windows...",
  "scope": "",
  "body": [ "# ## system::isWindows\n# \n# Check if the current OS is Windows.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the current OS is Windows\n#   - 1 otherwise.\n# \n# ```bash\n# if system::isWindows; then\n#   printf 'The current OS is Windows.'\n# fi\n# ```\n# \nsystem::isWindows$0" ]
},

"terminal::clearBox": {
  "prefix": "terminal::clearBox",
  "description": "Clear a \"box\" in the terminal...",
  "scope": "",
  "body": [ "terminal::clearBox top=${1:1} left=${2:1} width=${3:\"\\${GLOBAL_COLUMNS}\"} height=${4:\"\\${GLOBAL_LINES}\"}$0" ]
},

"terminal::clearBox#withdoc": {
  "prefix": "terminal::clearBox#withdoc",
  "description": "Clear a \"box\" in the terminal...",
  "scope": "",
  "body": [ "# ## terminal::clearBox\n# \n# Clear a \"box\" in the terminal.\n# Will return the cursor at the current position at the end (using GLOBAL_CURSOR_LINE and GLOBAL_CURSOR_COLUMN).\n# \n# - \\${top} _as int_:\n#       (optional) the top position of the box\n#       (defaults to 1)\n# - \\${left} _as int_:\n#       (optional) the left position of the box\n#       (defaults to 1)\n# - \\${width} _as int_:\n#       (optional) the width of the box\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# - \\${height} _as int_:\n#       (optional) the height of the box\n#       (defaults to \"\\${GLOBAL_LINES}\")\n# \n# ```bash\n# terminal::getCursorPosition\n# terminal::clearBox top=1 left=1 width=10 height=5\n# ```\n# \nterminal::clearBox top=${1:1} left=${2:1} width=${3:\"\\${GLOBAL_COLUMNS}\"} height=${4:\"\\${GLOBAL_LINES}\"}$0" ]
},

"terminal::clearKeyPressed": {
  "prefix": "terminal::clearKeyPressed",
  "description": "This function reads all the inputs from the user, effectively discarding them...",
  "scope": "",
  "body": [ "terminal::clearKeyPressed \"${1:read parameters}\"$0" ]
},

"terminal::clearKeyPressed#withdoc": {
  "prefix": "terminal::clearKeyPressed#withdoc",
  "description": "This function reads all the inputs from the user, effectively discarding them...",
  "scope": "",
  "body": [ "# ## terminal::clearKeyPressed\n# \n# This function reads all the inputs from the user, effectively discarding them.\n# \n# - \\$@: read parameters _as any_:\n#       additional parameters to pass to the read command\n# \n# ```bash\n# terminal::clearKeyPressed\n# ```\n# \nterminal::clearKeyPressed \"${1:read parameters}\"$0" ]
},

"terminal::createSpace": {
  "prefix": "terminal::createSpace",
  "description": "This function creates empty lines from the current cursor position...",
  "scope": "",
  "body": [ "terminal::createSpace \"${1:number of lines}\"$0" ]
},

"terminal::createSpace#withdoc": {
  "prefix": "terminal::createSpace#withdoc",
  "description": "This function creates empty lines from the current cursor position...",
  "scope": "",
  "body": [ "# ## terminal::createSpace\n# \n# This function creates empty lines from the current cursor position.\n# Then it moves back to its original line (at the column 1).\n# The current cursor line counts, meaning that `terminal::createSpace 1` will\n# not do anything but clear the current line.\n# \n# This effectively creates a space in the terminal (scroll up if we are at the bottom).\n# It does not create more space than the number of lines in the terminal.\n# \n# - \\$1: **number of lines** _as int_:\n#       the number of lines to create\n# \n# ```bash\n# terminal::createSpace 5\n# ```\n# \nterminal::createSpace \"${1:number of lines}\"$0" ]
},

"terminal::getBestAutocompleteBox": {
  "prefix": "terminal::getBestAutocompleteBox",
  "description": "This function returns the best position and size for an autocomplete box that would open at the given position...",
  "scope": "",
  "body": [ "terminal::getBestAutocompleteBox top=${1:1} left=${2:1} desiredHeight=${3:\"\\${GLOBAL_LINES}\"} desiredWidth=${4:\"\\${GLOBAL_COLUMNS}\"} maxHeight=${5:\"\\${GLOBAL_LINES}\"} forceBelow=${6:false} notOnCurrentLine=${7:true} terminalHeight=${8:\"\\${GLOBAL_LINES}\"} terminalWidth=${9:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"terminal::getBestAutocompleteBox#withdoc": {
  "prefix": "terminal::getBestAutocompleteBox#withdoc",
  "description": "This function returns the best position and size for an autocomplete box that would open at the given position...",
  "scope": "",
  "body": [ "# ## terminal::getBestAutocompleteBox\n# \n# This function returns the best position and size for an autocomplete box that would open\n# at the given position.\n# \n# - The box will be placed below the current position if possible, but can be placed\n#   above if there is not enough space below.\n# - The box will be placed on the same column as the current position if possible, but can be placed\n#   on the left side if there is not enough space on the right to display the full width of the box.\n# - The box will have the desired height and width if possible, but will be reduced if there is\n#   not enough space in the terminal.\n# - The box will not be placed on the same line as the current position if notOnCurrentLine is set to true.\n#   Otherwise it can use the current position line.\n# \n# - \\${top} _as int_:\n#       (optional) the current line of the cursor (1 based)\n#       (defaults to 1)\n# - \\${left} _as int_:\n#       (optional) the current column of the cursor (1 based)\n#       (defaults to 1)\n# - \\${desiredHeight} _as int_:\n#       (optional) the desired height of the box\n#       (defaults to \"\\${GLOBAL_LINES}\")\n# - \\${desiredWidth} _as int_:\n#       (optional) the desired width of the box\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# - \\${maxHeight} _as int_:\n#       (optional) the maximum height of the box\n#       (defaults to \"\\${GLOBAL_LINES}\")\n# - \\${forceBelow} _as bool_:\n#       (optional) force the box to be below the current position\n#       (defaults to false)\n# - \\${notOnCurrentLine} _as bool_:\n#       (optional) the box will not be placed on the same line as the current position\n#       (defaults to true)\n# - \\${terminalHeight} _as int_:\n#       (optional) the height of the terminal\n#       (defaults to \"\\${GLOBAL_LINES}\")\n# - \\${terminalWidth} _as int_:\n#       (optional) the width of the terminal\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# \n# Returns:\n# \n# - \\${REPLY}: the top position of the box (1 based)\n# - \\${REPLY2}: the left position of the box (1 based)\n# - \\${REPLY3}: the width of the box\n# - \\${REPLY4}: the height of the box\n# \n# ```bash\n# terminal::getBestAutocompleteBox top=1 left=1 desiredHeight=10 desiredWidth=5\n# ```\n# \nterminal::getBestAutocompleteBox top=${1:1} left=${2:1} desiredHeight=${3:\"\\${GLOBAL_LINES}\"} desiredWidth=${4:\"\\${GLOBAL_COLUMNS}\"} maxHeight=${5:\"\\${GLOBAL_LINES}\"} forceBelow=${6:false} notOnCurrentLine=${7:true} terminalHeight=${8:\"\\${GLOBAL_LINES}\"} terminalWidth=${9:\"\\${GLOBAL_COLUMNS}\"}$0" ]
},

"terminal::getCursorPosition": {
  "prefix": "terminal::getCursorPosition",
  "description": "Get the current cursor position...",
  "scope": "",
  "body": [ "terminal::getCursorPosition$0" ]
},

"terminal::getCursorPosition#withdoc": {
  "prefix": "terminal::getCursorPosition#withdoc",
  "description": "Get the current cursor position...",
  "scope": "",
  "body": [ "# ## terminal::getCursorPosition\n# \n# Get the current cursor position.\n# \n# Returns:\n# \n# - `GLOBAL_CURSOR_LINE`: the line number\n# - `GLOBAL_CURSOR_COLUMN`: the column number\n# \n# ```bash\n# terminal::getCursorPosition\n# ```\n# \nterminal::getCursorPosition$0" ]
},

"terminal::getTerminalSize": {
  "prefix": "terminal::getTerminalSize",
  "description": "This function exports the terminal size...",
  "scope": "",
  "body": [ "terminal::getTerminalSize$0" ]
},

"terminal::getTerminalSize#withdoc": {
  "prefix": "terminal::getTerminalSize#withdoc",
  "description": "This function exports the terminal size...",
  "scope": "",
  "body": [ "# ## terminal::getTerminalSize\n# \n# This function exports the terminal size.\n# \n# Returns:\n# \n# - `GLOBAL_COLUMNS`: The number of columns in the terminal.\n# - `GLOBAL_LINES`: The number of lines in the terminal.\n# \n# ```bash\n# terminal::getTerminalSize\n# printf '%s\\n' \"The terminal has ⌜\\${GLOBAL_COLUMNS}⌝ columns and ⌜\\${GLOBAL_LINES}⌝ lines.\"\n# ```\n# \nterminal::getTerminalSize$0" ]
},

"terminal::isCursorInBox": {
  "prefix": "terminal::isCursorInBox",
  "description": "Check if the cursor is inside a given box...",
  "scope": "",
  "body": [ "terminal::isCursorInBox cursorTop=${1} cursorLeft=${2} top=${3:1} left=${4:1} width=${5:\"\\${GLOBAL_COLUMNS}\"} height=${6:\"\\${GLOBAL_LINES}\"}$0" ]
},

"terminal::isCursorInBox#withdoc": {
  "prefix": "terminal::isCursorInBox#withdoc",
  "description": "Check if the cursor is inside a given box...",
  "scope": "",
  "body": [ "# ## terminal::isCursorInBox\n# \n# Check if the cursor is inside a given box.\n# \n# - \\${cursorTop} _as int_:\n#       the line number of the cursor (1 based)\n# - \\${cursorLeft} _as int_:\n#       the column number of the cursor (1 based)\n# - \\${top} _as int_:\n#       (optional) the top position of the box\n#       (defaults to 1)\n# - \\${left} _as int_:\n#       (optional) the left position of the box\n#       (defaults to 1)\n# - \\${width} _as int_:\n#       (optional) the width of the box\n#       (defaults to \"\\${GLOBAL_COLUMNS}\")\n# - \\${height} _as int_:\n#       (optional) the height of the box\n#       (defaults to \"\\${GLOBAL_LINES}\")\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the cursor is inside the box\n#   - 1 otherwise\n# \n# ```bash\n# if terminal::isCursorInBox 10 10 top=5 left=5 width=10 height=10; then\n#   echo \"Cursor is inside the box\"\n# else\n#   echo \"Cursor is outside the box\"\n# fi\n# ```\n# \nterminal::isCursorInBox cursorTop=${1} cursorLeft=${2} top=${3:1} left=${4:1} width=${5:\"\\${GLOBAL_COLUMNS}\"} height=${6:\"\\${GLOBAL_LINES}\"}$0" ]
},

"terminal::rebindKeymap": {
  "prefix": "terminal::rebindKeymap",
  "description": "Rebinds all special keys to call a given callback function...",
  "scope": "",
  "body": [ "terminal::rebindKeymap \"${1:callback function}\"$0" ]
},

"terminal::rebindKeymap#withdoc": {
  "prefix": "terminal::rebindKeymap#withdoc",
  "description": "Rebinds all special keys to call a given callback function...",
  "scope": "",
  "body": [ "# ## terminal::rebindKeymap\n# \n# Rebinds all special keys to call a given callback function.\n# See @terminal::testWaitForKeyPress for an implementation example.\n# \n# This allows to use the `-e` option with the read command and receive events for special key press.\n# \n# \n# This function should be called before using terminal::waitForKeyPress.\n# \n# You can call `terminal::restoreBindings` to restore the default bindings. However, this is not\n# necessary as the bindings are local to the script.\n# \n# - \\$1: **callback function** _as string_:\n#       The function name to call when a special key is pressed.\n# \n# ```bash\n# terminal::rebindKeymap\n# ```\n# \n# > Key binding is a mess because binding is based on the sequence of characters that gets\n# > generated by the terminal when a key is pressed and this is not standard across all terminals.\n# > We do our best here to cover most cases but it is by no mean perfect.\n# > A good base documentation was <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>.\n# > This means that certain keys cannot be bound, like SHIFT+ENTER. For this, you will\n# > need to use a terminal that allows to remap such keys and send a specific sequence\n# > of characters that you can bind in bash.\n# > `showkey -a` is a good program to see the sequence of characters sent by the terminal.\n# \nterminal::rebindKeymap \"${1:callback function}\"$0" ]
},

"terminal::rerouteLogs": {
  "prefix": "terminal::rerouteLogs",
  "description": "Reroute the logs to a temporary file...",
  "scope": "",
  "body": [ "terminal::rerouteLogs$0" ]
},

"terminal::rerouteLogs#withdoc": {
  "prefix": "terminal::rerouteLogs#withdoc",
  "description": "Reroute the logs to a temporary file...",
  "scope": "",
  "body": [ "# ## terminal::rerouteLogs\n# \n# Reroute the logs to a temporary file.\n# The logs will be displayed when calling `terminal::restoreLogs`\n# \n# ```bash\n# terminal::rerouteLogs\n# ```\n# \nterminal::rerouteLogs$0" ]
},

"terminal::restoreBindings": {
  "prefix": "terminal::restoreBindings",
  "description": "Reset the key bindings to the default ones...",
  "scope": "",
  "body": [ "terminal::restoreBindings$0" ]
},

"terminal::restoreBindings#withdoc": {
  "prefix": "terminal::restoreBindings#withdoc",
  "description": "Reset the key bindings to the default ones...",
  "scope": "",
  "body": [ "# ## terminal::restoreBindings\n# \n# Reset the key bindings to the default ones.\n# To be called after `terminal::rebindKeymap`.\n# \n# ```bash\n# terminal::restoreBindings\n# ```\n# \nterminal::restoreBindings$0" ]
},

"terminal::restoreInterruptTrap": {
  "prefix": "terminal::restoreInterruptTrap",
  "description": "Restore the original trap for the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "terminal::restoreInterruptTrap$0" ]
},

"terminal::restoreInterruptTrap#withdoc": {
  "prefix": "terminal::restoreInterruptTrap#withdoc",
  "description": "Restore the original trap for the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "# ## terminal::restoreInterruptTrap\n# \n# Restore the original trap for the interrupt signal (SIGINT).\n# To be called after terminal::setInterruptTrap.\n# \n# ```bash\n# terminal::restoreInterruptTrap\n# ```\n# \nterminal::restoreInterruptTrap$0" ]
},

"terminal::restoreLogs": {
  "prefix": "terminal::restoreLogs",
  "description": "Restore the logs to their original state...",
  "scope": "",
  "body": [ "terminal::restoreLogs$0" ]
},

"terminal::restoreLogs#withdoc": {
  "prefix": "terminal::restoreLogs#withdoc",
  "description": "Restore the logs to their original state...",
  "scope": "",
  "body": [ "# ## terminal::restoreLogs\n# \n# Restore the logs to their original state.\n# Should be called after `terminal::rerouteLogs` and at the end of an interactive session.\n# \n# ```bash\n# terminal::restoreLogs\n# ```\n# \nterminal::restoreLogs$0" ]
},

"terminal::restoreSettings": {
  "prefix": "terminal::restoreSettings",
  "description": "Restore the terminal options to their original state...",
  "scope": "",
  "body": [ "terminal::restoreSettings$0" ]
},

"terminal::restoreSettings#withdoc": {
  "prefix": "terminal::restoreSettings#withdoc",
  "description": "Restore the terminal options to their original state...",
  "scope": "",
  "body": [ "# ## terminal::restoreSettings\n# \n# Restore the terminal options to their original state.\n# Should be called after `terminal::setRawMode`.\n# \n# ```bash\n# terminal::restoreSettings\n# ```\n# \n# > Note that the bash read builtin will restore stty state as it was before entering.\n# > So you want to call this after all read has been finished (particularly, you want to kill\n# > any background process that is reading inputs before trying to restore these settings).\n# \nterminal::restoreSettings$0" ]
},

"terminal::saveSettings": {
  "prefix": "terminal::saveSettings",
  "description": "Save the current terminal options (`stty -g`) so they can be restored later...",
  "scope": "",
  "body": [ "terminal::saveSettings$0" ]
},

"terminal::saveSettings#withdoc": {
  "prefix": "terminal::saveSettings#withdoc",
  "description": "Save the current terminal options (`stty -g`) so they can be restored later...",
  "scope": "",
  "body": [ "# ## terminal::saveSettings\n# \n# Save the current terminal options (`stty -g`) so they can be restored later.\n# Call `terminal::restoreSettings` to restore the original settings.\n# \n# ```bash\n# terminal::saveSettings\n# ```\n# \nterminal::saveSettings$0" ]
},

"terminal::setRawMode": {
  "prefix": "terminal::setRawMode",
  "description": "Put the terminal in \"raw\" mode...",
  "scope": "",
  "body": [ "terminal::setRawMode$0" ]
},

"terminal::setRawMode#withdoc": {
  "prefix": "terminal::setRawMode#withdoc",
  "description": "Put the terminal in \"raw\" mode...",
  "scope": "",
  "body": [ "# ## terminal::setRawMode\n# \n# Put the terminal in \"raw\" mode.\n# Set options to enable a satisfying and consistent behavior for the GNU readline library.\n# Call `terminal::restoreSettings` to restore the original settings.\n# \n# ```bash\n# terminal::setRawMode\n# ```\n# \nterminal::setRawMode$0" ]
},

"terminal::switchBackFromFullScreen": {
  "prefix": "terminal::switchBackFromFullScreen",
  "description": "Call this function to switch back from the full screen mode...",
  "scope": "",
  "body": [ "terminal::switchBackFromFullScreen$0" ]
},

"terminal::switchBackFromFullScreen#withdoc": {
  "prefix": "terminal::switchBackFromFullScreen#withdoc",
  "description": "Call this function to switch back from the full screen mode...",
  "scope": "",
  "body": [ "# ## terminal::switchBackFromFullScreen\n# \n# Call this function to switch back from the full screen mode.\n# \n# - This function will restore the terminal state and show the cursor.\n# - It will also restore the key echoing.\n# \n# ```bash\n# terminal::switchBackFromFullScreen\n# ```\n# \nterminal::switchBackFromFullScreen$0" ]
},

"terminal::switchToFullScreen": {
  "prefix": "terminal::switchToFullScreen",
  "description": "Call this function to start an interactive session in full screen mode...",
  "scope": "",
  "body": [ "terminal::switchToFullScreen$0" ]
},

"terminal::switchToFullScreen#withdoc": {
  "prefix": "terminal::switchToFullScreen#withdoc",
  "description": "Call this function to start an interactive session in full screen mode...",
  "scope": "",
  "body": [ "# ## terminal::switchToFullScreen\n# \n# Call this function to start an interactive session in full screen mode.\n# This function will switch to the alternate screen, hide the cursor and clear the screen.\n# \n# You should call terminal::switchBackFromFullScreen at the end of the interactive session.\n# \n# ```bash\n# terminal::switchToFullScreen\n# ```\n# \nterminal::switchToFullScreen$0" ]
},

"terminal::testWaitForChar": {
  "prefix": "terminal::testWaitForChar",
  "description": "Wait for the user to send a character to stdin (i...",
  "scope": "",
  "body": [ "terminal::testWaitForChar$0" ]
},

"terminal::testWaitForChar#withdoc": {
  "prefix": "terminal::testWaitForChar#withdoc",
  "description": "Wait for the user to send a character to stdin (i...",
  "scope": "",
  "body": [ "# ## terminal::testWaitForChar\n# \n# Wait for the user to send a character to stdin (i.e. wait for a key press)\n# and prints the character that bash reads.\n# \n# Useful to test the `terminal::waitForChar` function and see the char sequence we\n# get when pressing a key in a given terminal.\n# \n# See @terminal::waitForChar for more information.\n# \n# ```bash\n# terminal::testWaitForChar\n# ```\n# \nterminal::testWaitForChar$0" ]
},

"terminal::waitForChar": {
  "prefix": "terminal::waitForChar",
  "description": "Wait for a user input (single char)...",
  "scope": "",
  "body": [ "terminal::waitForChar \"${1:read parameters}\"$0" ]
},

"terminal::waitForChar#withdoc": {
  "prefix": "terminal::waitForChar#withdoc",
  "description": "Wait for a user input (single char)...",
  "scope": "",
  "body": [ "# ## terminal::waitForChar\n# \n# Wait for a user input (single char).\n# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).\n# \n# It uses the read builtin command. This will not detect all key combinations.\n# The output will depend on the terminal used and the character sequences it sends on each key press.\n# \n# Some special keys are translated into more readable strings:\n# UP, DOWN, RIGHT, LEFT, BACKSPACE, DEL, PAGE_UP, PAGE_DOWN, HOME, END, ESC, F1, ALT+?.\n# However, this is not at all exhaustive and will depend on the terminal used.\n# Use `terminal::waitForKeyPress` if you need to listen to special keys.\n# \n# This simple implementation does not rely on GNU readline and does not require terminal options\n# to be set using `terminal::setRawMode`.\n# \n# \n# - \\$@: read parameters _as any_:\n#       additional parameters to pass to the read command\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a char was retrieved\n#   - 1 otherwise\n# - `LAST_KEY_PRESSED`: the last char (key) retrieved.\n# \n# ```bash\n# terminal::waitForChar\n# terminal::waitForChar -t 0.1\n# ```\n# \n# > <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>\n# \nterminal::waitForChar \"${1:read parameters}\"$0" ]
},

"terminal::waitForKeyPress": {
  "prefix": "terminal::waitForKeyPress",
  "description": "Wait for a key press (single key)...",
  "scope": "",
  "body": [ "terminal::waitForKeyPress \"${1:read parameters}\"$0" ]
},

"terminal::waitForKeyPress#withdoc": {
  "prefix": "terminal::waitForKeyPress#withdoc",
  "description": "Wait for a key press (single key)...",
  "scope": "",
  "body": [ "# ## terminal::waitForKeyPress\n# \n# Wait for a key press (single key).\n# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).\n# \n# It uses the read builtin command with the option `-e` to use readline behind the scene.\n# This means we can detect more key combinations but all keys needs to be bound first...\n# Special keys (CTRL+, ALT+, F1-F12, arrows, etc.) are intercepted using binding.\n# \n# You must call `terminal::rebindKeymap` and `terminal::setRawMode` before using this function.\n# You should use `tui::start` instead of using this function directly.\n# \n# - \\$@: read parameters _as any_:\n#       additional parameters to pass to the read command\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a key was pressed\n#   - 1 otherwise\n# - `LAST_KEY_PRESSED`: the key pressed.\n# \n# ```bash\n# terminal::waitForKeyPress\n# terminal::waitForKeyPress -t 0.1\n# ```\n# \n# > There are issues when using readline in bash:\n# >\n# > 1. if the cursor is at the end of the screen, it will make the screen scroll\n# >    even when nothing is read... Make sure to not position the cursor at the end of the screen.\n# > 2. When read is done, it will print a new line in stderr. So we redirect stderr to null.\n# >    This means that if you print something to stderr in a readline bound function, you will see nothing\n# >    As a workaround, do this in your callback function: `exec 2>&\"\\${GLOBAL_FD_LOG}\"`\n# > 3. Not all key combinations can be bound, like SHIFT+ENTER. This is inherent to the way terminals work,\n# >    they send a sequence of characters when a key is pressed and this sequence is read by readline/bash.\n# >    For advanced key combinations, you will need to use a terminal that allows to remap such keys\n# >    and send a specific sequence of characters that you can bind in bash.\n# \nterminal::waitForKeyPress \"${1:read parameters}\"$0" ]
},

"test::exec": {
  "prefix": "test::exec",
  "description": "Call this function to execute a command and write the command and its output to the report file...",
  "scope": "",
  "body": [ "test::exec \"${1:command}\"$0" ]
},

"test::exec#withdoc": {
  "prefix": "test::exec#withdoc",
  "description": "Call this function to execute a command and write the command and its output to the report file...",
  "scope": "",
  "body": [ "# ## test::exec\n# \n# Call this function to execute a command and write the command and its output to the report file.\n# The command can fail, in which case the returned exit code is written to the report file.\n# However, the command must not call `exit` (in which case, use test::exit).\n# \n# - \\$@: **command** _as string_:\n#       The command to execute.\n# \n# ```bash\n# test::exec echo \"Hello, world!\"\n# ```\n# \ntest::exec \"${1:command}\"$0" ]
},

"test::exit": {
  "prefix": "test::exit",
  "description": "Call this function to execute a command that can call `exit` and write the command and its output to the report file...",
  "scope": "",
  "body": [ "test::exit \"${1:command}\"$0" ]
},

"test::exit#withdoc": {
  "prefix": "test::exit#withdoc",
  "description": "Call this function to execute a command that can call `exit` and write the command and its output to the report file...",
  "scope": "",
  "body": [ "# ## test::exit\n# \n# Call this function to execute a command that can call `exit` and write the command and its output to the report file.\n# The command is executed in a subshell to catch the exit.\n# \n# - \\$@: **command** _as string_:\n#       The command to execute.\n# \n# ```bash\n# test::exit exit 3\n# ```\n# \ntest::exit \"${1:command}\"$0" ]
},

"test::fail": {
  "prefix": "test::fail",
  "description": "Call this function to log a message and exit with the status 142, which indicates to the self test command that the test failed and that we know the reason (it is a bad implementation of the test itself)...",
  "scope": "",
  "body": [ "test::fail \"${1:message}\"$0" ]
},

"test::fail#withdoc": {
  "prefix": "test::fail#withdoc",
  "description": "Call this function to log a message and exit with the status 142, which indicates to the self test command that the test failed and that we know the reason (it is a bad implementation of the test itself)...",
  "scope": "",
  "body": [ "# ## test::fail\n# \n# Call this function to log a message and exit with the status 142, which\n# indicates to the self test command that the test failed and that we know the\n# reason (it is a bad implementation of the test itself).\n# \n# - \\$@: **message** _as string_:\n#       The message to log.\n# \n# ```bash\n# test::fail \"This is a failure message with a clear reason.\"\n# ```\n# \ntest::fail \"${1:message}\"$0" ]
},

"test::flush": {
  "prefix": "test::flush",
  "description": "Call this function to flush the standard and error outputs to the report file...",
  "scope": "",
  "body": [ "test::flush$0" ]
},

"test::flush#withdoc": {
  "prefix": "test::flush#withdoc",
  "description": "Call this function to flush the standard and error outputs to the report file...",
  "scope": "",
  "body": [ "# ## test::flush\n# \n# Call this function to flush the standard and error outputs to the report file.\n# They will be added as code blocks in the report file (one for the standard\n# output, one for the standard error).\n# \n# ```bash\n# test::flush\n# ```\n# \ntest::flush$0" ]
},

"test::flushStderr": {
  "prefix": "test::flushStderr",
  "description": "Call this function to flush the standard error to the report file...",
  "scope": "",
  "body": [ "test::flushStderr blockTitle=${1:\"\"}$0" ]
},

"test::flushStderr#withdoc": {
  "prefix": "test::flushStderr#withdoc",
  "description": "Call this function to flush the standard error to the report file...",
  "scope": "",
  "body": [ "# ## test::flushStderr\n# \n# Call this function to flush the standard error to the report file.\n# It will be added as a code block in the report file.\n# \n# - \\${blockTitle} _as string_:\n#       (optional) Add a 'title' to the code block (`**title**:` before the code block).\n#       (defaults to \"\")\n# \n# ```bash\n# test::flushStderr\n# ```\n# \ntest::flushStderr blockTitle=${1:\"\"}$0" ]
},

"test::flushStdout": {
  "prefix": "test::flushStdout",
  "description": "Call this function to flush the standard output to the report file...",
  "scope": "",
  "body": [ "test::flushStdout blockTitle=${1:\"\"}$0" ]
},

"test::flushStdout#withdoc": {
  "prefix": "test::flushStdout#withdoc",
  "description": "Call this function to flush the standard output to the report file...",
  "scope": "",
  "body": [ "# ## test::flushStdout\n# \n# Call this function to flush the standard output to the report file.\n# It will be added as a code block in the report file.\n# \n# - \\${blockTitle} _as string_:\n#       (optional) Add a 'title' to the code block (`**title**:` before the code block).\n#       (defaults to \"\")\n# \n# ```bash\n# test::flushStdout\n# ```\n# \ntest::flushStdout blockTitle=${1:\"\"}$0" ]
},

"test::func": {
  "prefix": "test::func",
  "description": "Call this function to test a function that returns a value using the valet conventions (REPLY, REPLY2, REPLY_ARRAY, etc...",
  "scope": "",
  "body": [ "test::func \"${1:command}\"$0" ]
},

"test::func#withdoc": {
  "prefix": "test::func#withdoc",
  "description": "Call this function to test a function that returns a value using the valet conventions (REPLY, REPLY2, REPLY_ARRAY, etc...",
  "scope": "",
  "body": [ "# ## test::func\n# \n# Call this function to test a function that returns a value using the valet\n# conventions (REPLY, REPLY2, REPLY_ARRAY, etc...).\n# \n# It will write the command and its output to the report file.\n# It will also print the REPLY values.\n# \n# - \\$@: **command** _as string_:\n#       The command to execute (function and its arguments).\n# \n# ```bash\n# test::func myFunction\n# ```\n# \ntest::func \"${1:command}\"$0" ]
},

"test::log": {
  "prefix": "test::log",
  "description": "Call this function to log a message during a test...",
  "scope": "",
  "body": [ "test::log \"${1:messages}\"$0" ]
},

"test::log#withdoc": {
  "prefix": "test::log#withdoc",
  "description": "Call this function to log a message during a test...",
  "scope": "",
  "body": [ "# ## test::log\n# \n# Call this function to log a message during a test.\n# This log will only show in case of a script error or when the debug\n# log level is enabled when running the tests.\n# \n# - \\$@: **messages** _as string_:\n#       The messages to log.\n# \n# ```bash\n# test::log \"This is a log message.\"\n# ```\n# \ntest::log \"${1:messages}\"$0" ]
},

"test::markdown": {
  "prefix": "test::markdown",
  "description": "Call this function to add some markdown in the report file...",
  "scope": "",
  "body": [ "test::markdown \"${1:markdown}\"$0" ]
},

"test::markdown#withdoc": {
  "prefix": "test::markdown#withdoc",
  "description": "Call this function to add some markdown in the report file...",
  "scope": "",
  "body": [ "# ## test::markdown\n# \n# Call this function to add some markdown in the report file.\n# \n# - \\$@: **markdown** _as string_:\n#       The markdown to add in the report file.\n# \n# ```bash\n# test::markdown \"> This is a **quote**.\"\n# ```\n# \ntest::markdown \"${1:markdown}\"$0" ]
},

"test::printReplyVars": {
  "prefix": "test::printReplyVars",
  "description": "This function can be called to print the REPLY values, e...",
  "scope": "",
  "body": [ "test::printReplyVars$0" ]
},

"test::printReplyVars#withdoc": {
  "prefix": "test::printReplyVars#withdoc",
  "description": "This function can be called to print the REPLY values, e...",
  "scope": "",
  "body": [ "# ## test::printReplyVars\n# \n# This function can be called to print the REPLY values,\n# e.g. REPLY, REPLY2, REPLY_ARRAY...\n# They will each be printed in a code block in the report file.\n# \n# ```bash\n# test::printReplyVars\n# ```\n# \ntest::printReplyVars$0" ]
},

"test::printVars": {
  "prefix": "test::printVars",
  "description": "This function can be called to print the global variables in the report file...",
  "scope": "",
  "body": [ "test::printVars \"${1:variables}\"$0" ]
},

"test::printVars#withdoc": {
  "prefix": "test::printVars#withdoc",
  "description": "This function can be called to print the global variables in the report file...",
  "scope": "",
  "body": [ "# ## test::printVars\n# \n# This function can be called to print the global variables in the report file.\n# They will printed in a code block in the report file.\n# \n# - \\$@: **variables** _as string_:\n#       The variables to print.\n# \n# ```bash\n# test::printVars myVar\n# ```\n# \ntest::printVars \"${1:variables}\"$0" ]
},

"test::prompt": {
  "prefix": "test::prompt",
  "description": "Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file...",
  "scope": "",
  "body": [ "test::prompt \"${1:command}\"$0" ]
},

"test::prompt#withdoc": {
  "prefix": "test::prompt#withdoc",
  "description": "Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file...",
  "scope": "",
  "body": [ "# ## test::prompt\n# \n# Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file.\n# \n# - \\$@: **command** _as string_:\n#       The command to print as a prompt.\n# \n# ```bash\n# test::prompt \"echo 'Hello, world!'\"\n# ```\n# \ntest::prompt \"${1:command}\"$0" ]
},

"test::resetReplyVars": {
  "prefix": "test::resetReplyVars",
  "description": "Resets the value of each REPLY variable...",
  "scope": "",
  "body": [ "test::resetReplyVars$0" ]
},

"test::resetReplyVars#withdoc": {
  "prefix": "test::resetReplyVars#withdoc",
  "description": "Resets the value of each REPLY variable...",
  "scope": "",
  "body": [ "# ## test::resetReplyVars\n# \n# Resets the value of each REPLY variable.\n# \n# ```bash\n# test::resetReplyVars\n# ```\n# \ntest::resetReplyVars$0" ]
},

"test::scrubOutput": {
  "prefix": "test::scrubOutput",
  "description": "This function can be defined to modify the flushed text (both stdout and stderr) before adding it to the report...",
  "scope": "",
  "body": [ "test::scrubOutput$0" ]
},

"test::scrubOutput#withdoc": {
  "prefix": "test::scrubOutput#withdoc",
  "description": "This function can be defined to modify the flushed text (both stdout and stderr) before adding it to the report...",
  "scope": "",
  "body": [ "# ## test::scrubOutput\n# \n# This function can be defined to modify the flushed text (both stdout and stderr) before adding it to the report.\n# \n# Scrubbers are required when we need to convert non-deterministic text to something stable so that\n# tests are reproducible.\n# \n# The text to transform is in the global variable `GLOBAL_TEST_OUTPUT_CONTENT`.\n# You can also use `GLOBAL_TEST_FD_NUMBER` to know which file descriptor is being flushed (1 for stdout, 2 for stderr).\n# \n# Returns:\n# \n# - `GLOBAL_TEST_OUTPUT_CONTENT`: The modified text.\n# \n# > You can define this function directly in the test script, or in a test hook if\n# > you need it to be available for multiple tests.\n# > Note however that this function can be called very often, so it should be optimized.\n# \ntest::scrubOutput$0" ]
},

"test::scrubReplyVars": {
  "prefix": "test::scrubReplyVars",
  "description": "This function can be defined to modify the REPLY variables before printing them in the report...",
  "scope": "",
  "body": [ "test::scrubReplyVars$0" ]
},

"test::scrubReplyVars#withdoc": {
  "prefix": "test::scrubReplyVars#withdoc",
  "description": "This function can be defined to modify the REPLY variables before printing them in the report...",
  "scope": "",
  "body": [ "# ## test::scrubReplyVars\n# \n# This function can be defined to modify the REPLY variables before printing them in the report.\n# \n# Scrubbers are required when we need to convert non-deterministic text to something stable so that\n# tests are reproducible.\n# \n# > You can define this function directly in the test script, or in a test hook if\n# > you need it to be available for multiple tests.\n# > Note however that this function can be called very often, so it should be optimized.\n# \ntest::scrubReplyVars$0" ]
},

"test::setTerminalInputs": {
  "prefix": "test::setTerminalInputs",
  "description": "Replaces the functions `terminal::waitForChar` and `terminal::waitForKeyPress` by custom functions that return keys defined as an input of this function...",
  "scope": "",
  "body": [ "test::setTerminalInputs \"${1:keys}\"$0" ]
},

"test::setTerminalInputs#withdoc": {
  "prefix": "test::setTerminalInputs#withdoc",
  "description": "Replaces the functions `terminal::waitForChar` and `terminal::waitForKeyPress` by custom functions that return keys defined as an input of this function...",
  "scope": "",
  "body": [ "# ## test::setTerminalInputs\n# \n# Replaces the functions `terminal::waitForChar` and `terminal::waitForKeyPress` by custom functions\n# that return keys defined as an input of this function.\n# \n# - \\$@: **keys** _as string_:\n#       The keys to return when `terminal::waitForChar` or `terminal::waitForKeyPress` are called.\n#       Keys are consumed in the order they are provided.\n# \n# ```bash\n# test::setTerminalInputs \"a\" \"b\" \"c\"\n# ```\n# \ntest::setTerminalInputs \"${1:keys}\"$0" ]
},

"test::setupBashForConsistency": {
  "prefix": "test::setupBashForConsistency",
  "description": "This function is used to set up the Bash environment for maximum consistency during testing...",
  "scope": "",
  "body": [ "test::setupBashForConsistency$0" ]
},

"test::setupBashForConsistency#withdoc": {
  "prefix": "test::setupBashForConsistency#withdoc",
  "description": "This function is used to set up the Bash environment for maximum consistency during testing...",
  "scope": "",
  "body": [ "# ## test::setupBashForConsistency\n# \n# This function is used to set up the Bash environment for maximum consistency during testing.\n# It will override important dynamic bash variables to have more static results.\n# \n# ```bash\n# test::setupBashForConsistency\n# ```\n# \ntest::setupBashForConsistency$0" ]
},

"test::title": {
  "prefix": "test::title",
  "description": "Call this function to add an H3 title in the report file...",
  "scope": "",
  "body": [ "test::title \"${1:title}\"$0" ]
},

"test::title#withdoc": {
  "prefix": "test::title#withdoc",
  "description": "Call this function to add an H3 title in the report file...",
  "scope": "",
  "body": [ "# ## test::title\n# \n# Call this function to add an H3 title in the report file.\n# \n# - \\$1: title _as string_:\n#       The title of the test.\n# \n# ```bash\n# test::title \"Testing something\"\n# ```\n# \ntest::title \"${1:title}\"$0" ]
},

"time::getDate": {
  "prefix": "time::getDate",
  "description": "Get the current date in the given format...",
  "scope": "",
  "body": [ "time::getDate format=${1:\"%(%F_%Hh%Mm%Ss}$0" ]
},

"time::getDate#withdoc": {
  "prefix": "time::getDate#withdoc",
  "description": "Get the current date in the given format...",
  "scope": "",
  "body": [ "# ## time::getDate\n# \n# Get the current date in the given format.\n# \n# - \\${format} _as string_:\n#       (optional) the format (see printf) of the date to return\n#       (defaults to \"%(%F_%Hh%Mm%Ss)T\")\n# \n# Returns:\n# \n# - \\${REPLY}: the current date in the given format.\n# \n# ```bash\n# time::getDate\n# local date=\"\\${REPLY}\"\n# time::getDate format=\"'%(%Hh%Mm%Ss)T'\"\n# ```\n# \n# > This function avoid to call \\$(date) in a subshell (date is a an external executable).\n# \ntime::getDate format=${1:\"%(%F_%Hh%Mm%Ss}$0" ]
},

"time::getHumanTimeFromMicroseconds": {
  "prefix": "time::getHumanTimeFromMicroseconds",
  "description": "Convert microseconds to human readable format...",
  "scope": "",
  "body": [ "time::getHumanTimeFromMicroseconds \"${1:microseconds}\" format=${2:\"%HH:%MM:%SS\"}$0" ]
},

"time::getHumanTimeFromMicroseconds#withdoc": {
  "prefix": "time::getHumanTimeFromMicroseconds#withdoc",
  "description": "Convert microseconds to human readable format...",
  "scope": "",
  "body": [ "# ## time::getHumanTimeFromMicroseconds\n# \n# Convert microseconds to human readable format.\n# \n# - \\$1: **microseconds** _as int_:\n#       the microseconds to convert\n# - \\${format} _as string_:\n#       (optional) the format to use\n# \n#       Usable formats:\n#       - %HH: hours\n#       - %MM: minutes\n#       - %SS: seconds\n#       - %LL: milliseconds\n#       - %h: hours without leading zero\n#       - %m: minutes without leading zero\n#       - %s: seconds without leading zero\n#       - %l: milliseconds without leading zero\n#       - %u: microseconds without leading zero\n#       - %M: total minutes\n#       - %S: total seconds\n#       - %L: total milliseconds\n#       - %U: total microseconds\n# \n#       (defaults to \"%HH:%MM:%SS\")\n# \n# Returns:\n# \n# - \\${REPLY}: the human readable format\n# \n# ```bash\n# time::getHumanTimeFromMicroseconds 123456789\n# time::getHumanTimeFromMicroseconds 123456789 format=\"%HH:%MM:%SS\"\n# echo \"\\${REPLY}\"\n# ```\n# \ntime::getHumanTimeFromMicroseconds \"${1:microseconds}\" format=${2:\"%HH:%MM:%SS\"}$0" ]
},

"time::getMicrosecondsFromSeconds": {
  "prefix": "time::getMicrosecondsFromSeconds",
  "description": "Convert seconds (float number representation) to microseconds...",
  "scope": "",
  "body": [ "time::getMicrosecondsFromSeconds \"${1:seconds}\"$0" ]
},

"time::getMicrosecondsFromSeconds#withdoc": {
  "prefix": "time::getMicrosecondsFromSeconds#withdoc",
  "description": "Convert seconds (float number representation) to microseconds...",
  "scope": "",
  "body": [ "# ## time::getMicrosecondsFromSeconds\n# \n# Convert seconds (float number representation) to microseconds.\n# e.g. 1.234567 → 1234567\n# \n# - \\$1: **seconds** _as float_:\n#       the seconds to convert\n# \n# Returns:\n# \n# - \\${REPLY}: The microseconds (integer number).\n# \n# ```bash\n# time::getMicrosecondsFromSeconds 1.234567\n# echo \"\\${REPLY}\"\n# ```\n# \ntime::getMicrosecondsFromSeconds \"${1:seconds}\"$0" ]
},

"time::getProgramElapsedMicroseconds": {
  "prefix": "time::getProgramElapsedMicroseconds",
  "description": "Get the elapsed time in µs since the program started...",
  "scope": "",
  "body": [ "time::getProgramElapsedMicroseconds$0" ]
},

"time::getProgramElapsedMicroseconds#withdoc": {
  "prefix": "time::getProgramElapsedMicroseconds#withdoc",
  "description": "Get the elapsed time in µs since the program started...",
  "scope": "",
  "body": [ "# ## time::getProgramElapsedMicroseconds\n# \n# Get the elapsed time in µs since the program started.\n# \n# Returns:\n# \n# - \\${REPLY}: the elapsed time in µs since the program started.\n# \n# ```bash\n# time::getProgramElapsedMicroseconds\n# echo \"\\${REPLY}\"\n# time::getHumanTimeFromMicroseconds \"\\${REPLY}\"\n# echo \"Human time: \\${REPLY}\"\n# ```\n# \n# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.\n# > The 10# forces the base 10 conversion to avoid issues with leading zeros.\n# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.\n# \ntime::getProgramElapsedMicroseconds$0" ]
},

"time::getSecondsFromMicroseconds": {
  "prefix": "time::getSecondsFromMicroseconds",
  "description": "Convert microseconds to seconds (float number representation)...",
  "scope": "",
  "body": [ "time::getSecondsFromMicroseconds \"${1:microseconds}\" precision=${2:6}$0" ]
},

"time::getSecondsFromMicroseconds#withdoc": {
  "prefix": "time::getSecondsFromMicroseconds#withdoc",
  "description": "Convert microseconds to seconds (float number representation)...",
  "scope": "",
  "body": [ "# ## time::getSecondsFromMicroseconds\n# \n# Convert microseconds to seconds (float number representation).\n# e.g. 1234567 → 1.234567\n# \n# - \\$1: **microseconds** _as int_:\n#       the microseconds to convert\n# - \\${precision} _as string_:\n#       (optional) The precision to get (number of digits after the dot).\n#       (defaults to 6)\n# \n# Returns:\n# \n# - \\${REPLY}: The seconds (float number).\n# \n# ```bash\n# time::getSecondsFromMicroseconds 1234567\n# time::getSecondsFromMicroseconds 1234567 precision=3\n# echo \"\\${REPLY}\"\n# ```\n# \ntime::getSecondsFromMicroseconds \"${1:microseconds}\" precision=${2:6}$0" ]
},

"time::getTimerMicroseconds": {
  "prefix": "time::getTimerMicroseconds",
  "description": "Get the time elapsed since the call of `time::startTimer`...",
  "scope": "",
  "body": [ "time::getTimerMicroseconds logElapsedTime=${1:false} format=${2:\"%S.%LLs\"}$0" ]
},

"time::getTimerMicroseconds#withdoc": {
  "prefix": "time::getTimerMicroseconds#withdoc",
  "description": "Get the time elapsed since the call of `time::startTimer`...",
  "scope": "",
  "body": [ "# ## time::getTimerMicroseconds\n# \n# Get the time elapsed since the call of `time::startTimer`.\n# \n# - \\${logElapsedTime} _as bool_:\n#       (optional) Wether or not to log the elapsed time.\n#       (defaults to false)\n# - \\${format} _as string_:\n#       (optional) The format to use if we log the elapsed time.\n#       See `time::getHumanTimeFromMicroseconds` for the format.\n#       (defaults to \"%S.%LLs\").\n# \n# Returns:\n# \n# - \\${REPLY}: the elapsed time in microseconds.\n# \n# ```bash\n# time::startTimer\n# time::getTimerMicroseconds logElapsedTime=true\n# echo \"Total microseconds: \\${REPLY}\"\n# ```\n# \ntime::getTimerMicroseconds logElapsedTime=${1:false} format=${2:\"%S.%LLs\"}$0" ]
},

"time::isTimeElapsed": {
  "prefix": "time::isTimeElapsed",
  "description": "Check if a given time in microseconds has elapsed since the last call to this function...",
  "scope": "",
  "body": [ "time::isTimeElapsed \"${1:microseconds}\" timerName=${2:\"\\${FUNCNAME[1]}\"}$0" ]
},

"time::isTimeElapsed#withdoc": {
  "prefix": "time::isTimeElapsed#withdoc",
  "description": "Check if a given time in microseconds has elapsed since the last call to this function...",
  "scope": "",
  "body": [ "# ## time::isTimeElapsed\n# \n# Check if a given time in microseconds has elapsed since the last call\n# to this function.\n# \n# - \\$1: **microseconds** _as int_:\n#       the microseconds to check\n# - \\${timerName} _as int_:\n#       A variable name that will be used to store the last time this function was called.\n#       Defaults to the name of the calling function.\n#       Can be set to a fixed value if you call this function from different functions\n#       and want to share the same timer.\n#       (defaults to \"\\${FUNCNAME[1]}\")\n# \n# Returns:\n# \n# - 0 if the time has elapsed\n# - 1 if the time has not yet elapsed\n# \n# ```bash\n# if time::isTimeElapsed 500000; then\n#   echo \"500ms has elapsed since the last call to this function\"\n# fi\n# ```\n# \ntime::isTimeElapsed \"${1:microseconds}\" timerName=${2:\"\\${FUNCNAME[1]}\"}$0" ]
},

"time::startTimer": {
  "prefix": "time::startTimer",
  "description": "Start a timer...",
  "scope": "",
  "body": [ "time::startTimer$0" ]
},

"time::startTimer#withdoc": {
  "prefix": "time::startTimer#withdoc",
  "description": "Start a timer...",
  "scope": "",
  "body": [ "# ## time::startTimer\n# \n# Start a timer. You can then call `time::getTimerMicroseconds` to get the elapsed time.\n# \n# ```bash\n# time::startTimer\n# time::getTimerMicroseconds\n# ```\n# \ntime::startTimer$0" ]
},

"version::bump": {
  "prefix": "version::bump",
  "description": "This function allows to bump a semantic version formatted like: major...",
  "scope": "",
  "body": [ "version::bump \"${1:version}\" \"${2:level}\" keepPreRelease=${3:false}$0" ]
},

"version::bump#withdoc": {
  "prefix": "version::bump#withdoc",
  "description": "This function allows to bump a semantic version formatted like: major...",
  "scope": "",
  "body": [ "# ## version::bump\n# \n# This function allows to bump a semantic version formatted like:\n# major.minor.patch-prerelease+build\n# \n# - \\$1: **version** _as string_:\n#       the version to bump\n# - \\$2: **level** _as string_:\n#       the level to bump (major, minor, patch)\n# - \\${keepPreRelease} _as bool_:\n#       (optional) keep the prerelease and build strings\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY}: the new version string\n# \n# ```bash\n# version::bump \"1.2.3-prerelease+build\" \"major\" keepPreRelease=true\n# version::bump \"1.2.3-prerelease+build\" \"major\"\n# local newVersion=\"\\${REPLY}\"\n# ```\n# \nversion::bump \"${1:version}\" \"${2:level}\" keepPreRelease=${3:false}$0" ]
},

"version::compare": {
  "prefix": "version::compare",
  "description": "This function allows to compare two semantic versions formatted like: major...",
  "scope": "",
  "body": [ "version::compare \"${1:version1}\" \"${2:version2}\"$0" ]
},

"version::compare#withdoc": {
  "prefix": "version::compare#withdoc",
  "description": "This function allows to compare two semantic versions formatted like: major...",
  "scope": "",
  "body": [ "# ## version::compare\n# \n# This function allows to compare two semantic versions formatted like:\n# major.minor.patch-prerelease+build\n# \n# - \\$1: **version1** _as string_:\n#       the first version to compare\n# - \\$2: **version2** _as string_:\n#       the second version to compare\n# \n# Returns:\n# \n# - \\${REPLY}:\n#   - 0 if the versions are equal,\n#   - 1 if version1 is greater,\n#   - -1 if version2 is greater\n# \n# ```bash\n# version::compare \"2.3.4-prerelease+build\" \"1.2.3-prerelease+build\"\n# local comparison=\"\\${REPLY}\"\n# ```\n# \n# > The prerelease and build are ignored in the comparison.\n# \nversion::compare \"${1:version1}\" \"${2:version2}\"$0" ]
},

"windows::addToPath": {
  "prefix": "windows::addToPath",
  "description": "Add the given path to the PATH environment variable on Windows (current user only)...",
  "scope": "",
  "body": [ "windows::addToPath \"${1:path}\" prepend=${2:false}$0" ]
},

"windows::addToPath#withdoc": {
  "prefix": "windows::addToPath#withdoc",
  "description": "Add the given path to the PATH environment variable on Windows (current user only)...",
  "scope": "",
  "body": [ "# ## windows::addToPath\n# \n# Add the given path to the PATH environment variable on Windows (current user only).\n# \n# Will also export the PATH variable in the current bash.\n# \n# - \\$1: **path** _as string_:\n#       the path to add to the PATH environment variable.\n#       The path can be in unix format, it will be converted to windows format.\n# - \\${prepend} _as bool_:\n#       (optional) True to prepend the path to the PATH, false to append it.\n#       (defaults to false)\n# \n# ```bash\n# windows::addToPath \"/path/to/bin\"\n# windows::addToPath \"/path/to/bin\" prepend=true\n# ```\n# \n# > This function is only available on Windows, it uses `powershell` to directly modify the registry.\n# \nwindows::addToPath \"${1:path}\" prepend=${2:false}$0" ]
},

"windows::createLink": {
  "prefix": "windows::createLink",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "windows::createLink \"${1:linked path}\" \"${2:link path}\" hardlink=${3:false} force=${4:false}$0" ]
},

"windows::createLink#withdoc": {
  "prefix": "windows::createLink#withdoc",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "# ## windows::createLink\n# \n# Create a soft or hard link (original ← link).\n# \n# Reminder:\n# \n# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the\n#   form of an absolute or relative path.\n# - A hard link is a directory entry that associates a new pathname with an existing\n#   file (inode + data block) on a file system.\n# \n# - \\$1: **linked path** _as string_:\n#       the path to link to (the original file)\n# - \\$2: **link path** _as string_:\n#       the path where to create the link\n# - \\${hardlink} _as boolean_:\n#       (optional) True to create a hard link, false to create a symbolic link\n#       (defaults to false)\n# - \\${force} _as boolean_:\n#       (optional) True to overwrite the link or file if it already exists.\n#       Otherwise, the function will fail on an existing link.\n#       (defaults to false)\n# \n# ```bash\n# windows::createLink \"/path/to/link\" \"/path/to/linked\"\n# windows::createLink \"/path/to/link\" \"/path/to/linked\" hardlink=true force=true\n# ```\n# \n# > On Windows, the function uses `powershell` (and optionally ls to check the existing link).\n# > If you have the windows \"developer mode\" enabled + MSYS=winsymlinks:nativestrict,\n# > then it uses the ln command.\n# \nwindows::createLink \"${1:linked path}\" \"${2:link path}\" hardlink=${3:false} force=${4:false}$0" ]
},

"windows::createTempDirectory": {
  "prefix": "windows::createTempDirectory",
  "description": "Create a temporary directory on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "windows::createTempDirectory$0" ]
},

"windows::createTempDirectory#withdoc": {
  "prefix": "windows::createTempDirectory#withdoc",
  "description": "Create a temporary directory on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "# ## windows::createTempDirectory\n# \n# Create a temporary directory on Windows and return the path both for Windows and Unix.\n# \n# This is useful for creating temporary directories that can be used in both Windows and Unix.\n# \n# Returns:\n# \n# - \\${REPLY}: The Windows path.\n# - \\${REPLY2}: The Unix path.\n# \n# ```bash\n# windows::createTempDirectory\n# ```\n# \n# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nwindows::createTempDirectory$0" ]
},

"windows::createTempFile": {
  "prefix": "windows::createTempFile",
  "description": "Create a temporary file on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "windows::createTempFile$0" ]
},

"windows::createTempFile#withdoc": {
  "prefix": "windows::createTempFile#withdoc",
  "description": "Create a temporary file on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "# ## windows::createTempFile\n# \n# Create a temporary file on Windows and return the path both for Windows and Unix.\n# \n# This is useful for creating temporary files that can be used in both Windows and Unix.\n# \n# Returns:\n# \n# - \\${REPLY}: The Windows path.\n# - \\${REPLY2}: The Unix path.\n# \n# ```bash\n# windows::createTempFile\n# ```\n# \n# > Files created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nwindows::createTempFile$0" ]
},

"windows::endPs1Batch": {
  "prefix": "windows::endPs1Batch",
  "description": "This function will run all the commands that were batched with `windows::startPs1Batch`...",
  "scope": "",
  "body": [ "windows::endPs1Batch$0" ]
},

"windows::endPs1Batch#withdoc": {
  "prefix": "windows::endPs1Batch#withdoc",
  "description": "This function will run all the commands that were batched with `windows::startPs1Batch`...",
  "scope": "",
  "body": [ "# ## windows::endPs1Batch\n# \n# This function will run all the commands that were batched with `windows::startPs1Batch`.\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${REPLY}: The content of stdout.\n# - \\${REPLY2}: The content of stderr.\n# \n# ```bash\n# windows::startPs1Batch\n# windows::runPs1 \"Write-Host \\\"Hello\\\"\"\n# windows::runPs1 \"Write-Host \\\"World\\\"\"\n# windows::endPs1Batch\n# ```\n# \nwindows::endPs1Batch$0" ]
},

"windows::getEnvVar": {
  "prefix": "windows::getEnvVar",
  "description": "Get the value of an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "windows::getEnvVar \"${1:variable name}\"$0" ]
},

"windows::getEnvVar#withdoc": {
  "prefix": "windows::getEnvVar#withdoc",
  "description": "Get the value of an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "# ## windows::getEnvVar\n# \n# Get the value of an environment variable for the current user on Windows.\n# \n# - \\$1: **variable name** _as string_:\n#       the name of the environment variable to get.\n# \n# Returns:\n# \n# - \\${REPLY}: the value of the environment variable.\n# \n# ```bash\n# windows::getEnvVar \"MY_VAR\"\n# echo \"\\${REPLY}\"\n# ```\n# \nwindows::getEnvVar \"${1:variable name}\"$0" ]
},

"windows::getUnixPathFromWindowsPath": {
  "prefix": "windows::getUnixPathFromWindowsPath",
  "description": "Convert a Windows path to a unix path...",
  "scope": "",
  "body": [ "windows::getUnixPathFromWindowsPath \"${1:path}\"$0" ]
},

"windows::getUnixPathFromWindowsPath#withdoc": {
  "prefix": "windows::getUnixPathFromWindowsPath#withdoc",
  "description": "Convert a Windows path to a unix path...",
  "scope": "",
  "body": [ "# ## windows::getUnixPathFromWindowsPath\n# \n# Convert a Windows path to a unix path.\n# \n# - \\$1: **path** _as string_:\n#       the path to convert\n# \n# Returns:\n# \n# - \\${REPLY}: The unix path.\n# \n# ```bash\n# windows::getUnixPathFromWindowsPath \"C:\\path\\to\\file\"\n# ```\n# \n# > Handles paths starting with `X:\\`.\n# \nwindows::getUnixPathFromWindowsPath \"${1:path}\"$0" ]
},

"windows::getWindowsPathFromUnixPath": {
  "prefix": "windows::getWindowsPathFromUnixPath",
  "description": "Convert a unix path to a Windows path...",
  "scope": "",
  "body": [ "windows::getWindowsPathFromUnixPath \"${1:path}\"$0" ]
},

"windows::getWindowsPathFromUnixPath#withdoc": {
  "prefix": "windows::getWindowsPathFromUnixPath#withdoc",
  "description": "Convert a unix path to a Windows path...",
  "scope": "",
  "body": [ "# ## windows::getWindowsPathFromUnixPath\n# \n# Convert a unix path to a Windows path.\n# \n# - \\$1: **path** _as string_:\n#       the path to convert\n# \n# Returns:\n# \n# - \\${REPLY}: The Windows path.\n# \n# ```bash\n# windows::getWindowsPathFromUnixPath \"/path/to/file\"\n# ```\n# \n# > Handles paths starting with `/mnt/x/` or `/x/` in pure bash,\n# > handles other msys2 paths using `cygpath`.\n# \nwindows::getWindowsPathFromUnixPath \"${1:path}\"$0" ]
},

"windows::runPs1": {
  "prefix": "windows::runPs1",
  "description": "Runs a PowerShell command...",
  "scope": "",
  "body": [ "windows::runPs1 \"${1:command}\" runAsAdmin=${2:false} noFail=${3:false}$0" ]
},

"windows::runPs1#withdoc": {
  "prefix": "windows::runPs1#withdoc",
  "description": "Runs a PowerShell command...",
  "scope": "",
  "body": [ "# ## windows::runPs1\n# \n# Runs a PowerShell command.\n# This is mostly useful on Windows.\n# \n# - \\$1: **command** _as string_:\n#       the command to run.\n# - \\${runAsAdmin} _as bool_:\n#       (optional) Wether to run the command as administrator.\n#       (defaults to false).\n# - \\${noFail} _as bool_:\n#       (optional) A boolean to indicate if the function should call core::fail (exit) in case the execution fails.\n#       If true and the execution fails, the script will exit.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${REPLY_CODE}:\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${REPLY}: The content of stdout.\n# - \\${REPLY2}: The content of stderr.\n# \n# ```bash\n# windows::runPs1 \"Write-Host \\\"Press any key:\\\"; Write-Host -Object ('The key that was pressed was: {0}' -f [System.Console]::ReadKey().Key.ToString());\"\n# windows::runPs1 \"Write-Host \\\"Hello\\\"\" runAsAdmin=true noFail=true\n# ```\n# \nwindows::runPs1 \"${1:command}\" runAsAdmin=${2:false} noFail=${3:false}$0" ]
},

"windows::setEnvVar": {
  "prefix": "windows::setEnvVar",
  "description": "Set an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "windows::setEnvVar \"${1:variable name}\" \"${2:variable value}\"$0" ]
},

"windows::setEnvVar#withdoc": {
  "prefix": "windows::setEnvVar#withdoc",
  "description": "Set an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "# ## windows::setEnvVar\n# \n# Set an environment variable for the current user on Windows.\n# \n# - \\$1: **variable name** _as string_:\n#       The name of the environment variable to set.\n# - \\$2: **variable value** _as string_:\n#       The value of the environment variable to set.\n#       An empty string will unset the variable.\n# \n# ```bash\n# windows::setEnvVar \"MY_VAR\" \"my_value\"\n# ```\n# \n# > This function is only available on Windows, it uses `powershell` to directly modify the registry.\n# \nwindows::setEnvVar \"${1:variable name}\" \"${2:variable value}\"$0" ]
},

"windows::startPs1Batch": {
  "prefix": "windows::startPs1Batch",
  "description": "After running this function, all commands that should be executed by `windows::runPs1` will be added to a batch that will only be played when `windows::endPs1Batch` is called...",
  "scope": "",
  "body": [ "windows::startPs1Batch$0" ]
},

"windows::startPs1Batch#withdoc": {
  "prefix": "windows::startPs1Batch#withdoc",
  "description": "After running this function, all commands that should be executed by `windows::runPs1` will be added to a batch that will only be played when `windows::endPs1Batch` is called...",
  "scope": "",
  "body": [ "# ## windows::startPs1Batch\n# \n# After running this function, all commands that should be executed by\n# `windows::runPs1` will be added to a batch that will only be played\n# when `windows::endPs1Batch` is called.\n# \n# This is a convenient way to run multiple commands in a single PowerShell session.\n# It makes up for the fact that running a new PowerShell session for each command is slow.\n# \n# ```bash\n# windows::startPs1Batch\n# windows::runPs1 \"Write-Host \\\"Hello\\\"\"\n# windows::runPs1 \"Write-Host \\\"World\\\"\"\n# windows::endPs1Batch\n# ```\n# \nwindows::startPs1Batch$0" ]
},
	"function documentation": {
		"prefix": [
			"function documentation",
			"doc"
		],
		"description": "The documentation of a function",
		"scope": "",
		"body": [
			"# ## ${1:function name}",
			"#",
			"# ${2:description}",
			"#",
			"# - $1: **argument one** _as string_:",
			"#       description",
			"# - ${option} _as bool_:",
			"#       (optional) description",
			"#       (default to false)",
			"#",
			"# Returns:",
			"#",
			"# - ${REPLY}: ",
			"#",
			"# ```bash",
			"# #${1:function name} ",
			"# ```",
			"#",
			"# > notes",
			"$0"
		]
	},
	"[[:digit:]]": {
		"prefix": "[[:digit:]]",
		"description": "Regex digits, similar to [0-9]",
		"scope": "",
		"body": [
			"[[:digit:]]"
		]
	},
	"[[:xdigit:]]": {
		"prefix": "[[:xdigit:]]",
		"description": "Regex hexadecimal digits, similar to [0-9A-Fa-f]",
		"scope": "",
		"body": [
			"[[:xdigit:]]"
		]
	},
	"[[:punct:]]": {
		"prefix": "[[:punct:]]",
		"description": "Regex punctuation, similar to [.,!?:…]",
		"scope": "",
		"body": [
			"[[:punct:]]"
		]
	},
	"[[:blank:]]": {
		"prefix": "[[:blank:]]",
		"description": "Regex space and TAB characters only, similar to [ \\t]",
		"scope": "",
		"body": [
			"[[:blank:]]"
		]
	},
	"[[:space:]]": {
		"prefix": "[[:space:]]",
		"description": "Regex blank (whitespace) characters, similar to [ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:space:]]"
		]
	},
	"[[:cntrl:]]": {
		"prefix": "[[:cntrl:]]",
		"description": "Regex control characters",
		"scope": "",
		"body": [
			"[[:cntrl:]]"
		]
	},
	"[[:graph:]]": {
		"prefix": "[[:graph:]]",
		"description": "Regex printed characters, similar to [^\\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:graph:]]"
		]
	},
	"[[:print:]]": {
		"prefix": "[[:print:]]",
		"description": "Regex printed characters and space, similar to [^ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:print:]]"
		]
	},
	"[[:alnum:]]": {
		"prefix": "[[:alnum:]]",
		"description": "Regex digits, upper- and lowercase letters, similar to [[:alpha:][:digit:]]",
		"scope": "",
		"body": [
			"[[:alnum:]]$0"
		]
	},
	"[[:alpha:]]": {
		"prefix": "[[:alpha:]]",
		"description": "Regex upper- and lowercase letters, similar to [[:upper:][:lower:]]",
		"scope": "",
		"body": [
			"[[:alpha:]]$0"
		]
	},
	"[[:lower:]]": {
		"prefix": "[[:lower:]]",
		"description": "Regex lowercase letters, similar to [a-z]",
		"scope": "",
		"body": [
			"[[:lower:]]$0"
		]
	},
	"[[:upper:]]": {
		"prefix": [
			"[[:upper:]]",
			"regex [[:upper:]]"
		],
		"description": "Regex uppercase letters , similar to [A-Z]",
		"scope": "",
		"body": [
			"[[:upper:]]$0"
		]
	},
	"set bash options": {
		"prefix": "set bash options",
		"description": "Set good bash options",
		"scope": "",
		"body": [
			"set -Eeu -o pipefail$0"
		]
	},
	"new command alt": {
		"prefix": "new command alt",
		"description": "A new command alternative definition for Valet",
		"scope": "",
		"body": [
			"##<<VALET_COMMAND",
			"# command: $1",
			"# function: $2",
			"# shortDescription: A short sentence.",
			"# description: |-",
			"#   A long description that can use ⌜quotes⌝.",
			"# sudo: false",
			"# hideInMenu: false",
			"# arguments:",
			"# - name: firstArg",
			"#   description: |-",
			"#     First argument.",
			"# - name: more...",
			"#   description: |-",
			"#     Will be an an array of strings.",
			"# options:",
			"# - name: -o, --option1",
			"#   description: |-",
			"#     First option.",
			"#   noEnvironmentVariable: true",
			"# - name: -2, --this-is-option2 <level>",
			"#   description: |-",
			"#     An option with a value.",
			"#   noEnvironmentVariable: false",
			"# examples:",
			"# - name: command -o -2 value1 arg1 more1 more2",
			"#   description: |-",
			"#     Call command with option1, option2 and some arguments.",
			"##VALET_COMMAND",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${REPLY}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"new command": {
		"prefix": "new command",
		"description": "A new command definition for Valet",
		"scope": "",
		"body": [
			": \"---",
			"command: $1",
			"function: $2",
			"shortDescription: A short sentence.",
			"description: |-",
			"  A long description that can use ⌜quotes⌝.",
			"sudo: false",
			"hideInMenu: false",
			"arguments:",
			"- name: firstArg",
			"  description: |-",
			"    First argument.",
			"- name: more...",
			"  description: |-",
			"    Will be an an array of strings.",
			"options:",
			"- name: -o, --option1",
			"  description: |-",
			"    First option.",
			"  noEnvironmentVariable: true",
			"- name: -2, --this-is-option2 <level>",
			"  description: |-",
			"    An option with a value.",
			"  noEnvironmentVariable: false",
			"examples:",
			"- name: command -o -2 value1 arg1 more1 more2",
			"  description: |-",
			"    Call command with option1, option2 and some arguments.",
			": \"---",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${REPLY}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"comment section": {
		"prefix": "comment section",
		"description": "",
		"scope": "",
		"body": [
			"#===============================================================",
			"# >>> $1",
			"#===============================================================",
			"$0"
		]
	},
	"quote": {
		"prefix": "quote",
		"description": "",
		"scope": "",
		"body": [
			"⌜$1⌝$0"
		]
	},
	"read file to array and loop": {
		"prefix": "read file to array and loop",
		"description": "Read file to array and loop",
		"scope": "",
		"body": [
			"readarray -d $'\\n' fileLines < file",
			"for myString in \"${fileLines[@]}\"; do",
			"  # the difference is also that myString will end with the delimiter, so you might want to remove it",
			"  # Alternatively, you can run readarray with -t but in that case you will not have an array element for empty lines",
			"  echo \"${myString%$'\\n'}\"",
			"done"
		]
	},
	"loop through lines of string": {
		"prefix": "loop through lines of string",
		"description": "Loop through each line of a string (keep empty lines)",
		"scope": "",
		"body": [
			"while read -r line; do",
			"  echo \"${line}\"",
			"done <<< \"${var1}\""
		]
	},
	"loop through lines of string (for)": {
		"prefix": "loop through lines of string (for)",
		"description": "Loop through each line of a string (does not keep empty lines)",
		"scope": "",
		"body": [
			"local IFS=$'\\n'",
			"for line in ${var1}; do",
			"  echo \"${line}\"",
			"done"
		]
	},
	"read file loop on all lines": {
		"prefix": "read file loop on all lines",
		"description": "Read a file, line by line",
		"scope": "",
		"body": [
			"while IFS=$'\\n' read -rd $'\\n' line || [[ -n ${line:-} ]]; do",
			"  echo \"${line}\"",
			"done < file"
		]
	},
	"source": {
		"prefix": "source",
		"description": "Source a file for Valet, add the necessary comment for shellcheck.",
		"scope": "",
		"body": [
			"# shellcheck source=../lib-valet",
			"source $1",
			"$0",
			""
		]
	},
	"REPLY_CODE": {
		"prefix": "REPLY_CODE",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_CODE$0"
		]
	},
	"REPLY": {
		"prefix": "REPLY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY$0"
		]
	},
	"REPLY2": {
		"prefix": "REPLY2",
		"description": "",
		"scope": "",
		"body": [
			"REPLY2$0"
		]
	},
	"REPLY3": {
		"prefix": "REPLY3",
		"description": "",
		"scope": "",
		"body": [
			"REPLY3$0"
		]
	},
	"REPLY_ARRAY": {
		"prefix": "REPLY_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY$0"
		]
	},
	"REPLY_ARRAY2": {
		"prefix": "REPLY_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY2$0"
		]
	},
	"REPLY_ARRAY3": {
		"prefix": "REPLY_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ARRAY3$0"
		]
	},
	"REPLY_ASSOCIATIVE_ARRAY": {
		"prefix": "REPLY_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"REPLY_ASSOCIATIVE_ARRAY$0"
		]
	},
	"IFS": {
		"prefix": "IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"IFS$0"
		]
	},
	"$GLOBAL_COLUMNS": {
		"prefix": "$GLOBAL_COLUMNS",
		"description": "The current number or columns displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_COLUMNS}$0"
		]
	},
	"$GLOBAL_LINES": {
		"prefix": "$GLOBAL_LINES",
		"description": "The current number or lines displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_LINES}$0"
		]
	},
	"$GLOBAL_CURSOR_LINE": {
		"prefix": "$GLOBAL_CURSOR_LINE",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_LINE}$0"
		]
	},
	"$GLOBAL_CURSOR_COLUMN": {
		"prefix": "$GLOBAL_CURSOR_COLUMN",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_COLUMN}$0"
		]
	},
	"$GLOBAL_TEST_TEMP_FILE": {
		"prefix": "$GLOBAL_TEST_TEMP_FILE",
		"description": "The path to a temporary file that can be used during tests.",
		"scope": "",
		"body": [
			"\\${GLOBAL_TEST_TEMP_FILE}$0"
		]
	},
	"$GLOBAL_SCREEN_REDRAW_REQUIRED": {
		"prefix": "$GLOBAL_SCREEN_REDRAW_REQUIRED",
		"description": "Set to true when the terminal size changes, set it to false when you handle this event.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SCREEN_REDRAW_REQUIRED}$0"
		]
	},
	"$GLOBAL_SESSION_INTERRUPTED": {
		"prefix": "$GLOBAL_SESSION_INTERRUPTED",
		"description": "Set to true when the user presses CTRL+C during an interactive experience.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SESSION_INTERRUPTED}$0"
		]
	},
	"$LAST_KEY_PRESSED": {
		"prefix": "$LAST_KEY_PRESSED",
		"description": "",
		"scope": "",
		"body": [
			"\\${LAST_KEY_PRESSED}$0"
		]
	},
	"$REPLY_CODE": {
		"prefix": "$REPLY_CODE",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_CODE}$0"
		]
	},
	"$REPLY": {
		"prefix": "$REPLY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY}$0"
		]
	},
	"$REPLY2": {
		"prefix": "$REPLY2",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY2}$0"
		]
	},
	"$REPLY3": {
		"prefix": "$REPLY3",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY3}$0"
		]
	},
	"$REPLY_ARRAY": {
		"prefix": "$REPLY_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY}$0"
		]
	},
	"$REPLY_ARRAY2": {
		"prefix": "$REPLY_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY2}$0"
		]
	},
	"$REPLY_ARRAY3": {
		"prefix": "$REPLY_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ARRAY3}$0"
		]
	},
	"$REPLY_ASSOCIATIVE_ARRAY": {
		"prefix": "$REPLY_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${REPLY_ASSOCIATIVE_ARRAY}$0"
		]
	},
	"$BASHOPTS": {
		"prefix": "$BASHOPTS",
		"body": [
			"\\${BASHOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -s option to the shopt builtin command (see The Shopt Builtin). The options appearing in BASHOPTS are those reported as ‘on’ by ‘shopt’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$BASHPID": {
		"prefix": "$BASHPID",
		"body": [
			"\\${BASHPID}$0"
		],
		"scope": "",
		"description": "Expands to the process ID of the current Bash process. This differs from $$ under certain circumstances, such as subshells that do not require Bash to be re-initialized. Assignments to BASHPID have no effect. If BASHPID is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ALIASES": {
		"prefix": "$BASH_ALIASES",
		"body": [
			"\\${BASH_ALIASES}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal list of aliases as maintained by the alias builtin. (see Bourne Shell Builtins). Elements added to this array appear in the alias list; however, unsetting array elements currently does not cause aliases to be removed from the alias list. If BASH_ALIASES is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ARGC": {
		"prefix": "$BASH_ARGC",
		"body": [
			"\\${BASH_ARGC}$0"
		],
		"scope": "",
		"description": "An array variable whose values are the number of parameters in each frame of the current bash execution call stack. The number of parameters to the current subroutine (shell function or script executed with . or source) is at the top of the stack. When a subroutine is executed, the number of parameters passed is pushed onto BASH_ARGC. The shell sets BASH_ARGC only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV": {
		"prefix": "$BASH_ARGV",
		"body": [
			"\\${BASH_ARGV}$0"
		],
		"scope": "",
		"description": "An array variable containing all of the parameters in the current bash execution call stack. The final parameter of the last subroutine call is at the top of the stack; the first parameter of the initial call is at the bottom. When a subroutine is executed, the parameters supplied are pushed onto BASH_ARGV. The shell sets BASH_ARGV only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV0": {
		"prefix": "$BASH_ARGV0",
		"body": [
			"\\${BASH_ARGV0}$0"
		],
		"scope": "",
		"description": "When referenced, this variable expands to the name of the shell or shell script (identical to $0; See Special Parameters, for the description of special parameter 0). Assignment to BASH_ARGV0 causes the value assigned to also be assigned to $0. If BASH_ARGV0 is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_CMDS": {
		"prefix": "$BASH_CMDS",
		"body": [
			"\\${BASH_CMDS}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal hash table of commands as maintained by the hash builtin (see Bourne Shell Builtins). Elements added to this array appear in the hash table; however, unsetting array elements currently does not cause command names to be removed from the hash table. If BASH_CMDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMMAND": {
		"prefix": "$BASH_COMMAND",
		"body": [
			"\\${BASH_COMMAND}$0"
		],
		"scope": "",
		"description": "The command currently being executed or about to be executed, unless the shell is executing a command as the result of a trap, in which case it is the command executing at the time of the trap. If BASH_COMMAND is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMPAT": {
		"prefix": "$BASH_COMPAT",
		"body": [
			"\\${BASH_COMPAT}$0"
		],
		"scope": "",
		"description": "The value is used to set the shell’s compatibility level. See Shell Compatibility Mode, for a description of the various compatibility levels and their effects. The value may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the desired compatibility level. If BASH_COMPAT is unset or set to the empty string, the compatibility level is set to the default for the current version. If BASH_COMPAT is set to a value that is not one of the valid compatibility levels, the shell prints an error message and sets the compatibility level to the default for the current version. The valid values correspond to the compatibility levels described below (see Shell Compatibility Mode). For example, 4.2 and 42 are valid values that correspond to the compat42 shopt option and set the compatibility level to 42. The current version is also a valid value."
	},
	"$BASH_ENV": {
		"prefix": "$BASH_ENV",
		"body": [
			"\\${BASH_ENV}$0"
		],
		"scope": "",
		"description": "If this variable is set when Bash is invoked to execute a shell script, its value is expanded and used as the name of a startup file to read before executing the script. See Bash Startup Files."
	},
	"$BASH_EXECUTION_STRING": {
		"prefix": "$BASH_EXECUTION_STRING",
		"body": [
			"\\${BASH_EXECUTION_STRING}$0"
		],
		"scope": "",
		"description": "The command argument to the -c invocation option."
	},
	"$BASH_LINENO": {
		"prefix": "$BASH_LINENO",
		"body": [
			"\\${BASH_LINENO}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the line numbers in source files where each corresponding member of FUNCNAME was invoked. ${BASH_LINENO[$i]} is the line number in the source file (${BASH_SOURCE[$i+1]}) where ${FUNCNAME[$i]} was called (or ${BASH_LINENO[$i-1]} if referenced within another shell function). Use LINENO to obtain the current line number."
	},
	"$BASH_LOADABLES_PATH": {
		"prefix": "$BASH_LOADABLES_PATH",
		"body": [
			"\\${BASH_LOADABLES_PATH}$0"
		],
		"scope": "",
		"description": "A colon-separated list of directories in which the shell looks for dynamically loadable builtins specified by the enable command."
	},
	"$BASH_REMATCH": {
		"prefix": "$BASH_REMATCH",
		"body": [
			"\\${BASH_REMATCH}$0"
		],
		"scope": "",
		"description": "An array variable whose members are assigned by the ‘=~’ binary operator to the [[ conditional command (see Conditional Constructs). The element with index 0 is the portion of the string matching the entire regular expression. The element with index n is the portion of the string matching the nth parenthesized subexpression."
	},
	"$BASH_SOURCE": {
		"prefix": "$BASH_SOURCE",
		"body": [
			"\\${BASH_SOURCE}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the source filenames where the corresponding shell function names in the FUNCNAME array variable are defined. The shell function ${FUNCNAME[$i]} is defined in the file ${BASH_SOURCE[$i]} and called from ${BASH_SOURCE[$i+1]}"
	},
	"$BASH_SUBSHELL": {
		"prefix": "$BASH_SUBSHELL",
		"body": [
			"\\${BASH_SUBSHELL}$0"
		],
		"scope": "",
		"description": "Incremented by one within each subshell or subshell environment when the shell begins executing in that environment. The initial value is 0. If BASH_SUBSHELL is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_VERSINFO": {
		"prefix": "$BASH_VERSINFO",
		"body": [
			"\\${BASH_VERSINFO}$0"
		],
		"scope": "",
		"description": "A readonly array variable (see Arrays) whose members hold version information for this instance of Bash. The values assigned to the array members are as follows:"
	},
	"$BASH_VERSINFO[0]": {
		"prefix": "$BASH_VERSINFO[0]",
		"body": [
			"\\${BASH_VERSINFO[0]}$0"
		],
		"scope": "",
		"description": "The major version number (the release)."
	},
	"$BASH_VERSINFO[1]": {
		"prefix": "$BASH_VERSINFO[1]",
		"body": [
			"\\${BASH_VERSINFO[1]}$0"
		],
		"scope": "",
		"description": "The minor version number (the version)."
	},
	"$BASH_VERSINFO[2]": {
		"prefix": "$BASH_VERSINFO[2]",
		"body": [
			"\\${BASH_VERSINFO[2]}$0"
		],
		"scope": "",
		"description": "The patch level."
	},
	"$BASH_VERSINFO[3]": {
		"prefix": "$BASH_VERSINFO[3]",
		"body": [
			"\\${BASH_VERSINFO[3]}$0"
		],
		"scope": "",
		"description": "The build version."
	},
	"$BASH_VERSINFO[4]": {
		"prefix": "$BASH_VERSINFO[4]",
		"body": [
			"\\${BASH_VERSINFO[4]}$0"
		],
		"scope": "",
		"description": "The release status (e.g., beta1)."
	},
	"$BASH_VERSINFO[5]": {
		"prefix": "$BASH_VERSINFO[5]",
		"body": [
			"\\${BASH_VERSINFO[5]}$0"
		],
		"scope": "",
		"description": "The value of MACHTYPE. "
	},
	"$BASH_VERSION": {
		"prefix": "$BASH_VERSION",
		"body": [
			"\\${BASH_VERSION}$0"
		],
		"scope": "",
		"description": "The version number of the current instance of Bash."
	},
	"$BASH_XTRACEFD": {
		"prefix": "$BASH_XTRACEFD",
		"body": [
			"\\${BASH_XTRACEFD}$0"
		],
		"scope": "",
		"description": "If set to an integer corresponding to a valid file descriptor, Bash will write the trace output generated when ‘set -x’ is enabled to that file descriptor. This allows tracing output to be separated from diagnostic and error messages. The file descriptor is closed when BASH_XTRACEFD is unset or assigned a new value. Unsetting BASH_XTRACEFD or assigning it the empty string causes the trace output to be sent to the standard error. Note that setting BASH_XTRACEFD to 2 (the standard error file descriptor) and then unsetting it will result in the standard error being closed."
	},
	"$CHILD_MAX": {
		"prefix": "$CHILD_MAX",
		"body": [
			"\\${CHILD_MAX}$0"
		],
		"scope": "",
		"description": "Set the number of exited child status values for the shell to remember. Bash will not allow this value to be decreased below a POSIX-mandated minimum, and there is a maximum value (currently 8192) that this may not exceed. The minimum value is system-dependent."
	},
	"$COLUMNS": {
		"prefix": "$COLUMNS",
		"body": [
			"\\${COLUMNS}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the terminal width when printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$COMP_CWORD": {
		"prefix": "$COMP_CWORD",
		"body": [
			"\\${COMP_CWORD}$0"
		],
		"scope": "",
		"description": "An index into ${COMP_WORDS} of the word containing the current cursor position. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_LINE": {
		"prefix": "$COMP_LINE",
		"body": [
			"\\${COMP_LINE}$0"
		],
		"scope": "",
		"description": "The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_POINT": {
		"prefix": "$COMP_POINT",
		"body": [
			"\\${COMP_POINT}$0"
		],
		"scope": "",
		"description": "The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to ${#COMP_LINE}. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_TYPE": {
		"prefix": "$COMP_TYPE",
		"body": [
			"\\${COMP_TYPE}$0"
		],
		"scope": "",
		"description": "Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called: TAB, for normal completion, ‘?’, for listing completions after successive tabs, ‘!’, for listing alternatives on partial word completion, ‘@’, to list completions if the word is not unmodified, or ‘%’, for menu completion. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_KEY": {
		"prefix": "$COMP_KEY",
		"body": [
			"\\${COMP_KEY}$0"
		],
		"scope": "",
		"description": "The key (or final key of a key sequence) used to invoke the current completion function."
	},
	"$COMP_WORDBREAKS": {
		"prefix": "$COMP_WORDBREAKS",
		"body": [
			"\\${COMP_WORDBREAKS}$0"
		],
		"scope": "",
		"description": "The set of characters that the Readline library treats as word separators when performing word completion. If COMP_WORDBREAKS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$COMP_WORDS": {
		"prefix": "$COMP_WORDS",
		"body": [
			"\\${COMP_WORDS}$0"
		],
		"scope": "",
		"description": "An array variable consisting of the individual words in the current command line. The line is split into words as Readline would split it, using COMP_WORDBREAKS as described above. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMPREPLY": {
		"prefix": "$COMPREPLY",
		"body": [
			"\\${COMPREPLY}$0"
		],
		"scope": "",
		"description": "An array variable from which Bash reads the possible completions generated by a shell function invoked by the programmable completion facility (see Programmable Completion). Each array element contains one possible completion."
	},
	"$COPROC": {
		"prefix": "$COPROC",
		"body": [
			"\\${COPROC}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the file descriptors for output from and input to an unnamed coprocess (see Coprocesses)."
	},
	"$DIRSTACK": {
		"prefix": "$DIRSTACK",
		"body": [
			"\\${DIRSTACK}$0"
		],
		"scope": "",
		"description": "An array variable containing the current contents of the directory stack. Directories appear in the stack in the order they are displayed by the dirs builtin. Assigning to members of this array variable may be used to modify directories already in the stack, but the pushd and popd builtins must be used to add and remove directories. Assignment to this variable will not change the current directory. If DIRSTACK is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EMACS": {
		"prefix": "$EMACS",
		"body": [
			"\\${EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts with value ‘t’, it assumes that the shell is running in an Emacs shell buffer and disables line editing."
	},
	"$ENV": {
		"prefix": "$ENV",
		"body": [
			"\\${ENV}$0"
		],
		"scope": "",
		"description": "Expanded and executed similarly to BASH_ENV (see Bash Startup Files) when an interactive shell is invoked in POSIX Mode (see Bash POSIX Mode)."
	},
	"$EPOCHREALTIME": {
		"prefix": "$EPOCHREALTIME",
		"body": [
			"\\${EPOCHREALTIME}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch as a floating point value with micro-second granularity (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHREALTIME are ignored. If EPOCHREALTIME is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EPOCHSECONDS": {
		"prefix": "$EPOCHSECONDS",
		"body": [
			"\\${EPOCHSECONDS}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHSECONDS are ignored. If EPOCHSECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EUID": {
		"prefix": "$EUID",
		"body": [
			"\\${EUID}$0"
		],
		"scope": "",
		"description": "The numeric effective user id of the current user. This variable is readonly."
	},
	"$EXECIGNORE": {
		"prefix": "$EXECIGNORE",
		"body": [
			"\\${EXECIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of shell patterns (see Pattern Matching) defining the list of filenames to be ignored by command search using PATH. Files whose full pathnames match one of these patterns are not considered executable files for the purposes of completion and command execution via PATH lookup. This does not affect the behavior of the [, test, and [[ commands. Full pathnames in the command hash table are not subject to EXECIGNORE. Use this variable to ignore shared library files that have the executable bit set, but are not executable files. The pattern matching honors the setting of the extglob shell option."
	},
	"$FCEDIT": {
		"prefix": "$FCEDIT",
		"body": [
			"\\${FCEDIT}$0"
		],
		"scope": "",
		"description": "The editor used as a default by the -e option to the fc builtin command."
	},
	"$FIGNORE": {
		"prefix": "$FIGNORE",
		"body": [
			"\\${FIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of suffixes to ignore when performing filename completion. A filename whose suffix matches one of the entries in FIGNORE is excluded from the list of matched filenames. A sample value is ‘.o:~’"
	},
	"$FUNCNAME": {
		"prefix": "$FUNCNAME",
		"body": [
			"\\${FUNCNAME}$0"
		],
		"scope": "",
		"description": "An array variable containing the names of all shell functions currently in the execution call stack. The element with index 0 is the name of any currently-executing shell function. The bottom-most element (the one with the highest index) is main. This variable exists only when a shell function is executing. Assignments to FUNCNAME have no effect. If FUNCNAME is unset, it loses its special properties, even if it is subsequently reset. This variable can be used with BASH_LINENO and BASH_SOURCE. Each element of FUNCNAME has corresponding elements in BASH_LINENO and BASH_SOURCE to describe the call stack. For instance, ${FUNCNAME[$i]} was called from the file ${BASH_SOURCE[$i+1]} at line number ${BASH_LINENO[$i]}. The caller builtin displays the current call stack using this information."
	},
	"$FUNCNEST": {
		"prefix": "$FUNCNEST",
		"body": [
			"\\${FUNCNEST}$0"
		],
		"scope": "",
		"description": "If set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed this nesting level will cause the current command to abort."
	},
	"$GLOBIGNORE": {
		"prefix": "$GLOBIGNORE",
		"body": [
			"\\${GLOBIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns defining the set of file names to be ignored by filename expansion. If a file name matched by a filename expansion pattern also matches one of the patterns in GLOBIGNORE, it is removed from the list of matches. The pattern matching honors the setting of the extglob shell option."
	},
	"$GROUPS": {
		"prefix": "$GROUPS",
		"body": [
			"\\${GROUPS}$0"
		],
		"scope": "",
		"description": "An array variable containing the list of groups of which the current user is a member. Assignments to GROUPS have no effect. If GROUPS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$histchars": {
		"prefix": "$histchars",
		"body": [
			"\\${histchars}$0"
		],
		"scope": "",
		"description": "Up to three characters which control history expansion, quick substitution, and tokenization (see History Expansion). The first character is the history expansion character, that is, the character which signifies the start of a history expansion, normally ‘!’. The second character is the character which signifies ‘quick substitution’ when seen as the first character on a line, normally ‘^’. The optional third character is the character which indicates that the remainder of the line is a comment when found as the first character of a word, usually ‘#’. The history comment character causes history substitution to be skipped for the remaining words on the line. It does not necessarily cause the shell parser to treat the rest of the line as a comment."
	},
	"$HISTCMD": {
		"prefix": "$HISTCMD",
		"body": [
			"\\${HISTCMD}$0"
		],
		"scope": "",
		"description": "The history number, or index in the history list, of the current command. Assignments to HISTCMD are ignored. If HISTCMD is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$HISTCONTROL": {
		"prefix": "$HISTCONTROL",
		"body": [
			"\\${HISTCONTROL}$0"
		],
		"scope": "",
		"description": "A colon-separated list of values controlling how commands are saved on the history list. If the list of values includes ‘ignorespace’, lines which begin with a space character are not saved in the history list. A value of ‘ignoredups’ causes lines which match the previous history entry to not be saved. A value of ‘ignoreboth’ is shorthand for ‘ignorespace’ and ‘ignoredups’. A value of ‘erasedups’ causes all previous lines matching the current line to be removed from the history list before that line is saved. Any value not in the above list is ignored. If HISTCONTROL is unset, or does not include a valid value, all lines read by the shell parser are saved on the history list, subject to the value of HISTIGNORE. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTCONTROL."
	},
	"$HISTFILE": {
		"prefix": "$HISTFILE",
		"body": [
			"\\${HISTFILE}$0"
		],
		"scope": "",
		"description": "The name of the file to which the command history is saved. The default value is ~/.bash_history."
	},
	"$HISTFILESIZE": {
		"prefix": "$HISTFILESIZE",
		"body": [
			"\\${HISTFILESIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of lines contained in the history file. When this variable is assigned a value, the history file is truncated, if necessary, to contain no more than that number of lines by removing the oldest entries. The history file is also truncated to this size after writing it when a shell exits. If the value is 0, the history file is truncated to zero size. Non-numeric values and numeric values less than zero inhibit truncation. The shell sets the default value to the value of HISTSIZE after reading any startup files."
	},
	"$HISTIGNORE": {
		"prefix": "$HISTIGNORE",
		"body": [
			"\\${HISTIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns used to decide which command lines should be saved on the history list. Each pattern is anchored at the beginning of the line and must match the complete line (no implicit ‘*’ is appended). Each pattern is tested against the line after the checks specified by HISTCONTROL are applied. In addition to the normal shell pattern matching characters, ‘&’ matches the previous history line. ‘&’ may be escaped using a backslash; the backslash is removed before attempting a match. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTIGNORE. The pattern matching honors the setting of the extglob shell option. HISTIGNORE subsumes the function of HISTCONTROL. A pattern of ‘&’ is identical to ignoredups, and a pattern of ‘[ ]*’ is identical to ignorespace. Combining these two patterns, separating them with a colon, provides the functionality of ignoreboth."
	},
	"$HISTSIZE": {
		"prefix": "$HISTSIZE",
		"body": [
			"\\${HISTSIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of commands to remember on the history list. If the value is 0, commands are not saved in the history list. Numeric values less than zero result in every command being saved on the history list (there is no limit). The shell sets the default value to 500 after reading any startup files."
	},
	"$HISTTIMEFORMAT": {
		"prefix": "$HISTTIMEFORMAT",
		"body": [
			"\\${HISTTIMEFORMAT}$0"
		],
		"scope": "",
		"description": "If this variable is set and not null, its value is used as a format string for strftime to print the time stamp associated with each history entry displayed by the history builtin. If this variable is set, time stamps are written to the history file so they may be preserved across shell sessions. This uses the history comment character to distinguish timestamps from other history lines."
	},
	"$HOSTFILE": {
		"prefix": "$HOSTFILE",
		"body": [
			"\\${HOSTFILE}$0"
		],
		"scope": "",
		"description": "Contains the name of a file in the same format as /etc/hosts that should be read when the shell needs to complete a hostname. The list of possible hostname completions may be changed while the shell is running; the next time hostname completion is attempted after the value is changed, Bash adds the contents of the new file to the existing list. If HOSTFILE is set, but has no value, or does not name a readable file, Bash attempts to read /etc/hosts to obtain the list of possible hostname completions. When HOSTFILE is unset, the hostname list is cleared."
	},
	"$HOSTNAME": {
		"prefix": "$HOSTNAME",
		"body": [
			"\\${HOSTNAME}$0"
		],
		"scope": "",
		"description": "The name of the current host."
	},
	"$HOSTTYPE": {
		"prefix": "$HOSTTYPE",
		"body": [
			"\\${HOSTTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the machine Bash is running on."
	},
	"$IGNOREEOF": {
		"prefix": "$IGNOREEOF",
		"body": [
			"\\${IGNOREEOF}$0"
		],
		"scope": "",
		"description": "Controls the action of the shell on receipt of an EOF character as the sole input. If set, the value denotes the number of consecutive EOF characters that can be read as the first character on an input line before the shell will exit. If the variable exists but does not have a numeric value, or has no value, then the default is 10. If the variable does not exist, then EOF signifies the end of input to the shell. This is only in effect for interactive shells."
	},
	"$INPUTRC": {
		"prefix": "$INPUTRC",
		"body": [
			"\\${INPUTRC}$0"
		],
		"scope": "",
		"description": "The name of the Readline initialization file, overriding the default of ~/.inputrc."
	},
	"$INSIDE_EMACS": {
		"prefix": "$INSIDE_EMACS",
		"body": [
			"\\${INSIDE_EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts, it assumes that the shell is running in an Emacs shell buffer and may disable line editing depending on the value of TERM."
	},
	"$LANG": {
		"prefix": "$LANG",
		"body": [
			"\\${LANG}$0"
		],
		"scope": "",
		"description": "Used to determine the locale category for any category not specifically selected with a variable starting with LC_."
	},
	"$LC_ALL": {
		"prefix": "$LC_ALL",
		"body": [
			"\\${LC_ALL}$0"
		],
		"scope": "",
		"description": "This variable overrides the value of LANG and any other LC_ variable specifying a locale category."
	},
	"$LC_COLLATE": {
		"prefix": "$LC_COLLATE",
		"body": [
			"\\${LC_COLLATE}$0"
		],
		"scope": "",
		"description": "This variable determines the collation order used when sorting the results of filename expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_CTYPE": {
		"prefix": "$LC_CTYPE",
		"body": [
			"\\${LC_CTYPE}$0"
		],
		"scope": "",
		"description": "This variable determines the interpretation of characters and the behavior of character classes within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_MESSAGES": {
		"prefix": "$LC_MESSAGES",
		"body": [
			"\\${LC_MESSAGES}$0"
		],
		"scope": "",
		"description": "This variable determines the locale used to translate double-quoted strings preceded by a ‘$’ (see Locale-Specific Translation)."
	},
	"$LC_NUMERIC": {
		"prefix": "$LC_NUMERIC",
		"body": [
			"\\${LC_NUMERIC}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for number formatting."
	},
	"$LC_TIME": {
		"prefix": "$LC_TIME",
		"body": [
			"\\${LC_TIME}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for data and time formatting."
	},
	"$LINENO": {
		"prefix": "$LINENO",
		"body": [
			"\\${LINENO}$0"
		],
		"scope": "",
		"description": "The line number in the script or shell function currently executing. If LINENO is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$LINES": {
		"prefix": "$LINES",
		"body": [
			"\\${LINES}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the column length for printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$MACHTYPE": {
		"prefix": "$MACHTYPE",
		"body": [
			"\\${MACHTYPE}$0"
		],
		"scope": "",
		"description": "A string that fully describes the system type on which Bash is executing, in the standard GNU cpu-company-system format."
	},
	"$MAILCHECK": {
		"prefix": "$MAILCHECK",
		"body": [
			"\\${MAILCHECK}$0"
		],
		"scope": "",
		"description": "How often (in seconds) that the shell should check for mail in the files specified in the MAILPATH or MAIL variables. The default is 60 seconds. When it is time to check for mail, the shell does so before displaying the primary prompt. If this variable is unset, or set to a value that is not a number greater than or equal to zero, the shell disables mail checking."
	},
	"$MAPFILE": {
		"prefix": "$MAPFILE",
		"body": [
			"\\${MAPFILE}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the text read by the mapfile builtin when no variable name is supplied."
	},
	"$OLDPWD": {
		"prefix": "$OLDPWD",
		"body": [
			"\\${OLDPWD}$0"
		],
		"scope": "",
		"description": "The previous working directory as set by the cd builtin."
	},
	"$OPTERR": {
		"prefix": "$OPTERR",
		"body": [
			"\\${OPTERR}$0"
		],
		"scope": "",
		"description": "If set to the value 1, Bash displays error messages generated by the getopts builtin command."
	},
	"$OSTYPE": {
		"prefix": "$OSTYPE",
		"body": [
			"\\${OSTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the operating system Bash is running on."
	},
	"$PIPESTATUS": {
		"prefix": "$PIPESTATUS",
		"body": [
			"\\${PIPESTATUS}$0"
		],
		"scope": "",
		"description": "An array variable (see Arrays) containing a list of exit status values from the processes in the most-recently-executed foreground pipeline (which may contain only a single command)."
	},
	"$POSIXLY_CORRECT": {
		"prefix": "$POSIXLY_CORRECT",
		"body": [
			"\\${POSIXLY_CORRECT}$0"
		],
		"scope": "",
		"description": "If this variable is in the environment when Bash starts, the shell enters POSIX mode (see Bash POSIX Mode) before reading the startup files, as if the --posix invocation option had been supplied. If it is set while the shell is running, Bash enables POSIX mode, as if the command set -o posix had been executed. When the shell enters POSIX mode, it sets this variable if it was not already set."
	},
	"$PPID": {
		"prefix": "$PPID",
		"body": [
			"\\${PPID}$0"
		],
		"scope": "",
		"description": "The process ID of the shell’s parent process. This variable is readonly."
	},
	"$PROMPT_COMMAND": {
		"prefix": "$PROMPT_COMMAND",
		"body": [
			"\\${PROMPT_COMMAND}$0"
		],
		"scope": "",
		"description": "If this variable is set, and is an array, the value of each set element is interpreted as a command to execute before printing the primary prompt ($PS1). If this is set but not an array variable, its value is used as a command to execute instead."
	},
	"$PROMPT_DIRTRIM": {
		"prefix": "$PROMPT_DIRTRIM",
		"body": [
			"\\${PROMPT_DIRTRIM}$0"
		],
		"scope": "",
		"description": "If set to a number greater than zero, the value is used as the number of trailing directory components to retain when expanding the \\w and \\W prompt string escapes (see Controlling the Prompt). Characters removed are replaced with an ellipsis."
	},
	"$PS0": {
		"prefix": "$PS0",
		"body": [
			"\\${PS0}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and displayed by interactive shells after reading a command and before the command is executed."
	},
	"$PS3": {
		"prefix": "$PS3",
		"body": [
			"\\${PS3}$0"
		],
		"scope": "",
		"description": "The value of this variable is used as the prompt for the select command. If this variable is not set, the select command prompts with ‘#? ’"
	},
	"$PS4": {
		"prefix": "$PS4",
		"body": [
			"\\${PS4}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and the expanded value is the prompt printed before the command line is echoed when the -x option is set (see The Set Builtin). The first character of the expanded value is replicated multiple times, as necessary, to indicate multiple levels of indirection. The default is ‘+ ’."
	},
	"$PWD": {
		"prefix": "$PWD",
		"body": [
			"\\${PWD}$0"
		],
		"scope": "",
		"description": "The current working directory as set by the cd builtin."
	},
	"$RANDOM": {
		"prefix": "$RANDOM",
		"body": [
			"\\${RANDOM}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to a random integer between 0 and 32767. Assigning a value to this variable seeds the random number generator. If RANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$READLINE_ARGUMENT": {
		"prefix": "$READLINE_ARGUMENT",
		"body": [
			"\\${READLINE_ARGUMENT}$0"
		],
		"scope": "",
		"description": "Any numeric argument given to a Readline command that was defined using ‘bind -x’ (see Bash Builtin Commands when it was invoked."
	},
	"$READLINE_LINE": {
		"prefix": "$READLINE_LINE",
		"body": [
			"\\${READLINE_LINE}$0"
		],
		"scope": "",
		"description": "The contents of the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$READLINE_MARK": {
		"prefix": "$READLINE_MARK",
		"body": [
			"\\${READLINE_MARK}$0"
		],
		"scope": "",
		"description": "The position of the mark (saved insertion point) in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands). The characters between the insertion point and the mark are often called the region."
	},
	"$READLINE_POINT": {
		"prefix": "$READLINE_POINT",
		"body": [
			"\\${READLINE_POINT}$0"
		],
		"scope": "",
		"description": "The position of the insertion point in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$REPLY": {
		"prefix": "$REPLY",
		"body": [
			"\\${REPLY}$0"
		],
		"scope": "",
		"description": "The default variable for the read builtin."
	},
	"$SECONDS": {
		"prefix": "$SECONDS",
		"body": [
			"\\${SECONDS}$0"
		],
		"scope": "",
		"description": "This variable expands to the number of seconds since the shell was started. Assignment to this variable resets the count to the value assigned, and the expanded value becomes the value assigned plus the number of seconds since the assignment. The number of seconds at shell invocation and the current time are always determined by querying the system clock. If SECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$SHELL": {
		"prefix": "$SHELL",
		"body": [
			"\\${SHELL}$0"
		],
		"scope": "",
		"description": "This environment variable expands to the full pathname to the shell. If it is not set when the shell starts, Bash assigns to it the full pathname of the current user’s login shell."
	},
	"$SHELLOPTS": {
		"prefix": "$SHELLOPTS",
		"body": [
			"\\${SHELLOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -o option to the set builtin command (see The Set Builtin). The options appearing in SHELLOPTS are those reported as ‘on’ by ‘set -o’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$SHLVL": {
		"prefix": "$SHLVL",
		"body": [
			"\\${SHLVL}$0"
		],
		"scope": "",
		"description": "Incremented by one each time a new instance of Bash is started. This is intended to be a count of how deeply your Bash shells are nested."
	},
	"$SRANDOM": {
		"prefix": "$SRANDOM",
		"body": [
			"\\${SRANDOM}$0"
		],
		"scope": "",
		"description": "This variable expands to a 32-bit pseudo-random number each time it is referenced. The random number generator is not linear on systems that support /dev/urandom or arc4random, so each returned number has no relationship to the numbers preceding it. The random number generator cannot be seeded, so assignments to this variable have no effect. If SRANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$TIMEFORMAT": {
		"prefix": "$TIMEFORMAT",
		"body": [
			"\\${TIMEFORMAT}$0"
		],
		"scope": "",
		"description": "The value of this parameter is used as a format string specifying how the timing information for pipelines prefixed with the time reserved word should be displayed. The ‘%’ character introduces an escape sequence that is expanded to a time value or other information. If the value is null, no timing information is displayed. A trailing newline is added when the format string is displayed."
	},
	"$TMOUT": {
		"prefix": "$TMOUT",
		"body": [
			"\\${TMOUT}$0"
		],
		"scope": "",
		"description": "If set to a value greater than zero, TMOUT is treated as the default timeout for the read builtin (see Bash Builtin Commands). The select command (see Conditional Constructs) terminates if input does not arrive after TMOUT seconds when input is coming from a terminal. In an interactive shell, the value is interpreted as the number of seconds to wait for a line of input after issuing the primary prompt. Bash terminates after waiting for that number of seconds if a complete line of input does not arrive."
	},
	"$TMPDIR": {
		"prefix": "$TMPDIR",
		"body": [
			"\\${TMPDIR}$0"
		],
		"scope": "",
		"description": "If set, Bash uses its value as the name of a directory in which Bash creates temporary files for the shell’s use."
	},
	"$UID": {
		"prefix": "$UID",
		"body": [
			"\\${UID}$0"
		],
		"scope": "",
		"description": "The numeric real user id of the current user. This variable is readonly."
	},
	"$BASH": {
		"prefix": "$BASH",
		"description": "The full pathname used to execute the current instance of Bash. ",
		"scope": "",
		"body": [
			"\\${BASH}$0"
		]
	},
	"$_": {
		"prefix": "$_",
		"description": "",
		"scope": "",
		"body": [
			"\\${_}$0"
		]
	},
	"$CDPATH": {
		"prefix": "$CDPATH",
		"description": "A colon-separated list of directories used as a search path for the cd builtin command.",
		"scope": "",
		"body": [
			"\\${CDPATH}$0"
		]
	},
	"$PS2": {
		"prefix": "$PS2",
		"description": "The secondary prompt string. The default value is ‘> ’. PS2 is expanded in the same way as PS1 before being displayed.",
		"scope": "",
		"body": [
			"\\${PS2}$0"
		]
	},
	"$PS1": {
		"prefix": "$PS1",
		"description": "The primary prompt string. The default value is ‘\\s-\\v\\${ ’}. See Controlling the Prompt, for the complete list of escape sequences that are expanded before PS1 is displayed. ",
		"scope": "",
		"body": [
			"\\${PS1}$0"
		]
	},
	"$PATH": {
		"prefix": "$PATH",
		"description": "A colon-separated list of directories in which the shell looks for commands. A zero-length (null) directory name in the value of PATH indicates the current directory. A null directory name may appear as two adjacent colons, or as an initial or trailing colon. ",
		"scope": "",
		"body": [
			"\\${PATH}$0"
		]
	},
	"$OPTIND": {
		"prefix": "$OPTIND",
		"description": "The index of the last option argument processed by the getopts builtin. ",
		"scope": "",
		"body": [
			"\\${OPTIND}$0"
		]
	},
	"$OPTARG": {
		"prefix": "$OPTARG",
		"description": "The value of the last option argument processed by the getopts builtin.",
		"scope": "",
		"body": [
			"\\${OPTARG}$0"
		]
	},
	"$MAILPATH": {
		"prefix": "$MAILPATH",
		"description": "A colon-separated list of filenames which the shell periodically checks for new mail. Each list entry can specify the message that is printed when new mail arrives in the mail file by separating the filename from the message with a ‘?’. When used in the text of the message, $_ expands to the name of the current mail file.",
		"scope": "",
		"body": [
			"\\${MAILPATH}$0"
		]
	},
	"$MAIL": {
		"prefix": "$MAIL",
		"description": "If this parameter is set to a filename or directory name and the MAILPATH variable is not set, Bash informs the user of the arrival of mail in the specified file or Maildir-format directory.",
		"scope": "",
		"body": [
			"\\${MAIL}$0"
		]
	},
	"$IFS": {
		"prefix": "$IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"\\${IFS}$0"
		]
	},
	"$HOME": {
		"prefix": "$HOME",
		"description": "The current user’s home directory; the default for the cd builtin command. The value of this variable is also used by tilde expansion.",
		"scope": "",
		"body": [
			"\\${HOME}$0"
		]
	}
}