{
// Documentation generated for the version 0.18.87 (2024-06-16).

		"io::toAbsolutePath": {
		  "prefix": "io::toAbsolutePath",
		  "description": "This function returns the absolute path of a path...",
		  "scope": "",
		  "body": [ "io::toAbsolutePath \"${1:**path**}\"$0" ]
	  },

		"io::listPaths": {
		  "prefix": "io::listPaths",
		  "description": "List all the paths in the given directory...",
		  "scope": "",
		  "body": [ "io::listPaths \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:path filter function name}\" \"${5:directory filter function name}\"$0" ]
	  },

		"string::wrapSentence": {
		  "prefix": "string::wrapSentence",
		  "description": "Allows to soft wrap the given sentence (without new lines) at the given width...",
		  "scope": "",
		  "body": [ "string::wrapSentence \"${1:**text**}\" \"${2:wrap width}\"$0" ]
	  },

		"io::createFilePathIfNeeded": {
		  "prefix": "io::createFilePathIfNeeded",
		  "description": "Make sure that the given file path exists...",
		  "scope": "",
		  "body": [ "io::createFilePathIfNeeded \"${1:**path**}\"$0" ]
	  },

		"io::checkAndFail": {
		  "prefix": "io::checkAndFail",
		  "description": "Check last return code and fail (exit) if it is an error...",
		  "scope": "",
		  "body": [ "io::checkAndFail \"${1:**exit code**}\" \"${99:**message**}\"$0" ]
	  },

		"core::sourceUserCommands": {
		  "prefix": "core::sourceUserCommands",
		  "description": "Source the user 'commands' file from the valet user directory...",
		  "scope": "",
		  "body": [ "core::sourceUserCommands$0" ]
	  },

		"log::warning": {
		  "prefix": "log::warning",
		  "description": "Displays a warning...",
		  "scope": "",
		  "body": [ "log::warning \"${99:**message**}\"$0" ]
	  },

		"core::resetIncludedFiles": {
		  "prefix": "core::resetIncludedFiles",
		  "description": "Allows to reset the included files...",
		  "scope": "",
		  "body": [ "core::resetIncludedFiles$0" ]
	  },

		"core::getConfigurationDirectory": {
		  "prefix": "core::getConfigurationDirectory",
		  "description": "Returns the path to the valet configuration directory...",
		  "scope": "",
		  "body": [ "core::getConfigurationDirectory$0" ]
	  },

		"interactive::switchBackFromFullScreen": {
		  "prefix": "interactive::switchBackFromFullScreen",
		  "description": "Call this function to switch back from the full screen mode...",
		  "scope": "",
		  "body": [ "interactive::switchBackFromFullScreen$0" ]
	  },

		"interactive::displayAnswer": {
		  "prefix": "interactive::displayAnswer",
		  "description": "Displays an answer to a previous question...",
		  "scope": "",
		  "body": [ "interactive::displayAnswer \"${1:**answer**}\" \"${2:max width}\"$0" ]
	  },

		"string::split": {
		  "prefix": "string::split",
		  "description": "Split a string into an array using a separator...",
		  "scope": "",
		  "body": [ "string::split \"${1:**string**}\" \"${2:**separator**}\"$0" ]
	  },

		"array::makeArraysSameSize": {
		  "prefix": "array::makeArraysSameSize",
		  "description": "This function makes sure that all the arrays have the same size...",
		  "scope": "",
		  "body": [ "array::makeArraysSameSize \"${99:**array names**}\"$0" ]
	  },

		"log::isDebugEnabled": {
		  "prefix": "log::isDebugEnabled",
		  "description": "Check if the debug mode is enabled...",
		  "scope": "",
		  "body": [ "log::isDebugEnabled$0" ]
	  },

		"array::fuzzyFilterSort": {
		  "prefix": "array::fuzzyFilterSort",
		  "description": "Allows to fuzzy sort an array against a given pattern...",
		  "scope": "",
		  "body": [ "array::fuzzyFilterSort \"${1:**pattern**}\" \"${2:**array name**}\" \"${3:prefix matched char}\" \"${4:suffix matched char}\" \"${5:max line length}\"$0" ]
	  },

		"string::extractBetween": {
		  "prefix": "string::extractBetween",
		  "description": "Extract the text between two strings within a string...",
		  "scope": "",
		  "body": [ "string::extractBetween \"${1:**string**}\" \"${2:**start string**}\" \"${3:**end string**}\"$0" ]
	  },

		"log::setLevel": {
		  "prefix": "log::setLevel",
		  "description": "Set the log level...",
		  "scope": "",
		  "body": [ "log::setLevel \"${1:**log level**}\" \"${2:silent}\"$0" ]
	  },

		"core::showHelp": {
		  "prefix": "core::showHelp",
		  "description": "Show the help for the current function...",
		  "scope": "",
		  "body": [ "core::showHelp$0" ]
	  },

		"io::listFiles": {
		  "prefix": "io::listFiles",
		  "description": "List all the files in the given directory...",
		  "scope": "",
		  "body": [ "io::listFiles \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
	  },

		"interactive::createSpace": {
		  "prefix": "interactive::createSpace",
		  "description": "This function creates some new lines after the current cursor position...",
		  "scope": "",
		  "body": [ "interactive::createSpace \"${1:**number of lines**}\"$0" ]
	  },

		"log::printString": {
		  "prefix": "log::printString",
		  "description": "Display a string in the log...",
		  "scope": "",
		  "body": [ "log::printString \"${1:**content**}\" \"${2:new line pad string}\"$0" ]
	  },

		"interactive::promptYesNoRaw": {
		  "prefix": "interactive::promptYesNoRaw",
		  "description": "Ask the user to yes or no...",
		  "scope": "",
		  "body": [ "interactive::promptYesNoRaw \"${1:default}\"$0" ]
	  },

		"test::endTest": {
		  "prefix": "test::endTest",
		  "description": "Call this function after each test to write the test results to the report file...",
		  "scope": "",
		  "body": [ "test::endTest \"${1:**title**}\" \"${2:**exit code**}\" \"${3:comment}\"$0" ]
	  },

		"string::wrapCharacters": {
		  "prefix": "string::wrapCharacters",
		  "description": "Allows to hard wrap the given string (without new lines) at the given width...",
		  "scope": "",
		  "body": [ "string::wrapCharacters \"${1:**text**}\" \"${2:wrap width}\" \"${3:new line pad string}\" \"${4:new line wrap width}\"$0" ]
	  },

		"interactive::getCursorPosition": {
		  "prefix": "interactive::getCursorPosition",
		  "description": "Get the current cursor position...",
		  "scope": "",
		  "body": [ "interactive::getCursorPosition$0" ]
	  },

		"ansi-codes::*": {
		  "prefix": "ansi-codes::*",
		  "description": "ANSI codes for text attributes, colors, cursor control, and other common escape sequences...",
		  "scope": "",
		  "body": [ "ansi-codes::*$0" ]
	  },

		"io::cleanupTempFiles": {
		  "prefix": "io::cleanupTempFiles",
		  "description": "Removes all the temporary files and directories that were created by the io::createTempFile and io::createTempDirectory functions...",
		  "scope": "",
		  "body": [ "io::cleanupTempFiles$0" ]
	  },

		"interactive::switchToFullScreen": {
		  "prefix": "interactive::switchToFullScreen",
		  "description": "Call this function to start an interactive session in full screen mode...",
		  "scope": "",
		  "body": [ "interactive::switchToFullScreen$0" ]
	  },

		"system::env": {
		  "prefix": "system::env",
		  "description": "Get the list of all the environment variables...",
		  "scope": "",
		  "body": [ "system::env$0" ]
	  },

		"string::count": {
		  "prefix": "string::count",
		  "description": "Counts the number of occurences of a substring in a string...",
		  "scope": "",
		  "body": [ "string::count \"${1:**string**}\" \"${2:**substring**}\"$0" ]
	  },

		"interactive::testKeys": {
		  "prefix": "interactive::testKeys",
		  "description": "Wait for a user input and prints the character that bash sees...",
		  "scope": "",
		  "body": [ "interactive::testKeys$0" ]
	  },

		"array::sort": {
		  "prefix": "array::sort",
		  "description": "Sorts an array using the > bash operator (lexicographic order)...",
		  "scope": "",
		  "body": [ "array::sort \"${1:**array name**}\"$0" ]
	  },

		"string::indexOf": {
		  "prefix": "string::indexOf",
		  "description": "Find the first index of a string within another string...",
		  "scope": "",
		  "body": [ "string::indexOf \"${1:**string**}\" \"${2:**search**}\" \"${3:start index}\"$0" ]
	  },

		"source": {
		  "prefix": "source",
		  "description": "Allows to include a library file or sources a file...",
		  "scope": "",
		  "body": [ "source \"${1:**library name**}\" \"${99:arguments}\"$0" ]
	  },

		"log::trace": {
		  "prefix": "log::trace",
		  "description": "Displays a trace message...",
		  "scope": "",
		  "body": [ "log::trace \"${99:**message**}\"$0" ]
	  },

		"string::camelCaseToSnakeCase": {
		  "prefix": "string::camelCaseToSnakeCase",
		  "description": "This function convert a camelCase string to a SNAKE_CASE string...",
		  "scope": "",
		  "body": [ "string::camelCaseToSnakeCase \"${1:**camelCase string**}\"$0" ]
	  },

		"io::listDirectories": {
		  "prefix": "io::listDirectories",
		  "description": "List all the directories in the given directory...",
		  "scope": "",
		  "body": [ "io::listDirectories \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
	  },

		"log::success": {
		  "prefix": "log::success",
		  "description": "Displays a success message...",
		  "scope": "",
		  "body": [ "log::success \"${99:**message**}\"$0" ]
	  },

		"interactive::displayDialogBox": {
		  "prefix": "interactive::displayDialogBox",
		  "description": "Displays a dialog box with a speaker and a text...",
		  "scope": "",
		  "body": [ "interactive::displayDialogBox \"${1:**speaker**}\" \"${2:**text**}\" \"${3:max width}\"$0" ]
	  },

		"array::fuzzyFilter": {
		  "prefix": "array::fuzzyFilter",
		  "description": "Allows to fuzzy match an array against a given pattern...",
		  "scope": "",
		  "body": [ "array::fuzzyFilter \"${1:**pattern**}\" \"${2:**array name**}\"$0" ]
	  },

		"io::cat": {
		  "prefix": "io::cat",
		  "description": "Print the content of a file to stdout...",
		  "scope": "",
		  "body": [ "io::cat \"${1:**path**}\"$0" ]
	  },

		"string::cutField": {
		  "prefix": "string::cutField",
		  "description": "Allows to get the nth element of a string separated by a given separator...",
		  "scope": "",
		  "body": [ "string::cutField \"${1:**string to cut**}\" \"${2:**field number**}\" \"${3:separator}\"$0" ]
	  },

		"io::countArgs": {
		  "prefix": "io::countArgs",
		  "description": "Returns the number of arguments passed...",
		  "scope": "",
		  "body": [ "io::countArgs \"${99:**arguments**}\"$0" ]
	  },

		"log::printCallStack": {
		  "prefix": "log::printCallStack",
		  "description": "This function prints the current function stack in the logs...",
		  "scope": "",
		  "body": [ "log::printCallStack \"${1:**stack to skip**}\"$0" ]
	  },

		"log::isTraceEnabled": {
		  "prefix": "log::isTraceEnabled",
		  "description": "Check if the trace mode is enabled...",
		  "scope": "",
		  "body": [ "log::isTraceEnabled$0" ]
	  },

		"core::getUserDirectory": {
		  "prefix": "core::getUserDirectory",
		  "description": "Returns the path to the valet user directory...",
		  "scope": "",
		  "body": [ "core::getUserDirectory$0" ]
	  },

		"io::createTempFile": {
		  "prefix": "io::createTempFile",
		  "description": "Creates a temporary file and return its path...",
		  "scope": "",
		  "body": [ "io::createTempFile$0" ]
	  },

		"fsfs::itemSelector": {
		  "prefix": "fsfs::itemSelector",
		  "description": "Displays a menu where the user can search and select an item...",
		  "scope": "",
		  "body": [ "fsfs::itemSelector \"${1:**prompt**}\" \"${2:**array name**}\" \"${3:select callback function name}\" \"${4:preview title}\"$0" ]
	  },

		"io::invoke2piped": {
		  "prefix": "io::invoke2piped",
		  "description": "This function call an executable and its arguments and input a given string as stdin...",
		  "scope": "",
		  "body": [ "io::invoke2piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"string::trimAll": {
		  "prefix": "string::trimAll",
		  "description": "Trim all whitespaces and truncate spaces...",
		  "scope": "",
		  "body": [ "string::trimAll \"${1:**string to trim**}\"$0" ]
	  },

		"core::checkParseResults": {
		  "prefix": "core::checkParseResults",
		  "description": "A convenience function to check the parsing results and fails with an error message if there are parsing errors...",
		  "scope": "",
		  "body": [ "core::checkParseResults \"${1:**display help**}\" \"${2:**parsing errors**}\" \"${3:function name}\"$0" ]
	  },

		"system::exportTerminalSize": {
		  "prefix": "system::exportTerminalSize",
		  "description": "This function exports the terminal size...",
		  "scope": "",
		  "body": [ "system::exportTerminalSize$0" ]
	  },

		"io::invokef2piped": {
		  "prefix": "io::invokef2piped",
		  "description": "This function call an executable and its arguments and input a given string as stdin...",
		  "scope": "",
		  "body": [ "io::invokef2piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"log::printRaw": {
		  "prefix": "log::printRaw",
		  "description": "Display something in the log stream...",
		  "scope": "",
		  "body": [ "log::printRaw \"${1:**content**}\"$0" ]
	  },

		"log::error": {
		  "prefix": "log::error",
		  "description": "Displays an error message...",
		  "scope": "",
		  "body": [ "log::error \"${99:**message**}\"$0" ]
	  },

		"kurl::toFile": {
		  "prefix": "kurl::toFile",
		  "description": "This function is a wrapper around curl...",
		  "scope": "",
		  "body": [ "kurl::toFile \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**path**}\" \"${99:**curl arguments**}\"$0" ]
	  },

		"interactive::askForConfirmationRaw": {
		  "prefix": "interactive::askForConfirmationRaw",
		  "description": "Ask the user to press the button to continue...",
		  "scope": "",
		  "body": [ "interactive::askForConfirmationRaw$0" ]
	  },

		"log::info": {
		  "prefix": "log::info",
		  "description": "Displays an info message...",
		  "scope": "",
		  "body": [ "log::info \"${99:**message**}\"$0" ]
	  },

		"core::sourceFunction": {
		  "prefix": "core::sourceFunction",
		  "description": "Source the file associated with a command function...",
		  "scope": "",
		  "body": [ "core::sourceFunction \"${1:**function name**}\"$0" ]
	  },

		"string::bumpSemanticVersion": {
		  "prefix": "string::bumpSemanticVersion",
		  "description": "This function allows to bump a semantic version formatted like: major...",
		  "scope": "",
		  "body": [ "string::bumpSemanticVersion \"${1:**version**}\" \"${2:**level**}\" \"${3:clear build and prerelease}\"$0" ]
	  },

		"test::commentTest": {
		  "prefix": "test::commentTest",
		  "description": "Call this function to add a paragraph in the report file...",
		  "scope": "",
		  "body": [ "test::commentTest \"${1:**comment**}\"$0" ]
	  },

		"io::invoke": {
		  "prefix": "io::invoke",
		  "description": "This function call an executable and its arguments...",
		  "scope": "",
		  "body": [ "io::invoke \"${1:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"interactive::displayQuestion": {
		  "prefix": "interactive::displayQuestion",
		  "description": "Displays a question to the user...",
		  "scope": "",
		  "body": [ "interactive::displayQuestion \"${1:**prompt**}\" \"${2:max width}\"$0" ]
	  },

		"interactive::waitForKey": {
		  "prefix": "interactive::waitForKey",
		  "description": "Wait for a user input (single key)...",
		  "scope": "",
		  "body": [ "interactive::waitForKey \"${99:**read parameters**}\"$0" ]
	  },

		"io::createTempDirectory": {
		  "prefix": "io::createTempDirectory",
		  "description": "Creates a temporary directory...",
		  "scope": "",
		  "body": [ "io::createTempDirectory$0" ]
	  },

		"io::sleep": {
		  "prefix": "io::sleep",
		  "description": "Sleep for the given amount of time...",
		  "scope": "",
		  "body": [ "io::sleep \"${1:**time**}\"$0" ]
	  },

		"core::failWithCode": {
		  "prefix": "core::failWithCode",
		  "description": "Displays an error message and then exit the program with error...",
		  "scope": "",
		  "body": [ "core::failWithCode \"${1:**exit code**}\" \"${99:**message**}\"$0" ]
	  },

		"system::os": {
		  "prefix": "system::os",
		  "description": "Returns the name of the current OS...",
		  "scope": "",
		  "body": [ "system::os$0" ]
	  },

		"array::appendIfNotPresent": {
		  "prefix": "array::appendIfNotPresent",
		  "description": "Add a value to an array if it is not already present...",
		  "scope": "",
		  "body": [ "array::appendIfNotPresent \"${1:**array name**}\"$0" ]
	  },

		"system::getUndeclaredVariables": {
		  "prefix": "system::getUndeclaredVariables",
		  "description": "This function returns the list of undeclared variables for the given names...",
		  "scope": "",
		  "body": [ "system::getUndeclaredVariables \"${99:**variable names**}\"$0" ]
	  },

		"io::invokef2": {
		  "prefix": "io::invokef2",
		  "description": "This function call an executable and its arguments...",
		  "scope": "",
		  "body": [ "io::invokef2 \"${1:**fail**}\" \"${2:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"log::printFileString": {
		  "prefix": "log::printFileString",
		  "description": "Display a file content with line numbers in the logs...",
		  "scope": "",
		  "body": [ "log::printFileString \"${1:**content**}\" \"${2:**max lines**}\"$0" ]
	  },

		"io::invokef5": {
		  "prefix": "io::invokef5",
		  "description": "This function call an executable and its arguments...",
		  "scope": "",
		  "body": [ "io::invokef5 \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**fail**}\" \"${4:**sdtin**}\" \"${5:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"string::regexGetFirst": {
		  "prefix": "string::regexGetFirst",
		  "description": "Matches a string against a regex and returns the first capture group of the matched string...",
		  "scope": "",
		  "body": [ "string::regexGetFirst \"${1:**string**}\" \"${2:**regex**}\"$0" ]
	  },

		"system::date": {
		  "prefix": "system::date",
		  "description": "Get the current date in the given format...",
		  "scope": "",
		  "body": [ "system::date \"${1:format}\"$0" ]
	  },

		"kurl::toVar": {
		  "prefix": "kurl::toVar",
		  "description": "This function is a wrapper around curl...",
		  "scope": "",
		  "body": [ "kurl::toVar \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${99:**curl arguments**}\"$0" ]
	  },

		"core::getLocalStateDirectory": {
		  "prefix": "core::getLocalStateDirectory",
		  "description": "Returns the path to the valet locla state directory...",
		  "scope": "",
		  "body": [ "core::getLocalStateDirectory$0" ]
	  },

		"interactive::askForConfirmation": {
		  "prefix": "interactive::askForConfirmation",
		  "description": "Ask the user to press the button to continue...",
		  "scope": "",
		  "body": [ "interactive::askForConfirmation \"${1:**prompt**}\"$0" ]
	  },

		"core::fail": {
		  "prefix": "core::fail",
		  "description": "Displays an error message and then exit the program with error...",
		  "scope": "",
		  "body": [ "core::fail \"${99:**message**}\"$0" ]
	  },

		"string::kebabCaseToCamelCase": {
		  "prefix": "string::kebabCaseToCamelCase",
		  "description": "This function convert a kebab-case string to a camelCase string...",
		  "scope": "",
		  "body": [ "string::kebabCaseToCamelCase \"${1:**kebab-case string**}\"$0" ]
	  },

		"log::debug": {
		  "prefix": "log::debug",
		  "description": "Displays a debug message...",
		  "scope": "",
		  "body": [ "log::debug \"${99:**message**}\"$0" ]
	  },

		"log::getLevel": {
		  "prefix": "log::getLevel",
		  "description": "Get the current log level...",
		  "scope": "",
		  "body": [ "log::getLevel$0" ]
	  },

		"interactive::promptYesNo": {
		  "prefix": "interactive::promptYesNo",
		  "description": "Ask the user to yes or no...",
		  "scope": "",
		  "body": [ "interactive::promptYesNo \"${1:**prompt**}\" \"${2:default}\"$0" ]
	  },

		"string::trim": {
		  "prefix": "string::trim",
		  "description": "Trim leading and trailing whitespaces...",
		  "scope": "",
		  "body": [ "string::trim \"${1:**string to trim**}\"$0" ]
	  },

		"string::kebabCaseToSnakeCase": {
		  "prefix": "string::kebabCaseToSnakeCase",
		  "description": "This function convert a kebab-case string to a SNAKE_CASE string...",
		  "scope": "",
		  "body": [ "string::kebabCaseToSnakeCase \"${1:**kebab-case string**}\"$0" ]
	  },

		"core::reloadUserCommands": {
		  "prefix": "core::reloadUserCommands",
		  "description": "Forcibly source again the user 'commands' file from the valet user directory...",
		  "scope": "",
		  "body": [ "core::reloadUserCommands$0" ]
	  },

		"array::sortWithCriteria": {
		  "prefix": "array::sortWithCriteria",
		  "description": "Sorts an array using mulitple criteria...",
		  "scope": "",
		  "body": [ "array::sortWithCriteria \"${1:**array name**}\" \"${99:**criteria array names**}\"$0" ]
	  },

		"array::isInArray": {
		  "prefix": "array::isInArray",
		  "description": "Check if a value is in an array...",
		  "scope": "",
		  "body": [ "array::isInArray \"${1:**array name**}\"$0" ]
	  },

		"log::printFile": {
		  "prefix": "log::printFile",
		  "description": "Display a file content with line numbers in the logs...",
		  "scope": "",
		  "body": [ "log::printFile \"${1:**path**}\" \"${2:max lines}\"$0" ]
	  },

		"io::readFile": {
		  "prefix": "io::readFile",
		  "description": "Reads the content of a file and returns it in the global variable RETURNED_VALUE...",
		  "scope": "",
		  "body": [ "io::readFile \"${1:**path**}\" \"${2:max char}\"$0" ]
	  },

		"core::parseArguments": {
		  "prefix": "core::parseArguments",
		  "description": "Parse the arguments and options of a function and return a string that can be evaluated to set the variables...",
		  "scope": "",
		  "body": [ "core::parseArguments \"${99:**arguments**}\"$0" ]
	  },

		"io::checkAndWarn": {
		  "prefix": "io::checkAndWarn",
		  "description": "Check last return code and warn the user in case the return code is not 0...",
		  "scope": "",
		  "body": [ "io::checkAndWarn \"${1:**exit code**}\" \"${99:**message**}\"$0" ]
	  },

		"log::errorTrace": {
		  "prefix": "log::errorTrace",
		  "description": "Displays an error trace message...",
		  "scope": "",
		  "body": [ "log::errorTrace \"${99:**message**}\"$0" ]
	  },

		"io::invoke2": {
		  "prefix": "io::invoke2",
		  "description": "This function call an executable and its arguments...",
		  "scope": "",
		  "body": [ "io::invoke2 \"${1:**fail**}\" \"${2:**executable**}\" \"${99:**arguments**}\"$0" ]
	  },

		"io::readStdIn": {
		  "prefix": "io::readStdIn",
		  "description": "Read the content of the standard input...",
		  "scope": "",
		  "body": [ "io::readStdIn$0" ]
	  },
	"read file to array and loop": {
		"prefix": "read file to array and loop",
		"description": "Read file to array and loop",
		"scope": "",
		"body": [
			"readarray -d $'\\n' fileLines < file",
			"for myString in \"${fileLines[@]}\"; do",
			"  # the difference is also that myString will end with the delimiter, so you might want to remove it",
			"  # Alternatively, you can run readarray with -t but in that case you will not have an array element for empty lines",
			"  echo \"${myString%$'\\n'}\"",
			"done"
		]
	},
	"loop through lines of string": {
		"prefix": "loop through lines of string",
		"description": "Loop through each line of a string (keep empty lines)",
		"scope": "",
		"body": [
			"while read -r line; do",
			"  echo \"${line}\"",
			"done <<< \"${var1}\""
		]
	},
	"loop through lines of string (for)": {
		"prefix": "loop through lines of string (for)",
		"description": "Loop through each line of a string (does not keep empty lines)",
		"scope": "",
		"body": [
			"local IFS=$'\\n'",
			"for line in ${var1}; do",
			"  echo \"${line}\"",
			"done"
		]
	},
	"read file loop on all lines": {
		"prefix": "read file loop on all lines",
		"description": "Read a file, line by line",
		"scope": "",
		"body": [
			"while read -r line || [[ -n ${line:-} ]]; do",
			"  echo \"${line}\"",
			"done < file"
		]
	}
}