{
// Documentation generated for the version 0.28.3846 (2025-03-18).

"array::appendIfNotPresent": {
  "prefix": "array::appendIfNotPresent",
  "description": "Add a value to an array if it is not already present...",
  "scope": "",
  "body": [ "array::appendIfNotPresent \"${1:**array name**}\" \"${2:**value variable name**}\"$0" ]
},

"array::appendIfNotPresent#withdoc": {
  "prefix": "array::appendIfNotPresent#withdoc",
  "description": "Add a value to an array if it is not already present...",
  "scope": "",
  "body": [ "# ## array::appendIfNotPresent\n# \n# Add a value to an array if it is not already present.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array.\n# - \\$2: **value variable name** _as any_:\n#       The variable name containing the value to add.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the value was added\n#   - 1 if it was already present\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" )\n# declare myValue=\"b\"\n# array::appendIfNotPresent myArray myValue\n# printf '%s\\n' \"\\${myArray[@]}\"\n# ```\n# \narray::appendIfNotPresent \"${1:**array name**}\" \"${2:**value variable name**}\"$0" ]
},

"array::checkIfPresent": {
  "prefix": "array::checkIfPresent",
  "description": "Check if a value is in an array...",
  "scope": "",
  "body": [ "array::checkIfPresent \"${1:**array name**}\" \"${2:**value variable name**}\"$0" ]
},

"array::checkIfPresent#withdoc": {
  "prefix": "array::checkIfPresent#withdoc",
  "description": "Check if a value is in an array...",
  "scope": "",
  "body": [ "# ## array::checkIfPresent\n# \n# Check if a value is in an array.\n# It uses pure bash.\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array.\n# - \\$2: **value variable name** _as any_:\n#       The variable name containing the value to check.\n# \n# Returns:\n# \n# - \\$?: 0 if the value is in the array, 1 otherwise.\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" )\n# declare myValue=\"b\"\n# if array::checkIfPresent myArray myValue; then \"b is in the array\"; fi\n# ```\n# \narray::checkIfPresent \"${1:**array name**}\" \"${2:**value variable name**}\"$0" ]
},

"array::fuzzyFilterSort": {
  "prefix": "array::fuzzyFilterSort",
  "description": "Allows to fuzzy sort an array against a given searched string...",
  "scope": "",
  "body": [ "array::fuzzyFilterSort \"${1:**array name**}\" \"${2:**search string**}\"$0" ]
},

"array::fuzzyFilterSort#withdoc": {
  "prefix": "array::fuzzyFilterSort#withdoc",
  "description": "Allows to fuzzy sort an array against a given searched string...",
  "scope": "",
  "body": [ "# ## array::fuzzyFilterSort\n# \n# Allows to fuzzy sort an array against a given searched string.\n# Returns an array containing only the lines matching the searched string.\n# The array is sorted by (in order):\n# \n# - the index of the first matched character in the line\n# - the distance between the first and last matched characters in the line\n# - the original order in the list\n# \n# Also returns an array containing the indexes of the matched items in the original array.\n# \n# - \\$1: **array name** _as string_:\n#       The array name to fuzzy filter and sort.\n# - \\$2: **search string** _as string_:\n#       The variable name containing the search string to match.\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array containing the items sorted and filtered\n# - \\${RETURNED_ARRAY2[@]}: An array containing the indexes of the matched items in the original array\n# \n# ```bash\n# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING\n# echo \"\\${RETURNED_ARRAY[*]}\"\n# ```\n# \n# > - All characters in the searched string must be found in the same order in the matched line.\n# > - Use `shopt -s nocasematch` to make this function is case insensitive.\n# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.\n# \narray::fuzzyFilterSort \"${1:**array name**}\" \"${2:**search string**}\"$0" ]
},

"array::makeArraysSameSize": {
  "prefix": "array::makeArraysSameSize",
  "description": "This function makes sure that all the arrays have the same size...",
  "scope": "",
  "body": [ "array::makeArraysSameSize \"${1:**array names**}\"$0" ]
},

"array::makeArraysSameSize#withdoc": {
  "prefix": "array::makeArraysSameSize#withdoc",
  "description": "This function makes sure that all the arrays have the same size...",
  "scope": "",
  "body": [ "# ## array::makeArraysSameSize\n# \n# This function makes sure that all the arrays have the same size.\n# It will add empty strings to the arrays that are too short.\n# \n# - \\$@: **array names** _as string_:\n#       The variable names of each array to transform.\n# \n# ```bash\n# array::makeArraysSameSize \"array1\" \"array2\" \"array3\"\n# ```\n# \narray::makeArraysSameSize \"${1:**array names**}\"$0" ]
},

"array::sort": {
  "prefix": "array::sort",
  "description": "Sorts an array using the > bash operator (lexicographic order)...",
  "scope": "",
  "body": [ "array::sort \"${1:**array name**}\"$0" ]
},

"array::sort#withdoc": {
  "prefix": "array::sort#withdoc",
  "description": "Sorts an array using the > bash operator (lexicographic order)...",
  "scope": "",
  "body": [ "# ## array::sort\n# \n# Sorts an array using the > bash operator (lexicographic order).\n# \n# - \\$1: **array name** _as string_:\n#       The variable name of the array to sort  (it will be sorted in place).\n# \n# ```bash\n# declare myArray=(z f b h a j)\n# array::sort myArray\n# echo \"\\${myArray[*]}\"\n# ```\n# \n# > - This function uses a quicksort algorithm (hoarse partition).\n# > - The sorting is not stable (the order of equal elements is not preserved).\n# > - It is not appropriate for large array, use the `sort` binary for such cases.\n# \narray::sort \"${1:**array name**}\"$0" ]
},

"array::sortWithCriteria": {
  "prefix": "array::sortWithCriteria",
  "description": "Sorts an array using multiple criteria...",
  "scope": "",
  "body": [ "array::sortWithCriteria \"${1:**array name**}\" \"${2:**criteria array names**}\"$0" ]
},

"array::sortWithCriteria#withdoc": {
  "prefix": "array::sortWithCriteria#withdoc",
  "description": "Sorts an array using multiple criteria...",
  "scope": "",
  "body": [ "# ## array::sortWithCriteria\n# \n# Sorts an array using multiple criteria.\n# Excepts multiple arrays. The first array is the one to sort.\n# The other arrays are used as criteria. Criteria are used in the order they are given.\n# Each criteria array must have the same size as the array to sort.\n# Each criteria array must containing integers representing the order of the elements.\n# We first sort using the first criteria (from smallest to biggest), then the second, etc.\n# \n# - \\$1: **array name** _as string_:\n#       The name of the array to sort (it will be sorted in place).\n# - \\$@: **criteria array names** _as string_:\n#       The names of the arrays to use as criteria.\n#       Each array must have the same size as the array to sort and contain only numbers.\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array that contains the corresponding indexes of the sorted array in the original array\n# \n# ```bash\n# declare myArray=( \"a\" \"b\" \"c\" )\n# declare criteria1=( 3 2 2 )\n# declare criteria2=( 1 3 2 )\n# array::sortWithCriteria myArray criteria1 criteria2\n# echo \"\\${myArray[@]}\"\n# # c b a\n# echo \"\\${RETURNED_ARRAY[@]}\"\n# # 3 2 1\n# ```\n# \n# > - This function uses a quicksort algorithm (hoarse partition).\n# > - The sorting is not stable (the order of equal elements is not preserved).\n# > - It is not appropriate for large array, use the `sort` binary for such cases.\n# \narray::sortWithCriteria \"${1:**array name**}\" \"${2:**criteria array names**}\"$0" ]
},

"bash::countArgs": {
  "prefix": "bash::countArgs",
  "description": "Returns the number of arguments passed...",
  "scope": "",
  "body": [ "bash::countArgs \"${1:**arguments**}\"$0" ]
},

"bash::countArgs#withdoc": {
  "prefix": "bash::countArgs#withdoc",
  "description": "Returns the number of arguments passed...",
  "scope": "",
  "body": [ "# ## bash::countArgs\n# \n# Returns the number of arguments passed.\n# \n# A convenient function that can be used to:\n# \n# - count the files/directories in a directory:\n#   `bash::countArgs \"\\${PWD}\"/* && local numberOfFiles=\"\\${RETURNED_VALUE}\"`\n# - count the number of variables starting with VALET_\n#   `bash::countArgs \"\\${!VALET_@}\" && local numberOfVariables=\"\\${RETURNED_VALUE}\"`\n# \n# Inputs:\n# \n# - \\$@: **arguments** _as any_:\n#       the arguments to count\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The number of arguments passed.\n# \n# ```bash\n# bash::countArgs 1 2 3\n# ```\n# \nbash::countArgs \"${1:**arguments**}\"$0" ]
},

"bash::countJobs": {
  "prefix": "bash::countJobs",
  "description": "This function counts the number of jobs currently running in the background...",
  "scope": "",
  "body": [ "bash::countJobs$0" ]
},

"bash::countJobs#withdoc": {
  "prefix": "bash::countJobs#withdoc",
  "description": "This function counts the number of jobs currently running in the background...",
  "scope": "",
  "body": [ "# ## bash::countJobs\n# \n# This function counts the number of jobs currently running in the background.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the number of jobs currently running in the background.\n# \n# ```bash\n# bash::countJobs\n# echo \"There are currently \\${RETURNED_VALUE} jobs running in the background.\"\n# ```\n# \nbash::countJobs$0" ]
},

"bash::getFunctionDefinitionWithGlobalVars": {
  "prefix": "bash::getFunctionDefinitionWithGlobalVars",
  "description": "This function can be used to get the definition of an existing function, rename it, and replace the use of positional parameters by global variables...",
  "scope": "",
  "body": [ "bash::getFunctionDefinitionWithGlobalVars \"${1:**function name**}\" \"${2:**new function name**}\" \"${3:global variable name}\"$0" ]
},

"bash::getFunctionDefinitionWithGlobalVars#withdoc": {
  "prefix": "bash::getFunctionDefinitionWithGlobalVars#withdoc",
  "description": "This function can be used to get the definition of an existing function, rename it, and replace the use of positional parameters by global variables...",
  "scope": "",
  "body": [ "# ## bash::getFunctionDefinitionWithGlobalVars\n# \n# This function can be used to get the definition of an existing function,\n# rename it, and replace the use of positional parameters by global variables.\n# \n# This can be useful for performance reasons when a function is called many times,\n# to avoid copying the positional parameters each time.\n# \n# - \\$1: **function name** _as string_:\n#       the name of the function to re-export\n# - \\$2: **new function name** _as string_:\n#       the name of the new function to create\n# - \\$@: global variable name _as string_:\n#       the name of the global variable to use instead of the positional parameters\n#       (can be repeated multiple times, for each parameter)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the function was successfully re-exported\n#   - 1 if the function does not exist\n# - \\${RETURNED_VALUE}: the modified function definition\n# - \\${RETURNED_VALUE2}: the original function\n# \n# ```bash\n# bash::getFunctionDefinitionWithGlobalVars \"myFunction\" \"myFunctionWithGlobalVars\" \"MY_VAR1\" \"MY_VAR2\"\n# eval \"\\${RETURNED_VALUE}\"\n# myFunctionWithGlobalVars\n# ```\n# \nbash::getFunctionDefinitionWithGlobalVars \"${1:**function name**}\" \"${2:**new function name**}\" \"${3:global variable name}\"$0" ]
},

"bash::getMissingCommands": {
  "prefix": "bash::getMissingCommands",
  "description": "This function returns the list of not existing commands for the given names...",
  "scope": "",
  "body": [ "bash::getMissingCommands \"${1:**command names**}\"$0" ]
},

"bash::getMissingCommands#withdoc": {
  "prefix": "bash::getMissingCommands#withdoc",
  "description": "This function returns the list of not existing commands for the given names...",
  "scope": "",
  "body": [ "# ## bash::getMissingCommands\n# \n# This function returns the list of not existing commands for the given names.\n# \n# - \\$@: **command names** _as string_:\n#       the list of command names to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if there are not existing commands\n#   - 1 otherwise.\n# - \\${RETURNED_ARRAY[@]}: the list of not existing commands.\n# \n# ```bash\n# if bash::getMissingCommands \"command1\" \"command2\"; then\n#   printf 'The following commands do not exist: %s' \"\\${RETURNED_ARRAY[*]}\"\n# fi\n# ```\n# \nbash::getMissingCommands \"${1:**command names**}\"$0" ]
},

"bash::getMissingVariables": {
  "prefix": "bash::getMissingVariables",
  "description": "This function returns the list of undeclared variables for the given names...",
  "scope": "",
  "body": [ "bash::getMissingVariables \"${1:**variable names**}\"$0" ]
},

"bash::getMissingVariables#withdoc": {
  "prefix": "bash::getMissingVariables#withdoc",
  "description": "This function returns the list of undeclared variables for the given names...",
  "scope": "",
  "body": [ "# ## bash::getMissingVariables\n# \n# This function returns the list of undeclared variables for the given names.\n# \n# - \\$@: **variable names** _as string_:\n#       the list of variable names to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if there are variable undeclared\n#   - 1 otherwise.\n# - \\${RETURNED_ARRAY[@]}: the list of undeclared variables.\n# \n# ```bash\n# if bash::getMissingVariables \"var1\" \"var2\"; then\n#   printf 'The following variables are not declared: %s' \"\\${RETURNED_ARRAY[*]}\"\n# fi\n# ```\n# \nbash::getMissingVariables \"${1:**variable names**}\"$0" ]
},

"bash::injectCodeInFunction": {
  "prefix": "bash::injectCodeInFunction",
  "description": "This function injects code at the beginning or the end of a function and returns the modified function to be evaluated...",
  "scope": "",
  "body": [ "bash::injectCodeInFunction \"${1:**function name**}\" \"${2:**code**}\" \"${3:inject at beginning}\"$0" ]
},

"bash::injectCodeInFunction#withdoc": {
  "prefix": "bash::injectCodeInFunction#withdoc",
  "description": "This function injects code at the beginning or the end of a function and returns the modified function to be evaluated...",
  "scope": "",
  "body": [ "# ## bash::injectCodeInFunction\n# \n# This function injects code at the beginning or the end of a function and\n# returns the modified function to be evaluated.\n# \n# - \\$1: **function name** _as string_:\n#       The name of the function to inject the code into.\n# - \\$2: **code** _as string_:\n#       The code to inject.\n# - \\$3: inject at beginning _as bool_:\n#       (optional) Can be set using the variable `_OPTION_INJECT_AT_BEGINNING`.\n#       Whether to inject the code at the beginning of the function (or at the end).\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the modified function.\n# - \\${RETURNED_VALUE2}: the original function.\n# \n# ```bash\n# bash::injectCodeInFunction myFunction \"echo 'Hello world!'\" true\n# eval \"\\${RETURNED_VALUE}\"\n# myFunction\n# ```\n# \nbash::injectCodeInFunction \"${1:**function name**}\" \"${2:**code**}\" \"${3:inject at beginning}\"$0" ]
},

"bash::isCommand": {
  "prefix": "bash::isCommand",
  "description": "Check if the given command exists...",
  "scope": "",
  "body": [ "bash::isCommand \"${1:**command name**}\"$0" ]
},

"bash::isCommand#withdoc": {
  "prefix": "bash::isCommand#withdoc",
  "description": "Check if the given command exists...",
  "scope": "",
  "body": [ "# ## bash::isCommand\n# \n# Check if the given command exists.\n# \n# - \\$1: **command name** _as string_:\n#       the command name to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the command exists\n#   - 1 otherwise.\n# \n# ```bash\n# if bash::isCommand \"command1\"; then\n#   printf 'The command exists.'\n# fi\n# ```\n# \nbash::isCommand \"${1:**command name**}\"$0" ]
},

"bash::isFunction": {
  "prefix": "bash::isFunction",
  "description": "Check if the given function exists...",
  "scope": "",
  "body": [ "bash::isFunction \"${1:**function name**}\"$0" ]
},

"bash::isFunction#withdoc": {
  "prefix": "bash::isFunction#withdoc",
  "description": "Check if the given function exists...",
  "scope": "",
  "body": [ "# ## bash::isFunction\n# \n# Check if the given function exists.\n# \n# - \\$1: **function name** _as string_:\n#       the function name to check.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the function exists\n#   - 1 otherwise.\n# \n# ```bash\n# if bash::isFunction \"function1\"; then\n#   printf 'The function exists.'\n# fi\n# ```\n# \nbash::isFunction \"${1:**function name**}\"$0" ]
},

"bash::readStdIn": {
  "prefix": "bash::readStdIn",
  "description": "Read the content of the standard input...",
  "scope": "",
  "body": [ "bash::readStdIn$0" ]
},

"bash::readStdIn#withdoc": {
  "prefix": "bash::readStdIn#withdoc",
  "description": "Read the content of the standard input...",
  "scope": "",
  "body": [ "# ## bash::readStdIn\n# \n# Read the content of the standard input.\n# Will immediately return if the standard input is empty.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The content of the standard input.\n# \n# ```bash\n# bash::readStdIn && local stdIn=\"\\${RETURNED_VALUE}\"\n# ```\n# \nbash::readStdIn$0" ]
},

"bash::runInParallel": {
  "prefix": "bash::runInParallel",
  "description": "This function runs a list of commands in parallel with a maximum number of parallel jobs...",
  "scope": "",
  "body": [ "_OPTION_TIMEOUT_BETWEEN_CHECKS=${5} bash::runInParallel \"${1:**job names array name**}\" \"${2:**job commands array name**}\" \"${3:max parallel jobs}\" \"${4:job completed callback}\"$0" ]
},

"bash::runInParallel#withdoc": {
  "prefix": "bash::runInParallel#withdoc",
  "description": "This function runs a list of commands in parallel with a maximum number of parallel jobs...",
  "scope": "",
  "body": [ "# ## bash::runInParallel\n# \n# This function runs a list of commands in parallel with a maximum number of parallel jobs.\n# \n# - \\$1: **job names array name** _as string_:\n#       The name of the array containing the names of the jobs to run.\n# - \\$2: **job commands array name** _as string_:\n#       The name of the array containing the commands to run.\n# - \\$3: max parallel jobs _as integer_:\n#       (optional) Can be set using the variable `_OPTION_MAX_PARALLEL_JOBS`.\n#       The maximum number of parallel jobs to run.\n#       (defaults to 4)\n# - \\$4: job completed callback _as string_:\n#       (optional) Can be set using the variable `_OPTION_JOB_COMPLETED_CALLBACK`.\n#       The name of the function to call when a job is completed.\n#       The function will receive the following arguments:\n#       - the job index\n#       - the job name\n#       - the job exit code\n#       - the percentage of jobs completed\n#       If the function returns 1, the script will exit early.\n#       (defaults to \"\")\n# - \\${_OPTION_TIMEOUT_BETWEEN_CHECKS} _as float_:\n#       (optional) Can be set using the variable `_OPTION_TIMEOUT_BETWEEN_CHECKS`.\n#       The time to wait between checks for completed jobs (when no jobs finished\n#       when we last checked).\n#       (defaults to 0.2)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0: if all the jobs completed successfully.\n#   - 1: if the job completed callback returned 1.\n# - \\${RETURNED_ARRAY[@]}: an array containing the exit codes of the jobs.\n# \n# ```bash\n# declare -a jobNames=(\"job1\" \"job2\" \"job3\")\n# declare -a jobCommands=(\"sleep 1\" \"sleep 2\" \"sleep 3\")\n# _OPTION_MAX_PARALLEL_JOBS=2 bash::runInParallel jobNames jobCommands\n# ```\n# \n_OPTION_TIMEOUT_BETWEEN_CHECKS=${5} bash::runInParallel \"${1:**job names array name**}\" \"${2:**job commands array name**}\" \"${3:max parallel jobs}\" \"${4:job completed callback}\"$0" ]
},

"bash::sleep": {
  "prefix": "bash::sleep",
  "description": "Sleep for the given amount of time...",
  "scope": "",
  "body": [ "bash::sleep \"${1:**time**}\"$0" ]
},

"bash::sleep#withdoc": {
  "prefix": "bash::sleep#withdoc",
  "description": "Sleep for the given amount of time...",
  "scope": "",
  "body": [ "# ## bash::sleep\n# \n# Sleep for the given amount of time.\n# This is a pure bash replacement of sleep.\n# \n# - \\$1: **time** _as float_:\n#       the time to sleep in seconds (can be a float)\n# \n# ```bash\n# bash::sleep 1.5\n# ```\n# \n# > The sleep command is not a built-in command in bash, but a separate executable. When you use sleep, you are creating a new process.\n# \nbash::sleep \"${1:**time**}\"$0" ]
},

"benchmark::run": {
  "prefix": "benchmark::run",
  "description": "This function runs a benchmark on given functions...",
  "scope": "",
  "body": [ "benchmark::run \"${1:**baseline**}\" \"${2:functions}\" \"${3:time}\" \"${4:max runs}\"$0" ]
},

"benchmark::run#withdoc": {
  "prefix": "benchmark::run#withdoc",
  "description": "This function runs a benchmark on given functions...",
  "scope": "",
  "body": [ "# ## benchmark::run\n# \n# This function runs a benchmark on given functions.\n# \n# First, it will run the 1st function (the baseline) for a given number of time and\n# mark the number of times it was able to run it in that given time.\n# \n# Then, it will run all the functions for the same number of time and\n# print the difference between the baseline and the other functions.\n# \n# - \\$1: **baseline** _as string_:\n#       the name of the function to use as baseline\n# - \\$2: functions _as string_:\n#       The names of the functions to benchmark, comma separated.\n# - \\$3: time _as int_:\n#       (optional) Can be set using the variable `_OPTION_TIME`.\n#       The time in seconds for which to run the baseline.\n#       (defaults to 3s)\n# - \\$4: max runs _as int_:\n#       (optional) Can be set using the variable `_OPTION_MAX_RUNS`.\n#       The maximum number of runs to do for each function.\n#       (defaults to -1 which means no limit)\n# \n# ```bash\n# benchmark::run \"baseline\" \"function1,function2\" 1 100\n# ```\n# \nbenchmark::run \"${1:**baseline**}\" \"${2:functions}\" \"${3:time}\" \"${4:max runs}\"$0" ]
},

"command::checkParsedResults": {
  "prefix": "command::checkParsedResults",
  "description": "A convenience function to check the parsing results and fails with an error message if there are parsing errors...",
  "scope": "",
  "body": [ "command::checkParsedResults$0" ]
},

"command::checkParsedResults#withdoc": {
  "prefix": "command::checkParsedResults#withdoc",
  "description": "A convenience function to check the parsing results and fails with an error message if there are parsing errors...",
  "scope": "",
  "body": [ "# ## command::checkParsedResults\n# \n# A convenience function to check the parsing results and fails with an error message if there are\n# parsing errors.\n# Will also display the help if the help option is true.\n# \n# This should be called from a command function for which you want to check the parsing results.\n# \n# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed\n# and if there are parsing errors.\n# \n# ```bash\n# command::checkParsedResults\n# ```\n# \ncommand::checkParsedResults$0" ]
},

"command::parseArguments": {
  "prefix": "command::parseArguments",
  "description": "Parse the arguments and options of a function and return a string that can be evaluated to set the variables...",
  "scope": "",
  "body": [ "command::parseArguments \"${1:**arguments**}\"$0" ]
},

"command::parseArguments#withdoc": {
  "prefix": "command::parseArguments#withdoc",
  "description": "Parse the arguments and options of a function and return a string that can be evaluated to set the variables...",
  "scope": "",
  "body": [ "# ## command::parseArguments\n# \n# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.\n# This should be called from a command function for which you want to parse the arguments.\n# \n# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.\n# \n# \n# - \\$@: **arguments** _as any_:\n#       the arguments to parse\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: a string that can be evaluated to set the parsed variables\n# \n# Output example:\n# \n# ```\n# local arg1 option1\n# arg1=\"xxx\"\n# option1=\"xxx\"\n# ```\n# \n# ```bash\n# command::parseArguments \"\\$@\" && eval \"\\${RETURNED_VALUE}\"\n# ```\n# \ncommand::parseArguments \"${1:**arguments**}\"$0" ]
},

"command::showHelp": {
  "prefix": "command::showHelp",
  "description": "Show the help for the current function...",
  "scope": "",
  "body": [ "command::showHelp$0" ]
},

"command::showHelp#withdoc": {
  "prefix": "command::showHelp#withdoc",
  "description": "Show the help for the current function...",
  "scope": "",
  "body": [ "# ## command::showHelp\n# \n# Show the help for the current function.\n# This should be called directly from a command function for which you want to display the help text.\n# \n# ```bash\n# command::showHelp\n# ```\n# \ncommand::showHelp$0" ]
},

"command::sourceFunction": {
  "prefix": "command::sourceFunction",
  "description": "Source the file associated with a command function...",
  "scope": "",
  "body": [ "command::sourceFunction \"${1:**function name**}\"$0" ]
},

"command::sourceFunction#withdoc": {
  "prefix": "command::sourceFunction#withdoc",
  "description": "Source the file associated with a command function...",
  "scope": "",
  "body": [ "# ## command::sourceFunction\n# \n# Source the file associated with a command function.\n# This allows you to call a command function without having to source the file manually.\n# \n# - \\$1: **function name** _as string_:\n#       the function name\n# \n# ```bash\n# command::sourceFunction \"functionName\"\n# ```\n# \ncommand::sourceFunction \"${1:**function name**}\"$0" ]
},

"core::createNewStateFilePath": {
  "prefix": "core::createNewStateFilePath",
  "description": "Returns the path to a new file stored in the user state directory...",
  "scope": "",
  "body": [ "core::createNewStateFilePath \"${1:**file suffix**}\"$0" ]
},

"core::createNewStateFilePath#withdoc": {
  "prefix": "core::createNewStateFilePath#withdoc",
  "description": "Returns the path to a new file stored in the user state directory...",
  "scope": "",
  "body": [ "# ## core::createNewStateFilePath\n# \n# Returns the path to a new file stored in the user state directory.\n# Can be used to save the state of important temporary files generated during a program\n# execution.\n# \n# - \\$1: **file suffix** _as string_:\n#       The suffix for the file to create.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The path to the created file.\n# \n# ```bash\n# core::createNewStateFilePath \"my-file\"\n# printf '%s\\n' \"The file is ⌜\\${RETURNED_VALUE}⌝.\"\n# ```\n# \ncore::createNewStateFilePath \"${1:**file suffix**}\"$0" ]
},

"core::fail": {
  "prefix": "core::fail",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "core::fail \"${1:**message**}\"$0" ]
},

"core::fail#withdoc": {
  "prefix": "core::fail#withdoc",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "# ## core::fail\n# \n# Displays an error message and then exit the program with error.\n# \n# - \\$@: **message** _as string_:\n#       the error message to display\n# \n# ```bash\n# core::fail \"This is an error message.\"\n# ```\n# \ncore::fail \"${1:**message**}\"$0" ]
},

"core::failWithCode": {
  "prefix": "core::failWithCode",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "core::failWithCode \"${1:**exit code**}\" \"${2:**message**}\"$0" ]
},

"core::failWithCode#withdoc": {
  "prefix": "core::failWithCode#withdoc",
  "description": "Displays an error message and then exit the program with error...",
  "scope": "",
  "body": [ "# ## core::failWithCode\n# \n# Displays an error message and then exit the program with error.\n# \n# - \\$1: **exit code** _as int_:\n#       the exit code to use, should be between 1 and 255\n# - \\$@: **message** _as string_:\n#       the error message to display\n# \n# ```bash\n# core::failWithCode 255 \"This is an error message.\"\n# ```\n# \ncore::failWithCode \"${1:**exit code**}\" \"${2:**message**}\"$0" ]
},

"core::getConfigurationDirectory": {
  "prefix": "core::getConfigurationDirectory",
  "description": "Returns the path to the valet configuration directory...",
  "scope": "",
  "body": [ "core::getConfigurationDirectory$0" ]
},

"core::getConfigurationDirectory#withdoc": {
  "prefix": "core::getConfigurationDirectory#withdoc",
  "description": "Returns the path to the valet configuration directory...",
  "scope": "",
  "body": [ "# ## core::getConfigurationDirectory\n# \n# Returns the path to the valet configuration directory.\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the path to the valet configuration directory\n# \n# ```bash\n# core::getConfigurationDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \ncore::getConfigurationDirectory$0" ]
},

"core::getExtensionsDirectory": {
  "prefix": "core::getExtensionsDirectory",
  "description": "Returns the path to the user extensions directory...",
  "scope": "",
  "body": [ "core::getExtensionsDirectory$0" ]
},

"core::getExtensionsDirectory#withdoc": {
  "prefix": "core::getExtensionsDirectory#withdoc",
  "description": "Returns the path to the user extensions directory...",
  "scope": "",
  "body": [ "# ## core::getExtensionsDirectory\n# \n# Returns the path to the user extensions directory.\n# Does not create it if missing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the path to the valet user directory\n# \n# ```bash\n# core::getExtensionsDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \ncore::getExtensionsDirectory$0" ]
},

"core::getUserCacheDirectory": {
  "prefix": "core::getUserCacheDirectory",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "core::getUserCacheDirectory$0" ]
},

"core::getUserCacheDirectory#withdoc": {
  "prefix": "core::getUserCacheDirectory#withdoc",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "# ## core::getUserCacheDirectory\n# \n# Returns the path to the valet local cache directory.\n# Where user-specific non-essential (cached) data should be written (analogous to /var/cache).\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserCacheDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \ncore::getUserCacheDirectory$0" ]
},

"core::getUserDataDirectory": {
  "prefix": "core::getUserDataDirectory",
  "description": "Returns the path to the valet local data directory...",
  "scope": "",
  "body": [ "core::getUserDataDirectory$0" ]
},

"core::getUserDataDirectory#withdoc": {
  "prefix": "core::getUserDataDirectory#withdoc",
  "description": "Returns the path to the valet local data directory...",
  "scope": "",
  "body": [ "# ## core::getUserDataDirectory\n# \n# Returns the path to the valet local data directory.\n# Where user-specific data files should be written (analogous to /usr/share).\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserDataDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \ncore::getUserDataDirectory$0" ]
},

"core::getUserStateDirectory": {
  "prefix": "core::getUserStateDirectory",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "core::getUserStateDirectory$0" ]
},

"core::getUserStateDirectory#withdoc": {
  "prefix": "core::getUserStateDirectory#withdoc",
  "description": "Returns the path to the valet local cache directory...",
  "scope": "",
  "body": [ "# ## core::getUserStateDirectory\n# \n# Returns the path to the valet local cache directory.\n# Where user-specific state files should be written (analogous to /var/lib).\n# Ideal location for storing runtime information, logs, etc...\n# Creates it if missing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the path to the valet local state directory\n# \n# ```bash\n# core::getUserStateDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \ncore::getUserStateDirectory$0" ]
},

"core::getVersion": {
  "prefix": "core::getVersion",
  "description": "Returns the version of Valet...",
  "scope": "",
  "body": [ "core::getVersion$0" ]
},

"core::getVersion#withdoc": {
  "prefix": "core::getVersion#withdoc",
  "description": "Returns the version of Valet...",
  "scope": "",
  "body": [ "# ## core::getVersion\n# \n# Returns the version of Valet.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The version of Valet.\n# \n# ```bash\n# core::getVersion\n# printf '%s\\n' \"The version of Valet is ⌜\\${RETURNED_VALUE}⌝.\"\n# ```\n# \ncore::getVersion$0" ]
},

"curl::download": {
  "prefix": "curl::download",
  "description": "This function is a wrapper around curl to save a request result in a file...",
  "scope": "",
  "body": [ "curl::download \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**path**}\" \"${4:**curl arguments**}\"$0" ]
},

"curl::download#withdoc": {
  "prefix": "curl::download#withdoc",
  "description": "This function is a wrapper around curl to save a request result in a file...",
  "scope": "",
  "body": [ "# ## curl::download\n# \n# This function is a wrapper around curl to save a request result in a file.\n# It allows you to check the http status code and return 1 if it is not acceptable.\n# It invokes curl with the following options (do not repeat them): -sSL -w \"%{response_code}\" -o \\${2}.\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails\n# - \\$2: **acceptable codes** _as string_:\n#       list of http status codes that are acceptable, comma separated\n#       (defaults to 200,201,202,204,301,304,308 if left empty)\n# - \\$3: **path** _as string_:\n#       the file in which to save the output of curl\n# - \\$@: **curl arguments** _as any_:\n#       options for curl\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the http status code is acceptable\n#   - 1 otherwise\n# - \\${RETURNED_VALUE}: the content of stderr\n# - \\${RETURNED_VALUE2}: the http status code\n# \n# ```bash\n# curl::download true 200,201 \"/filePath\" \"https://example.com\"\n# curl::download false 200 \"/filePath2\" \"https://example2.com\" || core::fail \"The curl command failed.\"\n# ```\n# \ncurl::download \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**path**}\" \"${4:**curl arguments**}\"$0" ]
},

"curl::request": {
  "prefix": "curl::request",
  "description": "This function is a wrapper around curl to save the content of a request in a variable...",
  "scope": "",
  "body": [ "curl::request \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**curl arguments**}\"$0" ]
},

"curl::request#withdoc": {
  "prefix": "curl::request#withdoc",
  "description": "This function is a wrapper around curl to save the content of a request in a variable...",
  "scope": "",
  "body": [ "# ## curl::request\n# \n# This function is a wrapper around curl to save the content of a request in a variable.\n# It allows you to check the http status code and return 1 if it is not acceptable.\n# It invokes curl with the following options (do not repeat them): -sSL -w \"%{response_code}\" -o \"tempfile\".\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails\n# - \\$2: **acceptable codes** _as string_:\n#       list of http status codes that are acceptable, comma separated\n#       (defaults to 200,201,202,204,301,304,308 if left empty)\n# - \\$@: **curl arguments** _as any_:\n#       options for curl\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the http status code is acceptable\n#   - 1 otherwise\n# - \\${RETURNED_VALUE}: the content of the request\n# - \\${RETURNED_VALUE2}: the content of stderr\n# - \\${RETURNED_VALUE3}: the http status code\n# \n# ```bash\n# curl::request true 200 https://example.com -X POST -H 'Authorization: token'\n# curl::request false 200,201 https://example.com || core::fail \"The curl command failed.\"\n# ```\n# \ncurl::request \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**curl arguments**}\"$0" ]
},

"esc-codes::*": {
  "prefix": "esc-codes::*",
  "description": "ANSI codes for text attributes, colors, cursor control, and other common escape sequences...",
  "scope": "",
  "body": [ "esc-codes::*$0" ]
},

"esc-codes::*#withdoc": {
  "prefix": "esc-codes::*#withdoc",
  "description": "ANSI codes for text attributes, colors, cursor control, and other common escape sequences...",
  "scope": "",
  "body": [ "# ## esc-codes::*\n# \n# ANSI codes for text attributes, colors, cursor control, and other common escape sequences.\n# These codes can be used to format text in the terminal.\n# \n# These codes were selected because they are widely supported by terminals and they\n# probably will cover all use cases. It is also advised to stick to the 4-bit colors\n# which allows your application to adopt the color scheme of the terminal.\n# \n# They are defined as variables and not as functions. Please check the content of the esc-codes to learn more:\n# <https://github.com/jcaillon/valet/blob/latest/libraries.d/esc-codes>\n# \n# References:\n# \n# - https://en.wikipedia.org/wiki/ANSI_escape_code\n# - https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797\n# - https://paulbourke.net/dataformats/ascii/\n# - https://www.aivosto.com/articles/control-characters.html\n# - https://github.com/tmux/tmux/blob/master/tools/ansicode.txt\n# - https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_\n# - https://vt100.net/docs/vt102-ug/chapter5.html\n# - https://vt100.net/docs/vt100-ug/chapter3.html#S3.3.1\n# \n# Ascii graphics:\n# \n# - https://gist.github.com/dsample/79a97f38bf956f37a0f99ace9df367b9\n# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Box_Drawing\n# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Block_Elements\n# \n# > While it could be very handy to define a function for each of these instructions,\n# > it would also be slower to execute (function overhead + multiple printf calls).\n# \nesc-codes::*$0" ]
},

"exe::captureOutput": {
  "prefix": "exe::captureOutput",
  "description": "Capture the output of a command...",
  "scope": "",
  "body": [ "exe::captureOutput \"${1:**command**}\"$0" ]
},

"exe::captureOutput#withdoc": {
  "prefix": "exe::captureOutput#withdoc",
  "description": "Capture the output of a command...",
  "scope": "",
  "body": [ "# ## exe::captureOutput\n# \n# Capture the output of a command.\n# Made to be used on bash builtins that produce output.\n# It captures the stdout and stderr of the command.\n# \n# This function is a lot more basic than `exe::invoke` and does not support all its features.\n# \n# - \\$@: **command** _as string_:\n#       The command to run.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${RETURNED_VALUE}: The captured output.\n# \n# ```bash\n# exe::captureOutput declare -f exe::captureOutput\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nexe::captureOutput \"${1:**command**}\"$0" ]
},

"exe::invoke": {
  "prefix": "exe::invoke",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invoke \"${1:**executable**}\" \"${2:**arguments**}\"$0" ]
},

"exe::invoke#withdoc": {
  "prefix": "exe::invoke#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invoke\n# \n# This function call an executable and its arguments.\n# If the execution fails, it will fail the script and show the std/err output.\n# Otherwise it hides both streams, effectively rendering the execution silent unless it fails.\n# \n# It redirects the stdout and stderr to environment variables.\n# Equivalent to `exe::invoke5 true 0 '' '' \"\\${@}\"`\n# \n# - \\$1: **executable** _as string_:\n#       the executable or command\n# - \\$@: **arguments** _as any_:\n#       the command and its arguments\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# exe::invoke git add --all\n# ```\n# \n# > See exe::invokef5 for more information.\n# \nexe::invoke \"${1:**executable**}\" \"${2:**arguments**}\"$0" ]
},

"exe::invoke2": {
  "prefix": "exe::invoke2",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invoke2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"exe::invoke2#withdoc": {
  "prefix": "exe::invoke2#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invoke2\n# \n# This function call an executable and its arguments.\n# It redirects the stdout and stderr to environment variables.\n# Equivalent to `exe::invoke5 \"\\${1}\" 0 \"\" \"\" \"\\${@:2}\"`\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# exe::invoke2 false git status || core::fail \"status failed.\"\n# stdout=\"\\${RETURNED_VALUE}\"\n# stderr=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > See exe::invokef5 for more information.\n# \nexe::invoke2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"exe::invoke3piped": {
  "prefix": "exe::invoke3piped",
  "description": "This function call an executable and its arguments and input a given string as stdin...",
  "scope": "",
  "body": [ "exe::invoke3piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${4:**arguments**}\"$0" ]
},

"exe::invoke3piped#withdoc": {
  "prefix": "exe::invoke3piped#withdoc",
  "description": "This function call an executable and its arguments and input a given string as stdin...",
  "scope": "",
  "body": [ "# ## exe::invoke3piped\n# \n# This function call an executable and its arguments and input a given string as stdin.\n# It redirects the stdout and stderr to environment variables.\n# Equivalent to `exe::invoke5 \"\\${1}\" 0 false \"\\${2}\" \"\\${@:3}\"`\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **stdin** _as string_:\n#       The stdin content to pass to the executable\n# - \\$3: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# exe::invoke3piped true \"key: val\" yq -o json -p yaml -\n# stdout=\"\\${RETURNED_VALUE}\"\n# stderr=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > This is the equivalent of:\n# > `myvar=\"\\$(printf '%s\\n' \"mystring\" | mycommand)\"`\n# > But without using a subshell.\n# >\n# > See exe::invokef5 for more information.\n# \nexe::invoke3piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${4:**arguments**}\"$0" ]
},

"exe::invoke5": {
  "prefix": "exe::invoke5",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invoke5 \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**stdin from file**}\" \"${4:**stdin**}\" \"${5:**executable**}\" \"${6:**arguments**}\"$0" ]
},

"exe::invoke5#withdoc": {
  "prefix": "exe::invoke5#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invoke5\n# \n# This function call an executable and its arguments.\n# It redirects the stdout and stderr to environment variables.\n# It calls invoke5 and reads the files to set the environment variables.\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **acceptable codes** _as string_:\n#       the acceptable error codes, comma separated\n#       (if the error code is matched, then set the output error code to 0)\n# - \\$3: **stdin from file** _as bool_:\n#       true/false to indicate if the 4th argument represents a file path or directly the content for stdin\n# - \\$4: **stdin** _as string_:\n#       the stdin (can be empty)\n# - \\$5: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# exe::invoke5 \"false\" \"130,2\" \"false\" \"This is the stdin\" \"stuff\" \"--height=10\" || core::fail \"stuff failed.\"\n# stdout=\"\\${RETURNED_VALUE}\"\n# stderr=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > See exe::invokef5 for more information.\n# \nexe::invoke5 \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**stdin from file**}\" \"${4:**stdin**}\" \"${5:**executable**}\" \"${6:**arguments**}\"$0" ]
},

"exe::invokef2": {
  "prefix": "exe::invokef2",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invokef2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"exe::invokef2#withdoc": {
  "prefix": "exe::invokef2#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invokef2\n# \n# This function call an executable and its arguments.\n# It redirects the stdout and stderr to temporary files.\n# Equivalent to `exe::invokef5 \"\\${1}\" 0 \"\" \"\" \"\\${@:2}\"`\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The file path containing the stdout of the executable.\n# - \\${RETURNED_VALUE2}: The file path containing the stderr of the executable.\n# \n# ```bash\n# exe::invokef2 false git status || core::fail \"status failed.\"\n# stdoutFilePath=\"\\${RETURNED_VALUE}\"\n# stderrFilePath=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > See exe::invokef5 for more information.\n# \nexe::invokef2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"exe::invokef3piped": {
  "prefix": "exe::invokef3piped",
  "description": "This function call an executable and its arguments and input a given string as stdin...",
  "scope": "",
  "body": [ "exe::invokef3piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${4:**arguments**}\"$0" ]
},

"exe::invokef3piped#withdoc": {
  "prefix": "exe::invokef3piped#withdoc",
  "description": "This function call an executable and its arguments and input a given string as stdin...",
  "scope": "",
  "body": [ "# ## exe::invokef3piped\n# \n# This function call an executable and its arguments and input a given string as stdin.\n# It redirects the stdout and stderr to temporary files.\n# Equivalent to `exe::invokef5 \"\\${1}\" 0 false \"\\${2}\" \"\\${@:3}\"`\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **stdin** _as string_:\n#       The stdin content to pass to the executable\n# - \\$3: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The file path containing the stdout of the executable.\n# - \\${RETURNED_VALUE2}: The file path containing the stderr of the executable.\n# \n# ```bash\n# exe::invokef3piped true \"key: val\" yq -o json -p yaml -\n# stdoutFilePath=\"\\${RETURNED_VALUE}\"\n# stderrFilePath=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > This is the equivalent of:\n# > `myvar=\"\\$(printf '%s\\n' \"mystring\" | mycommand)\"`\n# > But without using a subshell.\n# >\n# > See exe::invokef5 for more information.\n# \nexe::invokef3piped \"${1:**fail**}\" \"${2:**stdin**}\" \"${3:**executable**}\" \"${4:**arguments**}\"$0" ]
},

"exe::invokef5": {
  "prefix": "exe::invokef5",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invokef5 \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**sdtin from file**}\" \"${4:**stdin**}\" \"${5:**executable**}\" \"${6:**arguments**}\"$0" ]
},

"exe::invokef5#withdoc": {
  "prefix": "exe::invokef5#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invokef5\n# \n# This function call an executable and its arguments.\n# It redirects the stdout and stderr to temporary files.\n# \n# - \\$1: **fail** _as bool_:\n#       A boolean to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **acceptable codes** _as string_:\n#       The acceptable error codes, comma separated.\n#       (if the error code is matched, then set the output error code to 0)\n# - \\$3: **sdtin from file** _as bool_:\n#       A boolean to indicate if the 4th argument represents a file path or\n#       directly the content for stdin.\n# - \\$2: **stdin** _as string_:\n#       The stdin content to pass to the executable.\n#       Can be empty if not used.\n# - \\$5: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# - \\${_OPTION_NO_REDIRECTION}: _as bool_:\n#       (optional) If set to true, the function will not redirect the stdout and stderr to temporary files.\n#       (default to false)\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# - \\${RETURNED_VALUE}: The file path containing the stdout of the executable.\n# - \\${RETURNED_VALUE2}: The file path containing the stderr of the executable.\n# \n# ```bash\n# exe::invokef5 \"false\" \"130,2\" \"false\" \"This is the stdin\" \"stuff\" \"--height=10\" || core::fail \"stuff failed.\"\n# stdoutFilePath=\"\\${RETURNED_VALUE}\"\n# stderrFilePath=\"\\${RETURNED_VALUE2}\"\n# ```\n# \n# > - In windows, this is tremendously faster to do (or any other invoke flavor):\n# >   `exe::invokef5 false 0 false '' mycommand && myvar=\"\\${RETURNED_VALUE}\"`\n# >   than doing:\n# >   `myvar=\"\\$(mycommand)\".`\n# > - On linux, it is slightly faster (but it might be slower if you don't have SSD?).\n# > - On linux, you can use a tmpfs directory for massive gains over subshells.\n# \nexe::invokef5 \"${1:**fail**}\" \"${2:**acceptable codes**}\" \"${3:**sdtin from file**}\" \"${4:**stdin**}\" \"${5:**executable**}\" \"${6:**arguments**}\"$0" ]
},

"exe::invoket2": {
  "prefix": "exe::invoket2",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "exe::invoket2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"exe::invoket2#withdoc": {
  "prefix": "exe::invoket2#withdoc",
  "description": "This function call an executable and its arguments...",
  "scope": "",
  "body": [ "# ## exe::invoket2\n# \n# This function call an executable and its arguments.\n# It does not redirect the stdout and stderr so it outputs to the\n# default 1/2 file descriptors.\n# Equivalent to `_OPTION_NO_REDIRECTION=true exe::invokef5 \"\\${1}\" 0 \"\" \"\" \"\\${@:2}\"`\n# \n# - \\$1: **fail** _as bool_:\n#       true/false to indicate if the function should fail in case the execution fails.\n#       If true and the execution fails, the script will exit.\n# - \\$2: **executable** _as string_:\n#       the executable or function to execute\n# - \\$@: **arguments** _as any_:\n#       the arguments to pass to the executable\n# \n# Returns:\n# \n# - \\$?:The exit code of the executable.\n# \n# ```bash\n# exe::invoket2 false git status || core::fail \"status failed.\"\n# ```\n# \n# > See exe::invokef5 for more information.\n# \nexe::invoket2 \"${1:**fail**}\" \"${2:**executable**}\" \"${3:**arguments**}\"$0" ]
},

"fs::cat": {
  "prefix": "fs::cat",
  "description": "Print the content of a file to stdout...",
  "scope": "",
  "body": [ "fs::cat \"${1:**path**}\"$0" ]
},

"fs::cat#withdoc": {
  "prefix": "fs::cat#withdoc",
  "description": "Print the content of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::cat\n# \n# Print the content of a file to stdout.\n# This is a pure bash equivalent of cat.\n# \n# - \\$1: **path** _as string_:\n#       the file to print\n# \n# ```bash\n# fs::cat \"myFile\"\n# ```\n# \n# > Also see log::printFile if you want to print a file for a user.\n# \nfs::cat \"${1:**path**}\"$0" ]
},

"fs::cleanTempFiles": {
  "prefix": "fs::cleanTempFiles",
  "description": "Removes all the temporary files and directories that were created by the fs::createTempFile and fs::createTempDirectory functions...",
  "scope": "",
  "body": [ "fs::cleanTempFiles$0" ]
},

"fs::cleanTempFiles#withdoc": {
  "prefix": "fs::cleanTempFiles#withdoc",
  "description": "Removes all the temporary files and directories that were created by the fs::createTempFile and fs::createTempDirectory functions...",
  "scope": "",
  "body": [ "# ## fs::cleanTempFiles\n# \n# Removes all the temporary files and directories that were created by the\n# fs::createTempFile and fs::createTempDirectory functions.\n# \n# ```bash\n# fs::cleanTempFiles\n# ```\n# \nfs::cleanTempFiles$0" ]
},

"fs::createDirectoryIfNeeded": {
  "prefix": "fs::createDirectoryIfNeeded",
  "description": "Create the directory tree if needed...",
  "scope": "",
  "body": [ "fs::createDirectoryIfNeeded \"${1:**path**}\"$0" ]
},

"fs::createDirectoryIfNeeded#withdoc": {
  "prefix": "fs::createDirectoryIfNeeded#withdoc",
  "description": "Create the directory tree if needed...",
  "scope": "",
  "body": [ "# ## fs::createDirectoryIfNeeded\n# \n# Create the directory tree if needed.\n# \n# - \\$1: **path** _as string_:\n#       The directory path to create.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The absolute path to the directory.\n# \n# ```bash\n# fs::createDirectoryIfNeeded \"/my/directory\"\n# ```\n# \nfs::createDirectoryIfNeeded \"${1:**path**}\"$0" ]
},

"fs::createFilePathIfNeeded": {
  "prefix": "fs::createFilePathIfNeeded",
  "description": "Make sure that the given file path exists...",
  "scope": "",
  "body": [ "fs::createFilePathIfNeeded \"${1:**path**}\"$0" ]
},

"fs::createFilePathIfNeeded#withdoc": {
  "prefix": "fs::createFilePathIfNeeded#withdoc",
  "description": "Make sure that the given file path exists...",
  "scope": "",
  "body": [ "# ## fs::createFilePathIfNeeded\n# \n# Make sure that the given file path exists.\n# Create the directory tree and the file if needed.\n# \n# - \\$1: **path** _as string_:\n#       the file path to create\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The absolute path of the file.\n# \n# ```bash\n# fs::createFilePathIfNeeded \"myFile\"\n# ```\n# \nfs::createFilePathIfNeeded \"${1:**path**}\"$0" ]
},

"fs::createLink": {
  "prefix": "fs::createLink",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "fs::createLink \"${1:**linked path**}\" \"${2:**link path**}\" \"${3:hard link}\" \"${4:force}\"$0" ]
},

"fs::createLink#withdoc": {
  "prefix": "fs::createLink#withdoc",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "# ## fs::createLink\n# \n# Create a soft or hard link (original ← link).\n# \n# Reminder:\n# \n# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the\n#   form of an absolute or relative path.\n# - A hard link is a directory entry that associates a new pathname with an existing\n#   file (inode + data block) on a file system.\n# \n# This function allows to create a symbolic link on Windows as well as on Unix.\n# \n# - \\$1: **linked path** _as string_:\n#       the path to link to (the original file)\n# - \\$2: **link path** _as string_:\n#       the path where to create the link\n# - \\$3: hard link _as boolean_:\n#       (optional) true to create a hard link, false to create a symbolic link\n#       (defaults to false)\n# - \\$4: force _as boolean_:\n#       (optional) true to overwrite the link or file if it already exists.\n#       Otherwise, the function will fail on an existing link.\n#       (defaults to true)\n# \n# ```bash\n# fs::createLink \"/path/to/link\" \"/path/to/linked\"\n# fs::createLink \"/path/to/link\" \"/path/to/linked\" true\n# ```\n# \n# > The function uses the `ln` command.\n# \nfs::createLink \"${1:**linked path**}\" \"${2:**link path**}\" \"${3:hard link}\" \"${4:force}\"$0" ]
},

"fs::createTempDirectory": {
  "prefix": "fs::createTempDirectory",
  "description": "Creates a temporary directory...",
  "scope": "",
  "body": [ "_OPTION_PATH_ONLY=${1} fs::createTempDirectory$0" ]
},

"fs::createTempDirectory#withdoc": {
  "prefix": "fs::createTempDirectory#withdoc",
  "description": "Creates a temporary directory...",
  "scope": "",
  "body": [ "# ## fs::createTempDirectory\n# \n# Creates a temporary directory.\n# \n# - \\${_OPTION_PATH_ONLY} _as bool_:\n#       (optional) If true, does not create the file, only returns the path.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The created path.\n# \n# ```bash\n# fs::createTempDirectory\n# local directory=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \n_OPTION_PATH_ONLY=${1} fs::createTempDirectory$0" ]
},

"fs::createTempFile": {
  "prefix": "fs::createTempFile",
  "description": "Creates a temporary file and return its path...",
  "scope": "",
  "body": [ "_OPTION_PATH_ONLY=${1} fs::createTempFile$0" ]
},

"fs::createTempFile#withdoc": {
  "prefix": "fs::createTempFile#withdoc",
  "description": "Creates a temporary file and return its path...",
  "scope": "",
  "body": [ "# ## fs::createTempFile\n# \n# Creates a temporary file and return its path.\n# \n# - \\${_OPTION_PATH_ONLY} _as bool_:\n#       (optional) If true, does not create the file, only returns the path.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The created path.\n# \n# ```bash\n# fs::createTempFile\n# local file=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# > Files created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \n_OPTION_PATH_ONLY=${1} fs::createTempFile$0" ]
},

"fs::getFileLineCount": {
  "prefix": "fs::getFileLineCount",
  "description": "Get the number of lines in a file...",
  "scope": "",
  "body": [ "fs::getFileLineCount \"${1:**path**}\"$0" ]
},

"fs::getFileLineCount#withdoc": {
  "prefix": "fs::getFileLineCount#withdoc",
  "description": "Get the number of lines in a file...",
  "scope": "",
  "body": [ "# ## fs::getFileLineCount\n# \n# Get the number of lines in a file.\n# \n# - \\$1: **path** _as string_:\n#       the file path to read\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The number of lines in the file.\n# \n# ```bash\n# fs::getFileLineCount \"/path/to/file\"\n# local lineCount=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# TODO: fails to count the last line if empty\n# \nfs::getFileLineCount \"${1:**path**}\"$0" ]
},

"fs::getPwdRealPath": {
  "prefix": "fs::getPwdRealPath",
  "description": "Get the real path of the current directory...",
  "scope": "",
  "body": [ "fs::getPwdRealPath$0" ]
},

"fs::getPwdRealPath#withdoc": {
  "prefix": "fs::getPwdRealPath#withdoc",
  "description": "Get the real path of the current directory...",
  "scope": "",
  "body": [ "# ## fs::getPwdRealPath\n# \n# Get the real path of the current directory.\n# By default, the `\\${PWD}` variable is the logical path, which may contain symlinks.\n# \n# ```bash\n# fs::getPwdRealPath\n# ```\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The realpath for the current directory.\n# \n# > This is a pure bash alternative to `realpath` or `readlink`.\n# \nfs::getPwdRealPath$0" ]
},

"fs::head": {
  "prefix": "fs::head",
  "description": "Print the first lines of a file to stdout...",
  "scope": "",
  "body": [ "fs::head \"${1:**path**}\" \"${2:**number of lines**}\" \"${3:to variable}\"$0" ]
},

"fs::head#withdoc": {
  "prefix": "fs::head#withdoc",
  "description": "Print the first lines of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::head\n# \n# Print the first lines of a file to stdout.\n# This is a pure bash equivalent of head.\n# \n# - \\$1: **path** _as string_:\n#       The file to print.\n# - \\$2: **number of lines** _as int_:\n#       The number of lines to print.\n# - \\$3: to variable _as bool_:\n#       (optional) Can be set using the variable `_OPTION_TO_VARIABLE`.\n#       If true, the output will be stored in the variable `RETURNED_ARRAY`\n#       instead of being printed to stdout.\n#       (defaults to false)\n# \n# ```bash\n# fs::head \"myFile\" 10\n# ```\n# \n# > #TODO: faster with mapfile + quantum?\n# \nfs::head \"${1:**path**}\" \"${2:**number of lines**}\" \"${3:to variable}\"$0" ]
},

"fs::isDirectoryWritable": {
  "prefix": "fs::isDirectoryWritable",
  "description": "Check if the directory is writable...",
  "scope": "",
  "body": [ "fs::isDirectoryWritable \"${1:**directory**}\" \"${2:test file name}\"$0" ]
},

"fs::isDirectoryWritable#withdoc": {
  "prefix": "fs::isDirectoryWritable#withdoc",
  "description": "Check if the directory is writable...",
  "scope": "",
  "body": [ "# ## fs::isDirectoryWritable\n# \n# Check if the directory is writable. Creates the directory if it does not exist.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to check\n# - \\$2: test file name _as string_:\n#       (optional) the name of the file to create in the directory to test the write access\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the directory is writable\n#   - 1 otherwise\n# \n# ```bash\n# if fs::isDirectoryWritable \"/path/to/directory\"; then\n#   echo \"The directory is writable.\"\n# fi\n# ```\n# \nfs::isDirectoryWritable \"${1:**directory**}\" \"${2:test file name}\"$0" ]
},

"fs::listDirectories": {
  "prefix": "fs::listDirectories",
  "description": "List all the directories in the given directory...",
  "scope": "",
  "body": [ "fs::listDirectories \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
},

"fs::listDirectories#withdoc": {
  "prefix": "fs::listDirectories#withdoc",
  "description": "List all the directories in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listDirectories\n# \n# List all the directories in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\$2: recursive _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\$3: hidden _as bool_:\n#       (optional) true to list hidden paths, false otherwise\n#       (defaults to false)\n# - \\$4: directory filter function name _as string_:\n#       (optional) a function name that is called to filter the sub directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to empty string, no filter)\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array with the list of all the files.\n# \n# ```bash\n# fs::listDirectories \"/path/to/directory\" true true myFilterFunction\n# for path in \"\\${RETURNED_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \nfs::listDirectories \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
},

"fs::listFiles": {
  "prefix": "fs::listFiles",
  "description": "List all the files in the given directory...",
  "scope": "",
  "body": [ "fs::listFiles \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
},

"fs::listFiles#withdoc": {
  "prefix": "fs::listFiles#withdoc",
  "description": "List all the files in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listFiles\n# \n# List all the files in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\$2: recursive _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\$3: hidden _as bool_:\n#       (optional) true to list hidden paths, false otherwise\n#       (defaults to false)\n# - \\$4: directory filter function name _as string_:\n#       (optional) a function name that is called to filter the directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to empty string, no filter)\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array with the list of all the files.\n# \n# ```bash\n# fs::listFiles \"/path/to/directory\" true true myFilterFunction\n# for path in \"\\${RETURNED_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \nfs::listFiles \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:directory filter function name}\"$0" ]
},

"fs::listPaths": {
  "prefix": "fs::listPaths",
  "description": "List all the paths in the given directory...",
  "scope": "",
  "body": [ "fs::listPaths \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:path filter function name}\" \"${5:directory filter function name}\"$0" ]
},

"fs::listPaths#withdoc": {
  "prefix": "fs::listPaths#withdoc",
  "description": "List all the paths in the given directory...",
  "scope": "",
  "body": [ "# ## fs::listPaths\n# \n# List all the paths in the given directory.\n# \n# - \\$1: **directory** _as string_:\n#       the directory to list\n# - \\$2: recursive _as bool_:\n#       (optional) true to list recursively, false otherwise\n#       (defaults to false)\n# - \\$3: hidden _as bool_:\n#       (optional) true to list hidden paths, false otherwise\n#       (defaults to false)\n# - \\$4: path filter function name _as string_:\n#       (optional) a function name that is called to filter the paths that will be listed\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to empty string, no filter)\n# - \\$5: directory filter function name _as string_:\n#       (optional) a function name that is called to filter the directories (for recursive listing)\n#       The function should return 0 if the path is to be kept, 1 otherwise.\n#       The function is called with the path as the first argument.\n#       (defaults to empty string, no filter)\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array with the list of all the paths.\n# \n# ```bash\n# fs::listPaths \"/path/to/directory\" true true myFilterFunction myFilterDirectoryFunction\n# for path in \"\\${RETURNED_ARRAY[@]}\"; do\n#   printf '%s' \"\\${path}\"\n# done\n# ```\n# \n# > - It will correctly list files under symbolic link directories.\n# \nfs::listPaths \"${1:**directory**}\" \"${2:recursive}\" \"${3:hidden}\" \"${4:path filter function name}\" \"${5:directory filter function name}\"$0" ]
},

"fs::readFile": {
  "prefix": "fs::readFile",
  "description": "Reads the content of a file and returns it in the global variable RETURNED_VALUE...",
  "scope": "",
  "body": [ "fs::readFile \"${1:**path**}\" \"${2:max char}\"$0" ]
},

"fs::readFile#withdoc": {
  "prefix": "fs::readFile#withdoc",
  "description": "Reads the content of a file and returns it in the global variable RETURNED_VALUE...",
  "scope": "",
  "body": [ "# ## fs::readFile\n# \n# Reads the content of a file and returns it in the global variable RETURNED_VALUE.\n# Uses pure bash.\n# \n# - \\$1: **path** _as string_:\n#       the file path to read\n# - \\$2: max char _as int_:\n#       (optional) the maximum number of characters to read\n#       (defaults to 0, which means read the whole file)\n# \n# > If the file does not exist, the function will return an empty string instead of failing.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The content of the file.\n# \n# ```bash\n# fs::readFile \"/path/to/file\" && local fileContent=\"\\${RETURNED_VALUE}\"\n# fs::readFile \"/path/to/file\" 500 && local fileContent=\"\\${RETURNED_VALUE}\"\n# ```\n# \nfs::readFile \"${1:**path**}\" \"${2:max char}\"$0" ]
},

"fs::tail": {
  "prefix": "fs::tail",
  "description": "Print the last lines of a file to stdout...",
  "scope": "",
  "body": [ "fs::tail \"${1:**path**}\" \"${2:**number of lines**}\" \"${3:to variable}\"$0" ]
},

"fs::tail#withdoc": {
  "prefix": "fs::tail#withdoc",
  "description": "Print the last lines of a file to stdout...",
  "scope": "",
  "body": [ "# ## fs::tail\n# \n# Print the last lines of a file to stdout.\n# This is a pure bash equivalent of tail.\n# However, because we have to read the whole file, it is not efficient for large files.\n# \n# - \\$1: **path** _as string_:\n#       The file to print.\n# - \\$2: **number of lines** _as int_:\n#       The number of lines to print from the end of the file.\n# - \\$3: to variable _as bool_:\n#       (optional) Can be set using the variable `_OPTION_TO_VARIABLE`.\n#       If true, the output will be stored in the variable `RETURNED_ARRAY`\n#       instead of being printed to stdout.\n#       (defaults to false)\n# \n# ```bash\n# fs::tail \"myFile\" 10\n# ```\n# \n# > #TODO: use mapfile quantum to not have to read the whole file in a single go.\n# \nfs::tail \"${1:**path**}\" \"${2:**number of lines**}\" \"${3:to variable}\"$0" ]
},

"fs::toAbsolutePath": {
  "prefix": "fs::toAbsolutePath",
  "description": "This function returns the absolute path of a path...",
  "scope": "",
  "body": [ "_OPTION_REALPATH=${2} fs::toAbsolutePath \"${1:**path**}\"$0" ]
},

"fs::toAbsolutePath#withdoc": {
  "prefix": "fs::toAbsolutePath#withdoc",
  "description": "This function returns the absolute path of a path...",
  "scope": "",
  "body": [ "# ## fs::toAbsolutePath\n# \n# This function returns the absolute path of a path.\n# \n# If the path exists, it can be resolved to the real path, following symlinks,\n# using the option `_OPTION_REALPATH=true`.\n# \n# - \\$1: **path** _as string_:\n#       The path to translate to absolute path.\n# - \\${_OPTION_REALPATH} _as bool_:\n#       (optional) true to resolve the path to the real path, following symlinks.\n#       (defaults to false)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The absolute path of the path.\n# \n# ```bash\n# fs::toAbsolutePath \"myPath\"\n# local myPathAbsolutePath=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# > This is a pure bash alternative to `realpath` or `readlink`.\n# > The `..` will be processed before following any symlinks, by removing\n# > the immediate pathname component.\n# \n_OPTION_REALPATH=${2} fs::toAbsolutePath \"${1:**path**}\"$0" ]
},

"include": {
  "prefix": "include",
  "description": "Allows to include multiple library files...",
  "scope": "",
  "body": [ "include \"${1:**libraries**}\"$0" ]
},

"include#withdoc": {
  "prefix": "include#withdoc",
  "description": "Allows to include multiple library files...",
  "scope": "",
  "body": [ "# ## include\n# \n# Allows to include multiple library files.\n# \n# It calls `source` for each argument.\n# Useful if you don't have arguments to pass to the sourced files.\n# \n# - \\$@: **libraries** _as string_:\n#       The names of the libraries (array, interactive, string...) or the file paths to include.\n# \n# ```bash\n# include string array ./my/path\n# ```\n# \ninclude \"${1:**libraries**}\"$0" ]
},

"interactive::askForConfirmation": {
  "prefix": "interactive::askForConfirmation",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "interactive::askForConfirmation \"${1:**prompt**}\"$0" ]
},

"interactive::askForConfirmation#withdoc": {
  "prefix": "interactive::askForConfirmation#withdoc",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "# ##  interactive::askForConfirmation\n# \n# Ask the user to press the button to continue.\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user pressed enter\n#   - 1 otherwise\n# \n# ```bash\n# interactive::askForConfirmation \"Press enter to continue.\"\n# ```\n# \ninteractive::askForConfirmation \"${1:**prompt**}\"$0" ]
},

"interactive::askForConfirmationRaw": {
  "prefix": "interactive::askForConfirmationRaw",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "interactive::askForConfirmationRaw$0" ]
},

"interactive::askForConfirmationRaw#withdoc": {
  "prefix": "interactive::askForConfirmationRaw#withdoc",
  "description": "Ask the user to press the button to continue...",
  "scope": "",
  "body": [ "# ## interactive::askForConfirmationRaw\n# \n# Ask the user to press the button to continue.\n# \n# This raw version does not display the prompt or the answer.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user pressed enter\n#   - 1 otherwise\n# \n# ```bash\n# interactive::askForConfirmationRaw\n# ```\n# \ninteractive::askForConfirmationRaw$0" ]
},

"interactive::displayAnswer": {
  "prefix": "interactive::displayAnswer",
  "description": "Displays an answer to a previous question...",
  "scope": "",
  "body": [ "interactive::displayAnswer \"${1:**answer**}\" \"${2:max width}\"$0" ]
},

"interactive::displayAnswer#withdoc": {
  "prefix": "interactive::displayAnswer#withdoc",
  "description": "Displays an answer to a previous question...",
  "scope": "",
  "body": [ "# ## interactive::displayAnswer\n# \n# Displays an answer to a previous question.\n# \n# The text is wrapped and put inside a box like so:\n# \n# ```text\n#     ╭─────╮\n#     │ No. ├──░\n#     ╰─────╯\n# ```\n# \n# - \\$1: **answer** _as string_:\n#       the answer to display\n# - \\$2: max width _as int_:\n#       (optional) the maximum width of the text in the dialog box\n#       (defaults to GLOBAL_COLUMNS)\n# \n# ```bash\n# interactive::displayAnswer \"My answer.\"\n# ```\n# \ninteractive::displayAnswer \"${1:**answer**}\" \"${2:max width}\"$0" ]
},

"interactive::displayDialogBox": {
  "prefix": "interactive::displayDialogBox",
  "description": "Displays a dialog box with a speaker and a text...",
  "scope": "",
  "body": [ "interactive::displayDialogBox \"${1:**speaker**}\" \"${2:**text**}\" \"${3:max width}\"$0" ]
},

"interactive::displayDialogBox#withdoc": {
  "prefix": "interactive::displayDialogBox#withdoc",
  "description": "Displays a dialog box with a speaker and a text...",
  "scope": "",
  "body": [ "# ## interactive::displayDialogBox\n# \n# Displays a dialog box with a speaker and a text.\n# \n# - \\$1: **speaker** _as string_:\n#       the speaker (system or user)\n# - \\$2: **text** _as string_:\n#       the text to display\n# - \\$3: max width _as int_:\n#       (optional) the maximum width of the text in the dialog box\n#       (defaults to GLOBAL_COLUMNS)\n# \n# ```bash\n# interactive::displayDialogBox \"system\" \"This is a system message.\"\n# ```\n# \ninteractive::displayDialogBox \"${1:**speaker**}\" \"${2:**text**}\" \"${3:max width}\"$0" ]
},

"interactive::displayQuestion": {
  "prefix": "interactive::displayQuestion",
  "description": "Displays a question to the user...",
  "scope": "",
  "body": [ "interactive::displayQuestion \"${1:**prompt**}\" \"${2:max width}\"$0" ]
},

"interactive::displayQuestion#withdoc": {
  "prefix": "interactive::displayQuestion#withdoc",
  "description": "Displays a question to the user...",
  "scope": "",
  "body": [ "# ## interactive::displayQuestion\n# \n# Displays a question to the user.\n# \n# The text is wrapped and put inside a box like so:\n# \n# ```text\n#    ╭────────────────────────────────╮\n# ░──┤ Is this an important question? │\n#    ╰────────────────────────────────╯\n# ```\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# - \\$2: max width _as int_:\n#       (optional) the maximum width of text in the dialog box\n#       (defaults to GLOBAL_COLUMNS)\n# \n# ```bash\n# interactive::displayPrompt \"Do you want to continue?\"\n# ```\n# \ninteractive::displayQuestion \"${1:**prompt**}\" \"${2:max width}\"$0" ]
},

"interactive::promptYesNo": {
  "prefix": "interactive::promptYesNo",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "interactive::promptYesNo \"${1:**prompt**}\" \"${2:default}\"$0" ]
},

"interactive::promptYesNo#withdoc": {
  "prefix": "interactive::promptYesNo#withdoc",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "# ## interactive::promptYesNo\n# \n# Ask the user to yes or no.\n# \n# - The user can switch between the two options with the arrow keys or space.\n# - The user can validate the choice with the enter key.\n# - The user can also validate immediately with the y or n key.\n# \n# Dialog boxes are displayed for the question and answer.\n# \n# - \\$1: **prompt** _as string_:\n#       the prompt to display\n# - \\$2: default _as bool_:\n#       (optional) the default value to select\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user answered yes\n#   - 1 otherwise\n# - \\${RETURNED_VALUE}: true or false.\n# \n# ```bash\n# if interactive::promptYesNo \"Do you want to continue?\"; then echo \"Yes.\"; else echo \"No.\"; fi\n# ```\n# \ninteractive::promptYesNo \"${1:**prompt**}\" \"${2:default}\"$0" ]
},

"interactive::promptYesNoRaw": {
  "prefix": "interactive::promptYesNoRaw",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "interactive::promptYesNoRaw \"${1:default}\"$0" ]
},

"interactive::promptYesNoRaw#withdoc": {
  "prefix": "interactive::promptYesNoRaw#withdoc",
  "description": "Ask the user to yes or no...",
  "scope": "",
  "body": [ "# ## interactive::promptYesNoRaw\n# \n# Ask the user to yes or no.\n# \n# - The user can switch between the two options with the arrow keys or space.\n# - The user can validate the choice with the enter key.\n# - The user can also validate immediately with the y or n key.\n# \n# This raw version does not display the prompt or the answer.\n# \n# - \\$1: default _as bool_:\n#       (optional) the default value to select\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if the user answered yes\n#   - 1 otherwise\n# - \\${RETURNED_VALUE}: true or false.\n# \n# ```bash\n# interactive::promptYesNoRaw \"Do you want to continue?\" && local answer=\"\\${RETURNED_VALUE}\"\n# ```\n# \ninteractive::promptYesNoRaw \"${1:default}\"$0" ]
},

"list_fuzzyFilterSortFileWithGrepAndGawk": {
  "prefix": "list_fuzzyFilterSortFileWithGrepAndGawk",
  "description": "Allows to fuzzy sort a file against a given searched string...",
  "scope": "",
  "body": [ "list_fuzzyFilterSortFileWithGrepAndGawk \"${1:**file to filer**}\" \"${2:**search string**}\" \"${3:**output filtered file**}\" \"${4:**output correspondences file**}\"$0" ]
},

"list_fuzzyFilterSortFileWithGrepAndGawk#withdoc": {
  "prefix": "list_fuzzyFilterSortFileWithGrepAndGawk#withdoc",
  "description": "Allows to fuzzy sort a file against a given searched string...",
  "scope": "",
  "body": [ "# ## list_fuzzyFilterSortFileWithGrepAndGawk\n# \n# Allows to fuzzy sort a file against a given searched string.\n# Outputs a file containing only the lines matching the searched string.\n# The array is sorted by (in order):\n# \n# - the index of the first matched character in the line\n# - the distance between the first and last matched characters in the line\n# \n# Will also output a file containing the indexes of the matched lines in the original file.\n# \n# - \\$1: **file to filer** _as string_:\n#       The input file to filter.\n# - \\$2: **search string** _as string_:\n#       The variable name containing the search string to match.\n# - \\$3: **output filtered file** _as string_:\n#       The output file containing the filtered lines.\n# - \\$4: **output correspondences file** _as string_:\n#       The output file containing the indexes of the matched lines in the original file.\n# \n# ```bash\n# list_fuzzyFilterSortFileWithGrepAndGawk file.txt filtered.txt correspondences.txt\n# ```\n# \n# > This is not a pure bash function! Use `array::fuzzyFilterSort` for pure bash alternative.\n# > This function is useful for very large arrays.\n# \nlist_fuzzyFilterSortFileWithGrepAndGawk \"${1:**file to filer**}\" \"${2:**search string**}\" \"${3:**output filtered file**}\" \"${4:**output correspondences file**}\"$0" ]
},

"log::debug": {
  "prefix": "log::debug",
  "description": "Displays a debug message...",
  "scope": "",
  "body": [ "log::debug \"${1:**message**}\"$0" ]
},

"log::debug#withdoc": {
  "prefix": "log::debug#withdoc",
  "description": "Displays a debug message...",
  "scope": "",
  "body": [ "# ## log::debug\n# \n# Displays a debug message.\n# \n# - \\$@: **message** _as string_:\n#       the debug messages to display\n# \n# ```bash\n# log::debug \"This is a debug message.\"\n# ```\n# \nlog::debug \"${1:**message**}\"$0" ]
},

"log::error": {
  "prefix": "log::error",
  "description": "Displays an error message...",
  "scope": "",
  "body": [ "log::error \"${1:**message**}\"$0" ]
},

"log::error#withdoc": {
  "prefix": "log::error#withdoc",
  "description": "Displays an error message...",
  "scope": "",
  "body": [ "# ## log::error\n# \n# Displays an error message.\n# \n# - \\$@: **message** _as string_:\n#       the error messages to display\n# \n# ```bash\n# log::error \"This is an error message.\"\n# ```\n# \n# > You probably want to exit immediately after an error and should consider using core::fail function instead.\n# \nlog::error \"${1:**message**}\"$0" ]
},

"log::errorTrace": {
  "prefix": "log::errorTrace",
  "description": "Displays an error trace message...",
  "scope": "",
  "body": [ "log::errorTrace \"${1:**message**}\"$0" ]
},

"log::errorTrace#withdoc": {
  "prefix": "log::errorTrace#withdoc",
  "description": "Displays an error trace message...",
  "scope": "",
  "body": [ "# ## log::errorTrace\n# \n# Displays an error trace message.\n# This is a trace message that is always displayed, independently of the log level.\n# It can be used before a fatal error to display useful information.\n# \n# - \\$@: **message** _as string_:\n#       the trace messages to display\n# \n# ```bash\n# log::errorTrace \"This is a debug message.\"\n# ```\n# \nlog::errorTrace \"${1:**message**}\"$0" ]
},

"log::getLevel": {
  "prefix": "log::getLevel",
  "description": "Get the current log level...",
  "scope": "",
  "body": [ "log::getLevel$0" ]
},

"log::getLevel#withdoc": {
  "prefix": "log::getLevel#withdoc",
  "description": "Get the current log level...",
  "scope": "",
  "body": [ "# ## log::getLevel\n# \n# Get the current log level.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The current log level.\n# \n# ```bash\n# log::getLevel\n# printf '%s\\n' \"The log level is ⌜\\${RETURNED_VALUE}⌝.\"\n# ```\n# \nlog::getLevel$0" ]
},

"log::info": {
  "prefix": "log::info",
  "description": "Displays an info message...",
  "scope": "",
  "body": [ "log::info \"${1:**message**}\"$0" ]
},

"log::info#withdoc": {
  "prefix": "log::info#withdoc",
  "description": "Displays an info message...",
  "scope": "",
  "body": [ "# ## log::info\n# \n# Displays an info message.\n# \n# - \\$@: **message** _as string_:\n#       the info messages to display\n# \n# ```bash\n# log::info \"This is an info message.\"\n# ```\n# \nlog::info \"${1:**message**}\"$0" ]
},

"log::isDebugEnabled": {
  "prefix": "log::isDebugEnabled",
  "description": "Check if the debug mode is enabled...",
  "scope": "",
  "body": [ "log::isDebugEnabled$0" ]
},

"log::isDebugEnabled#withdoc": {
  "prefix": "log::isDebugEnabled#withdoc",
  "description": "Check if the debug mode is enabled...",
  "scope": "",
  "body": [ "# ## log::isDebugEnabled\n# \n# Check if the debug mode is enabled.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if debug mode is enabled (log level is debug)\n#   - 1 if disabled\n# \n# ```bash\n# if log::isDebugEnabled; then printf '%s\\n' \"Debug mode is active.\"; fi\n# ```\n# \nlog::isDebugEnabled$0" ]
},

"log::isTraceEnabled": {
  "prefix": "log::isTraceEnabled",
  "description": "Check if the trace mode is enabled...",
  "scope": "",
  "body": [ "log::isTraceEnabled$0" ]
},

"log::isTraceEnabled#withdoc": {
  "prefix": "log::isTraceEnabled#withdoc",
  "description": "Check if the trace mode is enabled...",
  "scope": "",
  "body": [ "# ## log::isTraceEnabled\n# \n# Check if the trace mode is enabled.\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if trace mode is enabled (log level is trace)\n#   - 1 if disabled\n# \n# ```bash\n# if log::isTraceEnabled; then printf '%s\\n' \"Debug mode is active.\"; fi\n# ```\n# \nlog::isTraceEnabled$0" ]
},

"log::print": {
  "prefix": "log::print",
  "description": "Display a log message...",
  "scope": "",
  "body": [ "log::print \"${1:**color name**}\" \"${2:**icon**}\" \"${3:**severity**}\" \"${4:**message**}\"$0" ]
},

"log::print#withdoc": {
  "prefix": "log::print#withdoc",
  "description": "Display a log message...",
  "scope": "",
  "body": [ "# ## log::print\n# \n# Display a log message.\n# \n# - \\$1: **color name** _as string_:\n#       The color name to use for the severity (TRACE, DEBUG...).\n# - \\$2: **icon** _as string_:\n#       The icon to display in the log message (utf8 character from nerd icons).\n# - \\$3: **severity** _as string_:\n#       The severity to display (max 7 chars for the default log pattern).\n# - \\$@: **message** _as string_:\n#       The message to log.\n# \n# ```bash\n# log::print \"SUCCESS\" \\$'\\uf14a' \"OK\" \"This is a success message.\"\n# ```\n# \nlog::print \"${1:**color name**}\" \"${2:**icon**}\" \"${3:**severity**}\" \"${4:**message**}\"$0" ]
},

"log::printCallStack": {
  "prefix": "log::printCallStack",
  "description": "This function prints the current function stack in the logs...",
  "scope": "",
  "body": [ "log::printCallStack \"${1:Stack to skip}\" \"${2:Stack to skip at end}\"$0" ]
},

"log::printCallStack#withdoc": {
  "prefix": "log::printCallStack#withdoc",
  "description": "This function prints the current function stack in the logs...",
  "scope": "",
  "body": [ "# ## log::printCallStack\n# \n# This function prints the current function stack in the logs.\n# \n# - \\$1: Stack to skip _as int_:\n#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP`.\n#       The number of stack to skip.\n#       (defaults to 2 which skips this function and the first calling function\n#       which is usually the onError function)\n# - \\$2: Stack to skip at end _as int_:\n#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP_AT_END`.\n#       The number of stack to skip at the end.\n#       (defaults to 0)\n# \n# ```bash\n# log::printCallStack\n# log::printCallStack 0\n# ```\n# \n# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`\n# > variables to simulate a call stack.\n# \nlog::printCallStack \"${1:Stack to skip}\" \"${2:Stack to skip at end}\"$0" ]
},

"log::printFile": {
  "prefix": "log::printFile",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "log::printFile \"${1:**path**}\" \"${2:max lines}\"$0" ]
},

"log::printFile#withdoc": {
  "prefix": "log::printFile#withdoc",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "# ## log::printFile\n# \n# Display a file content with line numbers in the logs.\n# The file content will be aligned with the current log output and hard wrapped if necessary.\n# \n# - \\$1: **path** _as string_:\n#       the file path to display.\n# - \\$2: max lines _as int_:\n#       (optional) Can be set using the variable `_OPTION_MAX_LINES`.\n#       Max lines to display, can be set to 0 to display all lines.\n#       (defaults to 0)\n# \n# ```bash\n# log::printFile \"/my/file/path\"\n# ```\n# \nlog::printFile \"${1:**path**}\" \"${2:max lines}\"$0" ]
},

"log::printFileString": {
  "prefix": "log::printFileString",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "log::printFileString \"${1:**content variable name**}\" \"${2:max lines}\"$0" ]
},

"log::printFileString#withdoc": {
  "prefix": "log::printFileString#withdoc",
  "description": "Display a file content with line numbers in the logs...",
  "scope": "",
  "body": [ "# ## log::printFileString\n# \n# Display a file content with line numbers in the logs.\n# The file content will be aligned with the current log output and hard wrapped if necessary.\n# \n# - \\$1: **content variable name** _as string_:\n#       The name of the variable containing the file content to print.\n# - \\$2: max lines _as int_:\n#       (optional) Can be set using the variable `_OPTION_MAX_LINES`.\n#       Max lines to display, can be set to 0 to display all lines.\n#       (defaults to 0)\n# \n# ```bash\n# log::printFileString \"myvar\"\n# ```\n# \n# > This function is not at all suited for large strings, print the content to a file instead.\n# \nlog::printFileString \"${1:**content variable name**}\" \"${2:max lines}\"$0" ]
},

"log::printRaw": {
  "prefix": "log::printRaw",
  "description": "Display something in the log stream...",
  "scope": "",
  "body": [ "log::printRaw \"${1:**content variable name**}\"$0" ]
},

"log::printRaw#withdoc": {
  "prefix": "log::printRaw#withdoc",
  "description": "Display something in the log stream...",
  "scope": "",
  "body": [ "# ## log::printRaw\n# \n# Display something in the log stream.\n# Does not check the log level.\n# \n# - \\$1: **content variable name** _as string_:\n#       The variable name containing the content to print (can contain new lines).\n# \n# ```bash\n# log::printRaw \"my line\"\n# ```\n# \nlog::printRaw \"${1:**content variable name**}\"$0" ]
},

"log::printString": {
  "prefix": "log::printString",
  "description": "Display a string in the log...",
  "scope": "",
  "body": [ "log::printString \"${1:**content**}\" \"${2:new line pad string}\"$0" ]
},

"log::printString#withdoc": {
  "prefix": "log::printString#withdoc",
  "description": "Display a string in the log...",
  "scope": "",
  "body": [ "# ## log::printString\n# \n# Display a string in the log.\n# The string will be aligned with the current log output and hard wrapped if necessary.\n# Does not check the log level.\n# \n# - \\$1: **content** _as string_:\n#       the content to log (can contain new lines)\n# - \\$2: new line pad string _as string_:\n#       (optional) the string with which to prepend each wrapped line\n#       (empty by default)\n# \n# ```bash\n# log::printString \"my line\"\n# ```\n# \nlog::printString \"${1:**content**}\" \"${2:new line pad string}\"$0" ]
},

"log::saveFile": {
  "prefix": "log::saveFile",
  "description": "Save the given file by copying it to a new file in the user local state directory (using `core::createNewStateFilePath`)...",
  "scope": "",
  "body": [ "log::saveFile \"${1:**path**}\" \"${2:**suffix**}\" \"${3:log path}\"$0" ]
},

"log::saveFile#withdoc": {
  "prefix": "log::saveFile#withdoc",
  "description": "Save the given file by copying it to a new file in the user local state directory (using `core::createNewStateFilePath`)...",
  "scope": "",
  "body": [ "# ## log::saveFile\n# \n# Save the given file by copying it to a new file in the user local state directory\n# (using `core::createNewStateFilePath`).\n# Useful for debugging purposes, to save the state of a file during execution.\n# \n# - \\$1: **path** _as string_:\n#       The file path to save.\n# - \\$2: **suffix** _as string_:\n#       The suffix to add to the file name.\n# - \\$3: log path _as bool_:\n#       (optional) if true, log the path of the saved file using `log::printString`\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The path to the saved file.\n# \n# ```bash\n# log::saveFile \"/my/file/path\" \"suffix\" \"important result file\"\n# ```\n# \nlog::saveFile \"${1:**path**}\" \"${2:**suffix**}\" \"${3:log path}\"$0" ]
},

"log::saveFileString": {
  "prefix": "log::saveFileString",
  "description": "Save the given string to a new file in the user local state directory (using `core::createNewStateFilePath`)...",
  "scope": "",
  "body": [ "log::saveFileString \"${1:**content variable name**}\" \"${2:**suffix**}\" \"${3:log path}\"$0" ]
},

"log::saveFileString#withdoc": {
  "prefix": "log::saveFileString#withdoc",
  "description": "Save the given string to a new file in the user local state directory (using `core::createNewStateFilePath`)...",
  "scope": "",
  "body": [ "# ## log::saveFileString\n# \n# Save the given string to a new file in the user local state directory\n# (using `core::createNewStateFilePath`).\n# Useful for debugging purposes, to save the state of a string during execution.\n# \n# - \\$1: **content variable name** _as string_:\n#       The variable name of the content to save.\n# - \\$2: **suffix** _as string_:\n#       The suffix to add to the file name.\n# - \\$3: log path _as bool_:\n#       (optional) if true, log the path of the saved file using `log::printString`\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The path to the saved file.\n# \n# ```bash\n# log::saveFileString \"my content\" \"suffix\" \"important result file\"\n# ```\n# \nlog::saveFileString \"${1:**content variable name**}\" \"${2:**suffix**}\" \"${3:log path}\"$0" ]
},

"log::setLevel": {
  "prefix": "log::setLevel",
  "description": "Set the log level...",
  "scope": "",
  "body": [ "log::setLevel \"${1:**log level**}\" \"${2:silent}\"$0" ]
},

"log::setLevel#withdoc": {
  "prefix": "log::setLevel#withdoc",
  "description": "Set the log level...",
  "scope": "",
  "body": [ "# ## log::setLevel\n# \n# Set the log level.\n# \n# - \\$1: **log level** _as string_:\n#       The log level to set (or defaults to info), acceptable values are:\n#   - trace\n#   - debug\n#   - info\n#   - success\n#   - warning\n#   - error\n# - \\$2: silent _as bool_:\n#       (optional) true to silently switch log level, i.e. does not print a message\n#       (defaults to false)\n# \n# ```bash\n# log::setLevel debug\n# log::setLevel debug true\n# ```\n# \nlog::setLevel \"${1:**log level**}\" \"${2:silent}\"$0" ]
},

"log::success": {
  "prefix": "log::success",
  "description": "Displays a success message...",
  "scope": "",
  "body": [ "log::success \"${1:**message**}\"$0" ]
},

"log::success#withdoc": {
  "prefix": "log::success#withdoc",
  "description": "Displays a success message...",
  "scope": "",
  "body": [ "# ## log::success\n# \n# Displays a success message.\n# \n# - \\$@: **message** _as string_:\n#       the success messages to display\n# \n# ```bash\n# log::success \"This is a success message.\"\n# ```\n# \nlog::success \"${1:**message**}\"$0" ]
},

"log::trace": {
  "prefix": "log::trace",
  "description": "Displays a trace message...",
  "scope": "",
  "body": [ "log::trace \"${1:**message**}\"$0" ]
},

"log::trace#withdoc": {
  "prefix": "log::trace#withdoc",
  "description": "Displays a trace message...",
  "scope": "",
  "body": [ "# ## log::trace\n# \n# Displays a trace message.\n# \n# - \\$@: **message** _as string_:\n#       the trace messages to display\n# \n# ```bash\n# log::trace \"This is a trace message.\"\n# ```\n# \nlog::trace \"${1:**message**}\"$0" ]
},

"log::warning": {
  "prefix": "log::warning",
  "description": "Displays a warning...",
  "scope": "",
  "body": [ "log::warning \"${1:**message**}\"$0" ]
},

"log::warning#withdoc": {
  "prefix": "log::warning#withdoc",
  "description": "Displays a warning...",
  "scope": "",
  "body": [ "# ## log::warning\n# \n# Displays a warning.\n# \n# - \\$@: **message** _as string_:\n#       the warning messages to display\n# \n# ```bash\n# log::warning \"This is a warning message.\"\n# ```\n# \nlog::warning \"${1:**message**}\"$0" ]
},

"profiler::disable": {
  "prefix": "profiler::disable",
  "description": "Disable the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "profiler::disable$0" ]
},

"profiler::disable#withdoc": {
  "prefix": "profiler::disable#withdoc",
  "description": "Disable the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "# ## profiler::disable\n# \n# Disable the profiler if previously activated with profiler::enable.\n# \n# ```bash\n# profiler::disable\n# ```\n# \nprofiler::disable$0" ]
},

"profiler::enable": {
  "prefix": "profiler::enable",
  "description": "Enables the profiler and start writing to the given file...",
  "scope": "",
  "body": [ "profiler::enable \"${1:**path**}\"$0" ]
},

"profiler::enable#withdoc": {
  "prefix": "profiler::enable#withdoc",
  "description": "Enables the profiler and start writing to the given file...",
  "scope": "",
  "body": [ "# ## profiler::enable\n# \n# Enables the profiler and start writing to the given file.\n# The profiler will also be active in subshells of this current shell.\n# \n# - \\$1: **path** _as string_:\n#       the file to write to.\n# \n# ```bash\n# profiler::enable \"\\${HOME}/valet-profiler-\\${BASHPID}.txt\"\n# ```\n# \n# > There can be only one profiler active at a time.\n# \nprofiler::enable \"${1:**path**}\"$0" ]
},

"profiler::pause": {
  "prefix": "profiler::pause",
  "description": "Pause the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "profiler::pause$0" ]
},

"profiler::pause#withdoc": {
  "prefix": "profiler::pause#withdoc",
  "description": "Pause the profiler if previously activated with profiler::enable...",
  "scope": "",
  "body": [ "# ## profiler::pause\n# \n# Pause the profiler if previously activated with profiler::enable.\n# \n# ```bash\n# profiler::pause\n# ```\n# \nprofiler::pause$0" ]
},

"profiler::resume": {
  "prefix": "profiler::resume",
  "description": "Resume the profiler if previously paused with profiler::pause...",
  "scope": "",
  "body": [ "profiler::resume$0" ]
},

"profiler::resume#withdoc": {
  "prefix": "profiler::resume#withdoc",
  "description": "Resume the profiler if previously paused with profiler::pause...",
  "scope": "",
  "body": [ "# ## profiler::resume\n# \n# Resume the profiler if previously paused with profiler::pause.\n# \n# ```bash\n# profiler::resume\n# ```\n# \nprofiler::resume$0" ]
},

"progress::start": {
  "prefix": "progress::start",
  "description": "Shows a spinner / progress animation with configurable output including a progress bar...",
  "scope": "",
  "body": [ "_OPTION_MAX_FRAMES=${4} _OPTION_SPINNER=${5} _OPTION_DEFAULT_PERCENTAGE=${6} _OPTION_DEFAULT_MESSAGE=${7} progress::start \"${1:template}\" \"${2:bar size}\" \"${3:frame delay}\"$0" ]
},

"progress::start#withdoc": {
  "prefix": "progress::start#withdoc",
  "description": "Shows a spinner / progress animation with configurable output including a progress bar...",
  "scope": "",
  "body": [ "# ## progress::start\n# \n# Shows a spinner / progress animation with configurable output including a progress bar.\n# \n# The animation will be displayed until progress::stop is called\n# or if the max number of frames is reached.\n# \n# Outputs to stderr.\n# This will run in the background and will not block the main thread.\n# The main thread can continue to output logs while this animation is running.\n# \n# - \\$1: template _as string_:\n#       (optional) Can be set using the variable `_OPTION_TEMPLATE`.\n#       The template to display. The template can contain the following placeholders:\n#       - `<spinner>`: the spinner animation\n#       - `<percent>`: the percentage of the progress bar\n#       - `<bar>`: the progress bar\n#       - `<message>`: the message to display\n#       - #TODO: add `<cGradient>` and `<cDefault>`: colors the bar with a gradient (if colors enabled)\n#       (defaults to VALET_CONFIG_PROGRESS_DEFAULT_TEMPLATE or \"<spinner> <percent> ░<bar>░ <message>\")\n# - \\$2: bar size _as int_:\n#       (optional) Can be set using the variable `_OPTION_BAR_SIZE`.\n#       The maximum width of the progress bar.\n#       (defaults to VALET_CONFIG_PROGRESS_BAR_DEFAULT_SIZE or 20)\n# - \\$3: frame delay _as int_:\n#       (optional) Can be set using the variable `_OPTION_FRAME_DELAY`.\n#       The time in milliseconds between each frame of the spinner.\n#       (defaults to VALET_CONFIG_PROGRESS_DEFAULT_ANIMATION_DELAY or 200)\n# - \\${_OPTION_MAX_FRAMES} _as int_:\n#       (optional) The maximum number of frames to display.\n#       (defaults to 9223372036854775807)\n# - \\${_OPTION_SPINNER} _as string_:\n#       (optional) The spinner to display (each character is a frame).\n#       Examples:\n#       - ◐◓◑◒\n#       - ▖▘▝▗\n#       - ⣾⣽⣻⢿⡿⣟⣯⣷\n#       - ⢄⢂⢁⡁⡈⡐⡠\n#       - ◡⊙◠\n#       - ▌▀▐▄\n#       - ⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆\n#       (defaults to VALET_CONFIG_SPINNER_CHARACTERS or \"⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\")\n# - \\${_OPTION_DEFAULT_PERCENTAGE} _as int_:\n#       (optional) The default percentage to start with.\n#       (defaults to 0)\n# - \\${_OPTION_DEFAULT_MESSAGE} _as int_:\n#       (optional) The default message to start with.\n#       (defaults to \"\")\n# \n# ```bash\n# progress::start \"<spinner>\" \"\" 100\n# wait 4\n# progress::stop\n# \n# _OPTION_SPINNER=\"⢄⢂⢁⡁⡈⡐⡠\" progress::start \"<spinner> <percent> ░<bar>░ <message>\" 30\n# IDX=0\n# while [[ \\${IDX} -le 50 ]]; do\n#   progress::update \\$((IDX * 2)) \"Doing something \\${IDX}/50...\"\n#   IDX=\\$((IDX + 1))\n#   sleep 0.1\n# done\n# ```\n# \n# > Important: all progress functions will only work if called from the same shell\n# > that started the progress bar.\n# \n_OPTION_MAX_FRAMES=${4} _OPTION_SPINNER=${5} _OPTION_DEFAULT_PERCENTAGE=${6} _OPTION_DEFAULT_MESSAGE=${7} progress::start \"${1:template}\" \"${2:bar size}\" \"${3:frame delay}\"$0" ]
},

"progress::stop": {
  "prefix": "progress::stop",
  "description": "Stop the progress bar...",
  "scope": "",
  "body": [ "progress::stop$0" ]
},

"progress::stop#withdoc": {
  "prefix": "progress::stop#withdoc",
  "description": "Stop the progress bar...",
  "scope": "",
  "body": [ "# ## progress::stop\n# \n# Stop the progress bar.\n# \n# ```bash\n# progress::stop\n# ```\n# \nprogress::stop$0" ]
},

"progress::update": {
  "prefix": "progress::update",
  "description": "Update the progress bar with a new percentage and message...",
  "scope": "",
  "body": [ "progress::update \"${1:**percent**}\" \"${2:message}\"$0" ]
},

"progress::update#withdoc": {
  "prefix": "progress::update#withdoc",
  "description": "Update the progress bar with a new percentage and message...",
  "scope": "",
  "body": [ "# ## progress::update\n# \n# Update the progress bar with a new percentage and message.\n# \n# The animation can be started with progress::start for more options.\n# The animation will stop if the updated percentage is 100.\n# \n# - \\$1: **percent** _as int_:\n#       the percentage of the progress bar (0 to 100)\n# - \\$2: message _as string_:\n#       (optional) the message to display\n# \n# ```bash\n# progress::update 50 \"Doing something...\"\n# ```\n# \nprogress::update \"${1:**percent**}\" \"${2:message}\"$0" ]
},

"regex::getFirstGroup": {
  "prefix": "regex::getFirstGroup",
  "description": "Matches a string against a regex and returns the first captured group of the first match...",
  "scope": "",
  "body": [ "regex::getFirstGroup \"${1:**string variable name**}\" \"${2:**regex**}\"$0" ]
},

"regex::getFirstGroup#withdoc": {
  "prefix": "regex::getFirstGroup#withdoc",
  "description": "Matches a string against a regex and returns the first captured group of the first match...",
  "scope": "",
  "body": [ "# ## regex::getFirstGroup\n# \n# Matches a string against a regex and returns the first captured group of the first match.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string to match.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The first capture group in the matched string.\n#                      Empty if no match.\n# \n# ```bash\n# MY_STRING=\"name: julien\"\n# regex::getFirstGroup MY_STRING \"name:(.*)\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::getFirstGroup \"${1:**string variable name**}\" \"${2:**regex**}\"$0" ]
},

"regex::getMatches": {
  "prefix": "regex::getMatches",
  "description": "Returns an array containing all the matched for a regex in a string...",
  "scope": "",
  "body": [ "regex::getMatches \"${1:**string variable name**}\" \"${2:**regex**}\" \"${3:replacement}\" \"${4:max count}\"$0" ]
},

"regex::getMatches#withdoc": {
  "prefix": "regex::getMatches#withdoc",
  "description": "Returns an array containing all the matched for a regex in a string...",
  "scope": "",
  "body": [ "# ## regex::getMatches\n# \n# Returns an array containing all the matched for a regex in a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string to match.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# - \\$3: replacement _as string_:\n#       (optional) Can be set using the variable `_OPTION_REPLACEMENT`.\n#       The replacement string to use on each match.\n#       Use \\x to refer to the x-th capture group.\n#       Use \\c to refer to replacement counter.\n#       (default to \"\", which means no changes will be done on the matches)\n# - \\$4: max count _as int_:\n#       (optional) Can be set using the variable `_OPTION_MAX_COUNT`.\n#       The number of matches to return.\n#       (default to -1, which is unlimited)\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array containing all the matches.\n# \n# ```bash\n# MY_STRING=\"name: julien, name: john\"\n# regex::getMatches MY_STRING \"name: (.*)\"\n# for match in \"\\${RETURNED_ARRAY[@]}\"; do\n#   echo \"\\${match}\"\n# done\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::getMatches \"${1:**string variable name**}\" \"${2:**regex**}\" \"${3:replacement}\" \"${4:max count}\"$0" ]
},

"regex::replace": {
  "prefix": "regex::replace",
  "description": "Replaces strings within a string using a regex...",
  "scope": "",
  "body": [ "regex::replace \"${1:**string variable name**}\" \"${2:**regex**}\" \"${3:**replacement**}\" \"${4:max count}\" \"${5:only matches}\"$0" ]
},

"regex::replace#withdoc": {
  "prefix": "regex::replace#withdoc",
  "description": "Replaces strings within a string using a regex...",
  "scope": "",
  "body": [ "# ## regex::replace\n# \n# Replaces strings within a string using a regex.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name containing the string in which to do replacements.\n#       Replacement is done in place.\n# - \\$2: **regex** _as string_:\n#       The regex to use for the match.\n# - \\$3: **replacement** _as string_:\n#       The replacement string.\n#       Use \\x to refer to the x-th capture group.\n#       Use \\c to refer to replacement counter.\n# - \\$4: max count _as int_:\n#       (optional) Can be set using the variable `_OPTION_MAX_COUNT`.\n#       The number of replacements to do.\n#       (default to -1, which is unlimited)\n# - \\$5: only matches _as bool_:\n#       (optional) Can be set using the variable `_OPTION_ONLY_MATCHES`.\n#       Instead of replacing with the regex, we keep only the matches.\n#       This can be used to extract information from a string.\n#       (default to false)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The string with replacements.\n# \n# ```bash\n# MY_STRING=\"name: julien\"\n# regex::replace MY_STRING \"name: (.*)\" \"\\1\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions\n# \nregex::replace \"${1:**string variable name**}\" \"${2:**regex**}\" \"${3:**replacement**}\" \"${4:max count}\" \"${5:only matches}\"$0" ]
},

"sfzf::show": {
  "prefix": "sfzf::show",
  "description": "Displays a menu where the user can search and select an item...",
  "scope": "",
  "body": [ "sfzf::show \"${1:**prompt**}\" \"${2:**array name**}\" \"${3:select callback function name}\" \"${4:preview title}\"$0" ]
},

"sfzf::show#withdoc": {
  "prefix": "sfzf::show#withdoc",
  "description": "Displays a menu where the user can search and select an item...",
  "scope": "",
  "body": [ "# ## sfzf::show\n# \n# Displays a menu where the user can search and select an item.\n# The menu is displayed in full screen.\n# Each item can optionally have a description/details shown in a right panel.\n# The user can search for an item by typing.\n# \n# - \\$1: **prompt** _as string_:\n#       The prompt to display to the user (e.g. Please pick an item).\n# - \\$2: **array name** _as string_:\n#       The items to display (name of a global array).\n# - \\$3: select callback function name _as string_:\n#       (optional) The function to call when an item is selected\n#       (defaults to empty, no callback)\n#       this parameter can be left empty to hide the preview right pane;\n#       otherwise the callback function should have the following signature:\n#   - \\$1: the current item\n#   - \\$2: the item number;\n#   - \\$3: the current panel width;\n#   - it should return the details of the item in the `RETURNED_VALUE` variable.\n# - \\$4: preview title _as string_:\n#       (optional) the title of the preview right pane (if any)\n#       (defaults to empty)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The selected item value (or empty).\n# - \\${RETURNED_VALUE2}: The selected item index (from the original array).\n#                      Or -1 if the user cancelled the selection\n# \n# ```bash\n# declare -g -a SELECTION_ARRAY\n# SELECTION_ARRAY=(\"blue\" \"red\" \"green\" \"yellow\")\n# sfzf::show \"What's your favorite color?\" SELECTION_ARRAY\n# log::info \"You selected: ⌜\\${RETURNED_VALUE}⌝ (index: ⌜\\${RETURNED_VALUE2}⌝)\"\n# ```\n# \nsfzf::show \"${1:**prompt**}\" \"${2:**array name**}\" \"${3:select callback function name}\" \"${4:preview title}\"$0" ]
},

"source": {
  "prefix": "source",
  "description": "Allows to source/include a library file or sources a file...",
  "scope": "",
  "body": [ "source \"${1:**library name or path**}\" \"${2:arguments}\"$0" ]
},

"source#withdoc": {
  "prefix": "source#withdoc",
  "description": "Allows to source/include a library file or sources a file...",
  "scope": "",
  "body": [ "# ## source\n# \n# Allows to source/include a library file or sources a file.\n# \n# It replaces the builtin source command to make sure that we do not source the same library twice.\n# We replace source instead of creating a new function to allow us to\n# specify the included file for spellcheck.\n# \n# - \\$1: **library name or path** _as string_:\n#       the name of the library (array, interactive, string...) or the file path to include.\n# - \\$@: arguments _as any_:\n#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).\n# \n# ```bash\n#   source string\n#   source ./my/path\n# ```\n# \n# > - The file can be relative to the current script (script that calls this function).\n# > - Use `builtin source` if you want to include the file even if it was already included.\n# \nsource \"${1:**library name or path**}\" \"${2:arguments}\"$0" ]
},

"string::convertCamelCaseToSnakeCase": {
  "prefix": "string::convertCamelCaseToSnakeCase",
  "description": "This function convert a camelCase string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "string::convertCamelCaseToSnakeCase \"${1:**string variable name**}\"$0" ]
},

"string::convertCamelCaseToSnakeCase#withdoc": {
  "prefix": "string::convertCamelCaseToSnakeCase#withdoc",
  "description": "This function convert a camelCase string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "# ## string::convertCamelCaseToSnakeCase\n# \n# This function convert a camelCase string to a SNAKE_CASE string.\n# It uses pure bash.\n# Removes all leading underscores.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"myCamelCaseString\"\n# string::convertCamelCaseToSnakeCase MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::convertCamelCaseToSnakeCase \"${1:**string variable name**}\"$0" ]
},

"string::convertKebabCaseToCamelCase": {
  "prefix": "string::convertKebabCaseToCamelCase",
  "description": "This function convert a kebab-case string to a camelCase string...",
  "scope": "",
  "body": [ "string::convertKebabCaseToCamelCase \"${1:**string variable name**}\"$0" ]
},

"string::convertKebabCaseToCamelCase#withdoc": {
  "prefix": "string::convertKebabCaseToCamelCase#withdoc",
  "description": "This function convert a kebab-case string to a camelCase string...",
  "scope": "",
  "body": [ "# ## string::convertKebabCaseToCamelCase\n# \n# This function convert a kebab-case string to a camelCase string.\n# It uses pure bash.\n# Removes all leading dashes.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"my-kebab-case-string\"\n# string::convertKebabCaseToCamelCase MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::convertKebabCaseToCamelCase \"${1:**string variable name**}\"$0" ]
},

"string::convertKebabCaseToSnakeCase": {
  "prefix": "string::convertKebabCaseToSnakeCase",
  "description": "This function convert a kebab-case string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "string::convertKebabCaseToSnakeCase \"${1:**string variable name**}\"$0" ]
},

"string::convertKebabCaseToSnakeCase#withdoc": {
  "prefix": "string::convertKebabCaseToSnakeCase#withdoc",
  "description": "This function convert a kebab-case string to a SNAKE_CASE string...",
  "scope": "",
  "body": [ "# ## string::convertKebabCaseToSnakeCase\n# \n# This function convert a kebab-case string to a SNAKE_CASE string.\n# It uses pure bash.\n# Removes all leading dashes.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to convert.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"my-kebab-case-string\"\n# string::convertKebabCaseToSnakeCase MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::convertKebabCaseToSnakeCase \"${1:**string variable name**}\"$0" ]
},

"string::count": {
  "prefix": "string::count",
  "description": "Counts the number of occurrences of a substring in a string...",
  "scope": "",
  "body": [ "string::count \"${1:**string variable name**}\" \"${2:**substring**}\"$0" ]
},

"string::count#withdoc": {
  "prefix": "string::count#withdoc",
  "description": "Counts the number of occurrences of a substring in a string...",
  "scope": "",
  "body": [ "# ## string::count\n# \n# Counts the number of occurrences of a substring in a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string in which to count occurrences.\n# - \\$2: **substring** _as string_:\n#       the substring to count\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the number of occurrences\n# \n# ```bash\n# MY_STRING=\"name,first_name,address\"\n# string::count MY_STRING \",\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > This is faster than looping over the string and check the substring.\n# \nstring::count \"${1:**string variable name**}\" \"${2:**substring**}\"$0" ]
},

"string::doForEachLine": {
  "prefix": "string::doForEachLine",
  "description": "Execute a callback function for each item (e...",
  "scope": "",
  "body": [ "string::doForEachLine \"${1:**string variable name**}\" \"${2:**callback function**}\" \"${3:separator}\"$0" ]
},

"string::doForEachLine#withdoc": {
  "prefix": "string::doForEachLine#withdoc",
  "description": "Execute a callback function for each item (e...",
  "scope": "",
  "body": [ "# ## string::doForEachLine\n# \n# Execute a callback function for each item (e.g. line) of a string.\n# The string is split using a separator (default to a new line) and\n# the callback function is called for each item.\n# \n# - \\$1: **string variable name** _as string_:\n#       The name of the variable containing the string.\n# - \\$2: **callback function** _as string_:\n#       The name of the function to execute for each item (line).\n#       The function is called with the following arguments:\n# \n#       - \\$1: the current item (line) content\n# \n#       The function must return 0 if we should continue to the next line, 1 otherwise.\n#       (defaults to empty)\n# - \\$3: separator _as string_:\n#       (optional) Can be set using the variable `_OPTION_SEPARATOR`.\n#       The separator character to use.\n#       (defaults to newline if not provided)\n# \n# ```bash\n# string::doForEachLine myString myCallback\n# ```\n# \n# > This function provides a convenient way to avoid using a \"here string\" and handles extra\n# > newlines (which is not the case with a \"for loop\" using parameter expansion and IFS=\\$'\\n').\n# > Here string is significantly slower than using this.\n# \nstring::doForEachLine \"${1:**string variable name**}\" \"${2:**callback function**}\" \"${3:separator}\"$0" ]
},

"string::extractBetween": {
  "prefix": "string::extractBetween",
  "description": "Extract the text between two strings within a string...",
  "scope": "",
  "body": [ "string::extractBetween \"${1:**string variable name**}\" \"${2:**start string**}\" \"${3:**end string**}\"$0" ]
},

"string::extractBetween#withdoc": {
  "prefix": "string::extractBetween#withdoc",
  "description": "Extract the text between two strings within a string...",
  "scope": "",
  "body": [ "# ## string::extractBetween\n# \n# Extract the text between two strings within a string.\n# Search for the first occurrence of the start string and the first occurrence\n# (after the start index) of the end string.\n# Both start and end strings are excluded in the extracted text.\n# Both start and end strings must be found to extract something.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to extract a text.\n# - \\$2: **start string** _as string_:\n#       the start string\n#       (if empty, then it will extract from the beginning of the string)\n# - \\$3: **end string** _as string_:\n#       the end string\n#       (if empty, then it will extract until the end of the string)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted text\n# \n# ```bash\n# MY_STRING=\"This is a long text\"\n# string::extractBetween MY_STRING \"is a \" \" text\"\n# local extractedText=\"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::extractBetween \"${1:**string variable name**}\" \"${2:**start string**}\" \"${3:**end string**}\"$0" ]
},

"string::getField": {
  "prefix": "string::getField",
  "description": "Allows to get the nth element of a string separated by a given separator...",
  "scope": "",
  "body": [ "string::getField \"${1:**string variable name**}\" \"${2:**field number**}\" \"${3:separator}\"$0" ]
},

"string::getField#withdoc": {
  "prefix": "string::getField#withdoc",
  "description": "Allows to get the nth element of a string separated by a given separator...",
  "scope": "",
  "body": [ "# ## string::getField\n# \n# Allows to get the nth element of a string separated by a given separator.\n# This is the equivalent of the cut command \"cut -d\"\\${separator}\" -f\"\\${fieldNumber}\"\"\n# but it uses pure bash to go faster.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to extract from.\n# - \\$2: **field number** _as int_:\n#       The field number to get (starting at 0).\n# - \\$3: separator _as string_:\n#       The separator to use.\n#       (defaults to tab if not provided)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"field1 field2 field3\"\n# string::getField MY_STRING 1 \" \"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > This is faster than:\n# >\n# > - using read into an array from a here string\n# > - using bash parameter expansion to remove before/after the separator\n# \nstring::getField \"${1:**string variable name**}\" \"${2:**field number**}\" \"${3:separator}\"$0" ]
},

"string::getIndexOf": {
  "prefix": "string::getIndexOf",
  "description": "Find the first index of a string within another string...",
  "scope": "",
  "body": [ "string::getIndexOf \"${1:**string variable name**}\" \"${2:**search**}\" \"${3:start index}\"$0" ]
},

"string::getIndexOf#withdoc": {
  "prefix": "string::getIndexOf#withdoc",
  "description": "Find the first index of a string within another string...",
  "scope": "",
  "body": [ "# ## string::getIndexOf\n# \n# Find the first index of a string within another string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to find an index.\n# - \\$2: **search** _as string_:\n#       the string to search\n# - \\$3: start index _as int_:\n#       (optional) the starting index\n#       (defaults to 0)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the index of the substring in the string or -1 if not found.\n# \n# ```bash\n# MY_STRING=\"This is a long text\"\n# string::getIndexOf MY_STRING \"long\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::getIndexOf \"${1:**string variable name**}\" \"${2:**search**}\" \"${3:start index}\"$0" ]
},

"string::head": {
  "prefix": "string::head",
  "description": "Get the first nth items (e...",
  "scope": "",
  "body": [ "string::head \"${1:**string variable name**}\" \"${2:**nb items**}\" \"${3:separator}\"$0" ]
},

"string::head#withdoc": {
  "prefix": "string::head#withdoc",
  "description": "Get the first nth items (e...",
  "scope": "",
  "body": [ "# ## string::head\n# \n# Get the first nth items (e.g. lines) of a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string from which to get the first occurrences.\n# - \\$2: **nb items** _as int_:\n#       The number of items (lines) to extract.\n# - \\$3: separator _as string_:\n#       (optional) Can be set using the variable `_OPTION_SEPARATOR`.\n#       The separator character to use.\n#       (defaults to newline if not provided)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The extracted string.\n# \n# ```bash\n# MY_STRING=\"line1\"\\$'\\n'\"line2\"\\$'\\n'\"line3\"\n# string::head MY_STRING 2\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::head \"${1:**string variable name**}\" \"${2:**nb items**}\" \"${3:separator}\"$0" ]
},

"string::highlight": {
  "prefix": "string::highlight",
  "description": "Highlight characters in a string...",
  "scope": "",
  "body": [ "string::highlight \"${1:**text variable name**}\" \"${2:**characters variable name**}\" \"${3:highlight ansi code}\" \"${4:reset ansi code}\"$0" ]
},

"string::highlight#withdoc": {
  "prefix": "string::highlight#withdoc",
  "description": "Highlight characters in a string...",
  "scope": "",
  "body": [ "# ## string::highlight\n# \n# Highlight characters in a string.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to highlight.\n# - \\$2: **characters variable name** _as string_:\n#       The variable name that contains characters to highlight.\n# - \\$3: highlight ansi code _as string_:\n#       (optional) Can be set using the variable `_OPTION_HIGHLIGHT_ANSI`.\n#       The ANSI code to use for highlighting.\n#       (defaults to STYLE_COLOR_ACCENT)\n# - \\$4: reset ansi code _as string_:\n#       (optional) Can be set using the variable `_OPTION_RESET_ANSI`.\n#       The ANSI code to use for resetting the highlighting.\n#       (defaults to STYLE_COLOR_DEFAULT)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the highlighted text\n# \n# ```bash\n# string::highlight \"This is a text to highlight.\" \"ttttt\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > - All characters to highlight must be found in the same order in the matched line.\n# > - This functions is case insensitive.\n# \nstring::highlight \"${1:**text variable name**}\" \"${2:**characters variable name**}\" \"${3:highlight ansi code}\" \"${4:reset ansi code}\"$0" ]
},

"string::removeSgrCodes": {
  "prefix": "string::removeSgrCodes",
  "description": "Remove all SGR (Select Graphic Rendition) codes from a string...",
  "scope": "",
  "body": [ "string::removeSgrCodes \"${1:**string variable name**}\"$0" ]
},

"string::removeSgrCodes#withdoc": {
  "prefix": "string::removeSgrCodes#withdoc",
  "description": "Remove all SGR (Select Graphic Rendition) codes from a string...",
  "scope": "",
  "body": [ "# ## string::removeSgrCodes\n# \n# Remove all SGR (Select Graphic Rendition) codes from a string.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to clean.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the cleaned string\n# \n# ```bash\n# MY_STRING=\"This is a string with SGR codes\"\\$'\\e[0m'\n# string::removeSgrCodes MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::removeSgrCodes \"${1:**string variable name**}\"$0" ]
},

"string::split": {
  "prefix": "string::split",
  "description": "Split a string into an array using a separator...",
  "scope": "",
  "body": [ "string::split \"${1:**string variable name**}\" \"${2:**separators**}\"$0" ]
},

"string::split#withdoc": {
  "prefix": "string::split#withdoc",
  "description": "Split a string into an array using a separator...",
  "scope": "",
  "body": [ "# ## string::split\n# \n# Split a string into an array using a separator.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to split.\n# - \\$2: **separators** _as string_:\n#       The separator characters to use.\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: the array of strings\n# \n# ```bash\n# MY_STRING=\"name,first_name,address\"\n# string::split MY_STRING \",\"\n# ARRAY=(\"\\${RETURNED_ARRAY[@]}\")\n# ```\n# \n# > This is faster than using read into an array from a here string.\n# \nstring::split \"${1:**string variable name**}\" \"${2:**separators**}\"$0" ]
},

"string::trimAll": {
  "prefix": "string::trimAll",
  "description": "Trim all whitespaces and truncate spaces...",
  "scope": "",
  "body": [ "string::trimAll \"${1:**string variable name**}\"$0" ]
},

"string::trimAll#withdoc": {
  "prefix": "string::trimAll#withdoc",
  "description": "Trim all whitespaces and truncate spaces...",
  "scope": "",
  "body": [ "# ## string::trimAll\n# \n# Trim all whitespaces and truncate spaces.\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to trim.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"   example \"\\$'\\t'\"  string    \"\\$'\\n'\n# string::trimAll MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::trimAll \"${1:**string variable name**}\"$0" ]
},

"string::trimEdges": {
  "prefix": "string::trimEdges",
  "description": "Trim leading and trailing characters (defaults to whitespaces)...",
  "scope": "",
  "body": [ "string::trimEdges \"${1:**string variable name**}\" \"${2:characters to trim}\"$0" ]
},

"string::trimEdges#withdoc": {
  "prefix": "string::trimEdges#withdoc",
  "description": "Trim leading and trailing characters (defaults to whitespaces)...",
  "scope": "",
  "body": [ "# ## string::trimEdges\n# \n# Trim leading and trailing characters (defaults to whitespaces).\n# \n# - \\$1: **string variable name** _as string_:\n#       The variable name that contains the string to trim.\n# - \\$2: characters to trim _as string_:\n#       The characters to trim.\n#       (defaults to \" \"\\$'\\t'\\$'\\n')\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the extracted field\n# \n# ```bash\n# MY_STRING=\"   example  string    \"\n# string::trimEdges MY_STRING\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nstring::trimEdges \"${1:**string variable name**}\" \"${2:characters to trim}\"$0" ]
},

"string::wrapCharacters": {
  "prefix": "string::wrapCharacters",
  "description": "Allows to hard wrap the given string at the given width...",
  "scope": "",
  "body": [ "string::wrapCharacters \"${1:**text variable name**}\" \"${2:wrap width}\" \"${3:padding characters}\" \"${4:first line width}\"$0" ]
},

"string::wrapCharacters#withdoc": {
  "prefix": "string::wrapCharacters#withdoc",
  "description": "Allows to hard wrap the given string at the given width...",
  "scope": "",
  "body": [ "# ## string::wrapCharacters\n# \n# Allows to hard wrap the given string at the given width.\n# Wrapping is done at character boundaries, see string::warpText for word wrapping.\n# Optionally appends padding characters on each new line.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to wrap.\n# - \\$2: wrap width _as string_:\n#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.\n#       The width to wrap the text at.\n#       Note that length of the optional padding characters are subtracted from the\n#       width to make sure the text fits in the given width.\n#       (defaults to GLOBAL_COLUMNS)\n# - \\$3: padding characters _as string_:\n#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.\n#       The characters to apply as padding on the left of each new line.\n#       E.g. '  ' will add 2 spaces on the left of each new line.\n#       (defaults to \"\")\n# - \\$4: first line width _as int_:\n#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.\n#       The width to use for the first line.\n#       (defaults to the width)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the wrapped string\n# - \\${RETURNED_VALUE2}: the length taken on the last line\n# \n# ```bash\n# string::wrapCharacters \"This is a long text that should be wrapped at 20 characters.\" 20 --- 5\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > - This function is written in pure bash and is faster than calling the fold command.\n# > - It considers escape sequence for text formatting and does not count them as visible characters.\n# > - Leading spaces after a newly wrapped line are removed.\n# \nstring::wrapCharacters \"${1:**text variable name**}\" \"${2:wrap width}\" \"${3:padding characters}\" \"${4:first line width}\"$0" ]
},

"string::wrapWords": {
  "prefix": "string::wrapWords",
  "description": "Allows to soft wrap the given text at the given width...",
  "scope": "",
  "body": [ "string::wrapWords \"${1:**text variable name**}\" \"${2:wrap width}\" \"${3:padding characters}\" \"${4:first line width}\"$0" ]
},

"string::wrapWords#withdoc": {
  "prefix": "string::wrapWords#withdoc",
  "description": "Allows to soft wrap the given text at the given width...",
  "scope": "",
  "body": [ "# ## string::wrapWords\n# \n# Allows to soft wrap the given text at the given width.\n# Wrapping is done at word boundaries.\n# Optionally appends padding characters on each new line.\n# \n# - \\$1: **text variable name** _as string_:\n#       The variable name that contains the text to wrap.\n# - \\$2: wrap width _as string_:\n#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.\n#       The width to wrap the text at.\n#       Note that length of the optional padding characters are subtracted from the\n#       width to make sure the text fits in the given width.\n#       (defaults to GLOBAL_COLUMNS)\n# - \\$3: padding characters _as string_:\n#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.\n#       The characters to apply as padding on the left of each new line.\n#       E.g. '  ' will add 2 spaces on the left of each new line.\n#       (defaults to 0)\n# - \\$4: first line width _as int_:\n#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.\n#       The width to use for the first line.\n#       (defaults to the width)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the wrapped text\n# \n# ```bash\n# string::wrapWords \"This is a long text that should be wrapped at 20 characters.\" 20 '  ' 5\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \n# > - This function is written in pure bash and is faster than calling the fold command.\n# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).\n# > - It considers escape sequence for text formatting and does not count them as visible characters.\n# \nstring::wrapWords \"${1:**text variable name**}\" \"${2:wrap width}\" \"${3:padding characters}\" \"${4:first line width}\"$0" ]
},

"system::addToPath": {
  "prefix": "system::addToPath",
  "description": "Add the given path to the PATH environment variable for various shells, by adding the appropriate export command to the appropriate file...",
  "scope": "",
  "body": [ "system::addToPath \"${1:**path**}\"$0" ]
},

"system::addToPath#withdoc": {
  "prefix": "system::addToPath#withdoc",
  "description": "Add the given path to the PATH environment variable for various shells, by adding the appropriate export command to the appropriate file...",
  "scope": "",
  "body": [ "# ## system::addToPath\n# \n# Add the given path to the PATH environment variable for various shells,\n# by adding the appropriate export command to the appropriate file.\n# \n# Will also export the PATH variable in the current bash.\n# \n# - \\$1: **path** _as string_:\n#       the path to add to the PATH environment variable.\n# \n# ```bash\n# system::addToPath \"/path/to/bin\"\n# ```\n# \nsystem::addToPath \"${1:**path**}\"$0" ]
},

"system::getArchitecture": {
  "prefix": "system::getArchitecture",
  "description": "Returns the CPU architecture of the current machine...",
  "scope": "",
  "body": [ "system::getArchitecture$0" ]
},

"system::getArchitecture#withdoc": {
  "prefix": "system::getArchitecture#withdoc",
  "description": "Returns the CPU architecture of the current machine...",
  "scope": "",
  "body": [ "# ## system::getArchitecture\n# \n# Returns the CPU architecture of the current machine.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the CPU architecture of the current machine.\n# \n# ```bash\n# system::getArchitecture\n# local architecture=\"\\${RETURNED_VALUE}\"\n# ```\n# \nsystem::getArchitecture$0" ]
},

"system::getEnvVars": {
  "prefix": "system::getEnvVars",
  "description": "Get the list of all the environment variables...",
  "scope": "",
  "body": [ "system::getEnvVars$0" ]
},

"system::getEnvVars#withdoc": {
  "prefix": "system::getEnvVars#withdoc",
  "description": "Get the list of all the environment variables...",
  "scope": "",
  "body": [ "# ## system::getEnvVars\n# \n# Get the list of all the environment variables.\n# In pure bash, no need for env or printenv.\n# \n# Returns:\n# \n# - \\${RETURNED_ARRAY[@]}: An array with the list of all the environment variables.\n# \n# ```bash\n# system::getEnvVars\n# for var in \"\\${RETURNED_ARRAY[@]}\"; do\n#   printf '%s=%s\\n' \"\\${var}\" \"\\${!var}\"\n# done\n# ```\n# \nsystem::getEnvVars$0" ]
},

"system::getOs": {
  "prefix": "system::getOs",
  "description": "Returns the name of the current OS...",
  "scope": "",
  "body": [ "system::getOs$0" ]
},

"system::getOs#withdoc": {
  "prefix": "system::getOs#withdoc",
  "description": "Returns the name of the current OS...",
  "scope": "",
  "body": [ "# ## system::getOs\n# \n# Returns the name of the current OS.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the name of the current OS: \"darwin\", \"linux\" or \"windows\".\n# \n# ```bash\n# system::getOs\n# local osName=\"\\${RETURNED_VALUE}\"\n# ```\n# \nsystem::getOs$0" ]
},

"system::isRoot": {
  "prefix": "system::isRoot",
  "description": "Check if the script is running as root...",
  "scope": "",
  "body": [ "system::isRoot$0" ]
},

"system::isRoot#withdoc": {
  "prefix": "system::isRoot#withdoc",
  "description": "Check if the script is running as root...",
  "scope": "",
  "body": [ "# ## system::isRoot\n# \n# Check if the script is running as root.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the script is running as root\n#   - 1 otherwise.\n# \n# ```bash\n# if system::isRoot; then\n#   printf 'The script is running as root.'\n# fi\n# ```\n# \nsystem::isRoot$0" ]
},

"test::exec": {
  "prefix": "test::exec",
  "description": "Call this function to execute a command and write the command and its output to the report file...",
  "scope": "",
  "body": [ "test::exec \"${1:**command**}\"$0" ]
},

"test::exec#withdoc": {
  "prefix": "test::exec#withdoc",
  "description": "Call this function to execute a command and write the command and its output to the report file...",
  "scope": "",
  "body": [ "# ## test::exec\n# \n# Call this function to execute a command and write the command and its output to the report file.\n# The command can fail, in which case the returned exit code is written to the report file.\n# However, the command must not call `exit` (in which case, use test::exit).\n# \n# - \\$@: **command** _as string_:\n#       The command to execute.\n# \n# ```bash\n# test::exec echo \"Hello, world!\"\n# ```\n# \ntest::exec \"${1:**command**}\"$0" ]
},

"test::exit": {
  "prefix": "test::exit",
  "description": "Call this function to execute a command that can call `exit` and write the command and its output to the report file...",
  "scope": "",
  "body": [ "test::exit \"${1:**command**}\"$0" ]
},

"test::exit#withdoc": {
  "prefix": "test::exit#withdoc",
  "description": "Call this function to execute a command that can call `exit` and write the command and its output to the report file...",
  "scope": "",
  "body": [ "# ## test::exit\n# \n# Call this function to execute a command that can call `exit` and write the command and its output to the report file.\n# The command is executed in a subshell to catch the exit.\n# \n# - \\$@: **command** _as string_:\n#       The command to execute.\n# \n# ```bash\n# test::exit exit 3\n# ```\n# \ntest::exit \"${1:**command**}\"$0" ]
},

"test::fail": {
  "prefix": "test::fail",
  "description": "Call this function to log a message and exit with the status 142, which indicates to the self test command that the test failed and that we know the reason (it is a bad implementation of the test itself)...",
  "scope": "",
  "body": [ "test::fail \"${1:**message**}\"$0" ]
},

"test::fail#withdoc": {
  "prefix": "test::fail#withdoc",
  "description": "Call this function to log a message and exit with the status 142, which indicates to the self test command that the test failed and that we know the reason (it is a bad implementation of the test itself)...",
  "scope": "",
  "body": [ "# ## test::fail\n# \n# Call this function to log a message and exit with the status 142, which\n# indicates to the self test command that the test failed and that we know the\n# reason (it is a bad implementation of the test itself).\n# \n# - \\$@: **message** _as string_:\n#       The message to log.\n# \n# ```bash\n# test::fail \"This is a failure message with a clear reason.\"\n# ```\n# \ntest::fail \"${1:**message**}\"$0" ]
},

"test::flush": {
  "prefix": "test::flush",
  "description": "Call this function to flush the standard and error outputs to the report file...",
  "scope": "",
  "body": [ "test::flush$0" ]
},

"test::flush#withdoc": {
  "prefix": "test::flush#withdoc",
  "description": "Call this function to flush the standard and error outputs to the report file...",
  "scope": "",
  "body": [ "# ## test::flush\n# \n# Call this function to flush the standard and error outputs to the report file.\n# They will be added as code blocks in the report file (one for the standard\n# output, one for the standard error).\n# \n# ```bash\n# test::flush\n# ```\n# \ntest::flush$0" ]
},

"test::flushStderr": {
  "prefix": "test::flushStderr",
  "description": "Call this function to flush the standard error to the report file...",
  "scope": "",
  "body": [ "test::flushStderr \"${1:blockTitle}\"$0" ]
},

"test::flushStderr#withdoc": {
  "prefix": "test::flushStderr#withdoc",
  "description": "Call this function to flush the standard error to the report file...",
  "scope": "",
  "body": [ "# ## test::flushStderr\n# \n# Call this function to flush the standard error to the report file.\n# It will be added as a code block in the report file.\n# \n# - \\$1: blockTitle _as string_:\n#       (optional) Can be set using the variable `_OPTION_BLOCK_TITLE`.\n#       Add a 'title' to the code block (`**title**:` before the code block).\n#       (defaults to '' which will not add a title)\n# \n# ```bash\n# test::flushStderr\n# ```\n# \ntest::flushStderr \"${1:blockTitle}\"$0" ]
},

"test::flushStdout": {
  "prefix": "test::flushStdout",
  "description": "Call this function to flush the standard output to the report file...",
  "scope": "",
  "body": [ "test::flushStdout \"${1:blockTitle}\"$0" ]
},

"test::flushStdout#withdoc": {
  "prefix": "test::flushStdout#withdoc",
  "description": "Call this function to flush the standard output to the report file...",
  "scope": "",
  "body": [ "# ## test::flushStdout\n# \n# Call this function to flush the standard output to the report file.\n# It will be added as a code block in the report file.\n# \n# - \\$1: blockTitle _as string_:\n#       (optional) Can be set using the variable `_OPTION_BLOCK_TITLE`.\n#       Add a 'title' to the code block (`**title**:` before the code block).\n#       (defaults to '' which will not add a title)\n# \n# ```bash\n# test::flushStdout\n# ```\n# \ntest::flushStdout \"${1:blockTitle}\"$0" ]
},

"test::func": {
  "prefix": "test::func",
  "description": "Call this function to test a function that returns a value using the valet conventions (RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY, etc...",
  "scope": "",
  "body": [ "test::func \"${1:**command**}\"$0" ]
},

"test::func#withdoc": {
  "prefix": "test::func#withdoc",
  "description": "Call this function to test a function that returns a value using the valet conventions (RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY, etc...",
  "scope": "",
  "body": [ "# ## test::func\n# \n# Call this function to test a function that returns a value using the valet\n# conventions (RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY, etc...).\n# \n# It will write the command and its output to the report file.\n# It will also print the returned values.\n# \n# - \\$@: **command** _as string_:\n#       The command to execute (function and its arguments).\n# \n# ```bash\n# test::func myFunction\n# ```\n# \ntest::func \"${1:**command**}\"$0" ]
},

"test::log": {
  "prefix": "test::log",
  "description": "Call this function to log a message during a test...",
  "scope": "",
  "body": [ "test::log \"${1:**messages**}\"$0" ]
},

"test::log#withdoc": {
  "prefix": "test::log#withdoc",
  "description": "Call this function to log a message during a test...",
  "scope": "",
  "body": [ "# ## test::log\n# \n# Call this function to log a message during a test.\n# This log will only show in case of a script error or when the debug\n# log level is enabled when running the tests.\n# \n# - \\$@: **messages** _as string_:\n#       The messages to log.\n# \n# ```bash\n# test::log \"This is a log message.\"\n# ```\n# \ntest::log \"${1:**messages**}\"$0" ]
},

"test::markdown": {
  "prefix": "test::markdown",
  "description": "Call this function to add some markdown in the report file...",
  "scope": "",
  "body": [ "test::markdown \"${1:**markdown**}\"$0" ]
},

"test::markdown#withdoc": {
  "prefix": "test::markdown#withdoc",
  "description": "Call this function to add some markdown in the report file...",
  "scope": "",
  "body": [ "# ## test::markdown\n# \n# Call this function to add some markdown in the report file.\n# \n# - \\$@: **markdown** _as string_:\n#       The markdown to add in the report file.\n# \n# ```bash\n# test::markdown \"> This is a **quote**.\"\n# ```\n# \ntest::markdown \"${1:**markdown**}\"$0" ]
},

"test::printReturnedVars": {
  "prefix": "test::printReturnedVars",
  "description": "This function can be called to print the returned values, e...",
  "scope": "",
  "body": [ "test::printReturnedVars$0" ]
},

"test::printReturnedVars#withdoc": {
  "prefix": "test::printReturnedVars#withdoc",
  "description": "This function can be called to print the returned values, e...",
  "scope": "",
  "body": [ "# ## test::printReturnedVars\n# \n# This function can be called to print the returned values,\n# e.g. RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY...\n# They will each be printed in a code block in the report file.\n# \n# ```bash\n# test::printReturnedVars\n# ```\n# \ntest::printReturnedVars$0" ]
},

"test::printVars": {
  "prefix": "test::printVars",
  "description": "This function can be called to print the global variables in the report file...",
  "scope": "",
  "body": [ "test::printVars \"${1:**variables**}\"$0" ]
},

"test::printVars#withdoc": {
  "prefix": "test::printVars#withdoc",
  "description": "This function can be called to print the global variables in the report file...",
  "scope": "",
  "body": [ "# ## test::printVars\n# \n# This function can be called to print the global variables in the report file.\n# They will printed in a code block in the report file.\n# \n# - \\$@: **variables** _as string_:\n#       The variables to print.\n# \n# ```bash\n# test::printVars myVar\n# ```\n# \ntest::printVars \"${1:**variables**}\"$0" ]
},

"test::prompt": {
  "prefix": "test::prompt",
  "description": "Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file...",
  "scope": "",
  "body": [ "test::prompt \"${1:**command**}\"$0" ]
},

"test::prompt#withdoc": {
  "prefix": "test::prompt#withdoc",
  "description": "Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file...",
  "scope": "",
  "body": [ "# ## test::prompt\n# \n# Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file.\n# \n# - \\$@: **command** _as string_:\n#       The command to print as a prompt.\n# \n# ```bash\n# test::prompt \"echo 'Hello, world!'\"\n# ```\n# \ntest::prompt \"${1:**command**}\"$0" ]
},

"test::resetReturnedVars": {
  "prefix": "test::resetReturnedVars",
  "description": "Resets the value of each RETURNED_ variable...",
  "scope": "",
  "body": [ "test::resetReturnedVars$0" ]
},

"test::resetReturnedVars#withdoc": {
  "prefix": "test::resetReturnedVars#withdoc",
  "description": "Resets the value of each RETURNED_ variable...",
  "scope": "",
  "body": [ "# ## test::resetReturnedVars\n# \n# Resets the value of each RETURNED_ variable.\n# \n# ```bash\n# test::resetReturnedVars\n# ```\n# \ntest::resetReturnedVars$0" ]
},

"test::title": {
  "prefix": "test::title",
  "description": "Call this function to add an H3 title in the report file...",
  "scope": "",
  "body": [ "test::title \"${1:title}\"$0" ]
},

"test::title#withdoc": {
  "prefix": "test::title#withdoc",
  "description": "Call this function to add an H3 title in the report file...",
  "scope": "",
  "body": [ "# ## test::title\n# \n# Call this function to add an H3 title in the report file.\n# \n# - \\$1: title _as string_:\n#       (optional) Can be set using the variable `_OPTION_TITLE`.\n#       The title of the test.\n#      (defaults to \"Test\")\n# \n# ```bash\n# test::title \"Testing something\"\n# ```\n# \ntest::title \"${1:title}\"$0" ]
},

"test::transformReturnedVarsBeforePrinting": {
  "prefix": "test::transformReturnedVarsBeforePrinting",
  "description": "This function can be defined to modify the returned variables before printing them in the report...",
  "scope": "",
  "body": [ "test::transformReturnedVarsBeforePrinting$0" ]
},

"test::transformReturnedVarsBeforePrinting#withdoc": {
  "prefix": "test::transformReturnedVarsBeforePrinting#withdoc",
  "description": "This function can be defined to modify the returned variables before printing them in the report...",
  "scope": "",
  "body": [ "# ## test::transformReturnedVarsBeforePrinting\n# \n# This function can be defined to modify the returned variables before printing them in the report.\n# \n# > You can define this function directly in the test script, or in a test hook if\n# > you need it to be available for multiple tests.\n# > Note however that this function can be called very often, so it should be optimized.\n# \ntest::transformReturnedVarsBeforePrinting$0" ]
},

"test::transformTextBeforeFlushing": {
  "prefix": "test::transformTextBeforeFlushing",
  "description": "This function can be defined to modify the flushed text before adding it to the report...",
  "scope": "",
  "body": [ "test::transformTextBeforeFlushing$0" ]
},

"test::transformTextBeforeFlushing#withdoc": {
  "prefix": "test::transformTextBeforeFlushing#withdoc",
  "description": "This function can be defined to modify the flushed text before adding it to the report...",
  "scope": "",
  "body": [ "# ## test::transformTextBeforeFlushing\n# \n# This function can be defined to modify the flushed text before adding it to the report.\n# \n# The text to transform is in the global variable `_TEST_OUTPUT`.\n# \n# Returns:\n# \n# - `_TEST_OUTPUT`: The modified text.\n# \n# > You can define this function directly in the test script, or in a test hook if\n# > you need it to be available for multiple tests.\n# > Note however that this function can be called very often, so it should be optimized.\n# \ntest::transformTextBeforeFlushing$0" ]
},

"time::convertMicrosecondsToHuman": {
  "prefix": "time::convertMicrosecondsToHuman",
  "description": "Convert microseconds to human readable format...",
  "scope": "",
  "body": [ "time::convertMicrosecondsToHuman \"${1:**microseconds**}\" \"${2:format}\"$0" ]
},

"time::convertMicrosecondsToHuman#withdoc": {
  "prefix": "time::convertMicrosecondsToHuman#withdoc",
  "description": "Convert microseconds to human readable format...",
  "scope": "",
  "body": [ "# ## time::convertMicrosecondsToHuman\n# \n# Convert microseconds to human readable format.\n# \n# - \\$1: **microseconds** _as int_:\n#       the microseconds to convert\n# - \\$2: format _as string_:\n#      (optional) Can be set using the variable `_OPTION_FORMAT`.\n#      the format to use (defaults to \"%HH:%MM:%SS\")\n#      Usable formats:\n#      - %HH: hours\n#      - %MM: minutes\n#      - %SS: seconds\n#      - %LL: milliseconds\n#      - %h: hours without leading zero\n#      - %m: minutes without leading zero\n#      - %s: seconds without leading zero\n#      - %l: milliseconds without leading zero\n#      - %u: microseconds without leading zero\n#      - %M: total minutes\n#      - %S: total seconds\n#      - %L: total milliseconds\n#      - %U: total microseconds\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the human readable format\n# \n# ```bash\n# time::convertMicrosecondsToHuman 123456789\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \ntime::convertMicrosecondsToHuman \"${1:**microseconds**}\" \"${2:format}\"$0" ]
},

"time::getDate": {
  "prefix": "time::getDate",
  "description": "Get the current date in the given format...",
  "scope": "",
  "body": [ "time::getDate \"${1:format}\"$0" ]
},

"time::getDate#withdoc": {
  "prefix": "time::getDate#withdoc",
  "description": "Get the current date in the given format...",
  "scope": "",
  "body": [ "# ## time::getDate\n# \n# Get the current date in the given format.\n# \n# - \\$1: format _as string_:\n#       (optional) the format of the date to return\n#       (defaults to %(%F_%Hh%Mm%Ss)T).\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the current date in the given format.\n# \n# ```bash\n# time::getDate\n# local date=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# > This function avoid to call \\$(date) in a subshell (date is a an external executable).\n# \ntime::getDate \"${1:format}\"$0" ]
},

"time::getProgramElapsedMicroseconds": {
  "prefix": "time::getProgramElapsedMicroseconds",
  "description": "Get the elapsed time in µs since the program started...",
  "scope": "",
  "body": [ "time::getProgramElapsedMicroseconds$0" ]
},

"time::getProgramElapsedMicroseconds#withdoc": {
  "prefix": "time::getProgramElapsedMicroseconds#withdoc",
  "description": "Get the elapsed time in µs since the program started...",
  "scope": "",
  "body": [ "# ## time::getProgramElapsedMicroseconds\n# \n# Get the elapsed time in µs since the program started.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the elapsed time in µs since the program started.\n# \n# ```bash\n# core::getElapsedProgramTime\n# echo \"\\${RETURNED_VALUE}\"\n# time::convertMicrosecondsToHuman \"\\${RETURNED_VALUE}\"\n# echo \"Human time: \\${RETURNED_VALUE}\"\n# ```\n# \n# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.\n# > The 10# forces the base 10 conversion to avoid issues with leading zeros.\n# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.\n# \ntime::getProgramElapsedMicroseconds$0" ]
},

"time::getTimerValue": {
  "prefix": "time::getTimerValue",
  "description": "Get the time elapsed since the call of `time::startTimer`...",
  "scope": "",
  "body": [ "_OPTION_LOG_ELAPSED_TIME=${1} _OPTION_FORMAT=${2} time::getTimerValue$0" ]
},

"time::getTimerValue#withdoc": {
  "prefix": "time::getTimerValue#withdoc",
  "description": "Get the time elapsed since the call of `time::startTimer`...",
  "scope": "",
  "body": [ "# ## time::getTimerValue\n# \n# Get the time elapsed since the call of `time::startTimer`.\n# \n# - \\${_OPTION_LOG_ELAPSED_TIME} _as bool_:\n#      (optional) Wether or not to log the elapsed time.\n#      (defaults to false)\n# - \\${_OPTION_FORMAT} _as string_:\n#      (optional) The format to use if we log the elapsed time.\n#      See `time::convertMicrosecondsToHuman` for the format.\n#      (defaults to \"%S.%LLs\").\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the elapsed time in microseconds.\n# \n# ```bash\n# time::startTimer\n# _OPTION_LOG_ELAPSED_TIME=true time::getTimerValue\n# echo \"Total microseconds: \\${RETURNED_VALUE}\"\n# ```\n# \n_OPTION_LOG_ELAPSED_TIME=${1} _OPTION_FORMAT=${2} time::getTimerValue$0" ]
},

"time::startTimer": {
  "prefix": "time::startTimer",
  "description": "Start a timer...",
  "scope": "",
  "body": [ "time::startTimer$0" ]
},

"time::startTimer#withdoc": {
  "prefix": "time::startTimer#withdoc",
  "description": "Start a timer...",
  "scope": "",
  "body": [ "# ## time::startTimer\n# \n# Start a timer. You can then call `time::getTimerValue` to get the elapsed time.\n# \n# ```bash\n# time::startTimer\n# time::getTimerValue\n# ```\n# \ntime::startTimer$0" ]
},

"tui::clearBox": {
  "prefix": "tui::clearBox",
  "description": "Clear a \"box\" in the terminal...",
  "scope": "",
  "body": [ "tui::clearBox \"${1:**top**}\" \"${2:**left**}\" \"${3:**width**}\" \"${4:**height**}\"$0" ]
},

"tui::clearBox#withdoc": {
  "prefix": "tui::clearBox#withdoc",
  "description": "Clear a \"box\" in the terminal...",
  "scope": "",
  "body": [ "# ## tui::clearBox\n# \n# Clear a \"box\" in the terminal.\n# Will return the cursor at the current position at the end (using GLOBAL_CURSOR_LINE and GLOBAL_CURSOR_COLUMN).\n# \n# - \\$1: **top** _as int_:\n#       the left position of the box\n# - \\$2: **left** _as int_:\n#       the top position of the box\n# - \\$3: **width** _as int_:\n#       the width of the box\n# - \\$4: **height** _as int_:\n#       the height of the box\n# \n# ```bash\n# tui::getCursorPosition\n# tui::clearBox 1 1 10 5\n# ```\n# \ntui::clearBox \"${1:**top**}\" \"${2:**left**}\" \"${3:**width**}\" \"${4:**height**}\"$0" ]
},

"tui::clearKeyPressed": {
  "prefix": "tui::clearKeyPressed",
  "description": "This function reads all the inputs from the user, effectively discarding them...",
  "scope": "",
  "body": [ "tui::clearKeyPressed$0" ]
},

"tui::clearKeyPressed#withdoc": {
  "prefix": "tui::clearKeyPressed#withdoc",
  "description": "This function reads all the inputs from the user, effectively discarding them...",
  "scope": "",
  "body": [ "# ## tui::clearKeyPressed\n# \n# This function reads all the inputs from the user, effectively discarding them.\n# \n# ```bash\n# tui::clearKeyPressed\n# ```\n# \ntui::clearKeyPressed$0" ]
},

"tui::createSpace": {
  "prefix": "tui::createSpace",
  "description": "This function creates empty lines from the current cursor position...",
  "scope": "",
  "body": [ "tui::createSpace \"${1:**number of lines**}\"$0" ]
},

"tui::createSpace#withdoc": {
  "prefix": "tui::createSpace#withdoc",
  "description": "This function creates empty lines from the current cursor position...",
  "scope": "",
  "body": [ "# ## tui::createSpace\n# \n# This function creates empty lines from the current cursor position.\n# Then it moves back to its original line (at the column 1).\n# The current cursor line counts, meaning that `tui::createSpace 1` will\n# not do anything but clear the current line.\n# \n# This effectively creates a space in the terminal (scroll up if we are at the bottom).\n# It does not create more space than the number of lines in the terminal.\n# \n# - \\$1: **number of lines** _as int_:\n#       the number of lines to create\n# \n# ```bash\n# tui::createSpace 5\n# ```\n# \ntui::createSpace \"${1:**number of lines**}\"$0" ]
},

"tui::getBestAutocompleteBox": {
  "prefix": "tui::getBestAutocompleteBox",
  "description": "This function returns the best position and size for an autocomplete box that would open at the given position...",
  "scope": "",
  "body": [ "tui::getBestAutocompleteBox \"${1:**current line**}\" \"${2:**current column**}\" \"${3:**desired height**}\" \"${4:**desired width**}\" \"${5:**max height**}\" \"${6:force below}\" \"${7:not on current line}\" \"${8:terminal width}\" \"${9:terminal height}\"$0" ]
},

"tui::getBestAutocompleteBox#withdoc": {
  "prefix": "tui::getBestAutocompleteBox#withdoc",
  "description": "This function returns the best position and size for an autocomplete box that would open at the given position...",
  "scope": "",
  "body": [ "# ## tui::getBestAutocompleteBox\n# \n# This function returns the best position and size for an autocomplete box that would open\n# at the given position.\n# \n# - The box will be placed below the current position if possible, but can be placed\n#   above if there is not enough space below.\n# - The box will be placed on the same column as the current position if possible, but can be placed\n#   on the left side if there is not enough space on the right to display the full width of the box.\n# - The box will have the desired height and width if possible, but will be reduced if there is\n#   not enough space in the terminal.\n# - The box will not be placed on the same line as the current position if notOnCurrentLine is set to true.\n#   Otherwise it can use the current position line.\n# \n# - \\$1: **current line** _as int_:\n#       the current line of the cursor (1 based)\n# - \\$2: **current column** _as int_:\n#       the current column of the cursor (1 based)\n# - \\$3: **desired height** _as int_:\n#       the desired height of the box\n# - \\$4: **desired width** _as int_:\n#       the desired width of the box\n# - \\$5: **max height** _as int_:\n#       the maximum height of the box\n# - \\$6: force below _as bool_:\n#       (optional) force the box to be below the current position\n#       (defaults to false)\n# - \\$7: not on current line _as bool_:\n#       (optional) the box will not be placed on the same line as the current position\n#       (defaults to true)\n# - \\$8: terminal width _as int_:\n#       (optional) the width of the terminal\n#       (defaults to GLOBAL_COLUMNS)\n# - \\$9: terminal height _as int_:\n#       (optional) the height of the terminal\n#       (defaults to GLOBAL_LINES)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the top position of the box (1 based)\n# - \\${RETURNED_VALUE2}: the left position of the box (1 based)\n# - \\${RETURNED_VALUE3}: the width of the box\n# - \\${RETURNED_VALUE4}: the height of the box\n# \n# ```bash\n# tui::getBestAutocompleteBox 1 1 10 5\n# ```\n# \ntui::getBestAutocompleteBox \"${1:**current line**}\" \"${2:**current column**}\" \"${3:**desired height**}\" \"${4:**desired width**}\" \"${5:**max height**}\" \"${6:force below}\" \"${7:not on current line}\" \"${8:terminal width}\" \"${9:terminal height}\"$0" ]
},

"tui::getCursorPosition": {
  "prefix": "tui::getCursorPosition",
  "description": "Get the current cursor position...",
  "scope": "",
  "body": [ "tui::getCursorPosition$0" ]
},

"tui::getCursorPosition#withdoc": {
  "prefix": "tui::getCursorPosition#withdoc",
  "description": "Get the current cursor position...",
  "scope": "",
  "body": [ "# ## tui::getCursorPosition\n# \n# Get the current cursor position.\n# \n# Returns:\n# \n# - `GLOBAL_CURSOR_LINE`: the line number\n# - `GLOBAL_CURSOR_COLUMN`: the column number\n# \n# ```bash\n# tui::getCursorPosition\n# ```\n# \ntui::getCursorPosition$0" ]
},

"tui::getTerminalSize": {
  "prefix": "tui::getTerminalSize",
  "description": "This function exports the terminal size...",
  "scope": "",
  "body": [ "tui::getTerminalSize$0" ]
},

"tui::getTerminalSize#withdoc": {
  "prefix": "tui::getTerminalSize#withdoc",
  "description": "This function exports the terminal size...",
  "scope": "",
  "body": [ "# ## tui::getTerminalSize\n# \n# This function exports the terminal size.\n# \n# Returns:\n# \n# - `GLOBAL_COLUMNS`: The number of columns in the terminal.\n# - `GLOBAL_LINES`: The number of lines in the terminal.\n# \n# ```bash\n# tui::getTerminalSize\n# printf '%s\\n' \"The terminal has ⌜\\${GLOBAL_COLUMNS}⌝ columns and ⌜\\${GLOBAL_LINES}⌝ lines.\"\n# ```\n# \ntui::getTerminalSize$0" ]
},

"tui::rebindKeymap": {
  "prefix": "tui::rebindKeymap",
  "description": "Rebinds all special keys to call a given callback function...",
  "scope": "",
  "body": [ "tui::rebindKeymap \"${1:**callback function**}\"$0" ]
},

"tui::rebindKeymap#withdoc": {
  "prefix": "tui::rebindKeymap#withdoc",
  "description": "Rebinds all special keys to call a given callback function...",
  "scope": "",
  "body": [ "# ## tui::rebindKeymap\n# \n# Rebinds all special keys to call a given callback function.\n# See @tui::testWaitForKeyPress for an implementation example.\n# \n# This allows to use the `-e` option with the read command and receive events for special key press.\n# \n# Key binding is a mess because binding is based on the sequence of characters that gets\n# generated by the terminal when a key is pressed and this is not standard across all terminals.\n# We do our best here to cover most cases but it is by no mean perfect.\n# A good base documentation was <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>.\n# \n# This function should be called before using tui::waitForKeyPress.\n# \n# You can call `tui::restoreBindings` to restore the default bindings. However, this is not\n# necessary as the bindings are local to the script.\n# \n# - \\$1: **callback function** _as string_:\n#       The function name to call when a special key is pressed.\n# \ntui::rebindKeymap \"${1:**callback function**}\"$0" ]
},

"tui::rerouteLogs": {
  "prefix": "tui::rerouteLogs",
  "description": "Reroute the logs to a temporary file...",
  "scope": "",
  "body": [ "tui::rerouteLogs$0" ]
},

"tui::rerouteLogs#withdoc": {
  "prefix": "tui::rerouteLogs#withdoc",
  "description": "Reroute the logs to a temporary file...",
  "scope": "",
  "body": [ "# ## tui::rerouteLogs\n# \n# Reroute the logs to a temporary file.\n# The logs will be displayed at the end of the interactive session.\n# \n# ```bash\n# tui::rerouteLogs\n# ```\n# \ntui::rerouteLogs$0" ]
},

"tui::restoreBindings": {
  "prefix": "tui::restoreBindings",
  "description": "Reset the key bindings to the default ones...",
  "scope": "",
  "body": [ "tui::restoreBindings$0" ]
},

"tui::restoreBindings#withdoc": {
  "prefix": "tui::restoreBindings#withdoc",
  "description": "Reset the key bindings to the default ones...",
  "scope": "",
  "body": [ "# ## tui::restoreBindings\n# \n# Reset the key bindings to the default ones.\n# \n# ```bash\n# tui::restoreBindings\n# ```\n# \ntui::restoreBindings$0" ]
},

"tui::restoreInterruptTrap": {
  "prefix": "tui::restoreInterruptTrap",
  "description": "Restore the original trap for the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "tui::restoreInterruptTrap$0" ]
},

"tui::restoreInterruptTrap#withdoc": {
  "prefix": "tui::restoreInterruptTrap#withdoc",
  "description": "Restore the original trap for the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "# ## tui::restoreInterruptTrap\n# \n# Restore the original trap for the interrupt signal (SIGINT).\n# To be called after tui::setInterruptTrap.\n# \n# ```bash\n# tui::restoreInterruptTrap\n# ```\n# \ntui::restoreInterruptTrap$0" ]
},

"tui::restoreLogs": {
  "prefix": "tui::restoreLogs",
  "description": "Restore the logs to their original state...",
  "scope": "",
  "body": [ "tui::restoreLogs$0" ]
},

"tui::restoreLogs#withdoc": {
  "prefix": "tui::restoreLogs#withdoc",
  "description": "Restore the logs to their original state...",
  "scope": "",
  "body": [ "# ## tui::restoreLogs\n# \n# Restore the logs to their original state.\n# Should be called after `tui::rerouteLogs` and at the end of an interactive session.\n# \n# ```bash\n# tui::restoreLogs\n# ```\n# \ntui::restoreLogs$0" ]
},

"tui::restoreTerminalOptions": {
  "prefix": "tui::restoreTerminalOptions",
  "description": "Restore the terminal options to their original state...",
  "scope": "",
  "body": [ "tui::restoreTerminalOptions \"${1:force}\"$0" ]
},

"tui::restoreTerminalOptions#withdoc": {
  "prefix": "tui::restoreTerminalOptions#withdoc",
  "description": "Restore the terminal options to their original state...",
  "scope": "",
  "body": [ "# ## tui::restoreTerminalOptions\n# \n# Restore the terminal options to their original state.\n# Should be called after `tui::setTerminalOptions`.\n# \n# - \\$1: force _as bool_:\n#       (optional) force the restoration of the stty configuration\n#       stty state will not be restored if\n#       (defaults to false)\n# \n# ```bash\n# tui::restoreTerminalOptions\n# ```\n# \ntui::restoreTerminalOptions \"${1:force}\"$0" ]
},

"tui::setInterruptTrap": {
  "prefix": "tui::setInterruptTrap",
  "description": "Set a trap to catch the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "tui::setInterruptTrap$0" ]
},

"tui::setInterruptTrap#withdoc": {
  "prefix": "tui::setInterruptTrap#withdoc",
  "description": "Set a trap to catch the interrupt signal (SIGINT)...",
  "scope": "",
  "body": [ "# ## tui::setInterruptTrap\n# \n# Set a trap to catch the interrupt signal (SIGINT).\n# When the user presses Ctrl+C, the GLOBAL_SESSION_INTERRUPTED variable will be set to true.\n# \n# ```bash\n# tui::setInterruptTrap\n# ```\n# \ntui::setInterruptTrap$0" ]
},

"tui::setTerminalOptions": {
  "prefix": "tui::setTerminalOptions",
  "description": "Set the terminal options to enable a satisfying and consistent behavior for the GNU readline library...",
  "scope": "",
  "body": [ "tui::setTerminalOptions$0" ]
},

"tui::setTerminalOptions#withdoc": {
  "prefix": "tui::setTerminalOptions#withdoc",
  "description": "Set the terminal options to enable a satisfying and consistent behavior for the GNU readline library...",
  "scope": "",
  "body": [ "# ## tui::setTerminalOptions\n# \n# Set the terminal options to enable a satisfying and consistent behavior\n# for the GNU readline library.\n# Disable the echo of the terminal, no longer display the characters typed by the user.\n# \n# ```bash\n# tui::setTerminalOptions\n# ```\n# \ntui::setTerminalOptions$0" ]
},

"tui::switchBackFromFullScreen": {
  "prefix": "tui::switchBackFromFullScreen",
  "description": "Call this function to switch back from the full screen mode...",
  "scope": "",
  "body": [ "tui::switchBackFromFullScreen$0" ]
},

"tui::switchBackFromFullScreen#withdoc": {
  "prefix": "tui::switchBackFromFullScreen#withdoc",
  "description": "Call this function to switch back from the full screen mode...",
  "scope": "",
  "body": [ "# ## tui::switchBackFromFullScreen\n# \n# Call this function to switch back from the full screen mode.\n# \n# - This function will restore the terminal state and show the cursor.\n# - It will also restore the key echoing.\n# \n# ```bash\n# tui::switchBackFromFullScreen\n# ```\n# \ntui::switchBackFromFullScreen$0" ]
},

"tui::switchToFullScreen": {
  "prefix": "tui::switchToFullScreen",
  "description": "Call this function to start an interactive session in full screen mode...",
  "scope": "",
  "body": [ "tui::switchToFullScreen$0" ]
},

"tui::switchToFullScreen#withdoc": {
  "prefix": "tui::switchToFullScreen#withdoc",
  "description": "Call this function to start an interactive session in full screen mode...",
  "scope": "",
  "body": [ "# ## tui::switchToFullScreen\n# \n# Call this function to start an interactive session in full screen mode.\n# This function will switch to the alternate screen, hide the cursor and clear the screen.\n# \n# You should call tui::switchBackFromFullScreen at the end of the interactive session.\n# \n# ```bash\n# tui::switchToFullScreen\n# ```\n# \ntui::switchToFullScreen$0" ]
},

"tui::testWaitForChar": {
  "prefix": "tui::testWaitForChar",
  "description": "Wait for the user to send a character to stdin (i...",
  "scope": "",
  "body": [ "tui::testWaitForChar$0" ]
},

"tui::testWaitForChar#withdoc": {
  "prefix": "tui::testWaitForChar#withdoc",
  "description": "Wait for the user to send a character to stdin (i...",
  "scope": "",
  "body": [ "# ## tui::testWaitForChar\n# \n# Wait for the user to send a character to stdin (i.e. wait for a key press)\n# and prints the character that bash reads.\n# \n# Useful to test the `tui::waitForChar` function and see the char sequence we\n# get when pressing a key in a given terminal.\n# \n# See @tui::waitForChar for more information.\n# \n# ```bash\n# tui::testWaitForChar\n# ```\n# \ntui::testWaitForChar$0" ]
},

"tui::testWaitForKeyPress": {
  "prefix": "tui::testWaitForKeyPress",
  "description": "Wait for the user to press a key and prints it to the screen...",
  "scope": "",
  "body": [ "tui::testWaitForKeyPress$0" ]
},

"tui::testWaitForKeyPress#withdoc": {
  "prefix": "tui::testWaitForKeyPress#withdoc",
  "description": "Wait for the user to press a key and prints it to the screen...",
  "scope": "",
  "body": [ "# ## tui::testWaitForKeyPress\n# \n# Wait for the user to press a key and prints it to the screen.\n# This function is used to test the `tui::waitForKeyPress` function.\n# \n# See @tui::waitForKeyPress for more information.\n# \n# ```bash\n# tui::testWaitForKeyPress\n# ```\n# \ntui::testWaitForKeyPress$0" ]
},

"tui::waitForChar": {
  "prefix": "tui::waitForChar",
  "description": "Wait for a user input (single char)...",
  "scope": "",
  "body": [ "tui::waitForChar \"${1:**read parameters**}\"$0" ]
},

"tui::waitForChar#withdoc": {
  "prefix": "tui::waitForChar#withdoc",
  "description": "Wait for a user input (single char)...",
  "scope": "",
  "body": [ "# ## tui::waitForChar\n# \n# Wait for a user input (single char).\n# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).\n# \n# It uses the read builtin command. This will not detect all key combinations.\n# The output will depend on the terminal used and the character sequences it sends on each key press.\n# \n# Some special keys are translated into more readable strings:\n# UP, DOWN, RIGHT, LEFT, BACKSPACE, DEL, PAGE_UP, PAGE_DOWN, HOME, END, ESC, F1, ALT+?.\n# However, this is not at all exhaustive and will depend on the terminal used. Use `tui::waitForKeyPress`\n# if you need to listen to special keys.\n# \n# This simple implementation does not rely on GNU readline and does not require terminal options\n# to be set using `tui::setTerminalOptions`.\n# \n# \n# - \\$@: **read parameters** _as any_:\n#       additional parameters to pass to the read command\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a char was retrieved\n#   - 1 otherwise\n# - `LAST_KEY_PRESSED`: the last char (key) retrieved.\n# \n# ```bash\n# tui::waitForChar\n# tui::waitForChar -t 0.1\n# ```\n# \n# > <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>\n# \ntui::waitForChar \"${1:**read parameters**}\"$0" ]
},

"tui::waitForKeyPress": {
  "prefix": "tui::waitForKeyPress",
  "description": "Wait for a key press (single key)...",
  "scope": "",
  "body": [ "tui::waitForKeyPress \"${1:**read parameters**}\"$0" ]
},

"tui::waitForKeyPress#withdoc": {
  "prefix": "tui::waitForKeyPress#withdoc",
  "description": "Wait for a key press (single key)...",
  "scope": "",
  "body": [ "# ## tui::waitForKeyPress\n# \n# Wait for a key press (single key).\n# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).\n# \n# It uses the read builtin command with the option `-e` to use readline behind the scene.\n# This means we can detect more key combinations but all keys needs to be bound first...\n# Special keys (CTRL+, ALT+, F1-F12, arrows, etc.) are intercepted using binding.\n# \n# You must call `tui::rebindKeymap` and `tui::setTerminalOptions` before using this function.\n# \n# - \\$@: **read parameters** _as any_:\n#       additional parameters to pass to the read command\n# \n# Returns:\n# \n# - \\$?:\n#   - 0 if a key was pressed\n#   - 1 otherwise\n# - `LAST_KEY_PRESSED`: the key pressed.\n# \n# ```bash\n# tui::waitForKeyPress\n# tui::waitForKeyPress -t 0.1\n# ```\n# \n# > There are 2 issues when using readline in bash:\n# > 1. if the cursor is at the end of the screen, it will make the screen scroll\n# >    even when nothing is read... Make sure to not position the cursor at the end of the screen.\n# > 2. When read is done, it will print a new line in stderr. So we redirect stderr to null.\n# >    This means that if you print something in a readline bound function, do not print to stderr or you will get nothing !\n# \ntui::waitForKeyPress \"${1:**read parameters**}\"$0" ]
},

"version::bump": {
  "prefix": "version::bump",
  "description": "This function allows to bump a semantic version formatted like: major...",
  "scope": "",
  "body": [ "version::bump \"${1:**version**}\" \"${2:**level**}\" \"${3:clear build and prerelease}\"$0" ]
},

"version::bump#withdoc": {
  "prefix": "version::bump#withdoc",
  "description": "This function allows to bump a semantic version formatted like: major...",
  "scope": "",
  "body": [ "# ## version::bump\n# \n# This function allows to bump a semantic version formatted like:\n# major.minor.patch-prerelease+build\n# \n# - \\$1: **version** _as string_:\n#       the version to bump\n# - \\$2: **level** _as string_:\n#       the level to bump (major, minor, patch)\n# - \\$3: clear build and prerelease _as bool_:\n#       (optional) clear the prerelease and build\n#       (defaults to true)\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the new version string\n# \n# ```bash\n# version::bump \"1.2.3-prerelease+build\" \"major\"\n# local newVersion=\"\\${RETURNED_VALUE}\"\n# ```\n# \nversion::bump \"${1:**version**}\" \"${2:**level**}\" \"${3:clear build and prerelease}\"$0" ]
},

"version::compare": {
  "prefix": "version::compare",
  "description": "This function allows to compare two semantic versions formatted like: major...",
  "scope": "",
  "body": [ "version::compare \"${1:**version1**}\" \"${2:**version2**}\"$0" ]
},

"version::compare#withdoc": {
  "prefix": "version::compare#withdoc",
  "description": "This function allows to compare two semantic versions formatted like: major...",
  "scope": "",
  "body": [ "# ## version::compare\n# \n# This function allows to compare two semantic versions formatted like:\n# major.minor.patch-prerelease+build\n# \n# - \\$1: **version1** _as string_:\n#       the first version to compare\n# - \\$2: **version2** _as string_:\n#       the second version to compare\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}:\n#   - 0 if the versions are equal,\n#   - 1 if version1 is greater,\n#   - -1 if version2 is greater\n# \n# ```bash\n# version::compare \"2.3.4-prerelease+build\" \"1.2.3-prerelease+build\"\n# local comparison=\"\\${RETURNED_VALUE}\"\n# ```\n# \n# > The prerelease and build are ignored in the comparison.\n# \nversion::compare \"${1:**version1**}\" \"${2:**version2**}\"$0" ]
},

"windows::addToPath": {
  "prefix": "windows::addToPath",
  "description": "Add the given path to the PATH environment variable on Windows (current user only)...",
  "scope": "",
  "body": [ "windows::addToPath \"${1:**path**}\"$0" ]
},

"windows::addToPath#withdoc": {
  "prefix": "windows::addToPath#withdoc",
  "description": "Add the given path to the PATH environment variable on Windows (current user only)...",
  "scope": "",
  "body": [ "# ## windows::addToPath\n# \n# Add the given path to the PATH environment variable on Windows (current user only).\n# \n# Will also export the PATH variable in the current bash.\n# \n# - \\$1: **path** _as string_:\n#       the path to add to the PATH environment variable.\n#       The path can be in unix format, it will be converted to windows format.\n# \n# ```bash\n# windows::addToPath \"/path/to/bin\"\n# ```\n# \n# > This function is only available on Windows, it uses `powershell` to directly modify the registry.\n# \nwindows::addToPath \"${1:**path**}\"$0" ]
},

"windows::convertPathFromUnix": {
  "prefix": "windows::convertPathFromUnix",
  "description": "Convert a unix path to a Windows path...",
  "scope": "",
  "body": [ "windows::convertPathFromUnix \"${1:**path**}\"$0" ]
},

"windows::convertPathFromUnix#withdoc": {
  "prefix": "windows::convertPathFromUnix#withdoc",
  "description": "Convert a unix path to a Windows path...",
  "scope": "",
  "body": [ "# ## windows::convertPathFromUnix\n# \n# Convert a unix path to a Windows path.\n# \n# - \\$1: **path** _as string_:\n#       the path to convert\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The Windows path.\n# \n# ```bash\n# windows::convertPathFromUnix \"/path/to/file\"\n# ```\n# \n# > Handles paths starting with `/mnt/x/` or `/x/`.\n# \nwindows::convertPathFromUnix \"${1:**path**}\"$0" ]
},

"windows::convertPathToUnix": {
  "prefix": "windows::convertPathToUnix",
  "description": "Convert a Windows path to a unix path...",
  "scope": "",
  "body": [ "windows::convertPathToUnix \"${1:**path**}\"$0" ]
},

"windows::convertPathToUnix#withdoc": {
  "prefix": "windows::convertPathToUnix#withdoc",
  "description": "Convert a Windows path to a unix path...",
  "scope": "",
  "body": [ "# ## windows::convertPathToUnix\n# \n# Convert a Windows path to a unix path.\n# \n# - \\$1: **path** _as string_:\n#       the path to convert\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The unix path.\n# \n# ```bash\n# windows::convertPathToUnix \"C:\\path\\to\\file\"\n# ```\n# \n# > Handles paths starting with `X:\\`.\n# \nwindows::convertPathToUnix \"${1:**path**}\"$0" ]
},

"windows::createLink": {
  "prefix": "windows::createLink",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "windows::createLink \"${1:**linked path**}\" \"${2:**link path**}\" \"${3:hard link}\" \"${4:force}\"$0" ]
},

"windows::createLink#withdoc": {
  "prefix": "windows::createLink#withdoc",
  "description": "Create a soft or hard link (original ← link)...",
  "scope": "",
  "body": [ "# ## windows::createLink\n# \n# Create a soft or hard link (original ← link).\n# \n# Reminder:\n# \n# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the\n#   form of an absolute or relative path.\n# - A hard link is a directory entry that associates a new pathname with an existing\n#   file (inode + data block) on a file system.\n# \n# This function allows to create a symbolic link on Windows as well as on Unix.\n# \n# - \\$1: **linked path** _as string_:\n#       the path to link to (the original file)\n# - \\$2: **link path** _as string_:\n#       the path where to create the link\n# - \\$3: hard link _as bool_:\n#       (optional) true to create a hard link, false to create a symbolic link\n#       (defaults to false)\n# - \\$4: force _as bool_:\n#       (optional) true to overwrite the link or file if it already exists.\n#       Otherwise, the function will not on an existing link not pointing to the\n#       target path.\n#       (defaults to true)\n# \n# ```bash\n# windows::createLink \"/path/to/link\" \"/path/to/linked\"\n# windows::createLink \"/path/to/link\" \"/path/to/linked\" true\n# ```\n# \n# > On Windows, the function uses `powershell` (and optionally ls to check the existing link).\n# > If you have the windows \"developer mode\" enabled + MSYS=winsymlinks:nativestrict,\n# > then it uses the ln command.\n# \nwindows::createLink \"${1:**linked path**}\" \"${2:**link path**}\" \"${3:hard link}\" \"${4:force}\"$0" ]
},

"windows::createTempDirectory": {
  "prefix": "windows::createTempDirectory",
  "description": "Create a temporary directory on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "windows::createTempDirectory$0" ]
},

"windows::createTempDirectory#withdoc": {
  "prefix": "windows::createTempDirectory#withdoc",
  "description": "Create a temporary directory on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "# ## windows::createTempDirectory\n# \n# Create a temporary directory on Windows and return the path both for Windows and Unix.\n# \n# This is useful for creating temporary directories that can be used in both Windows and Unix.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The Windows path.\n# - \\${RETURNED_VALUE2}: The Unix path.\n# \n# ```bash\n# windows::createTempDirectory\n# ```\n# \n# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nwindows::createTempDirectory$0" ]
},

"windows::createTempFile": {
  "prefix": "windows::createTempFile",
  "description": "Create a temporary file on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "windows::createTempFile$0" ]
},

"windows::createTempFile#withdoc": {
  "prefix": "windows::createTempFile#withdoc",
  "description": "Create a temporary file on Windows and return the path both for Windows and Unix...",
  "scope": "",
  "body": [ "# ## windows::createTempFile\n# \n# Create a temporary file on Windows and return the path both for Windows and Unix.\n# \n# This is useful for creating temporary files that can be used in both Windows and Unix.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: The Windows path.\n# - \\${RETURNED_VALUE2}: The Unix path.\n# \n# ```bash\n# windows::createTempFile\n# ```\n# \n# > Files created this way are automatically cleaned up by the fs::cleanTempFiles\n# > function when valet ends.\n# \nwindows::createTempFile$0" ]
},

"windows::endPs1Batch": {
  "prefix": "windows::endPs1Batch",
  "description": "This function will run all the commands that were batched with `windows::startPs1Batch`...",
  "scope": "",
  "body": [ "windows::endPs1Batch$0" ]
},

"windows::endPs1Batch#withdoc": {
  "prefix": "windows::endPs1Batch#withdoc",
  "description": "This function will run all the commands that were batched with `windows::startPs1Batch`...",
  "scope": "",
  "body": [ "# ## windows::endPs1Batch\n# \n# This function will run all the commands that were batched with `windows::startPs1Batch`.\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# windows::startPs1Batch\n# windows::runPs1 \"Write-Host \\\"Hello\\\"\"\n# windows::runPs1 \"Write-Host \\\"World\\\"\"\n# windows::endPs1Batch\n# ```\n# \nwindows::endPs1Batch$0" ]
},

"windows::getEnvVar": {
  "prefix": "windows::getEnvVar",
  "description": "Get the value of an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "windows::getEnvVar \"${1:**variable name**}\"$0" ]
},

"windows::getEnvVar#withdoc": {
  "prefix": "windows::getEnvVar#withdoc",
  "description": "Get the value of an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "# ## windows::getEnvVar\n# \n# Get the value of an environment variable for the current user on Windows.\n# \n# - \\$1: **variable name** _as string_:\n#       the name of the environment variable to get.\n# \n# Returns:\n# \n# - \\${RETURNED_VALUE}: the value of the environment variable.\n# \n# ```bash\n# windows::getEnvVar \"MY_VAR\"\n# echo \"\\${RETURNED_VALUE}\"\n# ```\n# \nwindows::getEnvVar \"${1:**variable name**}\"$0" ]
},

"windows::runPs1": {
  "prefix": "windows::runPs1",
  "description": "Runs a PowerShell command...",
  "scope": "",
  "body": [ "windows::runPs1 \"${1:**command**}\" \"${2:run as administrator}\"$0" ]
},

"windows::runPs1#withdoc": {
  "prefix": "windows::runPs1#withdoc",
  "description": "Runs a PowerShell command...",
  "scope": "",
  "body": [ "# ## windows::runPs1\n# \n# Runs a PowerShell command.\n# This is mostly useful on Windows.\n# \n# - \\$1: **command** _as string_:\n#       the command to run.\n# - \\$2: run as administrator _as bool_:\n#       (optional) whether to run the command as administrator.\n#       (defaults to false).\n# \n# Returns:\n# \n# - \\$?\n#   - 0 if the command was successful\n#   - 1 otherwise.\n# - \\${RETURNED_VALUE}: The content of stdout.\n# - \\${RETURNED_VALUE2}: The content of stderr.\n# \n# ```bash\n# windows::runPs1 \"Write-Host \\\"Press any key:\\\"; Write-Host -Object ('The key that was pressed was: {0}' -f [System.Console]::ReadKey().Key.ToString());\"\n# ```\n# \nwindows::runPs1 \"${1:**command**}\" \"${2:run as administrator}\"$0" ]
},

"windows::setEnvVar": {
  "prefix": "windows::setEnvVar",
  "description": "Set an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "windows::setEnvVar \"${1:**variable name**}\" \"${2:**variable value**}\"$0" ]
},

"windows::setEnvVar#withdoc": {
  "prefix": "windows::setEnvVar#withdoc",
  "description": "Set an environment variable for the current user on Windows...",
  "scope": "",
  "body": [ "# ## windows::setEnvVar\n# \n# Set an environment variable for the current user on Windows.\n# \n# - \\$1: **variable name** _as string_:\n#       The name of the environment variable to set.\n# - \\$2: **variable value** _as string_:\n#       The value of the environment variable to set.\n#       An empty string will unset the variable.\n# \n# ```bash\n# windows::setEnvVar \"MY_VAR\" \"my_value\"\n# ```\n# \n# > This function is only available on Windows, it uses `powershell` to directly modify the registry.\n# \nwindows::setEnvVar \"${1:**variable name**}\" \"${2:**variable value**}\"$0" ]
},

"windows::startPs1Batch": {
  "prefix": "windows::startPs1Batch",
  "description": "After running this function, all commands that should be executed by `windows::runPs1` will be added to a batch that will only be played when `windows::endPs1Batch` is called...",
  "scope": "",
  "body": [ "windows::startPs1Batch$0" ]
},

"windows::startPs1Batch#withdoc": {
  "prefix": "windows::startPs1Batch#withdoc",
  "description": "After running this function, all commands that should be executed by `windows::runPs1` will be added to a batch that will only be played when `windows::endPs1Batch` is called...",
  "scope": "",
  "body": [ "# ## windows::startPs1Batch\n# \n# After running this function, all commands that should be executed by\n# `windows::runPs1` will be added to a batch that will only be played\n# when `windows::endPs1Batch` is called.\n# \n# This is a convenient way to run multiple commands in a single PowerShell session.\n# It makes up for the fact that running a new PowerShell session for each command is slow.\n# \n# ```bash\n# windows::startPs1Batch\n# windows::runPs1 \"Write-Host \\\"Hello\\\"\"\n# windows::runPs1 \"Write-Host \\\"World\\\"\"\n# windows::endPs1Batch\n# ```\n# \nwindows::startPs1Batch$0" ]
},
	"[[:digit:]]": {
		"prefix": "[[:digit:]]",
		"description": "Regex digits, similar to [0-9]",
		"scope": "",
		"body": [
			"[[:digit:]]"
		]
	},
	"[[:xdigit:]]": {
		"prefix": "[[:xdigit:]]",
		"description": "Regex hexadecimal digits, similar to [0-9A-Fa-f]",
		"scope": "",
		"body": [
			"[[:xdigit:]]"
		]
	},
	"[[:punct:]]": {
		"prefix": "[[:punct:]]",
		"description": "Regex punctuation, similar to [.,!?:…]",
		"scope": "",
		"body": [
			"[[:punct:]]"
		]
	},
	"[[:blank:]]": {
		"prefix": "[[:blank:]]",
		"description": "Regex space and TAB characters only, similar to [ \\t]",
		"scope": "",
		"body": [
			"[[:blank:]]"
		]
	},
	"[[:space:]]": {
		"prefix": "[[:space:]]",
		"description": "Regex blank (whitespace) characters, similar to [ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:space:]]"
		]
	},
	"[[:cntrl:]]": {
		"prefix": "[[:cntrl:]]",
		"description": "Regex control characters",
		"scope": "",
		"body": [
			"[[:cntrl:]]"
		]
	},
	"[[:graph:]]": {
		"prefix": "[[:graph:]]",
		"description": "Regex printed characters, similar to [^\\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:graph:]]"
		]
	},
	"[[:print:]]": {
		"prefix": "[[:print:]]",
		"description": "Regex printed characters and space, similar to [^ \\t\\n\\r\\f\\v]",
		"scope": "",
		"body": [
			"[[:print:]]"
		]
	},
	"[[:alnum:]]": {
		"prefix": "[[:alnum:]]",
		"description": "Regex digits, upper- and lowercase letters, similar to [[:alpha:][:digit:]]",
		"scope": "",
		"body": [
			"[[:alnum:]]$0"
		]
	},
	"[[:alpha:]]": {
		"prefix": "[[:alpha:]]",
		"description": "Regex upper- and lowercase letters, similar to [[:upper:][:lower:]]",
		"scope": "",
		"body": [
			"[[:alpha:]]$0"
		]
	},
	"[[:lower:]]": {
		"prefix": "[[:lower:]]",
		"description": "Regex lowercase letters, similar to [a-z]",
		"scope": "",
		"body": [
			"[[:lower:]]$0"
		]
	},
	"[[:upper:]]": {
		"prefix": [
			"[[:upper:]]",
			"regex [[:upper:]]"
		],
		"description": "Regex uppercase letters , similar to [A-Z]",
		"scope": "",
		"body": [
			"[[:upper:]]$0"
		]
	},
	"set bash options": {
		"prefix": "set bash options",
		"description": "Set good bash options",
		"scope": "",
		"body": [
			"set -Eeu -o pipefail$0"
		]
	},
	"new command alt": {
		"prefix": "new command alt",
		"description": "A new command alternative definition for Valet",
		"scope": "",
		"body": [
			"##<<VALET_COMMAND",
			"# command: $1",
			"# function: $2",
			"# shortDescription: A short sentence.",
			"# description: |-",
			"#   A long description that can use ⌜quotes⌝.",
			"# sudo: false",
			"# hideInMenu: false",
			"# arguments:",
			"# - name: firstArg",
			"#   description: |-",
			"#     First argument.",
			"# - name: more...",
			"#   description: |-",
			"#     Will be an an array of strings.",
			"# options:",
			"# - name: -o, --option1",
			"#   description: |-",
			"#     First option.",
			"#   noEnvironmentVariable: true",
			"# - name: -2, --this-is-option2 <level>",
			"#   description: |-",
			"#     An option with a value.",
			"#   noEnvironmentVariable: false",
			"# examples:",
			"# - name: command -o -2 value1 arg1 more1 more2",
			"#   description: |-",
			"#     Call command with option1, option2 and some arguments.",
			"##VALET_COMMAND",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${RETURNED_VALUE}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"new command": {
		"prefix": "new command",
		"description": "A new command definition for Valet",
		"scope": "",
		"body": [
			": \"---",
			"command: $1",
			"function: $2",
			"shortDescription: A short sentence.",
			"description: |-",
			"  A long description that can use ⌜quotes⌝.",
			"sudo: false",
			"hideInMenu: false",
			"arguments:",
			"- name: firstArg",
			"  description: |-",
			"    First argument.",
			"- name: more...",
			"  description: |-",
			"    Will be an an array of strings.",
			"options:",
			"- name: -o, --option1",
			"  description: |-",
			"    First option.",
			"  noEnvironmentVariable: true",
			"- name: -2, --this-is-option2 <level>",
			"  description: |-",
			"    An option with a value.",
			"  noEnvironmentVariable: false",
			"examples:",
			"- name: command -o -2 value1 arg1 more1 more2",
			"  description: |-",
			"    Call command with option1, option2 and some arguments.",
			": \"---",
			"function $2() {",
			"  command::parseArguments \"$@\" && eval \"${RETURNED_VALUE}\"",
			"  command::checkParsedResults \"${help:-}\" \"${commandArgumentsErrors:-}\"",
			"  $0",
			"}"
		]
	},
	"comment section": {
		"prefix": "comment section",
		"description": "",
		"scope": "",
		"body": [
			"#===============================================================",
			"# >>> $1",
			"#===============================================================",
			"$0"
		]
	},
	"quote": {
		"prefix": "quote",
		"description": "",
		"scope": "",
		"body": [
			"⌜$1⌝$0"
		]
	},
	"read file to array and loop": {
		"prefix": "read file to array and loop",
		"description": "Read file to array and loop",
		"scope": "",
		"body": [
			"readarray -d $'\\n' fileLines < file",
			"for myString in \"${fileLines[@]}\"; do",
			"  # the difference is also that myString will end with the delimiter, so you might want to remove it",
			"  # Alternatively, you can run readarray with -t but in that case you will not have an array element for empty lines",
			"  echo \"${myString%$'\\n'}\"",
			"done"
		]
	},
	"loop through lines of string": {
		"prefix": "loop through lines of string",
		"description": "Loop through each line of a string (keep empty lines)",
		"scope": "",
		"body": [
			"while read -r line; do",
			"  echo \"${line}\"",
			"done <<< \"${var1}\""
		]
	},
	"loop through lines of string (for)": {
		"prefix": "loop through lines of string (for)",
		"description": "Loop through each line of a string (does not keep empty lines)",
		"scope": "",
		"body": [
			"local IFS=$'\\n'",
			"for line in ${var1}; do",
			"  echo \"${line}\"",
			"done"
		]
	},
	"read file loop on all lines": {
		"prefix": "read file loop on all lines",
		"description": "Read a file, line by line",
		"scope": "",
		"body": [
			"while read -r line || [[ -n ${line:-} ]]; do",
			"  echo \"${line}\"",
			"done < file"
		]
	},
	"source": {
		"prefix": "source",
		"description": "Source a file for Valet, add the necessary comment for shellcheck.",
		"scope": "",
		"body": [
			"# shellcheck source=../lib-valet",
			"source $1",
			"$0",
			""
		]
	},
	"RETURNED_VALUE": {
		"prefix": "RETURNED_VALUE",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_VALUE$0"
		]
	},
	"RETURNED_VALUE2": {
		"prefix": "RETURNED_VALUE2",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_VALUE2$0"
		]
	},
	"RETURNED_VALUE3": {
		"prefix": "RETURNED_VALUE3",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_VALUE3$0"
		]
	},
	"RETURNED_ARRAY": {
		"prefix": "RETURNED_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_ARRAY$0"
		]
	},
	"RETURNED_ARRAY2": {
		"prefix": "RETURNED_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_ARRAY2$0"
		]
	},
	"RETURNED_ARRAY3": {
		"prefix": "RETURNED_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_ARRAY3$0"
		]
	},
	"RETURNED_ASSOCIATIVE_ARRAY": {
		"prefix": "RETURNED_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"RETURNED_ASSOCIATIVE_ARRAY$0"
		]
	},
	"IFS": {
		"prefix": "IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"IFS$0"
		]
	},
	"$GLOBAL_COLUMNS": {
		"prefix": "$GLOBAL_COLUMNS",
		"description": "The current number or columns displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_COLUMNS}$0"
		]
	},
	"$GLOBAL_LINES": {
		"prefix": "$GLOBAL_LINES",
		"description": "The current number or lines displayed by the terminal, refresh by interactive::getTerminalSize on resize.",
		"scope": "",
		"body": [
			"\\${GLOBAL_LINES}$0"
		]
	},
	"$GLOBAL_CURSOR_LINE": {
		"prefix": "$GLOBAL_CURSOR_LINE",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_LINE}$0"
		]
	},
	"$GLOBAL_CURSOR_COLUMN": {
		"prefix": "$GLOBAL_CURSOR_COLUMN",
		"description": "The position of the cursor. You need to refresh it by calling interactive::getCursorPosition.",
		"scope": "",
		"body": [
			"\\${GLOBAL_CURSOR_COLUMN}$0"
		]
	},
	"$GLOBAL_TEST_TEMP_FILE": {
		"prefix": "$GLOBAL_TEST_TEMP_FILE",
		"description": "The path to a temporary file that can be used during tests.",
		"scope": "",
		"body": [
			"\\${GLOBAL_TEST_TEMP_FILE}$0"
		]
	},
	"$GLOBAL_SCREEN_REDRAW_REQUIRED": {
		"prefix": "$GLOBAL_SCREEN_REDRAW_REQUIRED",
		"description": "Set to true when the terminal size changes, set it to false when you handle this event.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SCREEN_REDRAW_REQUIRED}$0"
		]
	},
	"$GLOBAL_SESSION_INTERRUPTED": {
		"prefix": "$GLOBAL_SESSION_INTERRUPTED",
		"description": "Set to true when the user presses CTRL+C during an interactive experience.",
		"scope": "",
		"body": [
			"\\${GLOBAL_SESSION_INTERRUPTED}$0"
		]
	},
	"$LAST_KEY_PRESSED": {
		"prefix": "$LAST_KEY_PRESSED",
		"description": "",
		"scope": "",
		"body": [
			"\\${LAST_KEY_PRESSED}$0"
		]
	},
	"$RETURNED_VALUE": {
		"prefix": "$RETURNED_VALUE",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_VALUE}$0"
		]
	},
	"$RETURNED_VALUE2": {
		"prefix": "$RETURNED_VALUE2",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_VALUE2}$0"
		]
	},
	"$RETURNED_VALUE3": {
		"prefix": "$RETURNED_VALUE3",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_VALUE3}$0"
		]
	},
	"$RETURNED_ARRAY": {
		"prefix": "$RETURNED_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_ARRAY}$0"
		]
	},
	"$RETURNED_ARRAY2": {
		"prefix": "$RETURNED_ARRAY2",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_ARRAY2}$0"
		]
	},
	"$RETURNED_ARRAY3": {
		"prefix": "$RETURNED_ARRAY3",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_ARRAY3}$0"
		]
	},
	"$RETURNED_ASSOCIATIVE_ARRAY": {
		"prefix": "$RETURNED_ASSOCIATIVE_ARRAY",
		"description": "",
		"scope": "",
		"body": [
			"\\${RETURNED_ASSOCIATIVE_ARRAY}$0"
		]
	},
	"$BASHOPTS": {
		"prefix": "$BASHOPTS",
		"body": [
			"\\${BASHOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -s option to the shopt builtin command (see The Shopt Builtin). The options appearing in BASHOPTS are those reported as ‘on’ by ‘shopt’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$BASHPID": {
		"prefix": "$BASHPID",
		"body": [
			"\\${BASHPID}$0"
		],
		"scope": "",
		"description": "Expands to the process ID of the current Bash process. This differs from $$ under certain circumstances, such as subshells that do not require Bash to be re-initialized. Assignments to BASHPID have no effect. If BASHPID is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ALIASES": {
		"prefix": "$BASH_ALIASES",
		"body": [
			"\\${BASH_ALIASES}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal list of aliases as maintained by the alias builtin. (see Bourne Shell Builtins). Elements added to this array appear in the alias list; however, unsetting array elements currently does not cause aliases to be removed from the alias list. If BASH_ALIASES is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_ARGC": {
		"prefix": "$BASH_ARGC",
		"body": [
			"\\${BASH_ARGC}$0"
		],
		"scope": "",
		"description": "An array variable whose values are the number of parameters in each frame of the current bash execution call stack. The number of parameters to the current subroutine (shell function or script executed with . or source) is at the top of the stack. When a subroutine is executed, the number of parameters passed is pushed onto BASH_ARGC. The shell sets BASH_ARGC only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV": {
		"prefix": "$BASH_ARGV",
		"body": [
			"\\${BASH_ARGV}$0"
		],
		"scope": "",
		"description": "An array variable containing all of the parameters in the current bash execution call stack. The final parameter of the last subroutine call is at the top of the stack; the first parameter of the initial call is at the bottom. When a subroutine is executed, the parameters supplied are pushed onto BASH_ARGV. The shell sets BASH_ARGV only when in extended debugging mode (see The Shopt Builtin for a description of the extdebug option to the shopt builtin). Setting extdebug after the shell has started to execute a script, or referencing this variable when extdebug is not set, may result in inconsistent values."
	},
	"$BASH_ARGV0": {
		"prefix": "$BASH_ARGV0",
		"body": [
			"\\${BASH_ARGV0}$0"
		],
		"scope": "",
		"description": "When referenced, this variable expands to the name of the shell or shell script (identical to $0; See Special Parameters, for the description of special parameter 0). Assignment to BASH_ARGV0 causes the value assigned to also be assigned to $0. If BASH_ARGV0 is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_CMDS": {
		"prefix": "$BASH_CMDS",
		"body": [
			"\\${BASH_CMDS}$0"
		],
		"scope": "",
		"description": "An associative array variable whose members correspond to the internal hash table of commands as maintained by the hash builtin (see Bourne Shell Builtins). Elements added to this array appear in the hash table; however, unsetting array elements currently does not cause command names to be removed from the hash table. If BASH_CMDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMMAND": {
		"prefix": "$BASH_COMMAND",
		"body": [
			"\\${BASH_COMMAND}$0"
		],
		"scope": "",
		"description": "The command currently being executed or about to be executed, unless the shell is executing a command as the result of a trap, in which case it is the command executing at the time of the trap. If BASH_COMMAND is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_COMPAT": {
		"prefix": "$BASH_COMPAT",
		"body": [
			"\\${BASH_COMPAT}$0"
		],
		"scope": "",
		"description": "The value is used to set the shell’s compatibility level. See Shell Compatibility Mode, for a description of the various compatibility levels and their effects. The value may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the desired compatibility level. If BASH_COMPAT is unset or set to the empty string, the compatibility level is set to the default for the current version. If BASH_COMPAT is set to a value that is not one of the valid compatibility levels, the shell prints an error message and sets the compatibility level to the default for the current version. The valid values correspond to the compatibility levels described below (see Shell Compatibility Mode). For example, 4.2 and 42 are valid values that correspond to the compat42 shopt option and set the compatibility level to 42. The current version is also a valid value."
	},
	"$BASH_ENV": {
		"prefix": "$BASH_ENV",
		"body": [
			"\\${BASH_ENV}$0"
		],
		"scope": "",
		"description": "If this variable is set when Bash is invoked to execute a shell script, its value is expanded and used as the name of a startup file to read before executing the script. See Bash Startup Files."
	},
	"$BASH_EXECUTION_STRING": {
		"prefix": "$BASH_EXECUTION_STRING",
		"body": [
			"\\${BASH_EXECUTION_STRING}$0"
		],
		"scope": "",
		"description": "The command argument to the -c invocation option."
	},
	"$BASH_LINENO": {
		"prefix": "$BASH_LINENO",
		"body": [
			"\\${BASH_LINENO}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the line numbers in source files where each corresponding member of FUNCNAME was invoked. ${BASH_LINENO[$i]} is the line number in the source file (${BASH_SOURCE[$i+1]}) where ${FUNCNAME[$i]} was called (or ${BASH_LINENO[$i-1]} if referenced within another shell function). Use LINENO to obtain the current line number."
	},
	"$BASH_LOADABLES_PATH": {
		"prefix": "$BASH_LOADABLES_PATH",
		"body": [
			"\\${BASH_LOADABLES_PATH}$0"
		],
		"scope": "",
		"description": "A colon-separated list of directories in which the shell looks for dynamically loadable builtins specified by the enable command."
	},
	"$BASH_REMATCH": {
		"prefix": "$BASH_REMATCH",
		"body": [
			"\\${BASH_REMATCH}$0"
		],
		"scope": "",
		"description": "An array variable whose members are assigned by the ‘=~’ binary operator to the [[ conditional command (see Conditional Constructs). The element with index 0 is the portion of the string matching the entire regular expression. The element with index n is the portion of the string matching the nth parenthesized subexpression."
	},
	"$BASH_SOURCE": {
		"prefix": "$BASH_SOURCE",
		"body": [
			"\\${BASH_SOURCE}$0"
		],
		"scope": "",
		"description": "An array variable whose members are the source filenames where the corresponding shell function names in the FUNCNAME array variable are defined. The shell function ${FUNCNAME[$i]} is defined in the file ${BASH_SOURCE[$i]} and called from ${BASH_SOURCE[$i+1]}"
	},
	"$BASH_SUBSHELL": {
		"prefix": "$BASH_SUBSHELL",
		"body": [
			"\\${BASH_SUBSHELL}$0"
		],
		"scope": "",
		"description": "Incremented by one within each subshell or subshell environment when the shell begins executing in that environment. The initial value is 0. If BASH_SUBSHELL is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$BASH_VERSINFO": {
		"prefix": "$BASH_VERSINFO",
		"body": [
			"\\${BASH_VERSINFO}$0"
		],
		"scope": "",
		"description": "A readonly array variable (see Arrays) whose members hold version information for this instance of Bash. The values assigned to the array members are as follows:"
	},
	"$BASH_VERSINFO[0]": {
		"prefix": "$BASH_VERSINFO[0]",
		"body": [
			"\\${BASH_VERSINFO[0]}$0"
		],
		"scope": "",
		"description": "The major version number (the release)."
	},
	"$BASH_VERSINFO[1]": {
		"prefix": "$BASH_VERSINFO[1]",
		"body": [
			"\\${BASH_VERSINFO[1]}$0"
		],
		"scope": "",
		"description": "The minor version number (the version)."
	},
	"$BASH_VERSINFO[2]": {
		"prefix": "$BASH_VERSINFO[2]",
		"body": [
			"\\${BASH_VERSINFO[2]}$0"
		],
		"scope": "",
		"description": "The patch level."
	},
	"$BASH_VERSINFO[3]": {
		"prefix": "$BASH_VERSINFO[3]",
		"body": [
			"\\${BASH_VERSINFO[3]}$0"
		],
		"scope": "",
		"description": "The build version."
	},
	"$BASH_VERSINFO[4]": {
		"prefix": "$BASH_VERSINFO[4]",
		"body": [
			"\\${BASH_VERSINFO[4]}$0"
		],
		"scope": "",
		"description": "The release status (e.g., beta1)."
	},
	"$BASH_VERSINFO[5]": {
		"prefix": "$BASH_VERSINFO[5]",
		"body": [
			"\\${BASH_VERSINFO[5]}$0"
		],
		"scope": "",
		"description": "The value of MACHTYPE. "
	},
	"$BASH_VERSION": {
		"prefix": "$BASH_VERSION",
		"body": [
			"\\${BASH_VERSION}$0"
		],
		"scope": "",
		"description": "The version number of the current instance of Bash."
	},
	"$BASH_XTRACEFD": {
		"prefix": "$BASH_XTRACEFD",
		"body": [
			"\\${BASH_XTRACEFD}$0"
		],
		"scope": "",
		"description": "If set to an integer corresponding to a valid file descriptor, Bash will write the trace output generated when ‘set -x’ is enabled to that file descriptor. This allows tracing output to be separated from diagnostic and error messages. The file descriptor is closed when BASH_XTRACEFD is unset or assigned a new value. Unsetting BASH_XTRACEFD or assigning it the empty string causes the trace output to be sent to the standard error. Note that setting BASH_XTRACEFD to 2 (the standard error file descriptor) and then unsetting it will result in the standard error being closed."
	},
	"$CHILD_MAX": {
		"prefix": "$CHILD_MAX",
		"body": [
			"\\${CHILD_MAX}$0"
		],
		"scope": "",
		"description": "Set the number of exited child status values for the shell to remember. Bash will not allow this value to be decreased below a POSIX-mandated minimum, and there is a maximum value (currently 8192) that this may not exceed. The minimum value is system-dependent."
	},
	"$COLUMNS": {
		"prefix": "$COLUMNS",
		"body": [
			"\\${COLUMNS}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the terminal width when printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$COMP_CWORD": {
		"prefix": "$COMP_CWORD",
		"body": [
			"\\${COMP_CWORD}$0"
		],
		"scope": "",
		"description": "An index into ${COMP_WORDS} of the word containing the current cursor position. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_LINE": {
		"prefix": "$COMP_LINE",
		"body": [
			"\\${COMP_LINE}$0"
		],
		"scope": "",
		"description": "The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_POINT": {
		"prefix": "$COMP_POINT",
		"body": [
			"\\${COMP_POINT}$0"
		],
		"scope": "",
		"description": "The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to ${#COMP_LINE}. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_TYPE": {
		"prefix": "$COMP_TYPE",
		"body": [
			"\\${COMP_TYPE}$0"
		],
		"scope": "",
		"description": "Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called: TAB, for normal completion, ‘?’, for listing completions after successive tabs, ‘!’, for listing alternatives on partial word completion, ‘@’, to list completions if the word is not unmodified, or ‘%’, for menu completion. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMP_KEY": {
		"prefix": "$COMP_KEY",
		"body": [
			"\\${COMP_KEY}$0"
		],
		"scope": "",
		"description": "The key (or final key of a key sequence) used to invoke the current completion function."
	},
	"$COMP_WORDBREAKS": {
		"prefix": "$COMP_WORDBREAKS",
		"body": [
			"\\${COMP_WORDBREAKS}$0"
		],
		"scope": "",
		"description": "The set of characters that the Readline library treats as word separators when performing word completion. If COMP_WORDBREAKS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$COMP_WORDS": {
		"prefix": "$COMP_WORDS",
		"body": [
			"\\${COMP_WORDS}$0"
		],
		"scope": "",
		"description": "An array variable consisting of the individual words in the current command line. The line is split into words as Readline would split it, using COMP_WORDBREAKS as described above. This variable is available only in shell functions invoked by the programmable completion facilities (see Programmable Completion)."
	},
	"$COMPREPLY": {
		"prefix": "$COMPREPLY",
		"body": [
			"\\${COMPREPLY}$0"
		],
		"scope": "",
		"description": "An array variable from which Bash reads the possible completions generated by a shell function invoked by the programmable completion facility (see Programmable Completion). Each array element contains one possible completion."
	},
	"$COPROC": {
		"prefix": "$COPROC",
		"body": [
			"\\${COPROC}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the file descriptors for output from and input to an unnamed coprocess (see Coprocesses)."
	},
	"$DIRSTACK": {
		"prefix": "$DIRSTACK",
		"body": [
			"\\${DIRSTACK}$0"
		],
		"scope": "",
		"description": "An array variable containing the current contents of the directory stack. Directories appear in the stack in the order they are displayed by the dirs builtin. Assigning to members of this array variable may be used to modify directories already in the stack, but the pushd and popd builtins must be used to add and remove directories. Assignment to this variable will not change the current directory. If DIRSTACK is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EMACS": {
		"prefix": "$EMACS",
		"body": [
			"\\${EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts with value ‘t’, it assumes that the shell is running in an Emacs shell buffer and disables line editing."
	},
	"$ENV": {
		"prefix": "$ENV",
		"body": [
			"\\${ENV}$0"
		],
		"scope": "",
		"description": "Expanded and executed similarly to BASH_ENV (see Bash Startup Files) when an interactive shell is invoked in POSIX Mode (see Bash POSIX Mode)."
	},
	"$EPOCHREALTIME": {
		"prefix": "$EPOCHREALTIME",
		"body": [
			"\\${EPOCHREALTIME}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch as a floating point value with micro-second granularity (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHREALTIME are ignored. If EPOCHREALTIME is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EPOCHSECONDS": {
		"prefix": "$EPOCHSECONDS",
		"body": [
			"\\${EPOCHSECONDS}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to the number of seconds since the Unix Epoch (see the documentation for the C library function time for the definition of Epoch). Assignments to EPOCHSECONDS are ignored. If EPOCHSECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$EUID": {
		"prefix": "$EUID",
		"body": [
			"\\${EUID}$0"
		],
		"scope": "",
		"description": "The numeric effective user id of the current user. This variable is readonly."
	},
	"$EXECIGNORE": {
		"prefix": "$EXECIGNORE",
		"body": [
			"\\${EXECIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of shell patterns (see Pattern Matching) defining the list of filenames to be ignored by command search using PATH. Files whose full pathnames match one of these patterns are not considered executable files for the purposes of completion and command execution via PATH lookup. This does not affect the behavior of the [, test, and [[ commands. Full pathnames in the command hash table are not subject to EXECIGNORE. Use this variable to ignore shared library files that have the executable bit set, but are not executable files. The pattern matching honors the setting of the extglob shell option."
	},
	"$FCEDIT": {
		"prefix": "$FCEDIT",
		"body": [
			"\\${FCEDIT}$0"
		],
		"scope": "",
		"description": "The editor used as a default by the -e option to the fc builtin command."
	},
	"$FIGNORE": {
		"prefix": "$FIGNORE",
		"body": [
			"\\${FIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of suffixes to ignore when performing filename completion. A filename whose suffix matches one of the entries in FIGNORE is excluded from the list of matched filenames. A sample value is ‘.o:~’"
	},
	"$FUNCNAME": {
		"prefix": "$FUNCNAME",
		"body": [
			"\\${FUNCNAME}$0"
		],
		"scope": "",
		"description": "An array variable containing the names of all shell functions currently in the execution call stack. The element with index 0 is the name of any currently-executing shell function. The bottom-most element (the one with the highest index) is main. This variable exists only when a shell function is executing. Assignments to FUNCNAME have no effect. If FUNCNAME is unset, it loses its special properties, even if it is subsequently reset. This variable can be used with BASH_LINENO and BASH_SOURCE. Each element of FUNCNAME has corresponding elements in BASH_LINENO and BASH_SOURCE to describe the call stack. For instance, ${FUNCNAME[$i]} was called from the file ${BASH_SOURCE[$i+1]} at line number ${BASH_LINENO[$i]}. The caller builtin displays the current call stack using this information."
	},
	"$FUNCNEST": {
		"prefix": "$FUNCNEST",
		"body": [
			"\\${FUNCNEST}$0"
		],
		"scope": "",
		"description": "If set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed this nesting level will cause the current command to abort."
	},
	"$GLOBIGNORE": {
		"prefix": "$GLOBIGNORE",
		"body": [
			"\\${GLOBIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns defining the set of file names to be ignored by filename expansion. If a file name matched by a filename expansion pattern also matches one of the patterns in GLOBIGNORE, it is removed from the list of matches. The pattern matching honors the setting of the extglob shell option."
	},
	"$GROUPS": {
		"prefix": "$GROUPS",
		"body": [
			"\\${GROUPS}$0"
		],
		"scope": "",
		"description": "An array variable containing the list of groups of which the current user is a member. Assignments to GROUPS have no effect. If GROUPS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$histchars": {
		"prefix": "$histchars",
		"body": [
			"\\${histchars}$0"
		],
		"scope": "",
		"description": "Up to three characters which control history expansion, quick substitution, and tokenization (see History Expansion). The first character is the history expansion character, that is, the character which signifies the start of a history expansion, normally ‘!’. The second character is the character which signifies ‘quick substitution’ when seen as the first character on a line, normally ‘^’. The optional third character is the character which indicates that the remainder of the line is a comment when found as the first character of a word, usually ‘#’. The history comment character causes history substitution to be skipped for the remaining words on the line. It does not necessarily cause the shell parser to treat the rest of the line as a comment."
	},
	"$HISTCMD": {
		"prefix": "$HISTCMD",
		"body": [
			"\\${HISTCMD}$0"
		],
		"scope": "",
		"description": "The history number, or index in the history list, of the current command. Assignments to HISTCMD are ignored. If HISTCMD is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$HISTCONTROL": {
		"prefix": "$HISTCONTROL",
		"body": [
			"\\${HISTCONTROL}$0"
		],
		"scope": "",
		"description": "A colon-separated list of values controlling how commands are saved on the history list. If the list of values includes ‘ignorespace’, lines which begin with a space character are not saved in the history list. A value of ‘ignoredups’ causes lines which match the previous history entry to not be saved. A value of ‘ignoreboth’ is shorthand for ‘ignorespace’ and ‘ignoredups’. A value of ‘erasedups’ causes all previous lines matching the current line to be removed from the history list before that line is saved. Any value not in the above list is ignored. If HISTCONTROL is unset, or does not include a valid value, all lines read by the shell parser are saved on the history list, subject to the value of HISTIGNORE. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTCONTROL."
	},
	"$HISTFILE": {
		"prefix": "$HISTFILE",
		"body": [
			"\\${HISTFILE}$0"
		],
		"scope": "",
		"description": "The name of the file to which the command history is saved. The default value is ~/.bash_history."
	},
	"$HISTFILESIZE": {
		"prefix": "$HISTFILESIZE",
		"body": [
			"\\${HISTFILESIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of lines contained in the history file. When this variable is assigned a value, the history file is truncated, if necessary, to contain no more than that number of lines by removing the oldest entries. The history file is also truncated to this size after writing it when a shell exits. If the value is 0, the history file is truncated to zero size. Non-numeric values and numeric values less than zero inhibit truncation. The shell sets the default value to the value of HISTSIZE after reading any startup files."
	},
	"$HISTIGNORE": {
		"prefix": "$HISTIGNORE",
		"body": [
			"\\${HISTIGNORE}$0"
		],
		"scope": "",
		"description": "A colon-separated list of patterns used to decide which command lines should be saved on the history list. Each pattern is anchored at the beginning of the line and must match the complete line (no implicit ‘*’ is appended). Each pattern is tested against the line after the checks specified by HISTCONTROL are applied. In addition to the normal shell pattern matching characters, ‘&’ matches the previous history line. ‘&’ may be escaped using a backslash; the backslash is removed before attempting a match. The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTIGNORE. The pattern matching honors the setting of the extglob shell option. HISTIGNORE subsumes the function of HISTCONTROL. A pattern of ‘&’ is identical to ignoredups, and a pattern of ‘[ ]*’ is identical to ignorespace. Combining these two patterns, separating them with a colon, provides the functionality of ignoreboth."
	},
	"$HISTSIZE": {
		"prefix": "$HISTSIZE",
		"body": [
			"\\${HISTSIZE}$0"
		],
		"scope": "",
		"description": "The maximum number of commands to remember on the history list. If the value is 0, commands are not saved in the history list. Numeric values less than zero result in every command being saved on the history list (there is no limit). The shell sets the default value to 500 after reading any startup files."
	},
	"$HISTTIMEFORMAT": {
		"prefix": "$HISTTIMEFORMAT",
		"body": [
			"\\${HISTTIMEFORMAT}$0"
		],
		"scope": "",
		"description": "If this variable is set and not null, its value is used as a format string for strftime to print the time stamp associated with each history entry displayed by the history builtin. If this variable is set, time stamps are written to the history file so they may be preserved across shell sessions. This uses the history comment character to distinguish timestamps from other history lines."
	},
	"$HOSTFILE": {
		"prefix": "$HOSTFILE",
		"body": [
			"\\${HOSTFILE}$0"
		],
		"scope": "",
		"description": "Contains the name of a file in the same format as /etc/hosts that should be read when the shell needs to complete a hostname. The list of possible hostname completions may be changed while the shell is running; the next time hostname completion is attempted after the value is changed, Bash adds the contents of the new file to the existing list. If HOSTFILE is set, but has no value, or does not name a readable file, Bash attempts to read /etc/hosts to obtain the list of possible hostname completions. When HOSTFILE is unset, the hostname list is cleared."
	},
	"$HOSTNAME": {
		"prefix": "$HOSTNAME",
		"body": [
			"\\${HOSTNAME}$0"
		],
		"scope": "",
		"description": "The name of the current host."
	},
	"$HOSTTYPE": {
		"prefix": "$HOSTTYPE",
		"body": [
			"\\${HOSTTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the machine Bash is running on."
	},
	"$IGNOREEOF": {
		"prefix": "$IGNOREEOF",
		"body": [
			"\\${IGNOREEOF}$0"
		],
		"scope": "",
		"description": "Controls the action of the shell on receipt of an EOF character as the sole input. If set, the value denotes the number of consecutive EOF characters that can be read as the first character on an input line before the shell will exit. If the variable exists but does not have a numeric value, or has no value, then the default is 10. If the variable does not exist, then EOF signifies the end of input to the shell. This is only in effect for interactive shells."
	},
	"$INPUTRC": {
		"prefix": "$INPUTRC",
		"body": [
			"\\${INPUTRC}$0"
		],
		"scope": "",
		"description": "The name of the Readline initialization file, overriding the default of ~/.inputrc."
	},
	"$INSIDE_EMACS": {
		"prefix": "$INSIDE_EMACS",
		"body": [
			"\\${INSIDE_EMACS}$0"
		],
		"scope": "",
		"description": "If Bash finds this variable in the environment when the shell starts, it assumes that the shell is running in an Emacs shell buffer and may disable line editing depending on the value of TERM."
	},
	"$LANG": {
		"prefix": "$LANG",
		"body": [
			"\\${LANG}$0"
		],
		"scope": "",
		"description": "Used to determine the locale category for any category not specifically selected with a variable starting with LC_."
	},
	"$LC_ALL": {
		"prefix": "$LC_ALL",
		"body": [
			"\\${LC_ALL}$0"
		],
		"scope": "",
		"description": "This variable overrides the value of LANG and any other LC_ variable specifying a locale category."
	},
	"$LC_COLLATE": {
		"prefix": "$LC_COLLATE",
		"body": [
			"\\${LC_COLLATE}$0"
		],
		"scope": "",
		"description": "This variable determines the collation order used when sorting the results of filename expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_CTYPE": {
		"prefix": "$LC_CTYPE",
		"body": [
			"\\${LC_CTYPE}$0"
		],
		"scope": "",
		"description": "This variable determines the interpretation of characters and the behavior of character classes within filename expansion and pattern matching (see Filename Expansion)."
	},
	"$LC_MESSAGES": {
		"prefix": "$LC_MESSAGES",
		"body": [
			"\\${LC_MESSAGES}$0"
		],
		"scope": "",
		"description": "This variable determines the locale used to translate double-quoted strings preceded by a ‘$’ (see Locale-Specific Translation)."
	},
	"$LC_NUMERIC": {
		"prefix": "$LC_NUMERIC",
		"body": [
			"\\${LC_NUMERIC}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for number formatting."
	},
	"$LC_TIME": {
		"prefix": "$LC_TIME",
		"body": [
			"\\${LC_TIME}$0"
		],
		"scope": "",
		"description": "This variable determines the locale category used for data and time formatting."
	},
	"$LINENO": {
		"prefix": "$LINENO",
		"body": [
			"\\${LINENO}$0"
		],
		"scope": "",
		"description": "The line number in the script or shell function currently executing. If LINENO is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$LINES": {
		"prefix": "$LINES",
		"body": [
			"\\${LINES}$0"
		],
		"scope": "",
		"description": "Used by the select command to determine the column length for printing selection lists. Automatically set if the checkwinsize option is enabled (see The Shopt Builtin), or in an interactive shell upon receipt of a SIGWINCH."
	},
	"$MACHTYPE": {
		"prefix": "$MACHTYPE",
		"body": [
			"\\${MACHTYPE}$0"
		],
		"scope": "",
		"description": "A string that fully describes the system type on which Bash is executing, in the standard GNU cpu-company-system format."
	},
	"$MAILCHECK": {
		"prefix": "$MAILCHECK",
		"body": [
			"\\${MAILCHECK}$0"
		],
		"scope": "",
		"description": "How often (in seconds) that the shell should check for mail in the files specified in the MAILPATH or MAIL variables. The default is 60 seconds. When it is time to check for mail, the shell does so before displaying the primary prompt. If this variable is unset, or set to a value that is not a number greater than or equal to zero, the shell disables mail checking."
	},
	"$MAPFILE": {
		"prefix": "$MAPFILE",
		"body": [
			"\\${MAPFILE}$0"
		],
		"scope": "",
		"description": "An array variable created to hold the text read by the mapfile builtin when no variable name is supplied."
	},
	"$OLDPWD": {
		"prefix": "$OLDPWD",
		"body": [
			"\\${OLDPWD}$0"
		],
		"scope": "",
		"description": "The previous working directory as set by the cd builtin."
	},
	"$OPTERR": {
		"prefix": "$OPTERR",
		"body": [
			"\\${OPTERR}$0"
		],
		"scope": "",
		"description": "If set to the value 1, Bash displays error messages generated by the getopts builtin command."
	},
	"$OSTYPE": {
		"prefix": "$OSTYPE",
		"body": [
			"\\${OSTYPE}$0"
		],
		"scope": "",
		"description": "A string describing the operating system Bash is running on."
	},
	"$PIPESTATUS": {
		"prefix": "$PIPESTATUS",
		"body": [
			"\\${PIPESTATUS}$0"
		],
		"scope": "",
		"description": "An array variable (see Arrays) containing a list of exit status values from the processes in the most-recently-executed foreground pipeline (which may contain only a single command)."
	},
	"$POSIXLY_CORRECT": {
		"prefix": "$POSIXLY_CORRECT",
		"body": [
			"\\${POSIXLY_CORRECT}$0"
		],
		"scope": "",
		"description": "If this variable is in the environment when Bash starts, the shell enters POSIX mode (see Bash POSIX Mode) before reading the startup files, as if the --posix invocation option had been supplied. If it is set while the shell is running, Bash enables POSIX mode, as if the command set -o posix had been executed. When the shell enters POSIX mode, it sets this variable if it was not already set."
	},
	"$PPID": {
		"prefix": "$PPID",
		"body": [
			"\\${PPID}$0"
		],
		"scope": "",
		"description": "The process ID of the shell’s parent process. This variable is readonly."
	},
	"$PROMPT_COMMAND": {
		"prefix": "$PROMPT_COMMAND",
		"body": [
			"\\${PROMPT_COMMAND}$0"
		],
		"scope": "",
		"description": "If this variable is set, and is an array, the value of each set element is interpreted as a command to execute before printing the primary prompt ($PS1). If this is set but not an array variable, its value is used as a command to execute instead."
	},
	"$PROMPT_DIRTRIM": {
		"prefix": "$PROMPT_DIRTRIM",
		"body": [
			"\\${PROMPT_DIRTRIM}$0"
		],
		"scope": "",
		"description": "If set to a number greater than zero, the value is used as the number of trailing directory components to retain when expanding the \\w and \\W prompt string escapes (see Controlling the Prompt). Characters removed are replaced with an ellipsis."
	},
	"$PS0": {
		"prefix": "$PS0",
		"body": [
			"\\${PS0}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and displayed by interactive shells after reading a command and before the command is executed."
	},
	"$PS3": {
		"prefix": "$PS3",
		"body": [
			"\\${PS3}$0"
		],
		"scope": "",
		"description": "The value of this variable is used as the prompt for the select command. If this variable is not set, the select command prompts with ‘#? ’"
	},
	"$PS4": {
		"prefix": "$PS4",
		"body": [
			"\\${PS4}$0"
		],
		"scope": "",
		"description": "The value of this parameter is expanded like PS1 and the expanded value is the prompt printed before the command line is echoed when the -x option is set (see The Set Builtin). The first character of the expanded value is replicated multiple times, as necessary, to indicate multiple levels of indirection. The default is ‘+ ’."
	},
	"$PWD": {
		"prefix": "$PWD",
		"body": [
			"\\${PWD}$0"
		],
		"scope": "",
		"description": "The current working directory as set by the cd builtin."
	},
	"$RANDOM": {
		"prefix": "$RANDOM",
		"body": [
			"\\${RANDOM}$0"
		],
		"scope": "",
		"description": "Each time this parameter is referenced, it expands to a random integer between 0 and 32767. Assigning a value to this variable seeds the random number generator. If RANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$READLINE_ARGUMENT": {
		"prefix": "$READLINE_ARGUMENT",
		"body": [
			"\\${READLINE_ARGUMENT}$0"
		],
		"scope": "",
		"description": "Any numeric argument given to a Readline command that was defined using ‘bind -x’ (see Bash Builtin Commands when it was invoked."
	},
	"$READLINE_LINE": {
		"prefix": "$READLINE_LINE",
		"body": [
			"\\${READLINE_LINE}$0"
		],
		"scope": "",
		"description": "The contents of the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$READLINE_MARK": {
		"prefix": "$READLINE_MARK",
		"body": [
			"\\${READLINE_MARK}$0"
		],
		"scope": "",
		"description": "The position of the mark (saved insertion point) in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands). The characters between the insertion point and the mark are often called the region."
	},
	"$READLINE_POINT": {
		"prefix": "$READLINE_POINT",
		"body": [
			"\\${READLINE_POINT}$0"
		],
		"scope": "",
		"description": "The position of the insertion point in the Readline line buffer, for use with ‘bind -x’ (see Bash Builtin Commands)."
	},
	"$REPLY": {
		"prefix": "$REPLY",
		"body": [
			"\\${REPLY}$0"
		],
		"scope": "",
		"description": "The default variable for the read builtin."
	},
	"$SECONDS": {
		"prefix": "$SECONDS",
		"body": [
			"\\${SECONDS}$0"
		],
		"scope": "",
		"description": "This variable expands to the number of seconds since the shell was started. Assignment to this variable resets the count to the value assigned, and the expanded value becomes the value assigned plus the number of seconds since the assignment. The number of seconds at shell invocation and the current time are always determined by querying the system clock. If SECONDS is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$SHELL": {
		"prefix": "$SHELL",
		"body": [
			"\\${SHELL}$0"
		],
		"scope": "",
		"description": "This environment variable expands to the full pathname to the shell. If it is not set when the shell starts, Bash assigns to it the full pathname of the current user’s login shell."
	},
	"$SHELLOPTS": {
		"prefix": "$SHELLOPTS",
		"body": [
			"\\${SHELLOPTS}$0"
		],
		"scope": "",
		"description": "A colon-separated list of enabled shell options. Each word in the list is a valid argument for the -o option to the set builtin command (see The Set Builtin). The options appearing in SHELLOPTS are those reported as ‘on’ by ‘set -o’. If this variable is in the environment when Bash starts up, each shell option in the list will be enabled before reading any startup files. This variable is readonly."
	},
	"$SHLVL": {
		"prefix": "$SHLVL",
		"body": [
			"\\${SHLVL}$0"
		],
		"scope": "",
		"description": "Incremented by one each time a new instance of Bash is started. This is intended to be a count of how deeply your Bash shells are nested."
	},
	"$SRANDOM": {
		"prefix": "$SRANDOM",
		"body": [
			"\\${SRANDOM}$0"
		],
		"scope": "",
		"description": "This variable expands to a 32-bit pseudo-random number each time it is referenced. The random number generator is not linear on systems that support /dev/urandom or arc4random, so each returned number has no relationship to the numbers preceding it. The random number generator cannot be seeded, so assignments to this variable have no effect. If SRANDOM is unset, it loses its special properties, even if it is subsequently reset."
	},
	"$TIMEFORMAT": {
		"prefix": "$TIMEFORMAT",
		"body": [
			"\\${TIMEFORMAT}$0"
		],
		"scope": "",
		"description": "The value of this parameter is used as a format string specifying how the timing information for pipelines prefixed with the time reserved word should be displayed. The ‘%’ character introduces an escape sequence that is expanded to a time value or other information. If the value is null, no timing information is displayed. A trailing newline is added when the format string is displayed."
	},
	"$TMOUT": {
		"prefix": "$TMOUT",
		"body": [
			"\\${TMOUT}$0"
		],
		"scope": "",
		"description": "If set to a value greater than zero, TMOUT is treated as the default timeout for the read builtin (see Bash Builtin Commands). The select command (see Conditional Constructs) terminates if input does not arrive after TMOUT seconds when input is coming from a terminal. In an interactive shell, the value is interpreted as the number of seconds to wait for a line of input after issuing the primary prompt. Bash terminates after waiting for that number of seconds if a complete line of input does not arrive."
	},
	"$TMPDIR": {
		"prefix": "$TMPDIR",
		"body": [
			"\\${TMPDIR}$0"
		],
		"scope": "",
		"description": "If set, Bash uses its value as the name of a directory in which Bash creates temporary files for the shell’s use."
	},
	"$UID": {
		"prefix": "$UID",
		"body": [
			"\\${UID}$0"
		],
		"scope": "",
		"description": "The numeric real user id of the current user. This variable is readonly."
	},
	"$BASH": {
		"prefix": "$BASH",
		"description": "The full pathname used to execute the current instance of Bash. ",
		"scope": "",
		"body": [
			"\\${BASH}$0"
		]
	},
	"$_": {
		"prefix": "$_",
		"description": "",
		"scope": "",
		"body": [
			"\\${_}$0"
		]
	},
	"$CDPATH": {
		"prefix": "$CDPATH",
		"description": "A colon-separated list of directories used as a search path for the cd builtin command.",
		"scope": "",
		"body": [
			"\\${CDPATH}$0"
		]
	},
	"$PS2": {
		"prefix": "$PS2",
		"description": "The secondary prompt string. The default value is ‘> ’. PS2 is expanded in the same way as PS1 before being displayed.",
		"scope": "",
		"body": [
			"\\${PS2}$0"
		]
	},
	"$PS1": {
		"prefix": "$PS1",
		"description": "The primary prompt string. The default value is ‘\\s-\\v\\${ ’}. See Controlling the Prompt, for the complete list of escape sequences that are expanded before PS1 is displayed. ",
		"scope": "",
		"body": [
			"\\${PS1}$0"
		]
	},
	"$PATH": {
		"prefix": "$PATH",
		"description": "A colon-separated list of directories in which the shell looks for commands. A zero-length (null) directory name in the value of PATH indicates the current directory. A null directory name may appear as two adjacent colons, or as an initial or trailing colon. ",
		"scope": "",
		"body": [
			"\\${PATH}$0"
		]
	},
	"$OPTIND": {
		"prefix": "$OPTIND",
		"description": "The index of the last option argument processed by the getopts builtin. ",
		"scope": "",
		"body": [
			"\\${OPTIND}$0"
		]
	},
	"$OPTARG": {
		"prefix": "$OPTARG",
		"description": "The value of the last option argument processed by the getopts builtin.",
		"scope": "",
		"body": [
			"\\${OPTARG}$0"
		]
	},
	"$MAILPATH": {
		"prefix": "$MAILPATH",
		"description": "A colon-separated list of filenames which the shell periodically checks for new mail. Each list entry can specify the message that is printed when new mail arrives in the mail file by separating the filename from the message with a ‘?’. When used in the text of the message, $_ expands to the name of the current mail file.",
		"scope": "",
		"body": [
			"\\${MAILPATH}$0"
		]
	},
	"$MAIL": {
		"prefix": "$MAIL",
		"description": "If this parameter is set to a filename or directory name and the MAILPATH variable is not set, Bash informs the user of the arrival of mail in the specified file or Maildir-format directory.",
		"scope": "",
		"body": [
			"\\${MAIL}$0"
		]
	},
	"$IFS": {
		"prefix": "$IFS",
		"description": "A list of characters that separate fields; used when the shell splits words as part of expansion. ",
		"scope": "",
		"body": [
			"\\${IFS}$0"
		]
	},
	"$HOME": {
		"prefix": "$HOME",
		"description": "The current user’s home directory; the default for the cd builtin command. The value of this variable is also used by tilde expansion.",
		"scope": "",
		"body": [
			"\\${HOME}$0"
		]
	}
}