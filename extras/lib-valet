#!/usr/bin/env bash
# This script contains the documentation of all the valet library functions.
# It can be used in your editor to provide auto-completion and documentation.
#
# Documentation generated for the version 0.28.2965 (2025-02-07).

# ## ansi-codes::*
#
# ANSI codes for text attributes, colors, cursor control, and other common escape sequences.
# These codes can be used to format text in the terminal.
#
# These codes were selected because they are widely supported by terminals and they
# probably will cover all use cases. It is also advised to stick to the 4-bit colors
# which allows your application to adopt the color scheme of the terminal.
#
# They are defined as variables and not as functions. Please check the content of the lib-ansi-codes to learn more:
# <https://github.com/jcaillon/valet/blob/latest/libraries.d/lib-ansi-codes>
#
# References:
#
# - https://en.wikipedia.org/wiki/ANSI_escape_code
# - https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
# - https://paulbourke.net/dataformats/ascii/
# - https://www.aivosto.com/articles/control-characters.html
# - https://github.com/tmux/tmux/blob/master/tools/ansicode.txt
# - https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_
# - https://vt100.net/docs/vt102-ug/chapter5.html
# - https://vt100.net/docs/vt100-ug/chapter3.html#S3.3.1
#
# Ascii graphics:
#
# - https://gist.github.com/dsample/79a97f38bf956f37a0f99ace9df367b9
# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Box_Drawing
# - https://en.wikipedia.org/wiki/List_of_Unicode_characters#Block_Elements
#
# > While it could be very handy to define a function for each of these instructions,
# > it would also be slower to execute (function overhead + multiple printf calls).
#
function ansi-codes::*() { :; }

# ## array::appendIfNotPresent
#
# Add a value to an array if it is not already present.
#
# - $1: **array name** _as string_:
#       The variable name of the array.
# - $2: **value** _as any_:
#       The value to add.
#
# Returns:
#
# - $?:
#   - 0 if the value was added
#   - 1 if it was already present
#
# ```bash
# declare myArray=( "a" "b" )
# array::appendIfNotPresent myArray "c"
# printf '%s\n' "${myArray[@]}"
# ```
#
function array::appendIfNotPresent() { :; }

# ## array::checkIfPresent
#
# Check if a value is in an array.
# It uses pure bash.
#
# - $1: **array name** _as string_:
#       The variable name of the array.
# - $2: **value** _as any_:
#       The value to check.
#
# Returns:
#
# - $?: 0 if the value is in the array, 1 otherwise.
#
# ```bash
# declare myArray=( "a" "b" )
# array::checkIfPresent myArray "b" && printf '%s\n' "b is in the array"
# ```
#
function array::checkIfPresent() { :; }

# ## array::fuzzyFilterSort
#
# Allows to fuzzy sort an array against a given searched string.
# Returns an array containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
# - the original order in the list
#
# Also returns an array containing the indexes of the matched items in the original array.
#
# - $1: **array name** _as string_:
#       The array name to fuzzy filter and sort.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array containing the items sorted and filtered
# - ${RETURNED_ARRAY2}: An array containing the indexes of the matched items in the original array
#
# ```bash
# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING
# echo "${RETURNED_ARRAY[*]}"
# ```
#
# > - All characters in the pattern must be found in the same order in the matched line.
# > - Use `shopt -s nocasematch` to make this function is case insensitive.
# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.
#
function array::fuzzyFilterSort() { :; }

# ## array::fuzzyFilterSortFileWithGrepAndGawk
#
# Allows to fuzzy sort a file against a given searched string.
# Outputs a file containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
#
# Will also output a file containing the indexes of the matched lines in the original file.
#
# - $1: **file to filer** _as string_:
#       The input file to filter.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
# - $3: **output filtered file** _as string_:
#       The output file containing the filtered lines.
# - $4: **output correspondences file** _as string_:
#       The output file containing the indexes of the matched lines in the original file.
#
# ```bash
# array::fuzzyFilterSortFileWithGrepAndGawk file.txt filtered.txt correspondences.txt
# ```
#
# > This is not a pure bash function! Use `array::fuzzyFilterSort` for pure bash alternative.
# > This function is useful for very large arrays.
#
function array::fuzzyFilterSortFileWithGrepAndGawk() { :; }

# ## array::makeArraysSameSize
#
# This function makes sure that all the arrays have the same size.
# It will add empty strings to the arrays that are too short.
#
# - $@: **array names** _as string_:
#       The variable names of each array to transform.
#
# ```bash
# array::makeArraysSameSize "array1" "array2" "array3"
# ```
#
function array::makeArraysSameSize() { :; }

# ## array::sort
#
# Sorts an array using the > bash operator (lexicographic order).
#
# - $1: **array name** _as string_:
#       The variable name of the array to sort  (it will be sorted in place).
#
# ```bash
# declare myArray=(z f b h a j)
# array::sort myArray
# echo "${myArray[*]}"
# ```
#
# > - This function uses a quicksort algorithm.
# > - It is not appropriate for large array, use the `sort` binary for such cases.
#
function array::sort() { :; }

# ## array::sortWithCriteria
#
# Sorts an array using multiple criteria.
# Excepts multiple arrays. The first array is the one to sort.
# The other arrays are used as criteria. Criteria are used in the order they are given.
# Each criteria array must have the same size as the array to sort.
# Each criteria array must containing integers representing the order of the elements.
# We first sort using the first criteria (from smallest to biggest), then the second, etc.
#
# - $1: **array name** _as string_:
#       The name of the array to sort (it will be sorted in place).
# - $@: **criteria array names** _as string_:
#       The names of the arrays to use as criteria.
#       Each array must have the same size as the array to sort and contain only numbers.
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array that contains the corresponding indexes of the sorted array in the original array
#
# ```bash
# declare myArray=( "a" "b" "c" )
# declare criteria1=( 3 2 2 )
# declare criteria2=( 1 3 2 )
# array::sortWithCriteria myArray criteria1 criteria2
# echo "${myArray[@]}"
# # c b a
# echo "${RETURNED_ARRAY[@]}"
# # 3 2 1
# ```
#
# > - This function uses a quicksort algorithm.
# > - It is not appropriate for large array, use the `sort` binary for such cases.
#
function array::sortWithCriteria() { :; }

# ## bash::countArgs
#
# Returns the number of arguments passed.
#
# A convenient function that can be used to:
#
# - count the files/directories in a directory:
#   `bash::countArgs "${PWD}"/* && local numberOfFiles="${RETURNED_VALUE}"`
# - count the number of variables starting with VALET_
#   `bash::countArgs "${!VALET_@}" && local numberOfVariables="${RETURNED_VALUE}"`
#
# Inputs:
#
# - $@: **arguments** _as any_:
#       the arguments to count
#
# Returns:
#
# - ${RETURNED_VALUE}: The number of arguments passed.
#
# ```bash
# bash::countArgs 1 2 3
# ```
#
function bash::countArgs() { :; }

# ## bash::countJobs
#
# This function counts the number of jobs currently running in the background.
#
# Returns:
#
# - ${RETURNED_VALUE}: the number of jobs currently running in the background.
#
# ```bash
# bash::countJobs
# echo "There are currently ${RETURNED_VALUE} jobs running in the background."
# ```
#
function bash::countJobs() { :; }

# ## bash::getFunctionDefinitionWithGlobalVars
#
# This function can be used to get the definition of an existing function,
# rename it, and replace the use of positional parameters by global variables.
#
# This can be useful for performance reasons when a function is called many times,
# to avoid copying the positional parameters each time.
#
# - $1: **function name** _as string_:
#       the name of the function to re-export
# - $2: **new function name** _as string_:
#       the name of the new function to create
# - $@: global variable name _as string_:
#       the name of the global variable to use instead of the positional parameters
#       (can be repeated multiple times, for each parameter)
#
# Returns:
#
# - $?:
#   - 0 if the function was successfully re-exported
#   - 1 if the function does not exist
# - ${RETURNED_VALUE}: the modified function definition
# - ${RETURNED_VALUE2}: the original function
#
# ```bash
# bash::getFunctionDefinitionWithGlobalVars "myFunction" "myFunctionWithGlobalVars" "MY_VAR1" "MY_VAR2"
# eval "${RETURNED_VALUE}"
# myFunctionWithGlobalVars
# ```
#
function bash::getFunctionDefinitionWithGlobalVars() { :; }

# ## bash::getMissingCommands
#
# This function returns the list of not existing commands for the given names.
#
# - $@: **command names** _as string_:
#       the list of command names to check.
#
# Returns:
#
# - $?
#   - 0 if there are not existing commands
#   - 1 otherwise.
# - ${RETURNED_ARRAY}: the list of not existing commands.
#
# ```bash
# if bash::getMissingCommands "command1" "command2"; then
#   printf 'The following commands do not exist: %s' "${RETURNED_ARRAY[*]}"
# fi
# ```
#
function bash::getMissingCommands() { :; }

# ## bash::getMissingVariables
#
# This function returns the list of undeclared variables for the given names.
#
# - $@: **variable names** _as string_:
#       the list of variable names to check.
#
# Returns:
#
# - $?
#   - 0 if there are variable undeclared
#   - 1 otherwise.
# - ${RETURNED_ARRAY}: the list of undeclared variables.
#
# ```bash
# if bash::getMissingVariables "var1" "var2"; then
#   printf 'The following variables are not declared: %s' "${RETURNED_ARRAY[*]}"
# fi
# ```
#
function bash::getMissingVariables() { :; }

# ## bash::injectCodeInFunction
#
# This function injects code at the beginning or the end of a function and
# returns the modified function to be evaluated.
#
# - $1: **function name** _as string_:
#       The name of the function to inject the code into.
# - $2: **code** _as string_:
#       The code to inject.
# - $3: inject at beginning _as boolean_:
#       (optional) Can be set using the variable `_OPTION_INJECT_AT_BEGINNING`.
#       Whether to inject the code at the beginning of the function (or at the end).
#       (defaults to false)
#
# Returns:
#
# - ${RETURNED_VALUE}: the modified function.
# - ${RETURNED_VALUE2}: the original function.
#
# ```bash
# bash::injectCodeInFunction myFunction "echo 'Hello world!'" true
# eval "${RETURNED_VALUE}"
# myFunction
# ```
#
function bash::injectCodeInFunction() { :; }

# ## bash::isCommand
#
# Check if the given command exists.
#
# - $1: **command name** _as string_:
#       the command name to check.
#
# Returns:
#
# - $?
#   - 0 if the command exists
#   - 1 otherwise.
#
# ```bash
# if bash::isCommand "command1"; then
#   printf 'The command exists.'
# fi
# ```
#
function bash::isCommand() { :; }

# ## bash::readStdIn
#
# Read the content of the standard input.
# Will immediately return if the standard input is empty.
#
# Returns:
#
# - ${RETURNED_VALUE}: The content of the standard input.
#
# ```bash
# bash::readStdIn && local stdIn="${RETURNED_VALUE}"
# ```
#
function bash::readStdIn() { :; }

# ## bash::runInParallel
#
# This function runs a list of commands in parallel with a maximum number of parallel jobs.
#
# - $1: **job names array name** _as string_:
#       The name of the array containing the names of the jobs to run.
# - $2: **job commands array name** _as string_:
#       The name of the array containing the commands to run.
# - $3: max parallel jobs _as integer_:
#       (optional) Can be set using the variable `_OPTION_MAX_PARALLEL_JOBS`.
#       The maximum number of parallel jobs to run.
#       (defaults to 4)
# - $4: job completed callback _as string_:
#       (optional) Can be set using the variable `_OPTION_JOB_COMPLETED_CALLBACK`.
#       The name of the function to call when a job is completed.
#       The function will receive the following arguments:
#       - the job index
#       - the job name
#       - the job exit code
#       - the percentage of jobs completed
#       If the function returns 1, the script will exit early.
#       (defaults to "")
# - ${_OPTION_TIMEOUT_BETWEEN_CHECKS} _as float_:
#       (optional) Can be set using the variable `_OPTION_TIMEOUT_BETWEEN_CHECKS`.
#       The time to wait between checks for completed jobs (when no jobs finished
#       when we last checked).
#       (defaults to 0.2)
#
# Returns:
#
# - $?:
#   - 0: if all the jobs completed successfully.
#   - 1: if the job completed callback returned 1.
# - ${RETURNED_ARRAY}: an array containing the exit codes of the jobs.
#
# ```bash
# declare -a jobNames=("job1" "job2" "job3")
# declare -a jobCommands=("sleep 1" "sleep 2" "sleep 3")
# _OPTION_MAX_PARALLEL_JOBS=2 bash::runInParallel jobNames jobCommands
# ```
#
function bash::runInParallel() { :; }

# ## bash::sleep
#
# Sleep for the given amount of time.
# This is a pure bash replacement of sleep.
#
# - $1: **time** _as float_:
#       the time to sleep in seconds (can be a float)
#
# ```bash
# bash::sleep 1.5
# ```
#
# > The sleep command is not a built-in command in bash, but a separate executable. When you use sleep, you are creating a new process.
#
function bash::sleep() { :; }

# ## benchmark::run
#
# This function runs a benchmark on given functions.
#
# First, it will run the 1st function (the baseline) for a given number of time and
# mark the number of times it was able to run it in that given time.
#
# Then, it will run all the functions for the same number of time and
# print the difference between the baseline and the other functions.
#
# - $1: **baseline** _as string_:
#       the name of the function to use as baseline
# - $2: **functions** _as string_:
#       The names of the functions to benchmark, comma separated.
# - $3: time _as int_:
#       (optional) Can be set using the variable `_OPTION_TIME`.
#       The time in seconds for which to run the baseline.
#       (defaults to 3s)
# - $4: max runs _as int_:
#       (optional) Can be set using the variable `_OPTION_MAX_RUNS`.
#       The maximum number of runs to do for each function.
#       (defaults to -1 which means no limit)
#
# ```bash
# benchmark::run "baseline" "function1,function2" 1 100
# ```
#
function benchmark::run() { :; }

# ## command::checkParsedResults
#
# A convenience function to check the parsing results and fails with an error message if there are
# parsing errors.
# Will also display the help if the help option is true.
#
# This should be called from a command function for which you want to check the parsing results.
#
# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed
# and if there are parsing errors.
#
# ```bash
# command::parseArguments "$@" && eval "${RETURNED_VALUE}"
# command::checkParsedResults
# ```
#
function command::checkParsedResults() { :; }

# ## command::parseArguments
#
# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.
#
#
# - $@: **arguments** _as any_:
#       the arguments to parse
#
# Returns:
#
# - ${RETURNED_VALUE}: a string that can be evaluated to set the parsed variables
#
# Output example:
#
# ```
# local arg1 option1
# arg1="xxx"
# option1="xxx"
# ```
#
# ```bash
# command::parseArguments "$@" && eval "${RETURNED_VALUE}"
# command::checkParsedResults
# ```
#
function command::parseArguments() { :; }

# ## command::showHelp
#
# Show the help for the current function.
# This should be called directly from a command function for which you want to display the help text.
#
# ```bash
# command::showHelp
# ```
#
function command::showHelp() { :; }

# ## command::sourceFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# command::sourceFunction "functionName"
# ```
#
function command::sourceFunction() { :; }

# ## core::fail
#
# Displays an error message and then exit the program with error.
#
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::fail "This is an error message."
# ```
#
function core::fail() { :; }

# ## core::failWithCode
#
# Displays an error message and then exit the program with error.
#
# - $1: **exit code** _as int_:
#       the exit code to use, should be between 1 and 255
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::failWithCode 255 "This is an error message."
# ```
#
function core::failWithCode() { :; }

# ## core::getConfigurationDirectory
#
# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet configuration directory
#
# ```bash
# core::getConfigurationDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
function core::getConfigurationDirectory() { :; }

# ## core::getLocalStateDirectory
#
# Returns the path to the valet local state directory.
# The base directory relative to which user-specific state files should be stored.
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet local state directory
#
# ```bash
# core::getLocalStateDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
function core::getLocalStateDirectory() { :; }

# ## core::getUserDirectory
#
# Returns the path to the valet user directory.
# Does not create it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet user directory
#
# ```bash
# core::getUserDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
function core::getUserDirectory() { :; }

# ## core::getVersion
#
# Returns the version of Valet.
#
# Returns:
#
# - ${RETURNED_VALUE}: The version of Valet.
#
# ```bash
# core::getVersion
# printf '%s\n' "The version of Valet is ⌜${RETURNED_VALUE}⌝."
# ```
#
function core::getVersion() { :; }

# ## curl::download
#
# This function is a wrapper around curl to save a request result in a file.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o ${2}.
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails
# - $2: **acceptable codes** _as string_:
#       list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
# - $3: **path** _as string_:
#       the file in which to save the output of curl
# - $@: **curl arguments** _as any_:
#       options for curl
#
# Returns:
#
# - $?:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${RETURNED_VALUE}: the content of stderr
# - ${RETURNED_VALUE2}: the http status code
#
# ```bash
# curl::download true 200,201 "/filePath" "https://example.com"
# curl::download false 200 "/filePath2" "https://example2.com" || core::fail "The curl command failed."
# ```
#
function curl::download() { :; }

# ## curl::request
#
# This function is a wrapper around curl to save the content of a request in a variable.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o "tempfile".
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails
# - $2: **acceptable codes** _as string_:
#       list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
# - $@: **curl arguments** _as any_:
#       options for curl
#
# Returns:
#
# - $?:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${RETURNED_VALUE}: the content of the request
# - ${RETURNED_VALUE2}: the content of stderr
# - ${RETURNED_VALUE3}: the http status code
#
# ```bash
# curl::request true 200 https://example.com -X POST -H 'Authorization: token'
# curl::request false 200,201 https://example.com || core::fail "The curl command failed."
# ```
#
function curl::request() { :; }

# ## exe::captureOutput
#
# Capture the output of a command.
# Made to be used on bash builtins that produce output.
# It captures the stdout and stderr of the command.
#
# This function is a lot more basic than `exe::invoke` and does not support all its features.
#
# - $@: **command** _as string_:
#       The command to run.
#
# Returns:
#
# - $?
#   - 0 if the command was successful
#   - 1 otherwise.
# - ${RETURNED_VALUE}: The captured output.
#
# ```bash
# exe::captureOutput declare -f exe::captureOutput
# echo "${RETURNED_VALUE}"
# ```
#
function exe::captureOutput() { :; }

# ## exe::invoke
#
# This function call an executable and its arguments.
# If the execution fails, it will fail the script and show the std/err output.
# Otherwise it hides both streams, effectively rendering the execution silent unless it fails.
#
# It redirects the stdout and stderr to environment variables.
# Equivalent to `exe::invoke5 true 0 '' '' "${@}"`
#
# - $1: **executable** _as string_:
#       the executable or command
# - $@: **arguments** _as any_:
#       the command and its arguments
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# exe::invoke git add --all
# ```
#
# > See exe::invokef5 for more information.
#
function exe::invoke() { :; }

# ## exe::invoke2
#
# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
# Equivalent to `exe::invoke5 "${1}" 0 "" "" "${@:2}"`
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#       If true and the execution fails, the script will exit.
# - $2: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# exe::invokef2 false git status || core::fail "status failed."
# stdout="${RETURNED_VALUE}"
# stderr="${RETURNED_VALUE2}"
# ```
#
# > See exe::invokef5 for more information.
#
function exe::invoke2() { :; }

# ## exe::invoke2piped
#
# This function call an executable and its arguments and input a given string as stdin.
# It redirects the stdout and stderr to environment variables.
# Equivalent to `exe::invoke5 "${1}" 0 false "${2}" "${@:3}"`
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#       If true and the execution fails, the script will exit.
# - $2: **stdin** _as string_:
#       the stdin to pass to the executable
# - $3: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# exe::invoke2piped true "key: val" yq -o json -p yaml -
# stdout="${RETURNED_VALUE}"
# stderr="${RETURNED_VALUE2}"
# ```
#
# > This is the equivalent of:
# > `myvar="$(printf '%s\n' "mystring" | mycommand)"`
# > But without using a subshell.
# >
# > See exe::invokef5 for more information.
#
function exe::invoke2piped() { :; }

# ## exe::invoke5
#
# This function call an executable and its arguments.
# It redirects the stdout and stderr to environment variables.
# It calls invoke5 and reads the files to set the environment variables.
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#       If true and the execution fails, the script will exit.
# - $2: **acceptable codes** _as string_:
#       the acceptable error codes, comma separated
#       (if the error code is matched, then set the output error code to 0)
# - $3: **stdin from file** _as bool_:
#       true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# - $4: **stdin** _as string_:
#       the stdin (can be empty)
# - $5: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# exe::invoke5 "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
# stdout="${RETURNED_VALUE}"
# stderr="${RETURNED_VALUE2}"
# ```
#
# > See exe::invokef5 for more information.
#
function exe::invoke5() { :; }

# ## exe::invokef2
#
# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
# Equivalent to `exe::invokef5 "${1}" 0 "" "" "${@:2}"`
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#       If true and the execution fails, the script will exit.
# - $2: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The file path containing the stdout of the executable.
# - ${RETURNED_VALUE2}: The file path containing the stderr of the executable.
#
# ```bash
# exe::invokef2 false git status || core::fail "status failed."
# stdoutFilePath="${RETURNED_VALUE}"
# stderrFilePath="${RETURNED_VALUE2}"
# ```
#
# > See exe::invokef5 for more information.
#
function exe::invokef2() { :; }

# ## exe::invokef2piped
#
# This function call an executable and its arguments and input a given string as stdin.
# It redirects the stdout and stderr to temporary files.
# Equivalent to `exe::invokef5 "${1}" 0 false "${2}" "${@:3}"`
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#       If true and the execution fails, the script will exit.
# - $2: **stdin** _as string_:
#       the stdin to pass to the executable
# - $3: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The file path containing the stdout of the executable.
# - ${RETURNED_VALUE2}: The file path containing the stderr of the executable.
#
# ```bash
# exe::invokef2piped true "key: val" yq -o json -p yaml -
# stdoutFilePath="${RETURNED_VALUE}"
# stderrFilePath="${RETURNED_VALUE2}"
# ```
#
# > This is the equivalent of:
# > `myvar="$(printf '%s\n' "mystring" | mycommand)"`
# > But without using a subshell.
# >
# > See exe::invokef5 for more information.
#
function exe::invokef2piped() { :; }

# ## exe::invokef5
#
# This function call an executable and its arguments.
# It redirects the stdout and stderr to temporary files.
#
# - $1: **fail** _as bool_:
#       true/false to indicate if the function should fail in case the execution fails.
#                      If true and the execution fails, the script will exit.
# - $2: **acceptable codes** _as string_:
#       the acceptable error codes, comma separated
#         (if the error code is matched, then set the output error code to 0)
# - $3: **sdtin from file** _as bool_:
#       true/false to indicate if the 4th argument represents a file path or directly the content for stdin
# - $4: **sdtin** _as string_:
#       the stdin (can be empty)
# - $5: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
#
# Returns:
#
# - $?:The exit code of the executable.
# - ${RETURNED_VALUE}: The file path containing the stdout of the executable.
# - ${RETURNED_VALUE2}: The file path containing the stderr of the executable.
#
# ```bash
# exe::invokef5 "false" "130,2" "false" "This is the stdin" "stuff" "--height=10" || core::fail "stuff failed."
# stdoutFilePath="${RETURNED_VALUE}"
# stderrFilePath="${RETURNED_VALUE2}"
# ```
#
# > - In windows, this is tremendously faster to do (or any other invoke flavor):
# >   `exe::invokef5 false 0 false '' mycommand && myvar="${RETURNED_VALUE}"`
# >   than doing:
# >   `myvar="$(mycommand)".`
# > - On linux, it is slightly faster (but it might be slower if you don't have SSD?).
# > - On linux, you can use a tmpfs directory for massive gains over subshells.
#
function exe::invokef5() { :; }

# ## extension1::doNothing
#
# Does nothing
#
# ```bash
# extension1::doNothing
# ```
#
function extension1::doNothing() { :; }

# ## extension2::doNothing
#
# Does nothing
#
# ```bash
# extension2::doNothing
# ```
#
function extension2::doNothing() { :; }

# ## extension3::doNothing
#
# Does nothing
#
# ```bash
# extension3::doNothing
# ```
#
function extension3::doNothing() { :; }

# ## fs::cat
#
# Print the content of a file to stdout.
# This is a pure bash equivalent of cat.
#
# - $1: **path** _as string_:
#       the file to print
#
# ```bash
# fs::cat "myFile"
# ```
#
# > Also see log::printFile if you want to print a file for a user.
#
function fs::cat() { :; }

# ## fs::cleanTempFiles
#
# Removes all the temporary files and directories that were created by the
# fs::createTempFile and fs::createTempDirectory functions.
#
# ```bash
# fs::cleanTempFiles
# ```
# shellcheck disable=SC2016
#
function fs::cleanTempFiles() { :; }

# ## fs::createDirectoryIfNeeded
#
# Create the directory tree if needed.
#
# - $1: **path** _as string_:
#       The directory path to create.
#
# Returns:
#
# - ${RETURNED_VALUE}: The absolute path to the directory.
#
# ```bash
# fs::createDirectoryIfNeeded "/my/directory"
# ```
#
function fs::createDirectoryIfNeeded() { :; }

# ## fs::createFilePathIfNeeded
#
# Make sure that the given file path exists.
# Create the directory tree and the file if needed.
#
# - $1: **path** _as string_:
#       the file path to create
#
# Returns:
#
# - ${RETURNED_VALUE}: The absolute path of the file.
#
# ```bash
# fs::createFilePathIfNeeded "myFile"
# ```
#
function fs::createFilePathIfNeeded() { :; }

# ## fs::createLink
#
# Create a soft or hard link (original ← link).
#
# Reminder:
#
# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the
#   form of an absolute or relative path.
# - A hard link is a directory entry that associates a new pathname with an existing
#   file (inode + data block) on a file system.
#
# This function allows to create a symbolic link on Windows as well as on Unix.
#
# - $1: **linked path** _as string_:
#       the path to link to (the original file)
# - $2: **link path** _as string_:
#       the path where to create the link
# - $3: hard link _as boolean_:
#       (optional) true to create a hard link, false to create a symbolic link
#       (defaults to false)
# - $4: force _as boolean_:
#       (optional) true to overwrite the link or file if it already exists.
#       Otherwise, the function will fail on an existing link.
#       (defaults to true)
#
# ```bash
# fs::createLink "/path/to/link" "/path/to/linked"
# fs::createLink "/path/to/link" "/path/to/linked" true
# ```
#
# > The function uses the `ln` command.
#
function fs::createLink() { :; }

# ## fs::createTempDirectory
#
# Creates a temporary directory.
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
#
function fs::createTempDirectory() { :; }

# ## fs::createTempFile
#
# Creates a temporary file and return its path.
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempFile
# local file="${RETURNED_VALUE}"
# ```
#
# > Files created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
#
function fs::createTempFile() { :; }

# ## fs::getFileLineCount
#
# Get the number of lines in a file.
#
# - $1: **path** _as string_:
#       the file path to read
#
# Returns:
#
# - ${RETURNED_VALUE}: The number of lines in the file.
#
# ```bash
# fs::getFileLineCount "/path/to/file"
# local lineCount="${RETURNED_VALUE}"
# ```
#
function fs::getFileLineCount() { :; }

# ## fs::head
#
# Print the first lines of a file to stdout.
# This is a pure bash equivalent of head.
#
# - $1: **path** _as string_:
#       The file to print.
# - $2: **number of lines** _as int_:
#       The number of lines to print.
# - $3: to variable _as bool_:
#       (optional) Can be set using the variable `_OPTION_TO_VARIABLE`.
#       If true, the output will be stored in the variable `RETURNED_ARRAY`
#       instead of being printed to stdout.
#       (defaults to false)
#
# ```bash
# fs::head "myFile" 10
# ```
#
# > #TODO: faster with mapfile + quantum?
#
function fs::head() { :; }

# ## fs::isDirectoryWritable
#
# Check if the directory is writable. Creates the directory if it does not exist.
#
# - $1: **directory** _as string_:
#       the directory to check
# - $2: test file name _as string_:
#       (optional) the name of the file to create in the directory to test the write access
#
# Returns:
#
# - $?:
#   - 0 if the directory is writable
#   - 1 otherwise
#
# ```bash
# if fs::isDirectoryWritable "/path/to/directory"; then
#   echo "The directory is writable."
# fi
# ```
#
function fs::isDirectoryWritable() { :; }

# ## fs::listDirectories
#
# List all the directories in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - $2: recursive _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - $3: hidden _as bool_:
#       (optional) true to list hidden paths, false otherwise
#       (defaults to false)
# - $4: directory filter function name _as string_:
#       (optional) a function name that is called to filter the sub directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to empty string, no filter)
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array with the list of all the files.
#
# ```bash
# fs::listDirectories "/path/to/directory" true true myFilterFunction
# for path in "${RETURNED_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
#
function fs::listDirectories() { :; }

# ## fs::listFiles
#
# List all the files in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - $2: recursive _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - $3: hidden _as bool_:
#       (optional) true to list hidden paths, false otherwise
#       (defaults to false)
# - $4: directory filter function name _as string_:
#       (optional) a function name that is called to filter the directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to empty string, no filter)
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array with the list of all the files.
#
# ```bash
# fs::listFiles "/path/to/directory" true true myFilterFunction
# for path in "${RETURNED_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
#
function fs::listFiles() { :; }

# ## fs::listPaths
#
# List all the paths in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - $2: recursive _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - $3: hidden _as bool_:
#       (optional) true to list hidden paths, false otherwise
#       (defaults to false)
# - $4: path filter function name _as string_:
#       (optional) a function name that is called to filter the paths that will be listed
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to empty string, no filter)
# - $5: directory filter function name _as string_:
#       (optional) a function name that is called to filter the directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to empty string, no filter)
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array with the list of all the paths.
#
# ```bash
# fs::listPaths "/path/to/directory" true true myFilterFunction myFilterDirectoryFunction
# for path in "${RETURNED_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
#
# > - It will correctly list files under symbolic link directories.
#
function fs::listPaths() { :; }

# ## fs::readFile
#
# Reads the content of a file and returns it in the global variable RETURNED_VALUE.
# Uses pure bash.
#
# - $1: **path** _as string_:
#       the file path to read
# - $2: max char _as int_:
#       (optional) the maximum number of characters to read
#       (defaults to 0, which means read the whole file)
#
# > If the file does not exist, the function will return an empty string instead of failing.
#
# Returns:
#
# - ${RETURNED_VALUE}: The content of the file.
#
# ```bash
# fs::readFile "/path/to/file" && local fileContent="${RETURNED_VALUE}"
# fs::readFile "/path/to/file" 500 && local fileContent="${RETURNED_VALUE}"
# ```
#
function fs::readFile() { :; }

# ## fs::tail
#
# Print the last lines of a file to stdout.
# This is a pure bash equivalent of tail.
# However, because we have to read the whole file, it is not efficient for large files.
#
# - $1: **path** _as string_:
#       The file to print.
# - $2: **number of lines** _as int_:
#       The number of lines to print from the end of the file.
# - $3: to variable _as bool_:
#       (optional) Can be set using the variable `_OPTION_TO_VARIABLE`.
#       If true, the output will be stored in the variable `RETURNED_ARRAY`
#       instead of being printed to stdout.
#       (defaults to false)
#
# ```bash
# fs::tail "myFile" 10
# ```
#
# > #TODO: use mapfile quantum to not have to read the whole file in a single go.
#
function fs::tail() { :; }

# ## fs::toAbsolutePath
#
# This function returns the absolute path of a path.
#
# - $1: **path** _as string_:
#       The path to translate to absolute path.
#
# Returns:
#
# - ${RETURNED_VALUE}: The absolute path of the path.
#
# ```bash
# fs::toAbsolutePath "myFile"
# local myFileAbsolutePath="${RETURNED_VALUE}"
# ```
#
# > This is a pure bash alternative to `realpath` or `readlink`.
#
function fs::toAbsolutePath() { :; }

# ##  interactive::askForConfirmation
#
# Ask the user to press the button to continue.
#
# - $1: **prompt** _as string_:
#       the prompt to display
#
# Returns:
#
# - $?:
#   - 0 if the user pressed enter
#   - 1 otherwise
#
# ```bash
# interactive::askForConfirmation "Press enter to continue."
# ```
#
function interactive::askForConfirmation() { :; }

# ## interactive::askForConfirmationRaw
#
# Ask the user to press the button to continue.
#
# This raw version does not display the prompt or the answer.
#
# Returns:
#
# - $?:
#   - 0 if the user pressed enter
#   - 1 otherwise
#
# ```bash
# interactive::askForConfirmationRaw
# ```
#
function interactive::askForConfirmationRaw() { :; }

# ## interactive::displayAnswer
#
# Displays an answer to a previous question.
#
# The text is wrapped and put inside a box like so:
#
# ```text
#     ┌─────┐
#     │ No. ├──░
#     └─────┘
# ```
#
# - $1: **answer** _as string_:
#       the answer to display
# - $2: max width _as int_:
#       (optional) the maximum width of the text in the dialog box
#       (defaults to GLOBAL_COLUMNS)
#
# ```bash
# interactive::displayAnswer "My answer."
# ```
#
function interactive::displayAnswer() { :; }

# ## interactive::displayDialogBox
#
# Displays a dialog box with a speaker and a text.
#
# - $1: **speaker** _as string_:
#       the speaker (system or user)
# - $2: **text** _as string_:
#       the text to display
# - $3: max width _as int_:
#       (optional) the maximum width of the text in the dialog box
#       (defaults to GLOBAL_COLUMNS)
#
# ```bash
# interactive::displayDialogBox "system" "This is a system message."
# ```
#
function interactive::displayDialogBox() { :; }

# ## interactive::displayQuestion
#
# Displays a question to the user.
#
# The text is wrapped and put inside a box like so:
#
# ```text
#    ┌────────────────────────────────┐
# ░──┤ Is this an important question? │
#    └────────────────────────────────┘
# ```
#
# - $1: **prompt** _as string_:
#       the prompt to display
# - $2: max width _as int_:
#       (optional) the maximum width of text in the dialog box
#       (defaults to GLOBAL_COLUMNS)
#
# ```bash
# interactive::displayPrompt "Do you want to continue?"
# ```
#
function interactive::displayQuestion() { :; }

# ## interactive::promptYesNo
#
# Ask the user to yes or no.
#
# - The user can switch between the two options with the arrow keys or space.
# - The user can validate the choice with the enter key.
# - The user can also validate immediately with the y or n key.
#
# Dialog boxes are displayed for the question and answer.
#
# - $1: **prompt** _as string_:
#       the prompt to display
# - $2: default _as bool_:
#       (optional) the default value to select
#       (defaults to true)
#
# Returns:
#
# - $?:
#   - 0 if the user answered yes
#   - 1 otherwise
# - ${RETURNED_VALUE}: true or false.
#
# ```bash
# if interactive::promptYesNo "Do you want to continue?"; then echo "Yes."; else echo "No."; fi
# ```
#
function interactive::promptYesNo() { :; }

# ## interactive::promptYesNoRaw
#
# Ask the user to yes or no.
#
# - The user can switch between the two options with the arrow keys or space.
# - The user can validate the choice with the enter key.
# - The user can also validate immediately with the y or n key.
#
# This raw version does not display the prompt or the answer.
#
# - $1: default _as bool_:
#       (optional) the default value to select
#       (defaults to true)
#
# Returns:
#
# - $?:
#   - 0 if the user answered yes
#   - 1 otherwise
# - ${RETURNED_VALUE}: true or false.
#
# ```bash
# interactive::promptYesNoRaw "Do you want to continue?" && local answer="${RETURNED_VALUE}"
# ```
#
function interactive::promptYesNoRaw() { :; }

# ## log::debug
#
# Displays a debug message.
#
# - $@: **message** _as string_:
#       the debug messages to display
#
# ```bash
# log::debug "This is a debug message."
# ```
#
function log::debug() { :; }

# ## log::error
#
# Displays an error message.
#
# - $@: **message** _as string_:
#       the error messages to display
#
# ```bash
# log::error "This is an error message."
# ```
#
# > You probably want to exit immediately after an error and should consider using core::fail function instead.
#
function log::error() { :; }

# ## log::errorTrace
#
# Displays an error trace message.
# This is a trace message that is always displayed, independently of the log level.
# It can be used before a fatal error to display useful information.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::errorTrace "This is a debug message."
# ```
#
function log::errorTrace() { :; }

# ## log::getLevel
#
# Get the current log level.
#
# Returns:
#
# - ${RETURNED_VALUE}: The current log level.
#
# ```bash
# log::getLevel
# printf '%s\n' "The log level is ⌜${RETURNED_VALUE}⌝."
# ```
#
function log::getLevel() { :; }

# ## log::info
#
# Displays an info message.
#
# - $@: **message** _as string_:
#       the info messages to display
#
# ```bash
# log::info "This is an info message."
# ```
#
function log::info() { :; }

# ## log::isDebugEnabled
#
# Check if the debug mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if debug mode is enabled (log level is debug)
#   - 1 if disabled
#
# ```bash
# if log::isDebugEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
#
function log::isDebugEnabled() { :; }

# ## log::isTraceEnabled
#
# Check if the trace mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if trace mode is enabled (log level is trace)
#   - 1 if disabled
#
# ```bash
# if log::isTraceEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
#
function log::isTraceEnabled() { :; }

# ## log::printCallStack
#
# This function prints the current function stack in the logs.
#
# - $1: Stack to skip _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP`.
#       The number of stack to skip.
#       (defaults to 2 which skips this function and the first calling function
#       which is usually the onError function)
# - $2: Stack to skip at end _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP_AT_END`.
#       The number of stack to skip at the end.
#       (defaults to 0)
#
# ```bash
# log::printCallStack
# log::printCallStack 0
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
#
function log::printCallStack() { :; }

# ## log::printFile
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **path** _as string_:
#       the file path to display.
# - $2: max lines _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFile "/my/file/path"
# ```
# shellcheck disable=SC2317
#
function log::printFile() { :; }

# ## log::printFileString
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **content** _as string_:
#       the file content.
# - $2: **max lines** _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFileString "myfilecontent"
# ```
# shellcheck disable=SC2317
#
function log::printFileString() { :; }

# ## log::printRaw
#
# Display something in the log stream.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to print (can contain new lines)
#
# ```bash
# log::printRaw "my line"
# ```
# shellcheck disable=SC2317
#
function log::printRaw() { :; }

# ## log::printString
#
# Display a string in the log.
# The string will be aligned with the current log output and hard wrapped if necessary.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to log (can contain new lines)
# - $2: new line pad string _as string_:
#       (optional) the string with which to prepend each wrapped line
#       (empty by default)
#
# ```bash
# log::printString "my line"
# ```
# shellcheck disable=SC2317
#
function log::printString() { :; }

# ## log::setLevel
#
# Set the log level.
#
# - $1: **log level** _as string_:
#       The log level to set (or defaults to info), acceptable values are:
#   - trace
#   - debug
#   - info
#   - success
#   - warning
#   - error
# - $2: silent _as bool_:
#       (optional) true to silently switch log level, i.e. does not print a message
#       (defaults to false)
#
# ```bash
# log::setLevel debug
# log::setLevel debug true
# ```
#
function log::setLevel() { :; }

# ## log::success
#
# Displays a success message.
#
# - $@: **message** _as string_:
#       the success messages to display
#
# ```bash
# log::success "This is a success message."
# ```
#
function log::success() { :; }

# ## log::trace
#
# Displays a trace message.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::trace "This is a trace message."
# ```
#
function log::trace() { :; }

# ## log::warning
#
# Displays a warning.
#
# - $@: **message** _as string_:
#       the warning messages to display
#
# ```bash
# log::warning "This is a warning message."
# ```
#
function log::warning() { :; }

# ## profiler::disable
#
# Disable the profiler if previously activated with profiler::enable.
#
# ```bash
# profiler::disable
# ```
#
function profiler::disable() { :; }

# ## profiler::enable
#
# Enables the profiler and start writing to the given file.
#
# - $1: **path** _as string_:
#       the file to write to.
#
# ```bash
# profiler::enable "${HOME}/valet-profiler-${BASHPID}.txt"
# ```
#
# > There can be only one profiler active at a time.
#
function profiler::enable() { :; }

# ## progress::start
#
# Shows a spinner / progress animation with configurable output including a progress bar.
#
# The animation will be displayed until progress::stop is called
# or if the max number of frames is reached.
#
# Outputs to stderr.
# This will run in the background and will not block the main thread.
# The main thread can continue to output logs while this animation is running.
#
# - $1: output template _as string_:
#       (optional) the template to display
#       (defaults to VALET_CONFIG_PROGRESS_BAR_TEMPLATE="#spinner #percent ░#bar░ #message")
# - $2: max width _as int_:
#       (optional) the maximum width of the progress bar
#       (defaults to VALET_CONFIG_PROGRESS_BAR_SIZE=20)
# - $3: frame delay _as float_:
#       (optional) the time in seconds between each frame of the spinner
#       (defaults to VALET_CONFIG_PROGRESS_ANIMATION_DELAY=0.1)
# - $4: refresh every x frames _as int_:
#       (optional) the number of frames of the spinner to wait before refreshing the progress bar
#       (defaults to VALET_CONFIG_PROGRESS_BAR_UPDATE_INTERVAL=3)
# - $5: max frames _as int_:
#       (optional) the maximum number of frames to display
#       (defaults to 9223372036854775807)
# - $6: spinner _as string_:
#       (optional) the spinner to display (each character is a frame)
#       (defaults to VALET_CONFIG_SPINNER_CHARACTERS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏")
#       Examples:
#       - ◐◓◑◒
#       - ▖▘▝▗
#       - ⣾⣽⣻⢿⡿⣟⣯⣷
#       - ⢄⢂⢁⡁⡈⡐⡠
#       - ◡⊙◠
#       - ▌▀▐▄
#       - ⠄⠆⠇⠋⠙⠸⠰⠠⠰⠸⠙⠋⠇⠆
#
# ```bash
# progress::start "#spinner" "" 0.05 "" "" "⢄⢂⢁⡁⡈⡐⡠"
# wait 4
# progress::stop
#
# progress::start "#spinner #percent ░#bar░ #message" 30 0.05 1
# IDX=0
# while [[ ${IDX} -le 50 ]]; do
#   progress::update $((IDX * 2)) "Doing something ${IDX}/50..."
#   IDX=$((IDX + 1))
#   sleep 0.1
# done
# ```
#
function progress::start() { :; }

# ## progress::stop
#
# Stop the progress bar.
#
# ```bash
# progress::stop
# ```
#
function progress::stop() { :; }

# ## progress::update
#
# Update the progress bar with a new percentage and message.
#
# The animation can be started with progress::start for more options.
# The animation will stop if the updated percentage is 100.
#
# - $1: **percent** _as int_:
#       the percentage of the progress bar (0 to 100)
# - $2: message _as string_:
#       (optional) the message to display
#
# ```bash
# progress::update 50 "Doing something..."
# ```
#
function progress::update() { :; }

# ## regex::getFirstGroup
#
# Matches a string against a regex and returns the first capture group of the matched string.
#
# - $1: **string** _as string_:
#       the string to match
# - $2: **regex** _as string_:
#       the regex
#
# Returns:
#
# - ${RETURNED_VALUE}: the first capture group in the matched string.
#                     Empty if no match.
#
# ```bash
# regex::getFirstGroup "name: julien" "name:(.*)"
# echo "${RETURNED_VALUE}"
# ```
#
# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions
#
function regex::getFirstGroup() { :; }

# ## sfzf::show
#
# Displays a menu where the user can search and select an item.
# The menu is displayed in full screen.
# Each item can optionally have a description/details shown in a right panel.
# The user can search for an item by typing.
#
# - $1: **prompt** _as string_:
#       The prompt to display to the user (e.g. Please pick an item).
# - $2: **array name** _as string_:
#       The items to display (name of a global array).
# - $3: select callback function name _as string_:
#       (optional) The function to call when an item is selected
#       (defaults to empty, no callback)
#       this parameter can be left empty to hide the preview right pane;
#       otherwise the callback function should have the following signature:
#   - $1: the current item
#   - $2: the item number;
#   - $3: the current panel width;
#   - it should return the details of the item in the `RETURNED_VALUE` variable.
# - $4: preview title _as string_:
#       (optional) the title of the preview right pane (if any)
#       (defaults to empty)
#
# Returns:
#
# - ${RETURNED_VALUE}: The selected item value (or empty).
# - ${RETURNED_VALUE2}: The selected item index (from the original array).
#                      Or -1 if the user cancelled the selection
#
# ```bash
# declare -g -a SELECTION_ARRAY
# SELECTION_ARRAY=("blue" "red" "green" "yellow")
# sfzf::show "What's your favorite color?" SELECTION_ARRAY
# log::info "You selected: ⌜${RETURNED_VALUE}⌝ (index: ⌜${RETURNED_VALUE2}⌝)"
# ```
#
function sfzf::show() { :; }

# ## source
#
# Allows to source/include a library file or sources a file.
#
# It replaces the builtin source command to make sure that we do not source the same library twice.
# We replace source instead of creating a new function to allow us to
# specify the included file for spellcheck.
#
# - $1: **library name or path** _as string_:
#       the name of the library (array, interactive, string...) or the file path to include.
# - $@: arguments _as any_:
#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).
#
# ```bash
#   source string
#   source ./my/path
# ```
#
# > - The file can be relative to the current script (script that calls this function).
# > - Use `builtin source` if you want to include the file even if it was already included.
#
function source() { :; }

# ## string::convertCamelCaseToSnakeCase
#
# This function convert a camelCase string to a SNAKE_CASE string.
# It uses pure bash.
# Removes all leading underscores.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="myCamelCaseString"
# string::convertCamelCaseToSnakeCase MY_STRING
# echo "${RETURNED_VALUE}"
# ```
#
function string::convertCamelCaseToSnakeCase() { :; }

# ## string::convertKebabCaseToCamelCase
#
# This function convert a kebab-case string to a camelCase string.
# It uses pure bash.
# Removes all leading dashes.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="my-kebab-case-string"
# string::convertKebabCaseToCamelCase MY_STRING
# echo "${RETURNED_VALUE}"
# ```
#
function string::convertKebabCaseToCamelCase() { :; }

# ## string::convertKebabCaseToSnakeCase
#
# This function convert a kebab-case string to a SNAKE_CASE string.
# It uses pure bash.
# Removes all leading dashes.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="my-kebab-case-string"
# string::convertKebabCaseToSnakeCase MY_STRING
# echo "${RETURNED_VALUE}"
# ```
#
function string::convertKebabCaseToSnakeCase() { :; }

# ## string::count
#
# Counts the number of occurrences of a substring in a string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string in which to count occurrences.
# - $2: **substring** _as string_:
#       the substring to count
#
# Returns:
#
# - ${RETURNED_VALUE}: the number of occurrences
#
# ```bash
# MY_STRING="name,first_name,address"
# string::count MY_STRING ","
# echo "${RETURNED_VALUE}"
# ```
#
# > This is faster than looping over the string and check the substring.
#
function string::count() { :; }

# ## string::doForEachLine
#
# Execute a callback function for each item (e.g. line) of a string.
# The string is split using a separator (default to a new line) and
# the callback function is called for each item.
#
# - $1: **string variable name** _as string_:
#       The name of the variable containing the string.
# - $2: **callback function** _as string_:
#       The name of the function to execute for each item (line).
#       The function is called with the following arguments:
#
#       - $1: the current item (line) content
#
#       The function must return 0 if we should continue to the next line, 1 otherwise.
#       (defaults to empty)
# - $3: separator _as string_:
#       (optional) Can be set using the variable `_OPTION_SEPARATOR`.
#       The separator character to use.
#       (defaults to newline if not provided)
#
# ```bash
# string::doForEachLine myString myCallback
# ```
#
# > This function provides a convenient way to avoid using a "here string" and handles extra
# > newlines (which is not the case with a "for loop" using parameter expansion and IFS=$'\n').
# > Here string is significantly slower than using this.
#
function string::doForEachLine() { :; }

# ## string::extractBetween
#
# Extract the text between two strings within a string.
# Search for the first occurrence of the start string and the first occurrence
# (after the start index) of the end string.
# Both start and end strings are excluded in the extracted text.
# Both start and end strings must be found to extract something.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to extract a text.
# - $2: **start string** _as string_:
#       the start string
#       (if empty, then it will extract from the beginning of the string)
# - $3: **end string** _as string_:
#       the end string
#       (if empty, then it will extract until the end of the string)
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted text
#
# ```bash
# MY_STRING="This is a long text"
# string::extractBetween MY_STRING "is a " " text"
# local extractedText="${RETURNED_VALUE}"
# ```
#
function string::extractBetween() { :; }

# ## string::getField
#
# Allows to get the nth element of a string separated by a given separator.
# This is the equivalent of the cut command "cut -d"${separator}" -f"${fieldNumber}""
# but it uses pure bash to go faster.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to extract from.
# - $2: **field number** _as int_:
#       The field number to get (starting at 0).
# - $3: separator _as string_:
#       The separator to use.
#       (defaults to tab if not provided)
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="field1 field2 field3"
# string::getField MY_STRING 1 " "
# echo "${RETURNED_VALUE}"
# ```
#
# > This is faster than:
# >
# > - using read into an array from a here string
# > - using bash parameter expansion to remove before/after the separator
#
function string::getField() { :; }

# ## string::getIndexOf
#
# Find the first index of a string within another string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to find an index.
# - $2: **search** _as string_:
#       the string to search
# - $3: start index _as int_:
#       (optional) the starting index
#       (defaults to 0)
#
# Returns:
#
# - ${RETURNED_VALUE}: the index of the substring in the string or -1 if not found.
#
# ```bash
# MY_STRING="This is a long text"
# string::getIndexOf MY_STRING "long"
# echo "${RETURNED_VALUE}"
# ```
#
function string::getIndexOf() { :; }

# ## string::head
#
# Get the first nth items (e.g. lines) of a string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to get the first occurrences.
# - $2: **nb items** _as int_:
#       The number of items (lines) to extract.
# - $3: separator _as string_:
#       (optional) Can be set using the variable `_OPTION_SEPARATOR`.
#       The separator character to use.
#       (defaults to newline if not provided)
#
# Returns:
#
# - ${RETURNED_VALUE}: The extracted string.
#
# ```bash
# MY_STRING="line1"$'\n'"line2"$'\n'"line3"
# string::head MY_STRING 2
# echo "${RETURNED_VALUE}"
# ```
#
function string::head() { :; }

# ## string::highlight
#
# Highlight a pattern (each character of this pattern) in a string.
#
# - $1: **text** _as string_:
#       The text to highlight.
# - $2: **pattern** _as string_:
#       The pattern to highlight.
# - $3: highlight ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_HIGHLIGHT_ANSI`.
#       The ANSI code to use for highlighting.
#       (defaults to VALET_CONFIG_COLOR_HIGHLIGHT)
# - $4: reset ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_RESET_ANSI`.
#       The ANSI code to use for resetting the highlighting.
#       (defaults to VALET_CONFIG_COLOR_DEFAULT)
#
# Returns:
#
# - ${RETURNED_VALUE}: the highlighted text
#
# ```bash
# string::highlight "This is a text to highlight." "ttttt"
# echo "${RETURNED_VALUE}"
# ```
#
# > - All characters in the pattern must be found in the same order in the matched line.
# > - This functions is case insensitive.
#
function string::highlight() { :; }

# ## string::split
#
# Split a string into an array using a separator.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to split.
# - $2: **separators** _as string_:
#       The separator characters to use.
#
# Returns:
#
# - ${RETURNED_ARRAY}: the array of strings
#
# ```bash
# MY_STRING="name,first_name,address"
# string::split MY_STRING ","
# ARRAY=("${RETURNED_ARRAY[@]}")
# ```
#
# > This is faster than using read into an array from a here string.
#
function string::split() { :; }

# ## string::trimAll
#
# Trim all whitespaces and truncate spaces.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to trim.
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="   example "$'\t'"  string    "$'\n'
# string::trimAll MY_STRING
# echo "${RETURNED_VALUE}"
# ```
#
function string::trimAll() { :; }

# ## string::trimEdges
#
# Trim leading and trailing characters (defaults to whitespaces).
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to trim.
# - $2: characters to trim _as string_:
#       The characters to trim.
#       (defaults to " "$'\t'$'\n')
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# MY_STRING="   example  string    "
# string::trimEdges MY_STRING
# echo "${RETURNED_VALUE}"
# ```
#
function string::trimEdges() { :; }

# ## string::wrapCharacters
#
# Allows to hard wrap the given string at the given width.
# Wrapping is done at character boundaries, see string::warpText for word wrapping.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped string
# - ${RETURNED_VALUE2}: the length taken on the last line
#
# ```bash
# string::wrapCharacters "This is a long text that should be wrapped at 20 characters." 20 --- 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - It considers escape sequence for text formatting and does not count them as visible characters.
# > - Leading spaces after a newly wrapped line are removed.
#
function string::wrapCharacters() { :; }

# ## string::wrapWords
#
# Allows to soft wrap the given text at the given width.
# Wrapping is done at word boundaries.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped text
#
# ```bash
# string::wrapWords "This is a long text that should be wrapped at 20 characters." 20 '  ' 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
# > - It considers escape sequence for text formatting and does not count them as visible characters.
#
function string::wrapWords() { :; }

# ## system::addToPath
#
# Add the given path to the PATH environment variable for various shells,
# by adding the appropriate export command to the appropriate file.
#
# Will also export the PATH variable in the current bash.
#
# - $1: **path** _as string_:
#       the path to add to the PATH environment variable.
#
# ```bash
# system::addToPath "/path/to/bin"
# ```
#
function system::addToPath() { :; }

# ## system::getEnvVars
#
# Get the list of all the environment variables.
# In pure bash, no need for env or printenv.
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array with the list of all the environment variables.
#
# ```bash
# system::getEnvVars
# for var in "${RETURNED_ARRAY[@]}"; do
#   printf '%s=%s\n' "${var}" "${!var}"
# done
# ```
#
# > This is faster than using mapfile on <(compgen -v).
#
function system::getEnvVars() { :; }

# ## system::getOs
#
# Returns the name of the current OS.
#
# Returns:
#
# - ${RETURNED_VALUE}: the name of the current OS: "darwin", "linux" or "windows".
#
# ```bash
# system::getOs
# local osName="${RETURNED_VALUE}"
# ```
#
function system::getOs() { :; }

# ## system::isRoot
#
# Check if the script is running as root.
#
# Returns:
#
# - $?
#   - 0 if the script is running as root
#   - 1 otherwise.
#
# ```bash
# if system::isRoot; then
#   printf 'The script is running as root.'
# fi
# ```
#
function system::isRoot() { :; }

# ## test::exec
#
# Call this function to execute a command and write the command and its output to the report file.
# The command can fail, in which case the returned exit code is written to the report file.
# However, the command must not call `exit` (in which case, use test::exit).
#
# - $@: **command** _as string_:
#       The command to execute.
#
# ```bash
# test::exec echo "Hello, world!"
# ```
#
function test::exec() { :; }

# ## test::exit
#
# Call this function to execute a command that can call `exit` and write the command and its output to the report file.
# The command is executed in a subshell to catch the exit.
#
# - $@: **command** _as string_:
#       The command to execute.
#
# ```bash
# test::exit exit 3
# ```
#
function test::exit() { :; }

# ## test::fail
#
# Call this function to log a message and exit with the status 142, which
# indicates to the self test command that the test failed and that we know the
# reason (it is a bad implementation of the test itself).
#
# - $@: **message** _as string_:
#       The message to log.
#
# ```bash
# test::fail "This is a failure message with a clear reason."
# ```
#
function test::fail() { :; }

# ## test::flush
#
# Call this function to flush the standard and error outputs to the report file.
# They will be added as code blocks in the report file (one for the standard
# output, one for the standard error).
#
# ```bash
# test::flush
# ```
#
function test::flush() { :; }

# ## test::flushStderr
#
# Call this function to flush the standard error to the report file.
# It will be added as a code block in the report file.
#
# - $1: blockTitle _as string_:
#       (optional) Can be set using the variable `_OPTION_BLOCK_TITLE`.
#       Add a 'title' to the code block (`**title**:` before the code block).
#       (defaults to '' which will not add a title)
#
# ```bash
# test::flushStderr
# ```
#
function test::flushStderr() { :; }

# ## test::flushStdout
#
# Call this function to flush the standard output to the report file.
# It will be added as a code block in the report file.
#
# - $1: blockTitle _as string_:
#       (optional) Can be set using the variable `_OPTION_BLOCK_TITLE`.
#       Add a 'title' to the code block (`**title**:` before the code block).
#       (defaults to '' which will not add a title)
#
# ```bash
# test::flushStdout
# ```
#
function test::flushStdout() { :; }

# ## test::func
#
# Call this function to test a function that returns a value using the valet
# conventions (RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY, etc...).
#
# It will write the command and its output to the report file.
# It will also print the returned values.
#
# - $@: **command** _as string_:
#       The command to execute (function and its arguments).
#
# ```bash
# test::func myFunction
# ```
#
function test::func() { :; }

# ## test::log
#
# Call this function to log a message during a test.
# This log will only show in case of a script error or when the debug
# log level is enabled when running the tests.
#
# - $@: **messages** _as string_:
#       The messages to log.
#
# ```bash
# test::log "This is a log message."
# ```
#
function test::log() { :; }

# ## test::markdown
#
# Call this function to add some markdown in the report file.
#
# - $@: **markdown** _as string_:
#       The markdown to add in the report file.
#
# ```bash
# test::markdown "> This is a **quote**."
# ```
#
function test::markdown() { :; }

# ## test::printReturnedVars
#
# This function can be called to print the returned values,
# e.g. RETURNED_VALUE, RETURNED_VALUE2, RETURNED_ARRAY...
# They will each be printed in a code block in the report file.
#
# ```bash
# test::printReturnedVars
# ```
#
function test::printReturnedVars() { :; }

# ## test::printVars
#
# This function can be called to print the global variables in the report file.
# They will printed in a code block in the report file.
#
# - $@: **variables** _as string_:
#       The variables to print.
#
# ```bash
# test::printVars myVar
# ```
#
function test::printVars() { :; }

# ## test::prompt
#
# Call this function to print a 'prompt' (markdown that looks like a prompt) in the report file.
#
# - $@: **command** _as string_:
#       The command to print as a prompt.
#
# ```bash
# test::prompt "echo 'Hello, world!'"
# ```
#
function test::prompt() { :; }

# ## test::resetReturnedVars
#
# Resets the value of each RETURNED_ variable.
#
# ```bash
# test::resetReturnedVars
# ```
#
function test::resetReturnedVars() { :; }

# ## test::title
#
# Call this function to add an H3 title in the report file.
#
# - $1: title _as string_:
#       (optional) Can be set using the variable `_OPTION_TITLE`.
#       The title of the test.
#      (defaults to "Test")
#
# ```bash
# test::title "Testing something"
# ```
#
function test::title() { :; }

# ## test::transformReturnedVarsBeforePrinting
#
# This function can be defined to modify the returned variables before printing them in the report.
#
# > You can define this function directly in the test script, or in a test hook if
# > you need it to be available for multiple tests.
# > Note however that this function can be called very often, so it should be optimized.
#
function test::transformReturnedVarsBeforePrinting() { :; }

# ## test::transformTextBeforeFlushing
#
# This function can be defined to modify the flushed text before adding it to the report.
#
# The text to transform is in the global variable `_TEST_OUTPUT`.
#
# Returns:
#
# - `_TEST_OUTPUT`: The modified text.
#
# > You can define this function directly in the test script, or in a test hook if
# > you need it to be available for multiple tests.
# > Note however that this function can be called very often, so it should be optimized.
#
function test::transformTextBeforeFlushing() { :; }

# ## time::convertMicrosecondsToHuman
#
# Convert microseconds to human readable format.
#
# - $1: **microseconds** _as int_:
#       the microseconds to convert
# - $2: format _as string_:
#      (optional) Can be set using the variable `_OPTION_FORMAT`.
#      the format to use (defaults to "%HH:%MM:%SS")
#      Usable formats:
#      - %HH: hours
#      - %MM: minutes
#      - %SS: seconds
#      - %LL: milliseconds
#      - %h: hours without leading zero
#      - %m: minutes without leading zero
#      - %s: seconds without leading zero
#      - %l: milliseconds without leading zero
#      - %u: microseconds without leading zero
#      - %M: total minutes
#      - %S: total seconds
#      - %L: total milliseconds
#      - %U: total microseconds
#
# Returns:
#
# - ${RETURNED_VALUE}: the human readable format
#
# ```bash
# time::convertMicrosecondsToHuman 123456789
# echo "${RETURNED_VALUE}"
# ```
#
function time::convertMicrosecondsToHuman() { :; }

# ## time::getDate
#
# Get the current date in the given format.
#
# - $1: format _as string_:
#       (optional) the format of the date to return
#       (defaults to %(%F_%Hh%Mm%Ss)T).
#
# Returns:
#
# - ${RETURNED_VALUE}: the current date in the given format.
#
# ```bash
# time::getDate
# local date="${RETURNED_VALUE}"
# ```
#
# > This function avoid to call $(date) in a subshell (date is a an external executable).
#
function time::getDate() { :; }

# ## time::getProgramElapsedMicroseconds
#
# Get the elapsed time in µs since the program started.
#
# Returns:
#
# - ${RETURNED_VALUE}: the elapsed time in µs since the program started.
#
# ```bash
# core::getElapsedProgramTime
# echo "${RETURNED_VALUE}"
# time::convertMicrosecondsToHuman "${RETURNED_VALUE}"
# echo "Human time: ${RETURNED_VALUE}"
# ```
#
# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.
# > The 10# forces the base 10 conversion to avoid issues with leading zeros.
# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.
#
function time::getProgramElapsedMicroseconds() { :; }

# ## tui::clearBox
#
# Clear a "box" in the terminal.
# Will return the cursor at the current position at the end (using GLOBAL_CURSOR_LINE and GLOBAL_CURSOR_COLUMN).
#
# - $1: **top** _as int_:
#       the left position of the box
# - $2: **left** _as int_:
#       the top position of the box
# - $3: **width** _as int_:
#       the width of the box
# - $4: **height** _as int_:
#       the height of the box
#
# ```bash
# tui::getCursorPosition
# tui::clearBox 1 1 10 5
# ```
#
function tui::clearBox() { :; }

# ## tui::clearKeyPressed
#
# This function reads all the inputs from the user, effectively discarding them.
#
# ```bash
# tui::clearKeyPressed
# ```
#
function tui::clearKeyPressed() { :; }

# ## tui::createSpace
#
# This function creates empty lines from the current cursor position.
# Then it moves back to its original line (at the column 1).
# The current cursor line counts, meaning that `tui::createSpace 1` will
# not do anything but clear the current line.
#
# This effectively creates a space in the terminal (scroll up if we are at the bottom).
# It does not create more space than the number of lines in the terminal.
#
# - $1: **number of lines** _as int_:
#       the number of lines to create
#
# ```bash
# tui::createSpace 5
# ```
#
function tui::createSpace() { :; }

# ## tui::getBestAutocompleteBox
#
# This function returns the best position and size for an autocomplete box that would open
# at the given position.
#
# - The box will be placed below the current position if possible, but can be placed
#   above if there is not enough space below.
# - The box will be placed on the same column as the current position if possible, but can be placed
#   on the left side if there is not enough space on the right to display the full width of the box.
# - The box will have the desired height and width if possible, but will be reduced if there is
#   not enough space in the terminal.
# - The box will not be placed on the same line as the current position if notOnCurrentLine is set to true.
#   Otherwise it can use the current position line.
#
# - $1: **current line** _as int_:
#       the current line of the cursor (1 based)
# - $2: **current column** _as int_:
#       the current column of the cursor (1 based)
# - $3: **desired height** _as int_:
#       the desired height of the box
# - $4: **desired width** _as int_:
#       the desired width of the box
# - $5: **max height** _as int_:
#       the maximum height of the box
# - $6: force below _as bool_:
#       (optional) force the box to be below the current position
#       (defaults to false)
# - $7: not on current line _as bool_:
#       (optional) the box will not be placed on the same line as the current position
#       (defaults to true)
# - $8: terminal width _as int_:
#       (optional) the width of the terminal
#       (defaults to GLOBAL_COLUMNS)
# - $9: terminal height _as int_:
#       (optional) the height of the terminal
#       (defaults to GLOBAL_LINES)
#
# Returns:
#
# - ${RETURNED_VALUE}: the top position of the box (1 based)
# - ${RETURNED_VALUE2}: the left position of the box (1 based)
# - ${RETURNED_VALUE3}: the width of the box
# - ${RETURNED_VALUE4}: the height of the box
#
# ```bash
# tui::getBestAutocompleteBox 1 1 10 5
# ```
#
function tui::getBestAutocompleteBox() { :; }

# ## tui::getCursorPosition
#
# Get the current cursor position.
#
# Returns:
#
# - `GLOBAL_CURSOR_LINE`: the line number
# - `GLOBAL_CURSOR_COLUMN`: the column number
#
# ```bash
# tui::getCursorPosition
# ```
#
function tui::getCursorPosition() { :; }

# ## tui::getTerminalSize
#
# This function exports the terminal size.
#
# Returns:
#
# - `GLOBAL_COLUMNS`: The number of columns in the terminal.
# - `GLOBAL_LINES`: The number of lines in the terminal.
#
# ```bash
# tui::getTerminalSize
# printf '%s\n' "The terminal has ⌜${GLOBAL_COLUMNS}⌝ columns and ⌜${GLOBAL_LINES}⌝ lines."
# ```
#
function tui::getTerminalSize() { :; }

# ## tui::rebindKeymap
#
# Rebinds all special keys to call a given callback function.
# See @tui::testWaitForKeyPress for an implementation example.
#
# This allows to use the `-e` option with the read command and receive events for special key press.
#
# Key binding is a mess because binding is based on the sequence of characters that gets
# generated by the terminal when a key is pressed and this is not standard across all terminals.
# We do our best here to cover most cases but it is by no mean perfect.
# A good base documentation was <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>.
#
# Users of this function can completely change the bindings afterward by implementing
# the `tui::RebindOverride` function.
#
# This function should be called before using tui::waitForKeyPress.
#
# You can call `tui::restoreBindings` to restore the default bindings. However, this is not
# necessary as the bindings are local to the script.
#
# - $1: **callback function** _as string_:
#       The function name to call when a special key is pressed.
#
function tui::rebindKeymap() { :; }

# ## tui::restoreBindings
#
# Reset the key bindings to the default ones.
#
# ```bash
# tui::restoreBindings
# ```
#
function tui::restoreBindings() { :; }

# ## tui::restoreInterruptTrap
#
# Restore the original trap for the interrupt signal (SIGINT).
# To be called after tui::setInterruptTrap.
#
# ```bash
# tui::restoreInterruptTrap
# ```
#
function tui::restoreInterruptTrap() { :; }

# ## tui::restoreTerminalOptions
#
# Restore the terminal options to their original state.
# Should be called after `tui::setTerminalOptions`.
#
# - $1: **force** _as bool_:
#       (optional) force the restoration of the stty configuration
#       stty state will not be restored if
#       (defaults to false)
#
# ```bash
# tui::restoreTerminalOptions
# ```
# shellcheck disable=SC2120
#
function tui::restoreTerminalOptions() { :; }

# ## tui::setInterruptTrap
#
# Set a trap to catch the interrupt signal (SIGINT).
# When the user presses Ctrl+C, the GLOBAL_SESSION_INTERRUPTED variable will be set to true.
#
# ```bash
# tui::setInterruptTrap
# ```
#
function tui::setInterruptTrap() { :; }

# ## tui::setTerminalOptions
#
# Set the terminal options to enable a satisfying and consistent behavior
# for the GNU readline library.
# Disable the echo of the terminal, no longer display the characters typed by the user.
#
# ```bash
# tui::setTerminalOptions
# ```
#
function tui::setTerminalOptions() { :; }

# ## tui::switchBackFromFullScreen
#
# Call this function to switch back from the full screen mode.
#
# - This function will restore the terminal state and show the cursor.
# - It will also restore the key echoing.
# - If there were error messages during the interactive session, they will be displayed at the end.
#
# ```bash
# tui::switchBackFromFullScreen
# ```
#
function tui::switchBackFromFullScreen() { :; }

# ## tui::switchToFullScreen
#
# Call this function to start an interactive session in full screen mode.
# This function will switch to the alternate screen, hide the cursor and clear the screen.
# It will also disable echoing when we type something.
#
# You should call tui::switchBackFromFullScreen at the end of the interactive session.
#
# In the alternate screen, we don't see the error messages so we capture them somewhere else.
#
# ```bash
# tui::switchToFullScreen
# ```
#
function tui::switchToFullScreen() { :; }

# ## tui::testWaitForChar
#
# Wait for the user to send a character to stdin (i.e. wait for a key press)
# and prints the character that bash reads.
#
# Useful to test the `tui::waitForChar` function and see the char sequence we
# get when pressing a key in a given terminal.
#
# See @tui::waitForChar for more information.
#
# ```bash
# tui::testWaitForChar
# ```
#
function tui::testWaitForChar() { :; }

# ## tui::testWaitForKeyPress
#
# Wait for the user to press a key and prints it to the screen.
# This function is used to test the `tui::waitForKeyPress` function.
#
# See @tui::waitForKeyPress for more information.
#
# ```bash
# tui::testWaitForKeyPress
# ```
#
function tui::testWaitForKeyPress() { :; }

# ## tui::waitForChar
#
# Wait for a user input (single char).
# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).
#
# It uses the read builtin command. This will not detect all key combinations.
# The output will depend on the terminal used and the character sequences it sends on each key press.
#
# Some special keys are translated into more readable strings:
# UP, DOWN, RIGHT, LEFT, BACKSPACE, DEL, PAGE_UP, PAGE_DOWN, HOME, END, ESC, F1-F12, ALT+...
# However, this is not at all exhaustive and will depend on the terminal used. Use `tui::waitForKeyPress`
# if you need to listen to special keys.
#
# This simple implementation does not rely on GNU readline and does not require terminal options
# to be set using `tui::setTerminalOptions`.
#
#
# - $@: **read parameters** _as any_:
#       additional parameters to pass to the read command
#
# Returns:
#
# - $?:
#   - 0 if a char was retrieved
#   - 1 otherwise
# - `LAST_KEY_PRESSED`: the last char (key) retrieved.
#
# ```bash
# tui::waitForChar
# tui::waitForChar -t 0.1
# ```
#
# > <https://en.wikipedia.org/wiki/ANSI_escape_code#Terminal_input_sequences>
#
function tui::waitForChar() { :; }

# ## tui::waitForKeyPress
#
# Wait for a key press (single key).
# You can pass additional parameters to the read command (e.g. to wait for a set amount of time).
#
# It uses the read builtin command with the option `-e` to use readline behind the scene.
# This means we can detect more key combinations but all keys needs to be bound first...
# Special keys (CTRL+, ALT+, F1-F12, arrows, etc.) are intercepted using binding.
#
# You must call `tui::rebindKeymap` and `tui::setTerminalOptions` before using this function.
#
# - $@: **read parameters** _as any_:
#       additional parameters to pass to the read command
#
# Returns:
#
# - $?:
#   - 0 if a key was pressed
#   - 1 otherwise
# - `LAST_KEY_PRESSED`: the key pressed.
#
# ```bash
# tui::waitForKeyPress
# tui::waitForKeyPress -t 0.1
# ```
#
# > Due to a bug in bash, if the cursor is at the end of the screen, it will make the screen scroll
# > even when nothing is read... Make sure to not position the cursor at the end of the screen.
#
function tui::waitForKeyPress() { :; }

# ## version::bump
#
# This function allows to bump a semantic version formatted like:
# major.minor.patch-prerelease+build
#
# - $1: **version** _as string_:
#       the version to bump
# - $2: **level** _as string_:
#       the level to bump (major, minor, patch)
# - $3: clear build and prerelease _as bool_:
#       (optional) clear the prerelease and build
#       (defaults to true)
#
# Returns:
#
# - ${RETURNED_VALUE}: the new version string
#
# ```bash
# version::bump "1.2.3-prerelease+build" "major"
# local newVersion="${RETURNED_VALUE}"
# ```
#
function version::bump() { :; }

# ## version::compare
#
# This function allows to compare two semantic versions formatted like:
# major.minor.patch-prerelease+build
#
# - $1: **version1** _as string_:
#       the first version to compare
# - $2: **version2** _as string_:
#       the second version to compare
#
# Returns:
#
# - ${RETURNED_VALUE}:
#   - 0 if the versions are equal,
#   - 1 if version1 is greater,
#   - -1 if version2 is greater
#
# ```bash
# version::compare "2.3.4-prerelease+build" "1.2.3-prerelease+build"
# local comparison="${RETURNED_VALUE}"
# ```
#
# > The prerelease and build are ignored in the comparison.
#
function version::compare() { :; }

# ## windows::addToPath
#
# Add the given path to the PATH environment variable on Windows (current user only).
#
# Will also export the PATH variable in the current bash.
#
# - $1: **path** _as string_:
#       the path to add to the PATH environment variable.
#       The path can be in unix format, it will be converted to windows format.
#
# ```bash
# windows::addToPath "/path/to/bin"
# ```
#
# > This function is only available on Windows, it uses `powershell` to directly modify the registry.
#
function windows::addToPath() { :; }

# ## windows::convertPathFromUnix
#
# Convert a unix path to a Windows path.
#
# - $1: **path** _as string_:
#       the path to convert
#
# Returns:
#
# - ${RETURNED_VALUE}: The Windows path.
#
# ```bash
# windows::convertPathFromUnix "/path/to/file"
# ```
#
# > Handles paths starting with `/mnt/x/` or `/x/`.
#
function windows::convertPathFromUnix() { :; }

# ## windows::convertPathToUnix
#
# Convert a Windows path to a unix path.
#
# - $1: **path** _as string_:
#       the path to convert
#
# Returns:
#
# - ${RETURNED_VALUE}: The unix path.
#
# ```bash
# windows::convertPathToUnix "C:\path\to\file"
# ```
#
# > Handles paths starting with `X:\`.
#
function windows::convertPathToUnix() { :; }

# ## windows::createLink
#
# Create a soft or hard link (original ← link).
#
# Reminder:
#
# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the
#   form of an absolute or relative path.
# - A hard link is a directory entry that associates a new pathname with an existing
#   file (inode + data block) on a file system.
#
# This function allows to create a symbolic link on Windows as well as on Unix.
#
# - $1: **linked path** _as string_:
#       the path to link to (the original file)
# - $2: **link path** _as string_:
#       the path where to create the link
# - $3: hard link _as boolean_:
#       (optional) true to create a hard link, false to create a symbolic link
#       (defaults to false)
# - $4: force _as boolean_:
#       (optional) true to overwrite the link or file if it already exists.
#       Otherwise, the function will not on an existing link not pointing to the
#       target path.
#       (defaults to true)
#
# ```bash
# windows::createLink "/path/to/link" "/path/to/linked"
# windows::createLink "/path/to/link" "/path/to/linked" true
# ```
#
# > On Windows, the function uses `powershell` (and optionally ls to check the existing link).
#
function windows::createLink() { :; }

# ## windows::createTempDirectory
#
# Create a temporary directory on Windows and return the path both for Windows and Unix.
#
# This is useful for creating temporary directories that can be used in both Windows and Unix.
#
# Returns:
#
# - ${RETURNED_VALUE}: The Windows path.
# - ${RETURNED_VALUE2}: The Unix path.
#
# ```bash
# windows::createTempDirectory
# ```
#
# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
#
function windows::createTempDirectory() { :; }

# ## windows::createTempFile
#
# Create a temporary file on Windows and return the path both for Windows and Unix.
#
# This is useful for creating temporary files that can be used in both Windows and Unix.
#
# Returns:
#
# - ${RETURNED_VALUE}: The Windows path.
# - ${RETURNED_VALUE2}: The Unix path.
#
# ```bash
# windows::createTempFile
# ```
#
# > Files created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
#
function windows::createTempFile() { :; }

# ## windows::endPs1Batch
#
# This function will run all the commands that were batched with `windows::startPs1Batch`.
#
# Returns:
#
# - $?
#   - 0 if the command was successful
#   - 1 otherwise.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# windows::startPs1Batch
# windows::runPs1 "Write-Host \"Hello\""
# windows::runPs1 "Write-Host \"World\""
# windows::endPs1Batch
# ```
#
function windows::endPs1Batch() { :; }

# ## windows::getEnvVar
#
# Get the value of an environment variable for the current user on Windows.
#
# - $1: **variable name** _as string_:
#       the name of the environment variable to get.
#
# Returns:
#
# - ${RETURNED_VALUE}: the value of the environment variable.
#
# ```bash
# windows::getEnvVar "MY_VAR"
# echo "${RETURNED_VALUE}"
# ```
#
function windows::getEnvVar() { :; }

# ## windows::runPs1
#
# Runs a PowerShell command.
# This is mostly useful on Windows.
#
# - $1: **command** _as string_:
#       the command to run.
# - $2: run as administrator _as boolean_:
#       (optional) whether to run the command as administrator.
#       (defaults to false).
#
# Returns:
#
# - $?
#   - 0 if the command was successful
#   - 1 otherwise.
# - ${RETURNED_VALUE}: The content of stdout.
# - ${RETURNED_VALUE2}: The content of stderr.
#
# ```bash
# windows::runPs1 "Write-Host \"Press any key:\"; Write-Host -Object ('The key that was pressed was: {0}' -f [System.Console]::ReadKey().Key.ToString());"
# ```
#
function windows::runPs1() { :; }

# ## windows::setEnvVar
#
# Set an environment variable for the current user on Windows.
#
# - $1: **variable name** _as string_:
#       the name of the environment variable to set.
# - $2: **variable value** _as string_:
#       the value of the environment variable to set.
#
# ```bash
# windows::setEnvVar "MY_VAR" "my_value"
# ```
#
# > This function is only available on Windows, it uses `powershell` to directly modify the registry.
#
function windows::setEnvVar() { :; }

# ## windows::startPs1Batch
#
# After running this function, all commands that should be executed by
# `windows::runPs1` will be added to a batch that will only be played
# when `windows::endPs1Batch` is called.
#
# This is a convenient way to run multiple commands in a single PowerShell session.
# It makes up for the fact that running a new PowerShell session for each command is slow.
#
# ```bash
# windows::startPs1Batch
# windows::runPs1 "Write-Host \"Hello\""
# windows::runPs1 "Write-Host \"World\""
# windows::endPs1Batch
# ```
#
function windows::startPs1Batch() { :; }

