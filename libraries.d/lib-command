#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

#===============================================================
# >>> Program arguments parser
#===============================================================

# parse the user arguments for the main program.
function command::parseProgramArguments() {
  command::sourceUserCommands

  _PARSED_COMMANDS=()
  _PARSED_COMMAND_ARGS=()

  # for the main command, we parse the arguments manually
  # this is for performance reasons, we want to stop parsing as soon as possible
  while (( $# > 0 )); do
    if [[ ${#_PARSED_COMMANDS[@]} -gt 0 && "${1}" == "-"* ]]; then
      # we matched the commands and we found an option for the sub command
      break
    fi
    command_parseProgramArgumentsSwitch "$@"
    if (( REPLY < 0 )); then
      break;
    elif (( REPLY > 0 )); then
      shift "${REPLY}"
    fi
    shift
  done

  log::trace "Command found ⌜${_PARSED_COMMANDS[*]}⌝."

  if (( ${#_PARSED_COMMANDS[@]} == 0 )); then
    # no command provided, we show the commands menu

    if [[ ${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3} -eq 0 ]]; then
      # if the user does not want to remember the last choices
      command_showCommandsMenuAndRun "main-menu" CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY
    else
      _COPIED_COMMANDS_ARRAY=("${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}")
      command_showCommandsMenuAndRun "main-menu" _COPIED_COMMANDS_ARRAY
    fi

    return 0
  fi

  local functionName nbArgs exactCommand
  command::fuzzyMatchCommandToFunctionNameOrFail "${_PARSED_COMMANDS[@]}"
  functionName="${REPLY:-}"
  nbArgs="${REPLY2:-}"
  exactCommand="${REPLY3:-}"

  log::trace "Function name found ⌜${functionName}⌝."

  if [[ ${functionName} == "_menu" ]]; then
    # run a menu with the list of sub commands
    command_runMenuWithSubCommands "${exactCommand}" "${_PARSED_COMMAND_ARGS[@]:nbArgs}"
  else
    # run the function without the matched commands in the arguments
    command_runFunction "${functionName}" "${_PARSED_COMMAND_ARGS[@]:nbArgs}"
  fi

  return 0
}

function command_parseProgramArgumentsSwitch() {
  case "${1}" in
  --source)
    printf '%s' "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/main"
    core::exit 0 silent=true
    ;;
  --profiler)
    VALET_PROFILING=true
    ;;
  --log | --log-level)
    if (( $# <= 1 )); then core::fail "Missing value for option ⌜${1}⌝."; fi
    shift
    log::setLevel "${1}"
    REPLY=1
    return 0
    ;;
  -v | --verbose)
    log::setLevel debug
    ;;
  --disable-progress-bars)
    # shellcheck disable=SC2034
    VALET_DISABLE_PROGRESS_BARS=true
    ;;
  --interactive)
    VALET_FORCE_INTERACTIVE_MODE=true
    ;;
  --version)
    core::getVersion
    printf '%s\n' "${REPLY}"
    core::exit 0 silent=true
    ;;
  -h | --help)
    command::printHelp function "this"
    core::exit 0 silent=true
    ;;
  --)
    REPLY=-1
    return 0
    ;;
  --*)
    # if we didn't match any known long option, try to fuzzy find it
    command_fuzzyFindOption "${1}" "${CMD_OPTS_this[@]}"

    if [[ -n ${REPLY2} ]]; then
      # we found a single match! need to parse it
      command_parseProgramArgumentsSwitch "${REPLY2}" "${@:2}"
      return 0
    else
      # we found multiple matches or no match
      core::fail "${REPLY}"
    fi
    ;;
  -*)
    # a single dash and single letter, we don't have a match
    if (( ${#1} <= 2 )); then
      command_getSingleLetterOptions "${CMD_OPTS_this[@]}"
      core::fail "Unknown option letter ⌜${1:1}⌝ in group ⌜${lettersGroup:-"${1}"}⌝. ${REPLY}"
    fi

    # many letters, we can resolve each letter as an option
    local -i letterIndex optionLength=${#1}
    local optionLetter lettersGroup="${1}"
    local -i argsToShift=0
    for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
      optionLetter="${1:letterIndex:1}"
      command_parseProgramArgumentsSwitch "-${optionLetter}" "${@:2 + argsToShift}"
      if (( REPLY > 0 )); then
        argsToShift+=REPLY
      fi
    done
    REPLY=${argsToShift}
    return 0
    ;;
  *)
    _PARSED_COMMANDS+=("${1}")
    # we don't expect more than CMD_MAX_SUB_COMMAND_LEVEL + 1 commands so if we matched enough, break
    if (( ${#_PARSED_COMMANDS[@]} >= CMD_MAX_SUB_COMMAND_LEVEL + 1 )); then
      REPLY=-1
      return 0
    fi
    # if we matched the first command, we can extract the arguments for the sub command
    if [[ "${#_PARSED_COMMANDS[@]}" -eq "1" ]]; then
      _PARSED_COMMAND_ARGS=("$@")
    fi
    ;;
  esac
  REPLY=0
}

# Run a given function
# The first arguments should be the function name,
# the rest of the arguments are the user arguments starting
# from the command name. e.g.:
# sub cmd --opt1 arg1 arg2
#
# $1: the function name
# $2+: the user arguments
function command_runFunction() {
  local functionName
  functionName="${1}"
  shift

  if [[ -z ${functionName} ]]; then
    core::fail "No function name provided."
  fi

  # get command name of the function
  local -n command="CMD_COMMAND_${functionName}"

  # check for sudo if the function requires it
  local -n requiresSudo="CMD_SUDO_${functionName}"
  if [[ ${requiresSudo:-} == "true" ]]; then
    command_checkSudo
  fi

  # source the file in which the function is located if needed
  command::sourceFunction "${functionName}"

  if ! declare -F "${functionName}" 1>/dev/null 2>&1; then
    core::fail "The function ⌜${functionName}⌝ associated with the command ⌜${command}⌝ does not exist."
  fi

  local IFS=' '
  log::debug "Running the command ⌜${command}⌝ with the function ⌜${functionName}⌝ and the arguments ⌜$*⌝."

  # disable startup profile and enable command profile, if needed
  if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi
  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    # shellcheck source=lib-profiler
    source profiler
    local profilerFileName
    printf -v profilerFileName "profiler-%(%FT%H-%M-%S%z)T--PID_%06d--fun_%s.log" "${EPOCHSECONDS}" "${BASHPID}" "${functionName}"
    core::getUserStateDirectory
    profiler::enable "${VALET_CONFIG_COMMAND_PROFILING_FILE:-"${REPLY}/logs/${profilerFileName}"}"
  fi

  # reset IFS to ensure consistent behavior
  IFS=' '$'\t'$'\n'

  # execute the function
  "${functionName}" "$@"

  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi

  return 0
}

# This function checks if the user has sudo privileges.
# If the user has sudo, it will set the SUDO variable to "sudo".
# If the user does not have sudo, it will set the SUDO variable to "".
#
# Usage:
#  command_checkSudo
function command_checkSudo() {
  # sudo
  if command -v sudo 1>/dev/null 2>&1; then
    log::info "This command requires sudo privileges."
    SUDO="sudo"
    ${SUDO} printf '%s' "alright" 1>/dev/null || core::fail "Could not sudo but the command requires it."
  else
    SUDO=""
  fi
}

# Run the a command that has sub command:
# - either show an interactive menu for a command that has sub commands,
# - or display the help for this menu.
#
# $1: the command name
#
# Usage:
#   command_runMenuWithSubCommands "command"
function command_runMenuWithSubCommands() {
  local command="${1}"
  shift

  # export the command name for the menu
  # shellcheck disable=SC2034
  CMD_COMMAND__menu="${command}"

  local parsedArguments
  command_parseFunctionArguments "_menu" "$@"
  parsedArguments="${REPLY}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi
  eval "${parsedArguments}"

  if [[ -n ${help:-} ]]; then
    command::printHelp menu "${command}"
    return 0
  fi

  if [[ -n ${commandArgumentsErrors:-} ]]; then
    core::fail "${commandArgumentsErrors}"
  fi

  # filter the commands to only keep the sub commands of the function
  local line
  declare -g -a FILTERED_COMMANDS_FOR_SUB_MENU=()
  for line in "${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}"; do
    if [[ ${line} =~ ^(${command} [^ ]+ ) ]]; then
      FILTERED_COMMANDS_FOR_SUB_MENU+=("${line}")
    fi
  done

  if (( ${#FILTERED_COMMANDS_FOR_SUB_MENU[@]} == 0 )); then
    core::fail "No sub commands found for ⌜${command}⌝."
  fi

  command_showCommandsMenuAndRun "${command//[^[:alnum:]]/_}" FILTERED_COMMANDS_FOR_SUB_MENU
}

# Show the given commands in an interactive menu and then
# run the selected command if any.
# $1: the menu id
# $2: the command selection items array name
function command_showCommandsMenuAndRun() {
  local menuId commandSelectionItemsArrayName
  menuId="${1}"
  commandSelectionItemsArrayName="${2}"

  # sort the commands according to the last choices
  command::sortCommands "${menuId}" "${commandSelectionItemsArrayName}"

  local commandChoice
  command_showInteractiveCommandsMenu "Please select the command to run." "${commandSelectionItemsArrayName}"
  commandChoice="${REPLY}"

  log::trace "Command choice ⌜${commandChoice}⌝."

  if [[ -z ${commandChoice} ]]; then
    # the user pressed escape or ctrl-c
    return 0
  fi

  command::addLastChoice "${menuId}" "${commandChoice}"

  # get the function name from the command by replacing spaces and hyphens with _
  local functionName
  command_getFunctionNameFromCommand "${commandChoice}"
  functionName="${REPLY}"

  command_runFunction "${functionName}"
}

# This function sorts the commands in the menu by reading
# a file that contains the last used commands (last on top).
# The file is located in the configuration directory of the program.
# $1: the id of the menu (used in the file name)
# $2: the menu body
#
# Usage:
#  command::sortCommands "id" "${commands}" && sortedCommands="${REPLY}"
function command::sortCommands() {
  local menuId="${1}"
  local -n commands="${2}"

  # if the user does not want to remember the last choices, we return
  if [[ "${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}" -eq 0 ]]; then
    return 0
  fi

  local lastChoicesFile
  core::getUserDataDirectory
  lastChoicesFile="${REPLY}/last-choices-${menuId}"
  if [[ ! -f "${lastChoicesFile}" ]]; then
    return 0
  fi

  local lastChoices
  readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"

  local -a unplayedCommands=()
  local -a playedCommands=()

  # list all the unplayed commands
  local unplayedCommands line command lastChoice played
  local -a commandsArray
  for line in "${commands[@]}"; do
    command="${line%%  *}"
    # check if the command has not been played yet
    played=false
    for lastChoice in "${lastChoices[@]}"; do
      if [[ ${lastChoice} == "${command}" ]]; then
        played=true
        break
      fi
    done
    # if not played, add it to the list
    if [[ ${played} == "false" ]]; then
      unplayedCommands+=("${line}")
    fi
    commandsArray+=("${line}")
  done

  # list all the played commands
  local playedCommands
  for lastChoice in "${lastChoices[@]}"; do
    # find the corresponding line in the commands, if any
    for line in "${commandsArray[@]}"; do
      command="${line%%  *}"
      if [[ ${command} == "${lastChoice}" ]]; then
        playedCommands+=("${line}")
        break
      fi
    done
  done

  commands=("${playedCommands[@]}")
  commands+=("${unplayedCommands[@]}")
}

# This function adds the user command choice to the last choices file.
# It allows to sort the commands in the menu by the last used commands.
# $1: the id of the menu (used in the file name)
# $2: the command to add
#
# Usage:
#  command::addLastChoice "id" "command"
function command::addLastChoice() {
  local menuId command
  menuId="${1}"
  command="${2}"

  local maxNumberOfLastChoice=${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}

  # if the user does not want to remember the last choices, we return
  if [[ "${maxNumberOfLastChoice}" -eq 0 ]]; then
    return 0
  fi

  # load last choices from the file into an array
  local lastChoicesFile
  local -a lastChoices
  core::getUserDataDirectory
  lastChoicesFile="${REPLY}/last-choices-${menuId}"
  if [[ -f "${lastChoicesFile}" ]]; then
    readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"
  else
    lastChoices=()
  fi

  {
    # write the command first
    printf '%s\n' "${command}"

    # loop through the last choices and add them to the file, limit to 20 total
    local -i total index
    total="${#lastChoices[@]}"
    if [[ total -gt maxNumberOfLastChoice ]]; then total=$((maxNumberOfLastChoice - 1)); fi
    index=0
    for ((index = 0; index < total; index++)); do
      if [[ "${lastChoices[${index}]}" != "${command}" ]]; then
        printf '%s\n' "${lastChoices[${index}]}"
      else
        total+=1
        if [[ total -gt ${#lastChoices[@]} ]]; then total=${#lastChoices[@]}; fi
      fi
    done
  } >"${lastChoicesFile}"
}

# show an interactive menu for commands
# returns the selected command in standard output
# $1: the menu id
# $2: the menu header
# $3: the menu items array name (reference)
#
# Usage:
#  command_showInteractiveCommandsMenu "menuId" "header" ARRAY_NAME && choice="${REPLY}"
function command_showInteractiveCommandsMenu() {
  local menuHeader commandSelectionItemsArrayName
  menuHeader="${1}"
  commandSelectionItemsArrayName="${2}"

  # shellcheck source=lib-sfzf
  source sfzf

  sfzf::show "${commandSelectionItemsArrayName}" prompt="${menuHeader}" itemDetailsCallback="command_onFsfsItemSelectionChange" previewTitle="Command help"

  choice="${REPLY}"
  if (( ${#choice} >= CMD_MAX_COMMAND_WIDTH)); then
    choice="${choice:0:CMD_MAX_COMMAND_WIDTH}  "
    choice="${choice%%  *}"
  else
    choice=""
  fi

  REPLY="${choice}"
}

function command_onFsfsItemSelectionChange() {
  local item="$1"
  local command="${item:0:CMD_MAX_COMMAND_WIDTH}  "
  command="${command%%  *}"
  command_getFunctionNameFromCommand "${command}"
  command::getHelpText function "${REPLY}" "${3}"
  return 0
}

#===============================================================
# >>> Find command/function from arguments
#===============================================================

# Get the function name of a command.
#
# Usage:
#  command_getFunctionNameFromCommand "self build" && printf '%s\n' "${REPLY}"
function command_getFunctionNameFromCommand() {
  local -n functionName="CMD_FUNCTION_NAME_${1//[^[:alnum:]]/_}"
  REPLY="${functionName:-}"
}

# Find the function name from arguments that represents the commands.
# If we do not find an exact match, we return try to fuzzy find the command
# and then return its function name.
#
# This function will fail with an error if the command does not match
# any function or if the command is ambiguous.
#
# - $@: the commands to find
#
# Returns:
#
# - ${REPLY}: The function name.
# - ${REPLY2}: The level of the command.
# - ${REPLY3}: The exact command.
#
# ```bash
# command::fuzzyMatchCommandToFunctionNameOrFail "self" "build" && printf '%s\n' "${REPLY}"
# ```
function command::fuzzyMatchCommandToFunctionNameOrFail() {
  if [[ $# -eq 0 ]]; then
    return 0
  fi

  # ignore case
  shopt -s nocasematch

  command_getMaxPossibleCommandLevel "$@"
  local level="${REPLY}"

  local IFS=" "

  # we put the arguments into an array so we can interpret 'my' 'sub'
  # and 'my sub' as the same command (we split everything by space)
  local -a commandArray
  # shellcheck disable=SC2206
  commandArray=($*)

  local loopI functionName command exactCommand
  for ((loopI = level; loopI >= 1; loopI--)); do
    command="${commandArray[*]:0:loopI}"

    # case where the command is exact, we can match the function immediately
    command_getFunctionNameFromCommand "${command}" && functionName="${REPLY}"
    if [[ -n ${functionName:-} ]]; then
      exactCommand="${command}"
      break
    fi

    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      continue
    fi

    # case where the command is not exact, we try to fuzzy match it
    array::fuzzyFilterSort CMD_ALL_COMMANDS_ARRAY command
    if (( ${#REPLY_ARRAY[@]} > 1)); then
        # case of ambiguous command, show the list of possible commands
        command_getDisplayableFilteredArray REPLY_ARRAY command
        core::fail "Found multiple matches for the command ⌜${command}⌝, please be more specific:"$'\n'"${REPLY}"
    elif (( ${#REPLY_ARRAY[@]} == 1 )); then
      # case of a single match, we can match the function immediately
      exactCommand="${REPLY_ARRAY[0]}"
      command_getFunctionNameFromCommand "${exactCommand}" && functionName="${REPLY}"
      log::info "Fuzzy matching the command ⌜${command}⌝ to ⌜${exactCommand}⌝."
      break
    fi
  done

  if [[ -z ${functionName:-} ]]; then
    local messageDetails
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      messageDetails="an exact command"
    else
      messageDetails="a matching command"
    fi
    core::fail "Could not find ${messageDetails} for ⌜${command}⌝, use ⌜--help⌝ to get a list of valid commands."
  fi

  shopt -u nocasematch

  REPLY="${functionName:-}"
  REPLY2="${loopI}"
  REPLY3="${exactCommand:-}"
}

# Return the maximum level of subcommands
# if in valet with have at max 2 level of commands
# e.g. cmd subcmd
# then there is no need to try to match a command with 5 arguments
# Same thing, if we provide only 1 argument to the cli, we
# can only match a simple command
# $@: the arguments
#
# Usage:
# command_getMaxPossibleCommandLevel "cmd1" "subcmd2" "subsubcmd3"
# level="${REPLY}"
function command_getMaxPossibleCommandLevel() {
  local level maxLevel
  local IFS=' '
  level=0
  # shellcheck disable=SC2048
  for _ in ${*}; do
    level=$((level + 1))
  done
  maxLevel=$((CMD_MAX_SUB_COMMAND_LEVEL + 1))
  if (( level > CMD_MAX_SUB_COMMAND_LEVEL + 1 )); then
    level="${maxLevel}"
  fi
  REPLY="${level}"
}

#===============================================================
# >>> Parsers
#===============================================================

# Parses the arguments and options of a function.
# Usage:
#  command_parseFunctionArguments "functionName" "$@" && eval "${REPLY}"
#
# Notes:
# - It will return a string that can be evaluated to set the variables
#   corresponding to the arguments and options; e.g.:
#     "local arg1 option1
#     arg1=\"\"
#     option1=\"\"
#     ..."
# - It will also set the variable commandArgumentsErrors if there are any errors.
# - Variable name for an option is taken from the first --long version of the option.
# - It will set the variable as an array if the (last) argument name ends with '...'
function command_parseFunctionArguments() {
  local functionName
  functionName="${1}"
  shift

  local IFS=$' '

  local -n argumentsName="CMD_ARGS_NAME_${functionName}"
  local -i totalNbArguments
  if [[ -v argumentsName && ${#argumentsName[@]} -gt 0 ]]; then
    totalNbArguments=${#argumentsName[@]};
  else
    totalNbArguments=0;
  fi
  local -n isLastArgumentAnArray="CMD_ARGS_LAST_IS_ARRAY_${functionName}"
  local -n nbOptionalArgsStr="CMD_ARGS_NB_OPTIONAL_${functionName}"
  local -i nbOptionalArgs="${nbOptionalArgsStr:-0}"
  if [[ -z ${isLastArgumentAnArray:-} ]]; then isLastArgumentAnArray=false; fi
  local -i argumentPosition=0

  # shellcheck disable=SC2178
  local -n options="CMD_OPTS_${functionName}"
  local -i totalNbOptions
  if [[ -v options && ${#options[@]} -gt 0 ]]; then
    totalNbOptions=${#options[@]};
  else
    totalNbOptions=0;
  fi
  # shellcheck disable=SC2034
  local -n optionsHasValue="CMD_OPTS_HAS_VALUE_${functionName}"
  local -n optionsName="CMD_OPTS_NAME_${functionName}"
  local -n optionsNameSc="CMD_OPTS_NAME_SC_${functionName}"
  local -n optionsDefault="CMD_OPTS_DEFAULT_${functionName}"

  # shortcut if the function expect no arguments and no options
  if [[ totalNbArguments -eq 0 && totalNbOptions -eq 0 ]]; then
    REPLY=""
    return 0
  fi

  local -a lastArgumentValues=()
  local -a outputErrors=()
  local -a outputSetLine
  local -a matchedOptionsIndex

  local badArguments=false

  # we define reusable pieces of code that will be used to parse the options
  # shellcheck disable=SC2016
  local optionFinder='
  # we are matching an option
  # try to match the argument with one of the option name
  if [[ totalNbOptions -gt 0 ]]; then
    for optionIndex in "${!options[@]}"; do
      for option in ${options[${optionIndex}]}; do
        if [[ ${option} == "${1}" ]]; then
          matchedIndex="${optionIndex}"
          break 2
        fi
      done
    done
  fi

  if [[ matchedIndex -ne -1 ]]; then
    # its a match!
    optionValue="${optionsHasValue[${matchedIndex}]:-}"
    optionName="${optionsName[${matchedIndex}]}"
    matchedOptionsIndex+=("${matchedIndex}")
  fi
  '

  # shellcheck disable=SC2016
  local registerOption='
  if [[ ${optionValue} == "true" ]]; then
    if (( $# == 1 )); then
      outputErrors+=("Missing value for option ⌜${optionName}⌝.")
    else
      shift
      outputSetLine+=("${optionName}=\"${1//\"/\\\"}\"")
    fi
  else
    outputSetLine+=("${optionName}=\"true\"")
  fi
  '

  # parse each arguments
  local -i optionIndex matchedIndex optionLength letterIndex
  # shellcheck disable=SC2034
  local optionValue
  local option startedArguments optionName argumentName optionLetter optionLetters
  startedArguments="false"
  while (( $# > 0 )); do

    if [[ ${1} == "-"* && ${startedArguments} != "true" ]]; then
      # we are matching an option, try to find the option index
      matchedIndex=-1
      eval "${optionFinder}"

      if [[ matchedIndex -ne -1 ]]; then
        # it's a match! register the option
        eval "${registerOption}"

      elif [[ ${1} == "--" ]]; then
        # if we have -- we stop parsing options
        startedArguments="true"

      elif [[ ${1} == "--"* ]]; then
        # if we didn't match any known long option, try to fuzzy find it
        command_fuzzyFindOption "${1}" "${options[@]}"

        if [[ -n ${REPLY2} ]]; then
          # we found a single match!
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"${REPLY2}"}"
          eval "${registerOption}"
        else
          # we found multiple matches or no match
          outputErrors+=("${REPLY}")
        fi

      else
        # a single dash, we can resolve each letter as an option
        optionLetters="${1}"
        optionLength=${#optionLetters}
        for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
          optionLetter="${optionLetters:letterIndex:1}"
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"-${optionLetter}"}"
          if [[ matchedIndex -ne -1 ]]; then
            eval "${registerOption}"
          else
            command_getSingleLetterOptions "${options[@]}"
            outputErrors+=("Unknown option letter ⌜${optionLetter}⌝ in group ⌜${optionLetters}⌝. ${REPLY}")
          fi
        done

      fi

    else
      # we are matching an argument

      if [[ argumentPosition -ge totalNbArguments ]]; then
        outputErrors+=("Expecting ${totalNbArguments} argument(s), got extra argument ⌜${1}⌝.")
        badArguments=true
      else
        argumentName="${argumentsName[${argumentPosition}]}"

        if [[ argumentPosition -eq $((totalNbArguments - 1)) && "${isLastArgumentAnArray}" = "true" ]]; then
          # if the arg ends with ... we expect an infinite amount of arguments
          lastArgumentValues+=("${1}")
        else
          argumentPosition+=1
          outputSetLine+=("${argumentName}=\"${1//\"/\\\"}\"")
        fi

      fi
    fi

    if (( $# > 0 )); then
      shift
    fi
  done

  # increase argument position if the last arg is an array because we don't do it in the loop
  if [[ ${#lastArgumentValues[@]} -gt 0 ]]; then
    argumentPosition=$((argumentPosition + 1))
  fi

  # check if we have missing arguments
  local -i nbExpectedArgs=$((totalNbArguments - nbOptionalArgs))
  if [[ argumentPosition -lt nbExpectedArgs ]]; then
    outputErrors+=("Expecting ⌜${nbExpectedArgs}⌝ argument(s) but got ⌜${argumentPosition}⌝.")
    badArguments=true
  fi

  if (( ${#outputErrors[@]} > 0 )); then
    local -n command="CMD_COMMAND_${functionName}"
    outputErrors+=("Use ⌜valet ${command} --help⌝ to get help.")
    if [[ ${badArguments} == "true" ]]; then
      command::getHelpText function "${functionName}"
      outputErrors+=($'\n'"Usage:"$'\n'"${REPLY2}")
    fi
  fi


  local outputString

  # define all the possible local variables for options and arguments
  local option argumentIndex nbScalarArguments
  outputString="local commandArgumentsErrors"
  for option in "${optionsName[@]}"; do
    outputString+=" ${option}"
  done
  nbScalarArguments="${totalNbArguments}"
  if [[ ${isLastArgumentAnArray} == "true" ]]; then nbScalarArguments=$((nbScalarArguments - 1)); fi
  for ((argumentIndex = 0; argumentIndex < nbScalarArguments; argumentIndex++)); do
    outputString+=" ${argumentsName[${argumentIndex}]}"
  done
  outputString+=$'\n'
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    outputString+="local -a ${argumentsName[${nbScalarArguments}]}"$'\n'
  fi

  # assign all unmatched options to the corresponding global variable
  local optionIndex optionName optionMatched matchedIndex optionNameSc optionDefault
  for optionIndex in "${!options[@]}"; do
    optionMatched="false"
    for matchedIndex in "${matchedOptionsIndex[@]}"; do
      if [[ ${optionIndex} == "${matchedIndex}" ]]; then
        optionMatched="true"
        break
      fi
    done
    if [[ ${optionMatched} == "false" ]]; then
      # shellcheck disable=SC2034
      optionName="${optionsName[${optionIndex}]}"
      optionNameSc="${optionsNameSc[${optionIndex}]:-}"
      optionDefault="${optionsDefault[${optionIndex}]:-}"
      if [[ -n ${optionNameSc} ]]; then
        if [[ -n ${optionDefault} ]]; then
          optionDefault="\"${optionDefault}\""
        fi
        outputString+="${optionsName[${optionIndex}]}=\"\${${optionNameSc}:-${optionDefault}}\""$'\n'
      else
        outputString+="${optionsName[${optionIndex}]}=\"${optionDefault}\""$'\n'
      fi
    fi
  done

  # output the parsing errors
  local -i outputErrorIndex
  outputString+="commandArgumentsErrors=\""
  for outputErrorIndex in "${!outputErrors[@]}"; do
    if [[ outputErrorIndex -gt 0 ]]; then
      outputString+=$'\n'
    fi
    outputString+="${outputErrors[${outputErrorIndex}]}"
  done
  outputString+="\""$'\n'

  # output the matched arguments/options values
  local outputSet
  for outputSet in "${outputSetLine[@]}"; do
    outputString+="${outputSet}"$'\n'
  done

  # output the last argument values
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    local lastArgumentValue
    outputString+="${argumentsName[${nbScalarArguments}]}=("$'\n'
    for lastArgumentValue in "${lastArgumentValues[@]}"; do
      outputString+="\"${lastArgumentValue//\"/\\\"}\""$'\n'
    done
    outputString+=")"
  fi

  REPLY="${outputString}"
}

# Tries to find a match for an inexact option.
# If the strict matching is enabled, we will only suggest a fix (if we find a match).
# If strict matching is disabled and we have found a single match, we can return it.
#
# - $1: the user string to match
# - $2+: list of options to match against
#
# Returns:
#
# - ${REPLY}: An error message with the suggested option(s).
# - ${REPLY2}: The single matched option that we can use.
#
# ```bash
# command_fuzzyFindOption opt1 option1 option2 option3 && fuzzyOption="${REPLY}"
# ```
function command_fuzzyFindOption() {
  local unknownOption suggestedOption
  unknownOption="${1}"
  shift
  # shellcheck disable=SC2206
  local IFS=$' '
  # shellcheck disable=SC2206
  _OPTIONS_TO_MATCH=($*)

  local singleMatchedOption
  IFS=$'\n'

  # ignore case
  shopt -s nocasematch

  # split to get one possible option per line
  array::fuzzyFilterSort _OPTIONS_TO_MATCH unknownOption
  if (( ${#REPLY_ARRAY[@]} == 1 )); then
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, did you mean ⌜${REPLY_ARRAY[0]}⌝?"
    else
      log::info "Fuzzy matching the option ⌜${unknownOption}⌝ to ⌜${REPLY_ARRAY[0]}⌝."
      singleMatchedOption="${REPLY_ARRAY[0]}"
    fi
  elif (( ${#REPLY_ARRAY[@]} > 1 )); then
    command_getDisplayableFilteredArray REPLY_ARRAY unknownOption
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, valid matches are:"$'\n'"${REPLY}"
    else
      suggestedOption="Found multiple matches for the option ⌜${unknownOption}⌝, please be more specific:"$'\n'"${REPLY}"
    fi
  else
    suggestedOption="Unknown option ⌜${unknownOption}⌝, valid options are:"$'\n'"$*"
  fi

  shopt -u nocasematch

  unset _OPTIONS_TO_MATCH

  REPLY="${suggestedOption:-}"
  REPLY2="${singleMatchedOption:-}"
}

# ## command_getDisplayableFilteredArray (private)
#
# Outputs a string that displays an array where each item gets highlighted
# characters.
#
# - $1: **array** _as string:
#       The name of the global array to display.
# - $2: **characters variable name** _as string_:
#       The characters to highlight in the array items.
#
# Returns:
#
# - ${REPLY}: The string to display.
#
function command_getDisplayableFilteredArray() {
  # shellcheck disable=SC2178
  local -n array="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # ignore case
  shopt -s nocasematch

  local line output=""
  local IFS=$'\n'
  for line in "${array[@]}"; do
    string::highlight line "${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
    output+="${REPLY}"$'\n'
  done

  shopt -u nocasematch

  REPLY="${output}"
}

# Helps to build a message for the user to inform them
# about the valid single letter options.
#
# - $@: the options
#
# Returns:
#
# - ${REPLY}: The message to display to the user.
#
# ```bash
# options=("opt1" "option1" "option2" "option3")
# command_getSingleLetterOptions "${options[@]}" && message="${REPLY}"
# ```
function command_getSingleLetterOptions() {
  local -a options
  # shellcheck disable=SC2206
  options=($*)

  REPLY="Valid single letter options are: "

  for option in "${options[@]}"; do
    if [[ ${#option} -eq 2 ]]; then
      REPLY+="⌜${option:1:1}⌝, "
    fi
  done

  REPLY="${REPLY%, }."
}

# ## command::parseCmdFunctionArgumentsOrGoInteractive (private)
#
# Parse the arguments and options of a function.
# If no arguments are provided but some are expected, it will enter interactive mode.
# See the @command::parseArguments function for more details on parsing.
#
# Usage:
#   command::parseCmdFunctionArgumentsOrGoInteractive "functionName" "$@" && eval "${REPLY}"
function command::parseCmdFunctionArgumentsOrGoInteractive() {
  local functionName
  functionName="${1}"
  shift

  command::sourceUserCommands

  command_parseFunctionArguments "${functionName}" "$@"
  local parsedArguments="${REPLY}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi

  # check if the function is expecting arguments and/or options
  local expectArguments
  local -n \
    arguments="CMD_ARGUMENTS_NAME_${functionName}" \
    nbOptionalArguments="CMD_ARGS_NB_OPTIONAL_${functionName}"
  if [[ -v arguments && -v nbOptionalArguments && "${#arguments[@]}" -gt nbOptionalArguments ]]; then
    expectArguments="true"
  fi

  if [[ ("${expectArguments:-false}" == "true" && $# -eq 0) || "${VALET_FORCE_INTERACTIVE_MODE:-false}" == "true" ]]; then
    command_goInteractive "${functionName}" "${parsedArguments}"
  fi

  REPLY="${parsedArguments}"
}

function command_goInteractive() {
  local functionName parsedArguments
  functionName="${1}"
  parsedArguments="${2}"

  # TODO: go interactive
  log::warning "Entering interactive mode for the function ⌜${functionName}⌝. But this is not yet implemented."

  # at the end, printf '%s\n' to the user the complete command that will be run
}


#===============================================================
# >>> Help
#===============================================================

# ## command::listCommands (private)
#
# Lists all the commands available in the valet CLI.
#
# - $1: if set to "true", only lists the core commands.
#
# Returns:
#
# - ${REPLY_ARRAY}: an array of command names.
# - ${REPLY_ARRAY2}: an array of function names corresponding to the commands.
#
# ```bash
# command::listCommands true
# ```
function command::listCommands() {
  local coreOnly="${1}"

  command::sourceUserCommands

  REPLY_ARRAY=()
  REPLY_ARRAY2=()
  local varName functionName IFS=$' '
  for varName in ${!CMD_COMMAND_*}; do
    functionName="${varName#CMD_COMMAND_}"

    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    local -n command="CMD_COMMAND_${functionName}"
    if [[ ${fileToSource} == "tests.d/"* ]]; then
      continue
    fi
    if [[ ${coreOnly} == "true" ]]; then
      if [[ ${fileToSource} == "showcase.d/"* || ! -f "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}" ]]; then
        continue
      fi
    fi

    REPLY_ARRAY+=("${command}")
    REPLY_ARRAY2+=("${functionName}")
  done
}

# ## command::getHelpAsMarkdown (private)
#
# Prints the help text of a function in markdown format.
#
# - $1: the name of the function.
#
# ```bash
# command::getHelpAsMarkdown selfUpdate
# ```
function command::getHelpAsMarkdown() {
  local functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  command::sourceUserCommands

  local -n command="CMD_COMMAND_${functionName}"
  local -n description="CMD_DESCRIPTION_${functionName}"
  local -n functionArguments="CMD_ARGUMENTS_NAME_${functionName}"

  local fullCommand
  if [[ ${functionName} == "this" ]]; then
    fullCommand="valet"
  else
    fullCommand="valet ${command}"
  fi

  # usage
  local usage="${fullCommand} [options]"
  if [[ -n ${functionCommands:-} ]]; then
    usage+=" [command]"
  elif [[ -n ${functionArguments:-} ]]; then
    usage+=" [--]"
    for argument in "${functionArguments[@]}"; do
      if [[ ${argument} == *\?* ]]; then
        usage+=" [${argument//\?/}]"
      else
        usage+=" <${argument}>"
      fi
    done
  fi

  local section sections="" functionNameArray functionDescriptionArray index

  # loop over each section
  for section in "options" "arguments" "commands" "examples"; do
    local -n functionNameArray="CMD_${section^^}_NAME_${functionName}"
    local -n functionDescriptionArray="CMD_${section^^}_DESCRIPTION_${functionName}"
    if [[ -z "${functionNameArray:-}" ]]; then
      continue
    fi

    sections+="### ${section^}"$'\n'$'\n'

    for index in "${!functionNameArray[@]}"; do
      sections+="- \`${functionNameArray[${index}]}\`"$'\n'$'\n'

      local line itemDescription="${functionDescriptionArray[${index}]}"
      while [[ -n ${itemDescription} ]]; do
        line="${itemDescription%%$'\n'*}"
        itemDescription="${itemDescription:${#line}+1}"

        sections+="  ${line}"$'\n'
      done

      sections+=$'\n'
    done

  done

  REPLY="## ▶️ ${fullCommand}

${description}

### Usage

\`\`\`bash
${usage}
\`\`\`

${sections}"
  REPLY="${REPLY//"⌜"/"**"}"
  REPLY="${REPLY//"⌝"/"**"}"
}

# ## command::printHelp (private)
#
# Prints the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) the maximum columns for the help text.
#
# ```bash
# command::printHelp function "this" "${GLOBAL_COLUMNS}"
# ```
function command::printHelp() {
  command::getHelpText "$@"
  printf '%s' "${REPLY}"
}

# ## command::getHelpText (private)
#
# Get the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) the maximum columns for the help text.
#
# Returns:
#
# - ${REPLY}: the help text
# - ${REPLY2}: the command usage text
#
# ```bash
# command::getHelpText function "this" "false" "${GLOBAL_COLUMNS}"
# ```
function command::getHelpText() {
  local type=${1:-function}
  local name="${2:-this}"
  local maxColumns="${3:-${GLOBAL_COLUMNS}}"

  command::sourceUserCommands

  local -i helpWidth
  helpWidth="${maxColumns}"
  if (( helpWidth > GLOBAL_COLUMNS )); then helpWidth=${GLOBAL_COLUMNS}; fi

  if [[ ${type} == "function" ]]; then
    # case of a function; we will get the description from CMD_ vars directly
    functionName="${name}"
  else
    # case of a menu; we will the sub commands for it
    functionName="_menu"
    # shellcheck disable=SC2034
    CMD_COMMAND__menu="${name}"
    CMD_COMMANDS_NAME__menu=()
    CMD_COMMANDS_DESCRIPTION__menu=()
    local index subCommand
    for index in "${!CMD_COMMANDS_NAME_this[@]}"; do
      local subCommand="${CMD_COMMANDS_NAME_this[${index}]}"
      if [[ "${subCommand}" != "${name} "* ]]; then continue; fi
      CMD_COMMANDS_NAME__menu+=("${subCommand}")
      CMD_COMMANDS_DESCRIPTION__menu+=("${CMD_COMMANDS_DESCRIPTION_this[${index}]}")
    done
  fi

  local -n command="CMD_COMMAND_${functionName}"
  local -n description="CMD_DESCRIPTION_${functionName}"
  local -n functionOptions="CMD_OPTIONS_NAME_${functionName}"
  local -n functionArguments="CMD_ARGUMENTS_NAME_${functionName}"
  local -n functionCommands="CMD_COMMANDS_NAME_${functionName}"
  local -n functionExamples="CMD_EXAMPLES_NAME_${functionName}"

  # description
  string::wrapWords description width="${helpWidth}" newLinePadString="  " firstLineWidth="$((helpWidth - 2))"
  local wrappedDescription="  ${REPLY}"

  # usage
  local usage
  if [[ ${functionName} == "this" ]]; then
    usage="valet"
  else
    usage="valet ${STYLE_HELP_OPTION}[global options]${STYLE_RESET} ${command}"
  fi
  if [[ -n ${functionOptions:-} ]]; then
    if [[ ${functionName} == "this" ]]; then
      usage+=" ${STYLE_HELP_OPTION}[global options]${STYLE_RESET}"
    else
      usage+=" ${STYLE_HELP_OPTION}[options]${STYLE_RESET}"
    fi
  fi
  if [[ -n ${functionCommands:-} ]]; then
    usage+=" ${STYLE_HELP_COMMAND}[command]${STYLE_RESET}"
  else
    if [[ -n ${functionArguments:-} ]]; then
      usage+=" [--]"
      for argument in "${functionArguments[@]}"; do
        if [[ ${argument} == *\?* ]]; then
          usage+=" ${STYLE_HELP_ARGUMENT}[${argument//\?/}]${STYLE_RESET}"
        else
          usage+=" ${STYLE_HELP_ARGUMENT}<${argument}>${STYLE_RESET}"
        fi
      done
    fi
  fi
  REPLY2="${usage}"
  string::wrapWords usage width="${helpWidth}" newLinePadString="  " firstLineWidth="$((helpWidth - 2))"
  usage="  ${REPLY}"

  # global options
  local options="${STYLE_HELP_TITLE}GLOBAL OPTIONS${STYLE_RESET}"$'\n'$'\n'
  command_writeAsTable "${helpWidth}" "${STYLE_HELP_OPTION}" "CMD_OPTIONS" "this"
  options+="${REPLY}"$'\n'

  # options
  if [[ ${functionName} != "this" ]]; then
    if [[ -n ${functionOptions:-} ]]; then
      options+="${STYLE_HELP_TITLE}OPTIONS${STYLE_RESET}"$'\n'$'\n'
      command_writeAsTable "${helpWidth}" "${STYLE_HELP_OPTION}" "CMD_OPTIONS" "${functionName}"
      options+="${REPLY}"$'\n'
    fi
  fi

  # arguments
  local arguments
  if [[ -z ${functionCommands:-} && -n ${functionArguments:-} ]]; then
    arguments="${STYLE_HELP_TITLE}ARGUMENTS${STYLE_RESET}"$'\n'$'\n'
    command_writeAsTable "${helpWidth}" "${STYLE_HELP_ARGUMENT}" "CMD_ARGUMENTS" "${functionName}"
    arguments+="${REPLY}"$'\n'
  fi

  # commands
  local commands
  if [[ -n ${functionCommands:-} ]]; then
    commands="${STYLE_HELP_TITLE}COMMANDS${STYLE_RESET}"$'\n'$'\n'
    command_writeAsTable "${helpWidth}" "${STYLE_HELP_COMMAND}" "CMD_COMMANDS" "${functionName}"
    commands+="${REPLY}"$'\n'
  fi

  # examples
  local examples
  if [[ -n ${functionExamples:-} ]]; then
    examples="${STYLE_HELP_TITLE}EXAMPLES${STYLE_RESET}"$'\n'$'\n'
    command_writeAsTable "${helpWidth}" "${STYLE_HELP_COMMAND}" "CMD_EXAMPLES" "${functionName}"
    examples+="${REPLY}"$'\n'
  fi

  local output="${STYLE_HELP_TITLE}ABOUT${STYLE_RESET}

${wrappedDescription}

${STYLE_HELP_TITLE}USAGE${STYLE_RESET}

${usage}

${options:-}${arguments:-}${commands:-}${examples:-}"

  # surround "markdown like" _italic_ with italic color
  if [[ -n ${STYLE_HELP_HIGHLIGHT} ]]; then
    output="${output//⌜/${STYLE_HELP_HIGHLIGHT}⌜}"
    output="${output//⌝/⌝${STYLE_RESET}}"
  fi

  REPLY="${output}"
}

# used in show help to write a table of options, commands, arguments...
# transform text1\ttext2 to:
#   text1
#           text2
# text1 can be showed in color and we respect a maximum width
function command_writeAsTable() {
  local width="${1}"
  local color="${2}"
  local prefix="${3}"
  local functionName="${4}"

  local -n names="${prefix}_NAME_${functionName}"
  local -n descriptions="${prefix}_DESCRIPTION_${functionName}"
  local output index

  output=""
  for index in "${!names[@]}"; do
    string::wrapWords "names[${index}]" width="${width}" newLinePadString="  " firstLineWidth="$((width - 2))"
    output+="  ${color}${REPLY}${STYLE_RESET:-}"$'\n'

    string::wrapWords "descriptions[${index}]" width="${width}" newLinePadString="      " firstLineWidth="$((width - 6))"
    output+="      ${REPLY}"$'\n'
  done

  REPLY="${output}"
}

#===============================================================
# >>> Commands sourcing functions
#===============================================================

# ## command::sourceCommandFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# command::sourceCommandFunction "functionName"
# ```
function command::sourceCommandFunction() {
  local functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  command::sourceUserCommands

  local fileToSource
  if ! declare -F "${functionName}" &>/dev/null; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -z "${fileToSource:-}" ]]; then
      core::fail "Could not find a command function named ⌜${functionName}⌝."
    elif [[ -f "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -f "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}"
      log::debug "Loaded file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝."
    else
      core::fail "The source file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# ## command::sourceUserCommands (private)
#
# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we build it on the fly.
#
# ```bash
# command::sourceUserCommands
# ```
function command::sourceUserCommands() {
  if [[ ${GLOBAL_CMD_INCLUDED:-} == "true" ]]; then
    return 0
  fi

  # source the user commands
  local stateDirectory
  core::getUserDataDirectory
  stateDirectory="${REPLY}"

  local commandsFile
  commandsFile="${stateDirectory}/commands"

  # if the commands file does not exist, we build it.
  if [[ ! -f "${commandsFile}" ]]; then
    log::info "The commands index does not exist ⌜${stateDirectory}/commands⌝."$'\n'"Now silently building it using ⌜valet self build⌝ command."

    # shellcheck disable=SC1091
    unset GLOBAL_CMD_INCLUDED
    # shellcheck source=/dev/null
    source "${GLOBAL_INSTALLATION_DIRECTORY}/commands.d/self-build.sh"
    selfBuild --silent

    if [[ ! -f "${commandsFile}" ]]; then
      core::fail "Could not build the commands file, please check the error above."
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  GLOBAL_ON_EXIT_MESSAGE="Error sourcing the commands file ⌜${commandsFile}⌝."$'\n'"Please rebuild it using the ⌜valet self build⌝ command."
  builtin source "${commandsFile}"
  unset -v GLOBAL_ON_EXIT_MESSAGE
}

# ## command::reloadUserCommands (private)
#
# Forcibly source again the user 'commands' file from the valet user directory.
#
# ```bash
# command::reloadUserCommands
# ```
function command::reloadUserCommands() {
  # delete previous variables
  # shellcheck disable=SC2086
  unset -v ${!CMD_*} GLOBAL_CMD_INCLUDED
  command::sourceUserCommands
}

# ## command::deleteUserCommands (private)
#
# Delete the user 'commands' file from the valet user directory.
#
# You probably want to reload the user commands afterward using `command::reloadUserCommands`.
#
# ```bash
# command::deleteUserCommands
# ```
function command::deleteUserCommands() {
  core::getUserDataDirectory
  rm -f "${REPLY}/commands" 1>/dev/null || :
}
