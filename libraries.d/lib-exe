#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-fs
source fs
# shellcheck source=lib-time
source time

# ## exe::invoke
#
# This function call an executable with its optional arguments.
#
# By default it redirects the stdout and stderr and captures them to output variables.
# This makes the executes silent unless the executable fails.
# By default, it will exit (core::fail) if the executable returns a non-zero exit code.
#
# This function should be used as a wrapper around any external program as it allows to easily
# mock the program during tests and facilitates debugging with trace level log.
#
# - $1: **executable** _as string_:
#       the executable or function to execute
# - $@: **arguments** _as any_:
#       the arguments to pass to the executable
# - ${noFail} _as bool_:
#       (optional) A boolean to indicate if the function should call core::fail (exit) in case the execution fails.
#       If true and the execution fails, the script will exit.
#       (defaults to false)
# - ${replyPathOnly} _as bool_:
#       (optional) If set to true, the function will return the file path of the stdout and stderr files
#       instead of their content. This will make the function faster.
#       (defaults to false)
# - ${stdoutPath} _as string_:
#       (optional) The file path to use for the stdout of the executable. Otherwise a temporary work file will be used.
#       (defaults to "")
# - ${stderrPath} _as string_:
#       (optional) The file path to use for the stderr of the executable. Otherwise a temporary work file will be used.
#       (defaults to "")
# - ${stdinFile} _as bool_:
#       (optional) The file path to use as stdin for the executable.
#       (defaults to "")
# - ${stdin} _as string_:
#       (optional) The stdin content to pass to the executable.
#       Can be empty if not used.
#       (defaults to "")
# - ${acceptableCodes} _as string_:
#       (optional) The acceptable error codes, comma separated.
#       If the error code is matched, then REPLY_CODE is set to 0)
#       (defaults to "0")
# - ${failMessage} _as string_:
#       (optional) The message to display on failure.
#       (defaults to "")
# - ${warnOnFailure} _as bool_:
#       (optional) If true, a warning message (uses failMessage) will be displayed on failure but
#       it will not cause the function to exit.
#       Contrary to noFail, it will display a warning message (noFail is silent).
#       (defaults to false)
# - ${appendRedirect} _as bool_:
#       (optional) If true will append the output to the stdout/stderr files instead of overwriting them (>> redirect).
#       This is useful when you want to run the same command multiple times and keep the previous output.
#       The stderr and stdout REPLY variables will both have the same content.
#       (defaults to false)
# - ${groupRedirect} _as bool_:
#       (optional) If true will output stdout/stderr to the same file (&> redirect).
#       (defaults to false)
# - ${noRedirection} _as bool_:
#       (optional) If set to true, the function will not redirect the stdout and stderr to temporary files.
#       (defaults to false)
#
# Returns:
#
# - ${REPLY_CODE}: The exit code of the executable.
# - ${REPLY}: The content of stdout (or file path to stdout if `replyPathOnly=true`).
# - ${REPLY2}: The content of stderr (or file path to stdout if `replyPathOnly=true`).
#
# ```bash
# # basic usage with some arguments:
# exe::invoke git branch --list --sort=-committerdate
# echo "${REPLY}"
#
# # invoke a command that is allowed to return an error code:
# exe::invoke risky-command --- noFail=true
# echo "${REPLY_CODE}"
#
# # invoke a command with custom stdout / stderr files and do not read the output into REPLY vars:
# exe::invoke thing --- stdoutPath=/path/to/stdout stderrPath=/path/to/stderr replyPathOnly=true
#
# # invoke a command and let the outputs go to the console:
# exe::invoke cat file --- noRedirection=true
#
# # invoke a command with stdin from a string:
# exe::invoke cat --- stdin="Hello World"
# ```
#
# > - In windows, this is tremendously faster to do:
# >   `exe::invoke mycommand; myvar="${REPLY}"`
# >   than doing:
# >   `myvar="$(mycommand)".`
# > - On linux, it is slightly faster (but it might be slower if you don't have SSD?).
# > - On linux, you can use a tmpfs directory for massive gains over subshells.
function exe::invoke() {
  local \
    executable="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    noFail=false \
    replyPathOnly=false \
    stdoutPath="${GLOBAL_TEMPORARY_STDOUT_FILE}" \
    stderrPath="${GLOBAL_TEMPORARY_STDERR_FILE}" \
    stdinFile="" \
    stdin="" \
    acceptableCodes="0" \
    failMessage="" \
    warnOnFailure=false \
    appendRedirect=false \
    groupRedirect=false \
    noRedirection=false
  shift 1
  core::parseFunctionOptions "${@}"
  eval "${REPLY}"

  # compute the necessary redirects
  # shellcheck disable=SC2016
  local \
    toEval='"${executable}" "${@}"' \
    redirectExtraSymbol=""
  if [[ -n ${stdin} ]]; then
    toEval+=" <<<${stdin@Q}"
  elif [[ -n ${stdinFile} ]]; then
    toEval+=" <${stdinFile@Q}"
  fi
  if [[ ${appendRedirect} == "true" ]]; then
    redirectExtraSymbol=">"
  fi
  if [[ ${noRedirection} != "true" ]]; then
    if [[ ${groupRedirect} == "true" ]]; then
      stderrPath="${stdoutPath}"
      toEval+=" &>${redirectExtraSymbol}\"${stdoutPath}\""
    else
      toEval+=" 1>${redirectExtraSymbol}\"${stdoutPath}\" 2>${redirectExtraSymbol}\"${stderrPath}\""
    fi
  fi

  local isTraceEnabled=false
  if log::isTraceEnabled; then
    isTraceEnabled=true
  fi

  # if trace mode is on, print some info
  if [[ ${isTraceEnabled} == "true" ]]; then
    local IFS=' '
    if (($# > 0)); then
      printf -v args "%q " "${@}"
      log::trace "Executing the command ${executable} with arguments: "$'\n'"${args% }"
    else
      log::trace "Executing the command ${executable} (no arguments)."
    fi
    log::trace "The command will be executed as:"$'\n'"${toEval}"
    log::trace "Options: noFail=${noFail}, warnOnFailure=${warnOnFailure}, acceptableCodes=${acceptableCodes}, replyPathOnly=${replyPathOnly}"
    if [[ -n ${stdin} ]]; then
      log::trace "${executable^} standard input from string:"
      log::saveFileString stdin suffix="${executable}-stdin"
    elif [[ -n ${stdinFile} ]]; then
      log::trace "${executable^} standard input from file ${stdinFile}:"
      log::saveFile "${stdinFile}" suffix="${executable}-stdin"
    else
      log::trace "No standard input."
    fi
  else
    log::debug "Executing the command ${executable}."
  fi

  time::getProgramElapsedMicroseconds
  local timerStart="${REPLY}"

  # execute the program
  local exitCode
  if eval "${toEval}"; then
    exitCode=0
  else
    exitCode=${?}
  fi

  time::getProgramElapsedMicroseconds
  local -i elapsed=$((REPLY - timerStart))
  time::getSecondsFromMicroseconds "${elapsed}" precision=3

  local debugMessage="The command ${executable} ended with exit code ${exitCode} in ${REPLY}s."

  if [[ -n ${failMessage} ]]; then
    debugMessage+=$'\n'"${failMessage}"
  fi

  # if the error code is acceptable, then we set it to 0
  if [[ ${exitCode} -ne 0 && ,${acceptableCodes}, == *",${exitCode},"* ]]; then
    exitCode=0
    log::trace "The error code ${exitCode} is acceptable and has been reset to 0."
  fi

  local \
    shouldFail=false \
    shouldWarn=false
  if [[ ${warnOnFailure} != "true" && ${noFail} != "true" && exitCode -ne 0 ]]; then
    shouldFail=true
  elif [[ ${warnOnFailure} == "true" && exitCode -ne 0 ]]; then
    shouldWarn=true
  fi

  # fail if needed or we are debug mode; display all the debug information that could be useful
  if [[ ${noRedirection} != "true" && (${shouldWarn} == "true" || ${shouldFail} == "true" || ${isTraceEnabled} == "true") ]]; then
    # print std out
    if [[ -s "${stdoutPath}" ]]; then
      log::errorTrace "${executable^} standard output stream:"
      log::saveFile "${stdoutPath}" suffix="${executable}-stdout"
      log::printFile "${stdoutPath}" maxLines=99
    else
      log::errorTrace "${executable^} had no standard output stream."
    fi

    # print stderr
    if [[ -s "${stderrPath}" ]]; then
      log::errorTrace "${executable^} standard error stream:"
      log::saveFile "${stderrPath}" suffix="${executable}-stderr"
      log::printFile "${stderrPath}" maxLines=99
    else
      log::errorTrace "${executable^} had no standard error stream."
    fi
  fi
  if [[ ${shouldFail} == "true" ]]; then
    core::fail "${debugMessage}"
  elif [[ ${shouldWarn} == "true" ]]; then
    log::warning "${debugMessage}"
  else
    log::debug "${debugMessage}"
  fi

  if [[ ${noRedirection} == "true" ]]; then
    REPLY=""
    REPLY2=""
  elif [[ ${replyPathOnly} == "true" ]]; then
    REPLY="${stdoutPath}"
    REPLY2="${stderrPath}"
  else
    fs::readFile "${stderrPath}"
    # shellcheck disable=SC2034
    REPLY2="${REPLY}"
    fs::readFile "${stdoutPath}"
  fi

  # shellcheck disable=SC2034
  REPLY_CODE="${exitCode}"

  return 0
}
