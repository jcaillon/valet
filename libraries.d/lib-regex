#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## regex::getFirstGroup
#
# Matches a string against a regex and returns the first captured group of the first match.
#
# - $1: **string variable name** _as string_:
#       The variable name containing the string to match.
# - $2: **regex** _as string_:
#       The regex to use for the match.
#
# Returns:
#
# - ${REPLY}: The first capture group in the matched string.
#                      Empty if no match.
#
# ```bash
# MY_STRING="name: julien"
# regex::getFirstGroup MY_STRING "name:(.*)"
# echo "${REPLY}"
# ```
#
# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions
function regex::getFirstGroup() {
  local -n inputString_nameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # Usage: regex "string" "regex"
  if [[ ${inputString_nameRef} =~ ${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."} ]]; then
    REPLY="${BASH_REMATCH[1]:-}"
  else
    # shellcheck disable=SC2034
    REPLY=""
  fi
}

# ## regex::replace
#
# Replaces strings within a string using a regex (replaces in place).
#
# - $1: **string variable name** _as string_:
#       The variable name containing the string in which to do replacements.
# - $2: **regex** _as string_:
#       The regex to use for the match.
# - $3: **replacement string** _as string_:
#       The replacement string.
#       Use \x to refer to the x-th capture group.
#       Use \c to refer to replacement counter.
# - ${max} _as int_:
#       (optional) The number of replacements to do.
#       Set to -1 for unlimited replacements.
#       (defaults to -1)
# - ${onlyMatches} _as bool_:
#       (optional) Instead of replacing with the regex, we keep only the matches.
#       This can be used to extract information from a string.
#       (defaults to false)
#
#
# ```bash
# MY_STRING="name: julien"
# regex::replace MY_STRING "name: (.*)" "\1"
# regex::replace MY_STRING "name: (.*)" "\1" maxCount=1 onlyMatches=true
# echo "${MY_STRING}"
# ```
#
# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions
function regex::replace() {
  local -n inputString_nameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    regex="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    replacement="${3?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    max=-1 \
    onlyMatches=false \
    IFS=" "
  shift 3
  eval "local a= ${*@Q}"

  if ((max == 0)); then
    if [[ ${onlyMatches} == "true" ]]; then
      inputString_nameRef=""
    fi
    return 0
  fi

  local usePlaceHolders=false actualReplacement
  if [[ ${replacement} == *"\\"* ]]; then
    usePlaceHolders=true
  else
    actualReplacement="${replacement}"
  fi

  local -i count=0 currentCharIndex=0
  local IFS="" stringBeforeMatch output=""

  while [[ ${inputString_nameRef:currentCharIndex} =~ ${regex} ]]; do
    stringBeforeMatch="${inputString_nameRef:currentCharIndex}"
    stringBeforeMatch="${stringBeforeMatch%%"${BASH_REMATCH[0]}"*}"
    currentCharIndex=$((currentCharIndex + ${#stringBeforeMatch} + ${#BASH_REMATCH[0]}))

    if [[ ${usePlaceHolders} == "true" ]]; then
      actualReplacement="${replacement//"\c"/"${count}"}"
      for ((i = 0; i < ${#BASH_REMATCH[@]}; i++)); do
        actualReplacement=${actualReplacement//"\\${i}"/"${BASH_REMATCH[i]}"}
      done
    fi

    if [[ ${onlyMatches} == "true" ]]; then
      output+="${actualReplacement}"
    else
      output+="${stringBeforeMatch}${actualReplacement}"
    fi

    count+=1
    if ((max != -1 && count >= max)); then
      break
    fi
  done
  if [[ ${onlyMatches} != "true" ]]; then
    output+="${inputString_nameRef:currentCharIndex}"
  fi
  inputString_nameRef="${output}"
}

# ## regex::getMatches
#
# Returns an array containing all the matched for a regex in a string.
#
# - $1: **string variable name** _as string_:
#       The variable name containing the string to match.
# - $2: **regex** _as string_:
#       The regex to use for the match.
# - ${replacement} _as string_:
#       (optional) The replacement string to use on each match.
#
#       - Use \x to refer to the x-th capture group.
#       - Use \c to refer to replacement counter.
#
#       Set to an empty string to keep the matches as they are.
#       (defaults to "")
# - ${max} _as int_:
#       (optional) The number of matches to return.
#       Set to -1 for unlimited replacements.
#       (defaults to -1)
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: An array containing all the matches.
#
# ```bash
# MY_STRING="name: julien, name: john"
# regex::getMatches MY_STRING "name: (.*)"
# regex::getMatches MY_STRING "name: (.*)" max=1
# for match in "${REPLY_ARRAY[@]}"; do
#   echo "${match}"
# done
# ```
#
# > Regex wiki: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions
function regex::getMatches() {
  local -n inputString_nameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    regex="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    replacement="" \
    max=-1 \
    IFS=" "
  shift 2
  eval "local a= ${*@Q}"

  REPLY_ARRAY=()

  if ((max == 0)); then
    return 0
  fi

  local useReplacement=false usePlaceHolders=false actualReplacement
  if ((${#replacement} > 0)); then
    useReplacement=true
    if [[ ${replacement} == *"\\"* ]]; then
      usePlaceHolders=true
    else
      actualReplacement="${replacement}"
    fi
  fi

  local IFS="" stringBeforeMatch
  local -i count=0 currentCharIndex=0

  while [[ ${inputString_nameRef:currentCharIndex} =~ ${regex} ]]; do
    stringBeforeMatch="${inputString_nameRef:currentCharIndex}"
    stringBeforeMatch="${stringBeforeMatch%%"${BASH_REMATCH[0]}"*}"
    currentCharIndex=$((currentCharIndex + ${#stringBeforeMatch} + ${#BASH_REMATCH[0]}))

    if [[ ${useReplacement} == "true" ]]; then
      if [[ ${usePlaceHolders} == "true" ]]; then
        actualReplacement="${replacement//"\c"/"${count}"}"
        for ((i = 0; i < ${#BASH_REMATCH[@]}; i++)); do
          actualReplacement=${actualReplacement//"\\${i}"/"${BASH_REMATCH[i]}"}
        done
      fi
      REPLY_ARRAY+=("${actualReplacement}")
    else
      REPLY_ARRAY+=("${BASH_REMATCH[0]}")
    fi

    count+=1
    if ((max != -1 && count >= max)); then
      break
    fi
  done
}

# ## regex::escapeRegexSpecialChars
#
# Escapes special characters in a string to be used as a regex.
#
# - $1: **string to escape** _as string_:
#       The string to escape.
#
# Returns:
#
# - ${REPLY}: The escaped string.
#
# ```bash
# regex::escapeRegexSpecialChars "a.(b)"
# echo "${REPLY}"
# ```
function regex::escapeRegexSpecialChars() {
  REPLY="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  REPLY=${REPLY//\\/\\\\}
  REPLY=${REPLY//\//\\\/}
  REPLY=${REPLY//\./\\\.}
  REPLY=${REPLY//\*/\\\*}
  REPLY=${REPLY//\+/\\\+}
  REPLY=${REPLY//\?/\\?}
  REPLY=${REPLY//\(/\\\(}
  REPLY=${REPLY//\)/\\\)}
  REPLY=${REPLY//\[/\\\[}
  REPLY=${REPLY//\]/\\\]}
  REPLY=${REPLY//\{/\\\{}
  REPLY=${REPLY//\}/\\\}}
  REPLY=${REPLY//\^/\\^}
  REPLY=${REPLY//\$/\\\$}
  REPLY=${REPLY//\|/\\|}
}
