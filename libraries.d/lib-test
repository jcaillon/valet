#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## test::title
#
# Call this function to add an H3 title in the report file.
#
# - $1: **title** _as string_:
#       The title of the test.
#
# ```bash
# test::title "Testing something"
# ```
function test::title() {
  printf "%s\n\n" "### ${1:-"Test"}" >>"${GLOBAL_TEST_REPORT_FILE}"
}

# ## test::commentTest
#
# Call this function to add a paragraph in the report file.
#
# - $1: **comment** _as string_:
#       The text to add in the report file.
#
# ```bash
# test::commentTest "This is a comment."
# ```
function test::commentTest() {
  printf "%s\n\n" "${1:-}" >>"${GLOBAL_TEST_REPORT_FILE}"
}

# ## test::exec
#
# Call this function to execute a command and write the command and its output to the report file.
# The command can fail, in which case the returned exit code is written to the report file.
# However, the command must not call `exit` (in which case, use test::execExiting).
#
# - $@: **command** _as string_:
#       The command to execute.
#
# ```bash
# test::exec echo "Hello, world!"
# ```
function test::exec() {
  test_execInternal false "$@"
}

# ## test::execExiting
#
# Call this function to execute a command that can call `exit` and write the command and its output to the report file.
# The command is executed in a subshell to catch the exit.
#
# - $@: **command** _as string_:
#       The command to execute.
#
# ```bash
# test::execExiting exit 3
# ```
function test::execExiting() {
  test_execInternal true "$@"
}

# ## test_execInternal (private)
#
# This function is called by test::exec and test::execExiting to execute a command and
# write the command and its output to the report file.
#
# - $1: **canExit** _as boolean_:
#       Whether the command can call `exit`.
# - $@: **command** _as string_:
#       The command to execute.
#
# ```bash
# test_execInternal false echo "Hello, world!"
# ```
function test_execInternal() {
  local canExit="${1}"
  shift 1
  local arg
  local reportSection="Prompt:"$'\n'$'\n'"\`\`\`bash"$'\n'
  for arg in "$@"; do
    if [[ ${arg} == *[[:space:]]* ]]; then
      reportSection+="\"${arg}\" "
    else
      reportSection+="${arg} "
    fi
  done
  reportSection="${reportSection% }"$'\n'"\`\`\`"$'\n'$'\n'

  printf '%s' "${reportSection}" >>"${GLOBAL_TEST_REPORT_FILE}"

  # reset the standard output and error output files
  # It is necessary to first close the file descriptors before resetting the files
  exec 1>&-
  exec 2>&-
  : >"${GLOBAL_TEST_STANDARD_OUTPUT_FILE}"
  : >"${GLOBAL_TEST_STANDARD_ERROR_FILE}"
  exec 1>"${GLOBAL_TEST_STANDARD_OUTPUT_FILE}"
  exec 2>"${GLOBAL_TEST_STANDARD_ERROR_FILE}"

  # execute the command
  local -i exitCode=0
  if [[ ${canExit} == "true" ]]; then
    if ! ("$@") 1>>"${GLOBAL_TEST_STANDARD_OUTPUT_FILE}" 2>>"${GLOBAL_TEST_STANDARD_ERROR_FILE}"; then
      exitCode=${PIPESTATUS[0]:-}
    fi
  else
    if ! "$@" 1>>"${GLOBAL_TEST_STANDARD_OUTPUT_FILE}" 2>>"${GLOBAL_TEST_STANDARD_ERROR_FILE}"; then
      exitCode=$?
    fi
  fi

  if (( exitCode != 0 )); then
    printf '%s\n\n' "Exited with code: \`${exitCode}\`" >>"${GLOBAL_TEST_REPORT_FILE}"
  fi

  test::flushFdToCodeBlock 1 true
  test::flushFdToCodeBlock 2 true
}

# ## test::flushFdToCodeBlock
#
# This function write the captured standard and error outputs to the report file
# and reset these file descriptors.
#
# - $1: **fdNumber** _as int_:
#       The file descriptor number to flush (1 or 2).
# - $2: **blockTitle** _as boolean_:
#       (optional) Can be set using the variable `_OPTION_BLOCK_TITLE`.
#       Whether to add a title to the code block.
#       (defaults to false)
#
# ```bash
# test::flushFdToCodeBlock 1 true
# ```
function test::flushFdToCodeBlock() {
  local -i fdNumber="${1}"
  local blockTitle="${2:-${_OPTION_BLOCK_TITLE:-false}}"
  local file
  local codeBlockName
  if (( fdNumber == 1 )); then
    file="${GLOBAL_TEST_STANDARD_OUTPUT_FILE}"
    codeBlockName="Standard output"
  else
    file="${GLOBAL_TEST_STANDARD_ERROR_FILE}"
    codeBlockName="Error output"
  fi
  if [[ ! -s "${file}" ]]; then
    return 0
  fi
  local text IFS=''
  read -rd '' text <"${file}" || :
  text="${text//${GLOBAL_VALET_HOME}/\$GLOBAL_VALET_HOME}"
  text="${text//${GLOBAL_TEST_CURRENT_DIRECTORY}/.}"
  text="${text//${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}/\/tmp/valet}"
  text="${text//${GLOBAL_TEMPORARY_FILE_PREFIX}/\/tmp/valet}"

  if [[ ${blockTitle} == "true" ]]; then
    # shellcheck disable=SC2016
    printf '**%s**:\n\n```text\n%s\n```\n\n' "${codeBlockName}" "${text%$'\n'}" >>"${GLOBAL_TEST_REPORT_FILE}"
  else
    # shellcheck disable=SC2016
    printf '```text\n%s\n```\n\n' "${text%$'\n'}" >>"${GLOBAL_TEST_REPORT_FILE}"
  fi

  # shellcheck disable=SC2093
  eval " exec ${fdNumber}>&-; : >'${file}'; exec ${fdNumber}>'${file}';"
}


function test::flush() {
  test::flushFdToCodeBlock 1 true
  test::flushFdToCodeBlock 2 true
}

# ## test::endTest
#
# Call this function after a test to write a test result section to the report file.
# This create a new H3 section in the report file with the given test description,
# the exit code, and the standard and error outputs (if any).
#
#
#
# - $1: **title** _as string_:
#       The title of the test.
# - $2: **exit code** _as int_:
#       The exit code of the test.
# - $3: comment _as string_:
#       (optional) Can be set using the variable `_OPTION_COMMENT`.
#       A text to explain what is being tested.
#       (defaults to "")
#
# ```bash
# test::endTest "Testing something" $?
# ```
function test::endTest() {
  local testTitle="${1:-}"
  local exitCode="${2:-}"
  local testDescription="${3:-${_OPTION_COMMENT:-}}"

  # write the test title
  local reportSection="### ${testTitle:-test}"

  # write the test description if any
  if [[ -n "${testDescription}" ]]; then
    reportSection+=$'\n'$'\n'"${testDescription}"
  fi

  # write the exit code
  reportSection+=$'\n'$'\n'"Exit code: \`${exitCode}\`"

  printf '%s\n\n' "${reportSection}" >>"${GLOBAL_TEST_REPORT_FILE}"

  test::flushFdToCodeBlock 1 true
  test::flushFdToCodeBlock 2 true
}

# Replaces the line numbers from an error log in the given file with XXX.
#
# - $1: **file path** _as string_:
#       The path of the file in which the output is stored.
#
# ```bash
# test::echoFileWithLineNumberSubstitution myFile.log
# ```
function test::echoFileWithLineNumberSubstitution() {
  local file="${1}"
  local line
  local IFS
  while IFS=$'\n' read -rd $'\n' line || [[ -n ${line:-} ]]; do
    if [[ ${line} =~ :[0-9]{1,4}$ ]]; then
      line="${line/%:[[:digit:]]/:XXX}"
      line="${line/%:[[:digit:]][[:digit:]]/:XXX}"
      line="${line/%:[[:digit:]][[:digit:]][[:digit:]]/:XXX}"
      line="${line/%:[[:digit:]][[:digit:]][[:digit:]][[:digit:]]/:XXX}"
    fi
    printf '%s\n' "${line}"
  done <"${file}"
}
