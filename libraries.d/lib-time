#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## time::getDate
#
# Get the current date in the given format.
#
# - ${format} _as string_:
#       (optional) the format (see printf) of the date to return
#       (defaults to "%(%F_%Hh%Mm%Ss)T")
#
# Returns:
#
# - ${REPLY}: the current date in the given format.
#
# ```bash
# time::getDate
# local date="${REPLY}"
# time::getDate format="'%(%Hh%Mm%Ss)T'"
# ```
#
# > This function avoid to call $(date) in a subshell (date is a an external executable).
function time::getDate() {
  local \
    format="%(%F_%Hh%Mm%Ss)T" \
    IFS=" "
  eval "local a= ${*@Q}"

  # shellcheck disable=SC2059
  printf -v REPLY "${format}" "${GLOBAL_MOCK_EPOCHSECONDS:-${EPOCHSECONDS}}"
}

# ## time::getMicrosecondsToHuman
#
# Convert microseconds to human readable format.
#
# - $1: **microseconds** _as int_:
#       the microseconds to convert
# - ${format} _as string_:
#       (optional) the format to use
#
#       Usable formats:
#       - %HH: hours
#       - %MM: minutes
#       - %SS: seconds
#       - %LL: milliseconds
#       - %h: hours without leading zero
#       - %m: minutes without leading zero
#       - %s: seconds without leading zero
#       - %l: milliseconds without leading zero
#       - %u: microseconds without leading zero
#       - %M: total minutes
#       - %S: total seconds
#       - %L: total milliseconds
#       - %U: total microseconds
#
#       (defaults to "%HH:%MM:%SS")
#
# Returns:
#
# - ${REPLY}: the human readable format
#
# ```bash
# time::getMicrosecondsToHuman 123456789
# time::getMicrosecondsToHuman 123456789 format="%HH:%MM:%SS"
# echo "${REPLY}"
# ```
function time::getMicrosecondsToHuman() {
  local -i us="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    format="%HH:%MM:%SS" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  local -i hours=$((us / 3600 / 1000000))
  local -i minutes=$(((us / 60 / 1000000) % 60))
  local -i seconds=$(((us / 1000000) % 60))
  local -i milliseconds=$((us / 1000 % 1000))
  local -i microseconds=$((us % 1000))

  local humanFormat="${format}"
  if [[ ${hours} -lt 10 ]]; then
    humanFormat="${humanFormat//%HH/0${hours}}"
  else
    humanFormat="${humanFormat//%HH/${hours}}"
  fi
  if [[ ${minutes} -lt 10 ]]; then
    humanFormat="${humanFormat//%MM/0${minutes}}"
  else
    humanFormat="${humanFormat//%MM/${minutes}}"
  fi
  if [[ ${seconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%SS/0${seconds}}"
  else
    humanFormat="${humanFormat//%SS/${seconds}}"
  fi
  if [[ ${milliseconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%LL/00${milliseconds}}"
  elif [[ ${milliseconds} -lt 100 ]]; then
    humanFormat="${humanFormat//%LL/0${milliseconds}}"
  else
    humanFormat="${humanFormat//%LL/${milliseconds}}"
  fi
  if [[ ${microseconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%UU/00${microseconds}}"
  elif [[ ${microseconds} -lt 100 ]]; then
    humanFormat="${humanFormat//%UU/0${microseconds}}"
  else
    humanFormat="${humanFormat//%UU/${microseconds}}"
  fi
  humanFormat="${humanFormat//%h/${hours}}"
  humanFormat="${humanFormat//%m/${minutes}}"
  humanFormat="${humanFormat//%s/${seconds}}"
  humanFormat="${humanFormat//%l/${milliseconds}}"
  humanFormat="${humanFormat//%u/${microseconds}}"
  humanFormat="${humanFormat//%M/$((hours * 60 + minutes))}"
  humanFormat="${humanFormat//%S/$((hours * 3600 + minutes * 60 + seconds))}"
  humanFormat="${humanFormat//%L/$(((hours * 3600 * +minutes * 60 + seconds) * 1000 + milliseconds))}"
  humanFormat="${humanFormat//%U/$((us))}"

  REPLY="${humanFormat}"
}

# ## time::startTimer
#
# Start a timer. You can then call `time::getTimerMicroseconds` to get the elapsed time.
#
# ```bash
# time::startTimer
# time::getTimerMicroseconds
# ```
function time::startTimer() {
  time::getProgramElapsedMicroseconds
  _TIME_TIMER_START="${REPLY}"
}

# ## time::getTimerMicroseconds
#
# Get the time elapsed since the call of `time::startTimer`.
#
# - ${logElapsedTime} _as bool_:
#       (optional) Wether or not to log the elapsed time.
#       (defaults to false)
# - ${format} _as string_:
#       (optional) The format to use if we log the elapsed time.
#       See `time::getMicrosecondsToHuman` for the format.
#       (defaults to "%S.%LLs").
#
# Returns:
#
# - ${REPLY}: the elapsed time in microseconds.
#
# ```bash
# time::startTimer
# time::getTimerMicroseconds logElapsedTime=true
# echo "Total microseconds: ${REPLY}"
# ```
function time::getTimerMicroseconds() {
  local \
    logElapsedTime=false \
    format="%S.%LLs" \
    IFS=" "
  eval "local a= ${*@Q}"

  time::getProgramElapsedMicroseconds
  local -i elapsed=$((REPLY - _TIME_TIMER_START))

  if [[ ${logElapsedTime} == "true" ]]; then
    time::getMicrosecondsToHuman ${elapsed} format="${format}"
    log::info "Elapsed time: ${REPLY}"
  fi

  REPLY="${elapsed}"
}

# ## time::getMicrosecondsToSeconds
#
# Convert a microseconds integer to seconds float.
# e.g. 1234567 → 1.234567
#
# - $1: **microseconds** _as int_:
#       the microseconds to convert
# - ${precision} _as string_:
#       (optional) The precision to get (number of digits after the dot).
#       (defaults to 6)
#
# Returns:
#
# - ${REPLY}: The seconds (float number).
#
# ```bash
# time::getMicrosecondsToSeconds 1234567
# time::getMicrosecondsToSeconds 1234567 precision=3
# echo "${REPLY}"
# ```
function time::getMicrosecondsToSeconds() {
  local \
    microseconds="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    precision=6 \
    IFS=" "
  shift 1
  eval "local a= ${*@Q}"

  if [[ ${#microseconds} -gt 6 ]]; then
    local ms="${microseconds:${#microseconds}-6}"
    REPLY="${microseconds:0:${#microseconds}-6}.${ms:0:${precision}}"
  else
    printf -v REPLY "%06d" "${microseconds}"
    printf -v REPLY "0.%s" "${REPLY:0:${precision}}"
  fi
}

# ## time::getSecondsToMicroseconds
#
# Convert a seconds float to microseconds integer.
# e.g. 1.234567 → 1234567
#
# - $1: **seconds** _as float_:
#       the seconds to convert
#
# Returns:
#
# - ${REPLY}: The microseconds (integer number).
#
# ```bash
# time::getSecondsToMicroseconds 1.234567
# echo "${REPLY}"
# ```
function time::getSecondsToMicroseconds() {
  local seconds="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  local integerPart="${seconds%%.*}"
  local decimalPart="${seconds#*.}"
  if [[ ${integerPart} == "${seconds}" ]]; then
    decimalPart="0"
  fi
  printf -v decimalPart "%-06s" "${decimalPart}"
  decimalPart="${decimalPart// /0}"
  REPLY="$((integerPart * 1000000 + 10#${decimalPart:0:6}))"
}

# ## time::isTimeElapsed
#
# Check if a given time in microseconds has elapsed since the last call
# to this function.
#
# - $1: **microseconds** _as int_:
#       the microseconds to check
# - ${timerName} _as int_:
#       A variable name that will be used to store the last time this function was called.
#       Defaults to the name of the calling function.
#       Can be set to a fixed value if you call this function from different functions
#       and want to share the same timer.
#       (defaults to "${FUNCNAME[1]}")
#
# Returns:
#
# - 0 if the time has elapsed
# - 1 if the time has not yet elapsed
#
# ```bash
# if time::isTimeElapsed 500000; then
#   echo "500ms has elapsed since the last call to this function"
# fi
# ```
function time::isTimeElapsed() {
  local \
    microseconds="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    timerName="${FUNCNAME[1]:-main}" \
    IFS=" "
  shift 1
  eval "local a= ${*@Q}"

  timerName="${timerName//[^a-zA-Z0-9_]/_}"

  local REPLY
  time::getProgramElapsedMicroseconds

  if [[ ! -v _TIME_IS_TIME_ELAPSED_${timerName} ]]; then
    # initialize the variable to 0 if it does not exist
    declare -g "_TIME_IS_TIME_ELAPSED_${timerName}=${REPLY}"
    return 1
  fi

  local -n lastTime="_TIME_IS_TIME_ELAPSED_${timerName}"

  if ((REPLY - lastTime >= microseconds)); then
    lastTime="${REPLY}"
    return 0
  fi

  return 1
}
