#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## time::getDate
#
# Get the current date in the given format.
#
# - ${format} _as string_:
#       (optional) the format (see printf) of the date to return
#       (defaults to "%(%F_%Hh%Mm%Ss)T")
#
# Returns:
#
# - ${REPLY}: the current date in the given format.
#
# ```bash
# time::getDate
# local date="${REPLY}"
# time::getDate format="'%(%Hh%Mm%Ss)T'"
# ```
#
# > This function avoid to call $(date) in a subshell (date is a an external executable).
function time::getDate() {
  local \
    format="%(%F_%Hh%Mm%Ss)T" \
    IFS=" "
  eval "local a= ${*@Q}"

  # shellcheck disable=SC2059
  printf -v REPLY "${format}" "${EPOCHSECONDS}"
}

# ## time::convertMicrosecondsToHuman
#
# Convert microseconds to human readable format.
#
# - $1: **microseconds** _as int_:
#       the microseconds to convert
# - ${format} _as string_:
#       (optional) the format to use
#
#       Usable formats:
#       - %HH: hours
#       - %MM: minutes
#       - %SS: seconds
#       - %LL: milliseconds
#       - %h: hours without leading zero
#       - %m: minutes without leading zero
#       - %s: seconds without leading zero
#       - %l: milliseconds without leading zero
#       - %u: microseconds without leading zero
#       - %M: total minutes
#       - %S: total seconds
#       - %L: total milliseconds
#       - %U: total microseconds
#
#       (defaults to "%HH:%MM:%SS")
#
# Returns:
#
# - ${REPLY}: the human readable format
#
# ```bash
# time::convertMicrosecondsToHuman 123456789
# time::convertMicrosecondsToHuman 123456789 format="%HH:%MM:%SS"
# echo "${REPLY}"
# ```
function time::convertMicrosecondsToHuman() {
  local -i us="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    format="%HH:%MM:%SS" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  local -i hours=$((us / 3600 / 1000000))
  local -i minutes=$(((us / 60 / 1000000) % 60))
  local -i seconds=$(((us / 1000000) % 60))
  local -i milliseconds=$((us / 1000 % 1000))
  local -i microseconds=$((us % 1000))

  local humanFormat="${format}"
  if [[ ${hours} -lt 10 ]]; then
    humanFormat="${humanFormat//%HH/0${hours}}"
  else
    humanFormat="${humanFormat//%HH/${hours}}"
  fi
  if [[ ${minutes} -lt 10 ]]; then
    humanFormat="${humanFormat//%MM/0${minutes}}"
  else
    humanFormat="${humanFormat//%MM/${minutes}}"
  fi
  if [[ ${seconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%SS/0${seconds}}"
  else
    humanFormat="${humanFormat//%SS/${seconds}}"
  fi
  if [[ ${milliseconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%LL/00${milliseconds}}"
  elif [[ ${milliseconds} -lt 100 ]]; then
    humanFormat="${humanFormat//%LL/0${milliseconds}}"
  else
    humanFormat="${humanFormat//%LL/${milliseconds}}"
  fi
  if [[ ${microseconds} -lt 10 ]]; then
    humanFormat="${humanFormat//%UU/00${microseconds}}"
  elif [[ ${microseconds} -lt 100 ]]; then
    humanFormat="${humanFormat//%UU/0${microseconds}}"
  else
    humanFormat="${humanFormat//%UU/${microseconds}}"
  fi
  humanFormat="${humanFormat//%h/${hours}}"
  humanFormat="${humanFormat//%m/${minutes}}"
  humanFormat="${humanFormat//%s/${seconds}}"
  humanFormat="${humanFormat//%l/${milliseconds}}"
  humanFormat="${humanFormat//%u/${microseconds}}"
  humanFormat="${humanFormat//%M/$((hours * 60 + minutes))}"
  humanFormat="${humanFormat//%S/$((hours * 3600 + minutes * 60 + seconds))}"
  humanFormat="${humanFormat//%L/$(((hours * 3600 * +minutes * 60 + seconds) * 1000 + milliseconds))}"
  humanFormat="${humanFormat//%U/$((us))}"

  REPLY="${humanFormat}"
}

# ## time::startTimer
#
# Start a timer. You can then call `time::getTimerMicroseconds` to get the elapsed time.
#
# ```bash
# time::startTimer
# time::getTimerMicroseconds
# ```
function time::startTimer() {
  time::getProgramElapsedMicroseconds
  _TIME_TIMER_START="${REPLY}"
}

# ## time::getTimerMicroseconds
#
# Get the time elapsed since the call of `time::startTimer`.
#
# - ${logElapsedTime} _as bool_:
#       (optional) Wether or not to log the elapsed time.
#       (defaults to false)
# - ${format} _as string_:
#       (optional) The format to use if we log the elapsed time.
#       See `time::convertMicrosecondsToHuman` for the format.
#       (defaults to "%S.%LLs").
#
# Returns:
#
# - ${REPLY}: the elapsed time in microseconds.
#
# ```bash
# time::startTimer
# time::getTimerMicroseconds logElapsedTime=true
# echo "Total microseconds: ${REPLY}"
# ```
function time::getTimerMicroseconds() {
  local \
    logElapsedTime=false \
    format="%S.%LLs" \
    IFS=" "
  eval "local a= ${*@Q}"

  time::getProgramElapsedMicroseconds
  local -i elapsed=$((REPLY - _TIME_TIMER_START))

  if [[ ${logElapsedTime} == "true" ]]; then
    time::convertMicrosecondsToHuman ${elapsed} format="${format}"
    log::info "Elapsed time: ${REPLY}"
  fi

  REPLY="${elapsed}"
}

# ## time::convertMicrosecondsToSeconds
#
# Convert a microseconds integer to seconds float.
# e.g. 1234567 → 1.234567
#
# - $1: **microseconds** _as int_:
#       the microseconds to convert
# - ${precision} _as string_:
#       (optional) The precision to get (number of digits after the dot).
#       (defaults to 6)
#
# Returns:
#
# - ${REPLY}: The seconds (float number).
#
# ```bash
# time::convertMicrosecondsToSeconds 1234567
# time::convertMicrosecondsToSeconds 1234567 precision=3
# echo "${REPLY}"
# ```
function time::convertMicrosecondsToSeconds() {
  local \
    microseconds="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    precision=6 \
    IFS=" "
  shift 1
  eval "local a= ${*@Q}"

  if [[ ${#microseconds} -gt 6 ]]; then
    local ms="${microseconds:${#microseconds}-6}"
    REPLY="${microseconds:0:${#microseconds}-6}.${ms:0:${precision}}"
  else
    printf -v REPLY "%06d" "${microseconds}"
    printf -v REPLY "0.%s" "${REPLY:0:${precision}}"
  fi
}
