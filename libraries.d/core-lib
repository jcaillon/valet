#!/usr/bin/env bash
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

#===============================================================
# >>> Temporary files and folders
#===============================================================

# ## fs::setupTempFileGlobalVariable (private)
#
# Setup global variables that will be used for temporary files and folders.
function fs::setupTempFileGlobalVariable() {
  # get unique file names for the stdout, stderr and temporary directory
  # to be fast, we do not create anything until we really need it
  # this could lead to issues, although it is very unlikely
  GLOBAL_TEMPORARY_DIRECTORY_PREFIX="${VALET_CONFIG_TEMP_DIRECTORY:-${TMPDIR:-/tmp}}/vt-${BASHPID}"
  GLOBAL_TEMPORARY_FILE_PREFIX="${VALET_CONFIG_RUNTIME_DIRECTORY:-${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}}/vt-${BASHPID}"

  while [[ -e "${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d" ]]; do
    # just in case we have a collision
    GLOBAL_TEMPORARY_DIRECTORY_PREFIX+="x"
    GLOBAL_TEMPORARY_FILE_PREFIX+="x"
  done

  GLOBAL_TEMPORARY_DIRECTORY="${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_WORK_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-work.f"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_STDOUT_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stdout.f"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_STDERR_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stderr.f"
  unset -v TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
}

# ## fs::setupSubshellTempFileGlobalVariable (private)
#
# Setup global variables that will be used for temporary files and folders in the context
# of a subshell. We keep everything under a new directory named with the process ID;
# the dir gets cleanup when the main process ends.
function fs::setupSubshellTempFileGlobalVariable() {
  if ((BASH_SUBSHELL == 0)); then
    core::fail "This function should only be called in a subshell."
  fi
  TMPDIR="${GLOBAL_TEMPORARY_DIRECTORY}/job-${BASHPID}"
  unset -v VALET_CONFIG_RUNTIME_DIRECTORY VALET_CONFIG_TEMP_DIRECTORY XDG_RUNTIME_DIR
  fs::setupTempFileGlobalVariable
}

# ## fs::createTempFile
#
# Creates a temporary file and return its path.
#
# - ${pathOnly} _as bool_:
#       (optional) If true, does not create the file, only returns the path.
#       (defaults to false)
#
# Returns:
#
# - ${REPLY}: The created path.
#
# ```bash
# fs::createTempFile
# echo "${REPLY}"
# fs::createTempFile pathOnly=true
# ```
#
# > Files created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
function fs::createTempFile() {
  local \
    pathOnly="false" \
    IFS=$' '
  eval "local a= ${*@Q}"

  if [[ ! -v TEMPORARY_FILE_NUMBER ]]; then
    TEMPORARY_FILE_NUMBER=0
    if [[ ! -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
      mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    fi
  fi
  TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
  REPLY="${GLOBAL_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
  if [[ ${pathOnly} != "true" ]]; then
    : >"${REPLY}"
  fi
}

# ## fs::createTempDirectory
#
# Creates a temporary directory.
#
# - ${pathOnly} _as bool_:
#       (optional) If true, does not create the file, only returns the path.
#       (defaults to false)
#
# Returns:
#
# - ${REPLY}: The created path.
#
# ```bash
# fs::createTempDirectory
# echo "${REPLY}"
# fs::createTempDirectory pathOnly=true
# ```
#
# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
function fs::createTempDirectory() {
  local \
    pathOnly="false" \
    IFS=$' '
  eval "local a= ${*@Q}"

  if [[ ! -v TEMPORARY_DIRECTORY_NUMBER ]]; then
    TEMPORARY_DIRECTORY_NUMBER=0
    if [[ ${pathOnly} == "true" && ! -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
      mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    fi
  fi
  TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
  REPLY="${GLOBAL_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
  if [[ ${pathOnly} != "true" ]]; then
    mkdir -p "${REPLY}" 1>/dev/null
  fi
}

# ## fs::cleanTempFiles
#
# Removes all the temporary files and directories that were created by the
# `fs::createTempFile` and `fs::createTempDirectory` functions.
#
# ```bash
# fs::cleanTempFiles
# ```
function fs::cleanTempFiles() {
  if [[ -d ${GLOBAL_TEMPORARY_DIRECTORY:-} ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${GLOBAL_TEMPORARY_DIRECTORY}" &>/dev/null || :
  fi
  if [[ -n ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY:-} && -d ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting temporary windows directory."
    rm -Rf "${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY}" &>/dev/null || :
  fi
  if [[ -n ${GLOBAL_TEMPORARY_FILE_PREFIX:-} ]]; then
    log::debug "Deleting temporary files."
    rm -f "${GLOBAL_TEMPORARY_FILE_PREFIX}"* &>/dev/null || :
  fi
  unset -v TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
}

# TODO: create fs::cleanAllTempFiles which looks for existing temp files from older processes
# if not running then it is safe to delete

#===============================================================
# >>> Terminal UI
#===============================================================

# ## terminal::getTerminalSize
#
# This function exports the terminal size.
#
# Returns:
#
# - `GLOBAL_COLUMNS`: The number of columns in the terminal.
# - `GLOBAL_LINES`: The number of lines in the terminal.
#
# ```bash
# terminal::getTerminalSize
# printf '%s\n' "The terminal has ⌜${GLOBAL_COLUMNS}⌝ columns and ⌜${GLOBAL_LINES}⌝ lines."
# ```
# shellcheck disable=SC2034
function terminal::getTerminalSize() {
  if [[ ! -t ${GLOBAL_FD_TUI} ]]; then
    return 0
  fi
  {
    shopt -s checkwinsize
    # the following subshell is required to correctly compute the columns and lines
    # the bash manual says these are computed after the execution of an external command
    # but it works with a subshell
    (
      :
      :
    )
    GLOBAL_COLUMNS="${COLUMNS:-120}"
    GLOBAL_LINES="${LINES:-30}"
    shopt -u checkwinsize
  } 1>&"${GLOBAL_FD_TUI}" 2>&1
  # redirection to the terminal FD is necessary for bash to compute the terminal size
}

#===============================================================
# >>> Logging
#===============================================================

# ## log::setLevel
#
# Set the log level.
#
# - $1: **log level** _as string_:
#       The log level to set (or defaults to info), acceptable values are:
#   - trace
#   - debug
#   - info
#   - success
#   - warning
#   - error
# - ${silent} _as bool_:
#       (optional) true to silently switch log level, i.e. does not print a message
#       (defaults to false)
#
# ```bash
# log::setLevel debug
# log::setLevel debug silent=true
# ```
function log::setLevel() {
  GLOBAL_LOG_LEVEL="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    silent="false" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  # lowercase the log level
  GLOBAL_LOG_LEVEL="${GLOBAL_LOG_LEVEL,,}"

  # log level, defaults to info
  case "${GLOBAL_LOG_LEVEL}" in
  error) GLOBAL_LOG_LEVEL_INT=4 ;;
  warning) GLOBAL_LOG_LEVEL_INT=3 ;;
  success) GLOBAL_LOG_LEVEL_INT=2 ;;
  info) GLOBAL_LOG_LEVEL_INT=1 ;;
  debug) GLOBAL_LOG_LEVEL_INT=0 ;;
  trace) GLOBAL_LOG_LEVEL_INT=-1 ;;
  *) core::fail "Unknown log level: ${GLOBAL_LOG_LEVEL}" ;;
  esac

  if [[ ${silent} != "true" ]]; then
    if ((GLOBAL_LOG_LEVEL_INT != 1)); then
      log::debug "Log level set to ${GLOBAL_LOG_LEVEL}."
    fi
    if ((GLOBAL_LOG_LEVEL_INT <= 0)); then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# ## log::getLevel
#
# Get the current log level.
#
# Returns:
#
# - ${REPLY}: The current log level.
#
# ```bash
# log::getLevel
# printf '%s\n' "The log level is ⌜${REPLY}⌝."
# ```
function log::getLevel() {
  REPLY="${GLOBAL_LOG_LEVEL:-info}"
}

# ## log::print
#
# Display a log message.
#
# - $1: **color name** _as string_:
#       The color name to use for the severity (TRACE, DEBUG...).
# - $2: **icon** _as string_:
#       The icon to display in the log message (utf8 character from nerd icons).
# - $3: **severity** _as string_:
#       The severity to display (max 7 chars for the default log pattern).
# - $4: **message** _as string_:
#       The message to log.
#
# ```bash
# log::print "SUCCESS" $'\uf14a' "OK" "This is a success message."
# ```
# shellcheck disable=SC2034
function log::print() {
  local \
    colorName="${1}" \
    icon="${2}" \
    level="${3}" \
    messageToLog="${4}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::error
#
# Displays an error message.
#
# - $1: **message** _as string_:
#       the error messages to display
#
# ```bash
# log::error "This is an error message."
# ```
#
# > You probably want to exit immediately after an error and should consider using core::fail function instead.
function log::error() {
  # shellcheck disable=SC2034
  local \
    colorName="ERROR" \
    icon="${ICON_ERROR:-}" \
    level="ERROR" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"

  if log::isDebugEnabled; then
    log::printCallStack
  fi
}

# ## log::warning
#
# Displays a warning.
#
# - $1: **message** _as string_:
#       the warning messages to display
#
# ```bash
# log::warning "This is a warning message."
# ```
function log::warning() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 3)); then
    return 0
  fi
  # shellcheck disable=SC2034
  local \
    colorName="WARNING" \
    icon="${ICON_WARNING:-}" \
    level="WARNING" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::success
#
# Displays a success message.
#
# - $1: **message** _as string_:
#       the success messages to display
#
# ```bash
# log::success "This is a success message."
# ```
function log::success() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 2)); then
    return 0
  fi
  # shellcheck disable=SC2034
  local \
    colorName="SUCCESS" \
    icon="${ICON_SUCCESS:-}" \
    level="SUCCESS" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::info
#
# Displays an info message.
#
# - $1: **message** _as string_:
#       the info messages to display
#
# ```bash
# log::info "This is an info message."
# ```
function log::info() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 1)); then
    return 0
  fi
  # shellcheck disable=SC2034
  local \
    colorName="INFO" \
    icon="${ICON_INFO:-}" \
    level="INFO" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::debug
#
# Displays a debug message.
#
# - $1: **message** _as string_:
#       the debug messages to display
#
# ```bash
# log::debug "This is a debug message."
# ```
function log::debug() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 0)); then
    return 0
  fi
  # shellcheck disable=SC2034
  local \
    colorName="DEBUG" \
    icon="${ICON_DEBUG:-}" \
    level="DEBUG" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::trace
#
# Displays a trace message.
#
# - $1: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::trace "This is a trace message."
# ```
function log::trace() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > -1)); then
    return 0
  fi
  # shellcheck disable=SC2034
  local \
    colorName="TRACE" \
    icon="${ICON_TRACE:-}" \
    level="TRACE" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::errorTrace
#
# Displays an error trace message.
# This is a trace message that is always displayed, independently of the log level.
# It can be used before a fatal error to display useful information.
#
# - $1: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::errorTrace "This is a debug message."
# ```
function log::errorTrace() {
  # shellcheck disable=SC2034
  local \
    colorName="TRACE" \
    icon="${ICON_TRACE:-}" \
    level="TRACE" \
    messageToLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::isDebugEnabled
#
# Check if the debug mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if debug mode is enabled (log level is debug)
#   - 1 if disabled
#
# ```bash
# if log::isDebugEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isDebugEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= 0)); then
    return 0
  fi
  return 1
}

# ## log::isTraceEnabled
#
# Check if the trace mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if trace mode is enabled (log level is trace)
#   - 1 if disabled
#
# ```bash
# if log::isTraceEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isTraceEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= -1)); then
    return 0
  fi
  return 1
}

# ## log::printTrappedBashCommand (private)
#
# This function prints the current bash command when called from a trap.
function log::printTrappedBashCommand() {
  local symbol="╰"
  if [[ -n ${FUNCNAME[2]:-} ]]; then
    symbol="╭"
  fi
  log::printString "${symbol} ${BASH_COMMAND:-}" newLinePadString="│ "
}

# ## log::printCallStack
#
# This function prints the current function stack in the logs.
#
# - ${stackToSkip} _as int_:
#       (optional) The number of stack to skip.
#       (defaults to 2 which skips this function and the first calling function
#       which is usually the onError function)
# - ${stackToSkipAtEnd} _as int_:
#       (optional) The number of stack to skip at the end.
#       (defaults to 0)
#
# ```bash
# log::printCallStack
# log::printCallStack stackToSkip=0
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
# shellcheck disable=SC2120
function log::printCallStack() {
  local \
    stackToSkip=2 \
    stackToSkipAtEnd=0 \
    IFS=$' '
  eval "local a= ${*@Q}"

  log::getCallStack stackToSkip="$((stackToSkip + 1))" stackToSkipAtEnd="${stackToSkipAtEnd}" wrapWidth="$((${GLOBAL_LOG_COLUMNS:-${GLOBAL_COLUMNS}} - ${#GLOBAL_LOG_WRAP_PADDING}))"
  if ((${#REPLY} > 0)); then
    log::printString "${REPLY}"
  fi
}

# ## log::getCallStack
#
# This function returns the current function stack.
#
# - ${stackToSkip} _as int_:
#       (optional) The number of stack to skip.
#       (defaults to 1 which skips this function)
# - ${stackToSkipAtEnd} _as int_:
#       (optional) The number of stack to skip at the end.
#       (defaults to 0)
# - ${wrapWidth} _as int_:
#       (optional) The width to wrap the call stack.
#       (defaults 0 which means no wrapping)
#
# Returns:
#
# - ${REPLY}: The call stack as a string.
#
# ```bash
# log::getCallStack
# echo "${REPLY}"
# log::getCallStack stackToSkip=2 stackToSkipAtEnd=1 wrapWidth=80
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
function log::getCallStack() {
  local \
    stackToSkip=1 \
    stackToSkipAtEnd=0 \
    wrapWidth=0 \
    IFS=$' '
  eval "local a= ${*@Q}"

  local -a stackFunctionNames stackSourceFiles stackLineNumbers
  if [[ -n ${GLOBAL_STACK_FUNCTION_NAMES:-} ]]; then
    stackFunctionNames=("${GLOBAL_STACK_FUNCTION_NAMES[@]}")
    stackSourceFiles=("${GLOBAL_STACK_SOURCE_FILES[@]}")
    stackLineNumbers=("${GLOBAL_STACK_LINE_NUMBERS[@]}")
  else
    stackFunctionNames=("${FUNCNAME[@]}")
    stackSourceFiles=("${BASH_SOURCE[@]}")
    stackLineNumbers=("${BASH_LINENO[@]}")
  fi

  local -i idx stackSize=$((${#stackFunctionNames[@]} - stackToSkipAtEnd))
  local functionName lineNumber="${LINENO}" sourceFile line returnedString=""
  local treeString="├─" treePadding="│  "
  for ((idx = stackToSkip; idx < stackSize; idx++)); do
    functionName="${stackFunctionNames[${idx}]}"
    if [[ -z ${functionName} ]]; then
      functionName=ROOT
    else
      functionName="${functionName}()"
    fi
    if ((idx > 0)); then
      lineNumber="${stackLineNumbers[$((idx - 1))]}"
    fi
    sourceFile="${stackSourceFiles[${idx}]}"
    if [[ -z ${sourceFile} ]]; then
      sourceFile=non_file_source
    fi
    sourceFile="${sourceFile#"./"}"
    sourceFile="${sourceFile#"${GLOBAL_PROGRAM_STARTED_AT_DIRECTORY}/"}"
    if ((idx == stackSize - 1)); then
      treeString="╰─"
      treePadding="   "
    fi
    line="${treeString} in ${functionName} at ${sourceFile}:${lineNumber}"
    if ((wrapWidth > 0)); then
      local REPLY2
      string::wrapCharacters line width="${wrapWidth}" newLinePadString="${treePadding}"
      returnedString+="${REPLY}"$'\n'
    else
      returnedString+="${line}"$'\n'
    fi
  done

  REPLY="${returnedString}"
}

# ## log::printFile
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **path** _as string_:
#       the file path to display.
# - ${maxLines} _as int_:
#       (optional) Max lines to display, can be set to 0 to display all lines.
#       (defaults to 0)
#
# ```bash
# log::printFile "/my/file/path"
# log::printFile "/my/file/path" maxLines=10
# ```
# shellcheck disable=SC2317
function log::printFile() {
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    maxLines="0" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  local REPLY_CODE REPLY REPLY2 line rawStringToPrintInLog lineNumberPadding="   "
  local -i lineNumber=1 currentLineNumberLength=1
  if [[ ! -f "${filePath}" ]]; then
    log::error "Can not print the file ⌜${filePath}⌝ because does not exist."
    return 0
  fi

  while IFS=$'\n' read -rd $'\n' line || [[ -n ${line:-} ]]; do
    log::printFileInternalLoop
    if ((REPLY_CODE != 0)); then
      break
    fi
  done <"${filePath}"

  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::printFileString
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **content variable name** _as string_:
#       The name of the variable containing the file content to print.
# - ${maxLines} _as int_:
#       (optional) Max lines to display, can be set to 0 to display all lines.
#       (defaults to 0)
#
# ```bash
# log::printFileString "myvar"
# log::printFileString "myvar" maxLines=10
# ```
#
# > This function is not at all suited for large strings, print the content to a file instead.
# shellcheck disable=SC2317
function log::printFileString() {
  local -n contentToPrint="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    maxLines="0" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  local REPLY_CODE REPLY REPLY2 line rawStringToPrintInLog lineNumberPadding="   "
  local -i lineNumber=1 currentLineNumberLength=1

  while IFS=$'\n' read -rd $'\n' line; do
    log::printFileInternalLoop
    if ((REPLY_CODE != 0)); then
      break
    fi
  done <<<"${contentToPrint}"

  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::printFileInternalLoop (private)
#
# An internal function used in log::printFile and log::printFileString to display each line
# of a file or string. It uses the local variables set by the calling function.
function log::printFileInternalLoop() {
  if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
    string::wrapCharacters line width="${GLOBAL_LOG_COLUMNS}" newLinePadString="${GLOBAL_LOG_WRAP_PADDING}     ${STYLE_COLOR_FADED}░${STYLE_COLOR_DEFAULT} " firstLineWidth=$((GLOBAL_LOG_COLUMNS - 7 - ${#GLOBAL_LOG_WRAP_PADDING}))

    rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}${STYLE_COLOR_FADED}${lineNumberPadding}${lineNumber} ░${STYLE_COLOR_DEFAULT} ${REPLY}"$'\n'
  else
    rawStringToPrintInLog+="${STYLE_COLOR_FADED}${lineNumberPadding}${lineNumber} ░${STYLE_COLOR_DEFAULT} ${line}"$'\n'
  fi

  lineNumber+=1
  if ((${#lineNumber} > currentLineNumberLength)); then
    lineNumberPadding="${lineNumberPadding%?}"
    currentLineNumberLength+=1
  fi
  if ((maxLines != 0 && lineNumber > maxLines)); then
    if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
      rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}"
    fi
    rawStringToPrintInLog+="${STYLE_COLOR_FADED}     ░ (truncated)${STYLE_COLOR_DEFAULT}"$'\n'
    REPLY_CODE=1
    return 0
  fi
  REPLY_CODE=0
}

# ## log::printString
#
# Display a string in the log.
# The string will be aligned with the current log output and hard wrapped if necessary.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to log (can contain new lines)
# - ${newLinePadString} _as string_:
#       (optional) the string with which to prepend each wrapped line
#       (empty by default)
#
# ```bash
# log::printString "my line"
# log::printString "my line" newLinePadString="  "
# ```
# shellcheck disable=SC2317
function log::printString() {
  local \
    content="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    newLinePadString="" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  local REPLY REPLY2 line rawStringToPrintInLog
  while [[ -n ${content} ]]; do
    line="${content%%$'\n'*}"
    content="${content:${#line}+1}"

    if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
      string::wrapCharacters line width="${GLOBAL_LOG_COLUMNS}" newLinePadString="${GLOBAL_LOG_WRAP_PADDING}${newLinePadString}" firstLineWidth="$((GLOBAL_LOG_COLUMNS - ${#GLOBAL_LOG_WRAP_PADDING}))"
      rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}${REPLY}"$'\n'
    else
      rawStringToPrintInLog+="${line}"$'\n'
    fi
  done
  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::saveFile
#
# Save the given file by copying it to a new file in the user local state directory
# (using `core::createSavedFilePath`).
# Useful for debugging purposes, to save the state of a file during execution.
#
# - $1: **path** _as string_:
#       The file path to save.
# - ${suffix} _as string_:
#       The suffix for the file to create.
# - ${logPath} _as bool_:
#       (optional) if true, log the path of the saved file using `log::printString`
#       (defaults to true)
#
# Returns:
#
# - ${REPLY}: The path to the saved file.
#
# ```bash
# log::saveFile "/my/file/path" "suffix" "important result file"
# ```
function log::saveFile() {
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    suffix="" \
    logPath="true" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  core::createSavedFilePath suffix="${suffix}"
  local newFilePath="${REPLY}"
  cp "${filePath}" "${newFilePath}"
  if [[ ${logPath} == "true" ]]; then
    log::printString "⌜${newFilePath}⌝"
  fi
  REPLY="${newFilePath}"
}

# ## log::saveFileString
#
# Save the given string to a new file in the user local state directory
# (using `core::createSavedFilePath`).
# Useful for debugging purposes, to save the state of a string during execution.
#
# - $1: **content variable name** _as string_:
#       The variable name of the content to save.
# - ${suffix} _as string_:
#       The suffix for the file to create.
# - ${logPath} _as bool_:
#       (optional) if true, log the path of the saved file using `log::printString`
#       (defaults to true)
#
# Returns:
#
# - ${REPLY}: The path to the saved file.
#
# ```bash
# log::saveFileString "my content" "suffix" "important result file"
# ```
function log::saveFileString() {
  local -n contentToSave="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    suffix="" \
    logPath="true" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  core::createSavedFilePath suffix="${suffix}"
  local newFilePath="${REPLY}"
  printf '%s' "${contentToSave}" >"${newFilePath}"
  if [[ ${logPath} == "true" ]]; then
    log::printString "⌜${newFilePath}⌝"
  fi
  REPLY="${newFilePath}"
}

# ## log::printRaw
#
# Display something in the log stream.
# Does not check the log level.
#
# - $1: **content variable name** _as string_:
#       The variable name containing the content to print (can contain new lines).
#
# ```bash
# log::printRaw "my line"
# ```
# shellcheck disable=SC2317
function log::printRaw() {
  local -n rawStringToPrintInLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # shellcheck disable=SC2034

  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log_setPrintfArgumentFromFormat (private)
#
# Set the variable printfArgument from the format specifier.
function log_setPrintfArgumentFromFormat() {
  local format="${printfFormat#'%'}"
  if [[ ${format} != *[0-9]* ]]; then
    printfArgument="\${${1}}"
  else
    format="${format%[sd]}"
    if [[ ${format} == "-"* ]]; then
      format="${format#-}"
      printfArgument="\${${1}:0:${format#-}}"
    else
      printfArgument="\${${1}:\${#${1}} - ${format} > 0 ? \${#${1}} - ${format} : 0}"
    fi
  fi
}

# ## log::parseLogPattern (private)
#
# Parse the log pattern and set variables that will be used to print the logs.
# If the pattern changes during runtime, the function `log::init` should be called again.
#
# - $1: **log pattern** _as string_:
#       The log pattern to parse.
#
# Available placeholders:
#
# - `<colorXXX>`: The value of the color variable `STYLE_COLOR_XXX`.
# - `<time>`: The current time formatted with the `format` string.
# - `<level>`: The log level.
# - `<levelColor>`: The color for the log level.
# - `<icon>`: The log level icon.
# - `<pid>`: The process ID of the bash instance that logged the message.
# - `<subshell>`: The subshell level of the bash instance that logged the message.
# - `<function>`: The name of the function that logged the message.
# - `<line>`: The line number where the message was logged.
# - `<source>`: The source of the function that logged the message.
# - `<varXXX>`: The value of an arbitrary variable `XXX`.
# - `<message>`: The log message (should be the last placeholder).
# - `<sourceFile>`: The file name of the source of the function that logged the message.
# - `<wrapPadding>`: The padding (spaces) used for wrapping the log message.
# - `<elapsedTime>`: The time elapsed since the start of the script.
# - `<elapsedTimeSinceLastLog>`: The time elapsed since the last log.
#
# Each placeholder can be fallowed by `{...}` to add the format specifier (see printf help).
#
# Returns:
#
# - ${REPLY}: The format string to use in a printf statement.
# - ${REPLY2}: The arguments (as a string space separated) to use in the printf statement.
# - ${REPLY3}: The length of the displayed log before the message.
# - ${REPLY4}: Extra code to compute variables that will be used to print the logs.
#
# ```bash
# log::parseLogPattern "<colorFaded><time>{(%H:%M:%S)T}<colorDefault> <levelColor><level> <icon><colorDefault> <message>"
# ```
# shellcheck disable=SC2120
function log::parseLogPattern() {
  local pattern="${1}"

  REPLY=""  # format
  REPLY2="" # arguments
  REPLY3=0  # wrap padding length
  REPLY4="" # code
  local -i wrapPaddingLength=0

  local normalString placeHolder formatSpecifier normalStringVisibleCharacters formatLengthTest printfFormat printfArgument
  while [[ -n ${pattern} ]]; do
    # extract the next placeholder
    if [[ ${pattern} =~ \<([^\>]+)\>(\{([^}]+)\})? ]]; then
      placeHolder="${BASH_REMATCH[1]}"
      formatSpecifier="${BASH_REMATCH[3]:-}"
      normalString="${pattern%%"${BASH_REMATCH[0]}"*}"
      pattern="${pattern#*"${BASH_REMATCH[0]}"}"
    else
      placeHolder=""
      normalString="${pattern}"
      pattern=""
    fi

    # handle the normal string
    if [[ -n ${normalString} ]]; then
      normalStringVisibleCharacters="${normalString}"
      string::removeTextFormatting normalStringVisibleCharacters
      REPLY+="%s"
      REPLY2+="\"${normalString//\"/\\\"}\" "
      wrapPaddingLength+=${#normalStringVisibleCharacters}

      if [[ ${normalString} == *$'\n'* ]]; then
        local stringAfterNewline="${normalString##*$'\n'}"
        wrapPaddingLength=${#stringAfterNewline}
      fi
    fi

    printfFormat=""

    # handle a placeholder
    case "${placeHolder}" in
    color*)
      placeHolder="${placeHolder#color}"
      local -n color="STYLE_COLOR_${placeHolder^^}"
      if [[ -n ${color:-} ]]; then
        printfFormat="%s"
        printfArgument="${color}"
      fi
      ;;
    time)
      printfFormat="%${formatSpecifier:-"(%H:%M:%S)T"}"
      printfArgument="\${EPOCHSECONDS}"
      ;;
    levelColor)
      if [[ ${VALET_CONFIG_ENABLE_COLORS:-} == "true" ]]; then
        printfFormat="%s"
        printfArgument="\${levelColor:-}"
      fi
      ;;
    level)
      printfFormat="%${formatSpecifier:-"-8s"}"
      log_setPrintfArgumentFromFormat "level"
      ;;
    icon)
      if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} == "true" ]]; then
        printfFormat="%${formatSpecifier:-"-4s"}"
        printfArgument="\${icon:-}"
        # nerd font icons are 2 characters long
        wrapPaddingLength=$((wrapPaddingLength - 2))
      fi
      ;;
    var*)
      printfFormat="%${formatSpecifier:-"s"}"
      printfArgument="\${${placeHolder#var}:-}"
      REPLY4+=$'\n'"local variableToPrintInLog=\"\${${placeHolder#var}:-}\""
      log_setPrintfArgumentFromFormat "variableToPrintInLog"
      ;;
    pid)
      printfFormat="%${formatSpecifier:-"-5d"}"
      log_setPrintfArgumentFromFormat "BASHPID"
      ;;
    processName)
      printfFormat="%${formatSpecifier:-"-5d"}"
      # shellcheck disable=SC2034
      declare -g -A GLOBAL_PID_TO_PNAME
      REPLY4+=$'\n'"local processName=\${GLOBAL_PID_TO_PNAME[\${BASHPID}]:-}; if [[ -z \${processName} ]]; then if [[ \${BASHPID} == \"${GLOBAL_PROGRAM_MAIN_PID}\" ]]; then GLOBAL_PID_TO_PNAME[\${BASHPID}]=\"main\"; else string::numberToUniqueId \"\${BASHPID}\"; GLOBAL_PID_TO_PNAME[\${BASHPID}]=\"\${REPLY}\"; fi; processName=\${GLOBAL_PID_TO_PNAME[\${BASHPID}]}; fi"
      log_setPrintfArgumentFromFormat "processName"
      ;;
    subshell)
      printfFormat="%${formatSpecifier:-"-2d"}"
      log_setPrintfArgumentFromFormat "BASH_SUBSHELL"
      ;;
    function)
      printfFormat="%${formatSpecifier:-"-10s"}"
      log_setPrintfArgumentFromFormat "FUNCNAME[2]"
      ;;
    line)
      printfFormat="%${formatSpecifier:-"-4s"}"
      log_setPrintfArgumentFromFormat "BASH_LINENO[1]"
      ;;
    source)
      printfFormat="%${formatSpecifier:-"-10s"}"
      log_setPrintfArgumentFromFormat "BASH_SOURCE[2]"
      ;;
    sourceFile)
      printfFormat="%${formatSpecifier:-"-10s"}"
      REPLY4+=$'\n'"local sourceFile=\"\${BASH_SOURCE[2]##*/}\""
      log_setPrintfArgumentFromFormat "sourceFile"
      ;;
    elapsedTime)
      printfFormat="%${formatSpecifier:-"-7s"}"
      log_setPrintfArgumentFromFormat "loggedElapsedTime"
      # shellcheck disable=SC1091
      source time
      REPLY4+=$'\n'"time::getProgramElapsedMicroseconds; time::convertMicrosecondsToSeconds \"\${REPLY}\" precision=3; local loggedElapsedTime=\"\${REPLY}\""
      ;;
    elapsedTimeSinceLastLog)
      printfFormat="%${formatSpecifier:-"-7s"}"
      log_setPrintfArgumentFromFormat "loggedElapsedTimeSinceLastLog"
      # shellcheck disable=SC1091
      source time
      REPLY4+=$'\n'"time::getProgramElapsedMicroseconds; local -i currentTime=\${REPLY}; _LOG_ELAPSED_TIME=\$(( currentTime - \${_LOG_ELAPSED_TIME:-0} )); time::convertMicrosecondsToSeconds \"\${_LOG_ELAPSED_TIME}\" precision=3; local loggedElapsedTimeSinceLastLog=\"\${REPLY}\"; _LOG_ELAPSED_TIME=\${currentTime}"
      ;;
    wrapPadding)
      printfFormat="%s"
      printfArgument="\${GLOBAL_LOG_WRAP_PADDING}"
      ;;
    message)
      printfFormat="%s"
      printfArgument="\${messageToPrintInLog:-}"

      # shellcheck disable=SC2034
      REPLY3="${wrapPaddingLength}"
      ;;
    esac
    if [[ -z ${printfFormat} ]]; then
      continue
    fi
    REPLY+="${printfFormat}"
    REPLY2+="\"${printfArgument}\" "

    if [[ ${printfFormat} != "%s" ]]; then
      # shellcheck disable=SC2059
      printf -v formatLengthTest "${printfFormat}" "1"
      wrapPaddingLength+=${#formatLengthTest}
    fi
  done

  REPLY+="\n"
}

# ## log::init (private)
#
# In charge of setting up global variables that will be used to print the logs.
# We compute them once to avoid recomputing them at each log call.
# Indeed, each log function might have to output the same log to different file descriptors or files,
# we don't want to repeat code and we don't want to recompute the same output logic on each function.
#
# - ${logFileDescriptor} _as string_:
#       (optional) The variable name to use for the coproc.
#       (defaults to "${VALET_CONFIG_LOG_FD}" which defaults to 2).
# - ${logPattern} _as string_:
#       (optional) If defined, the log pattern to use.
#       (defaults to "")
#
# It uses the following config
#
# - ${VALET_CONFIG_LOG_PATTERN}: The pattern used to display a formatted log line.
# - ${VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL}: Contains a bash code executed before the print statement, to further process the variable messageToPrintInLog or define new variables to use in the log pattern.
#   to compute extra variables that can be used in the log pattern.
# - ${VALET_CONFIG_LOG_COLUMNS}: The number of columns to use for the log.
# - ${VALET_CONFIG_LOG_DISABLE_HIGHLIGHT}: true to disable highlight for ⌜⌝.
# - ${VALET_CONFIG_LOG_DISABLE_WRAP}: true if the log should not be wrapped.
# - ${VALET_CONFIG_LOG_FD}: The file descriptor to use for the log.
# - ${VALET_CONFIG_LOG_TO_DIRECTORY}: The directory in which to create an additional log file.
# - ${VALET_CONFIG_LOG_FILENAME_PATTERN}: pattern for the new log file name
# - ${VALET_CONFIG_ENABLE_NERDFONT_ICONS}: To know if we display a nerd icon for the log level.
#
# Returns:
#
# - ${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}: The statement to print the formatted log.
# - ${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}: The statement to print the standard log.
# - ${GLOBAL_LOG_WRAP_PADDING}: The string with the number of spaces necessary to align with other log messages.
# - $[GLOBAL_LOG_COLUMNS}: The number of columns to use for the log.
# - $[GLOBAL_LOG_DISABLE_WRAP}: true if the log should not be wrapped.
# shellcheck disable=SC2120
function log::init() {
  local \
    logFileDescriptor="${VALET_CONFIG_LOG_FD:-}" \
    logPattern="" \
    IFS=$' '
  eval "local a= ${*@Q}"

  GLOBAL_LOG_COLUMNS="${VALET_CONFIG_LOG_COLUMNS:-${GLOBAL_COLUMNS}}"
  GLOBAL_LOG_DISABLE_WRAP="${VALET_CONFIG_LOG_DISABLE_WRAP:-false}"
  GLOBAL_LOG_PATTERN="${logPattern:-${VALET_CONFIG_LOG_PATTERN:-"<colorFaded><time>{(%H:%M:%S)T}<colorDefault> <levelColor><level>  <icon><colorDefault> <message>"}}"

  if [[ -v GLOBAL_FD_LOG ]]; then
    # close if already opened
    exec {GLOBAL_FD_LOG}>&-
  fi

  # make sure the file descriptor (if any) is valid
  if [[ -n ${logFileDescriptor} && ${logFileDescriptor} != 2 ]]; then
    local isFdValid=false
    if [[ ${logFileDescriptor} =~ ^[0-9]+$ ]]; then
      if { : >&"${logFileDescriptor}"; } 2>/dev/null && exec {GLOBAL_FD_LOG}>&"${logFileDescriptor}"; then
        isFdValid=true
      fi
    elif { : >>"${logFileDescriptor}"; } 2>/dev/null && exec {GLOBAL_FD_LOG}>>"${logFileDescriptor}"; then
      # it is a file
      isFdValid=true
    fi
    if [[ ${isFdValid} != "true" ]]; then
      core::fail "The file descriptor for the logs VALET_CONFIG_LOG_FD is not valid: ⌜${logFileDescriptor}⌝."
    fi
    # we also redirect the builtin bash errors to the same FD so we can have them along the logs
    exec 2>&"${GLOBAL_FD_LOG}"
  else
    exec {GLOBAL_FD_LOG}>&"${GLOBAL_FD_ORIGINAL_STDERR}"
    exec 2>&"${GLOBAL_FD_ORIGINAL_STDERR}"
    logFileDescriptor="${GLOBAL_FD_ORIGINAL_STDERR}"
  fi

  local progressBarCode progressBarCode2 progressBarCode3 outputCode
  if [[ ${logFileDescriptor} =~ ^[0-9]+$ ]]; then
    # it is a numbered file descriptor
    outputCode="1>&${logFileDescriptor}"

    # clear the line before printing if we are display a progress bar/spinner
    if [[ -t ${logFileDescriptor} || ${GLOBAL_TEST_FORCE_FD_OPEN:-} == "true" ]]; then
      progressBarCode="local eraseLine; if [[ -v _PROGRESS_BAR_RUNNING ]]; then eraseLine=$'\e[2K'; fi"$'\n'
      progressBarCode2="\${eraseLine:-}"
      progressBarCode3=$'\n'"if [[ -v _PROGRESS_BAR_RUNNING ]]; then progress:redraw; fi"$'\n'
    fi
  else
    # it is a file
    outputCode="1>>\"${logFileDescriptor}\""
  fi

  # we prepare the variables that will be used to print the formatted logs
  local -n printfFormat=REPLY
  local -n printfArguments=REPLY2
  local -n wrapPaddingLength=REPLY3
  local -n beforePrintStatementCode=REPLY4
  log::parseLogPattern "${GLOBAL_LOG_PATTERN}"

  # string with the number of spaces necessary to align with other log messages
  if ((wrapPaddingLength > 0)); then
    printf -v GLOBAL_LOG_WRAP_PADDING "%${wrapPaddingLength}s" ""
  else
    GLOBAL_LOG_WRAP_PADDING=""
  fi

  # now we build the two statements that can be evaluated to print the logs
  # in the correct file descriptor or file (and to additional log file if needed)
  GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG=""
  GLOBAL_LOG_PRINT_STATEMENT_STANDARD=""

  if [[ ${VALET_CONFIG_ENABLE_COLORS:-} == "true" ]]; then
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="local -n levelColor=\"STYLE_COLOR_\${colorName}\""$'\n'
  fi
  if ((${#beforePrintStatementCode} > 0)); then
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="${beforePrintStatementCode}"$'\n'
  fi
  if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
    # define REPLY/REPLY2 as local so we don't impact the parent scope (they are used during parsing)
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="local REPLY REPLY2"$'\n'"local -n messageToPrintInLog=REPLY"$'\n'"string::wrapWords messageToLog width=${GLOBAL_LOG_COLUMNS} newLinePadString=\"${GLOBAL_LOG_WRAP_PADDING}\" firstLineWidth=$((GLOBAL_LOG_COLUMNS - wrapPaddingLength))"$'\n'
  else
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="local -n messageToPrintInLog=messageToLog"$'\n'
  fi
  if [[ ${VALET_CONFIG_LOG_DISABLE_HIGHLIGHT:-false} != "true" ]]; then
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="messageToPrintInLog=\"\${messageToPrintInLog//⌜/${STYLE_COLOR_ACCENT}⌜}\""$'\n'"messageToPrintInLog=\"\${messageToPrintInLog//⌝/⌝${STYLE_COLOR_DEFAULT}}\""$'\n'
  fi
  if [[ -v VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL ]]; then
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+=$'\n'"${VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL}"$'\n'
  fi

  # define the formatted log statement
  local formattedLogStatement="printf \"${progressBarCode2:-}${printfFormat}\" ${printfArguments}"
  local standardStatement="printf \"${progressBarCode2:-}%s\" \"\${rawStringToPrintInLog:-}\""

  GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="${progressBarCode:-}${formattedLogStatement} ${outputCode}${progressBarCode3:-}"
  GLOBAL_LOG_PRINT_STATEMENT_STANDARD+="${progressBarCode:-}${standardStatement} ${outputCode}${progressBarCode3:-}"

  # check if we need to additionally output the logs to a file
  if [[ -n ${VALET_CONFIG_LOG_TO_DIRECTORY:-} && ${VALET_CONFIG_LOG_TO_DIRECTORY:-} != "false" ]]; then
    # compute the name of the output file
    local logFile
    if [[ -n ${VALET_CONFIG_LOG_FILENAME_PATTERN:-} ]]; then
      eval "${VALET_CONFIG_LOG_FILENAME_PATTERN}"
      if [[ ! -v logFile ]]; then
        core::fail "The filename pattern for the log files VALET_CONFIG_LOG_FILENAME_PATTERN is not valid (does not create the variable logFile): ⌜${VALET_CONFIG_LOG_FILENAME_PATTERN}⌝."
      fi
    else
      printf -v logFile "log-%(%FT%H-%M-%S%z)T--PID_%06d.log" "${EPOCHSECONDS}" "${BASHPID}"
    fi
    if [[ ${VALET_CONFIG_LOG_TO_DIRECTORY} == "true" ]]; then
      core::getUserStateDirectory
      VALET_CONFIG_LOG_TO_DIRECTORY="${REPLY}/logs"
    fi
    if [[ ! -d "${VALET_CONFIG_LOG_TO_DIRECTORY}" ]]; then
      mkdir -p "${VALET_CONFIG_LOG_TO_DIRECTORY}" 1>/dev/null
    fi
    # append the log to the file
    GLOBAL_LOG_ADDITIONAL_LOG_FILE="${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}"
    outputCode="1>>\"${GLOBAL_LOG_ADDITIONAL_LOG_FILE}\""
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+=$'\n'"${formattedLogStatement} ${outputCode}"
    GLOBAL_LOG_PRINT_STATEMENT_STANDARD+=$'\n'"${standardStatement} ${outputCode}"
  fi
}

#===============================================================
# >>> String utilities
#===============================================================

# ## string::removeTextFormatting
#
# Removes all text formatting from the given string.
# This includes colors, bold, underline, etc.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to remove formatting from.
#
# ```bash
# string::removeTextFormatting "myText"
# echo "${myText}"
# ```
function string::removeTextFormatting() {
  local -n textForWhichToRemoveFormatting="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if [[ ${textForWhichToRemoveFormatting} == *$'\e'* ]]; then
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;5;[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;5;[0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;5;[0-9][0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9];[0-9];[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9][0-9];[0-9];[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9][0-9][0-9];[0-9];[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9];[0-9][0-9];[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9];[0-9][0-9][0-9];[0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9];[0-9];[0-9][0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9];[0-9];[0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9][0-9];[0-9][0-9];[0-9][0-9]m/}"
    textForWhichToRemoveFormatting="${textForWhichToRemoveFormatting//$'\e['[0-9]8;2;[0-9][0-9][0-9];[0-9][0-9][0-9];[0-9][0-9][0-9]m/}"
  fi
}

# ## string::wrapWords
#
# Allows to soft wrap the given text at the given width.
# Wrapping is done at word boundaries.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - ${width} _as string_:
#       (optional) The width to wrap the text at.
#       Note that length of the new line pad string is subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - ${newLinePadString} _as string_:
#       (optional) The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - ${firstLineWidth} _as int_:
#       (optional) The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${REPLY}: the wrapped text
#
# ```bash
# string::wrapWords "This is a long text."
# string::wrapWords "This is a long text wrapped at 20 characters." width=20 newLinePadString="---" firstLineWidth=20
# echo "${REPLY}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
# > - It considers escape sequence for text formatting and does not count them as visible characters.
function string::wrapWords() {
  local -n textToWrapAtWords="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    width="${GLOBAL_COLUMNS}" \
    newLinePadString="" \
    firstLineWidth \
    IFS=$' \t'
  shift 1
  eval "local a= ${*@Q}"

  firstLineWidth="${firstLineWidth:-${width}}"

  # short cut in case the text is already shorter than the width
  if [[ ${#textToWrapAtWords} -le ${firstLineWidth} && ${textToWrapAtWords} != *$'\n'* ]]; then
    REPLY="${textToWrapAtWords}"
    return 0
  fi

  local text="${textToWrapAtWords}"
  local output="" line word realWord REPLY2
  local leftPaddingVisibleChars="${newLinePadString}"
  string::removeTextFormatting leftPaddingVisibleChars
  local -i sentenceWidth=$((width - ${#leftPaddingVisibleChars})) realWordLength=0 firstWord=1
  local -i lineLength=$((sentenceWidth - firstLineWidth))

  while ((${#text} > 0)); do
    line="${text%%$'\n'*}"
    text="${text:${#line}+1}"

    output+=$'\n'"${newLinePadString}"

    # short cut in case the text is already shorter than the width
    if ((lineLength + ${#line} <= sentenceWidth)); then
      output+="${line}"
      continue
    fi

    firstWord=1

    for word in ${line}; do
      if [[ ${word} == *$'\e'* ]]; then
        realWord="${word}"
        string::removeTextFormatting realWord
        realWordLength="${#realWord}"
      else
        realWordLength="${#word}"
      fi

      if ((lineLength < sentenceWidth && firstWord == 0)); then
        output+=" "
        lineLength+=1
      else
        firstWord=0
      fi

      if ((lineLength + realWordLength <= sentenceWidth)); then
        # add the word to the current line
        output+="${word}"
        lineLength+=realWordLength
      else
        # not enough space left, check if the word fits on the next line
        if ((realWordLength <= sentenceWidth)); then
          output+=$'\n'"${newLinePadString}${word}"
          lineLength=realWordLength
        else
          # the word is too long to fit on a line, split it in multiple lines
          string::wrapCharacters word width="${width}" newLinePadString="${newLinePadString}" firstLineWidth="$((sentenceWidth - lineLength))"
          output+="${REPLY}"
          lineLength=${REPLY2}
        fi
      fi

    done

    lineLength=0
  done

  REPLY="${output#$'\n'"${newLinePadString}"}"
}

# ## string::wrapCharacters
#
# Allows to hard wrap the given string at the given width.
# Wrapping is done at character boundaries, see string::warpText for word wrapping.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - ${width} _as string_:
#       (optional) The width to wrap the text at.
#       Note that length of the new line pad string is subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - ${newLinePadString} _as string_:
#       (optional) The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - ${firstLineWidth} _as int_:
#       (optional) The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${REPLY}: the wrapped string
# - ${REPLY2}: the length taken on the last line
#
# ```bash
# string::wrapCharacters "This-is-a-long-text"
# string::wrapCharacters "This-is-a-long-text-that-should-be-wrapped-at-20-characters." width=20 newLinePadString="---" firstLineWidth=5
# echo "${REPLY}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - It considers escape sequence for text formatting and does not count them as visible characters.
# > - Leading spaces after a newly wrapped line are removed.
function string::wrapCharacters() {
  local -n textToWrapAtCharacters="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    width="${GLOBAL_COLUMNS}" \
    newLinePadString="" \
    firstLineWidth
  IFS=$' \t' \
    shift 1
  eval "local a= ${*@Q}"

  firstLineWidth="${firstLineWidth:-${width}}"

  local itemChunk spaces text="${textToWrapAtCharacters}"
  local leftPaddingVisibleChars="${newLinePadString}"
  string::removeTextFormatting leftPaddingVisibleChars
  width=$((width - ${#leftPaddingVisibleChars}))
  local -i lineLength=$((width - firstLineWidth)) isWrapping=0

  if ((width <= 0)); then
    REPLY=""
    REPLY2=0
    return
  fi

  REPLY=""
  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    itemChunk="${itemChunk%%$'\n'*}"

    spaces="${itemChunk%%[^ ]*}"
    if [[ -n ${spaces} && lineLength -eq 0 && isWrapping -eq 1 ]]; then
      # if the chunk contains heading spaces, we can remove them
      itemChunk="${itemChunk:${#spaces}}"
      text="${text:${#spaces}}"
    fi

    if ((lineLength < width)); then
      itemChunk="${itemChunk:0:$((width - lineLength))}"
      text="${text:${#itemChunk}}"
      lineLength+=${#itemChunk}
      REPLY+="${itemChunk}"
      isWrapping=1

      while [[ ${text} == $'\e'* ]]; do
        # case where we have an escape sequence at the beginning of the string
        # we only consider escape sequences for text formatting, they end with 'm'
        itemChunk="${text%%"m"*}m"
        REPLY+="${itemChunk}"
        text="${text:${#itemChunk}}"
      done

      while [[ ${text} == $'\n'* ]]; do
        REPLY+=$'\n'"${newLinePadString}"
        text="${text:1}"
        lineLength=0
        isWrapping=0
      done
    fi

    if ((lineLength >= width)); then
      # we reached the desired size
      lineLength=0
      REPLY+=$'\n'"${newLinePadString}"
    fi
  done

  REPLY="${REPLY%$'\n'"${newLinePadString}"}"
  REPLY2=${lineLength}
}

# ## string::highlight
#
# Highlight characters in a string.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to highlight.
# - $2: **characters variable name** _as string_:
#       The variable name that contains characters to highlight.
# - ${highlightCode} _as string_:
#       (optional) The ANSI code to use for highlighting.
#       (defaults to STYLE_COLOR_ACCENT)
# - ${resetCode} _as string_:
#       (optional) The ANSI code to use for resetting the highlighting.
#       (defaults to STYLE_COLOR_DEFAULT)
#
# Returns:
#
# - ${REPLY}: the highlighted text
#
# ```bash
# string::highlight "This is a text to highlight." "ttttt"
# echo "${REPLY}"
# ```
#
# > - All characters to highlight must be found in the same order in the matched line.
# > - This functions is case insensitive.
function string::highlight() {
  local -n \
    textToHighlight="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    charactersToHighlight="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    highlightCode="${STYLE_COLOR_ACCENT:-$'\e'"[95m"}" \
    resetCode="${STYLE_COLOR_DEFAULT:-$'\e'"[0m"}"
  IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local itemChunk itemChunkPiece
  local -i searchStringIndex=0
  local searchStringCharacter="${charactersToHighlight:0:1}"
  local searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
  local text="${textToHighlight}"

  REPLY=""

  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    text="${text:${#itemChunk}}"

    if [[ -n ${itemChunk} ]]; then
      # colorize the search string in this chunk
      while [[ -n ${searchStringCharacter} && ${itemChunk} == *["${searchStringCharacters}"]* ]]; do
        itemChunkPiece="${itemChunk%%["${searchStringCharacters}"]*}"
        REPLY+="${itemChunkPiece}${highlightCode}${itemChunk:${#itemChunkPiece}:1}${resetCode}"
        itemChunk="${itemChunk:${#itemChunkPiece}+1}"
        searchStringIndex+=1
        searchStringCharacter="${charactersToHighlight:searchStringIndex:1}"
        searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
      done

      REPLY+="${itemChunk}"
    fi

    while [[ ${text} == $'\e'* ]]; do
      # case where we have an escape sequence at the beginning of the string
      # we only consider escape sequences for text formatting, they end with m
      itemChunk="${text%%"m"*}m"
      REPLY+="${itemChunk}"
      text="${text:${#itemChunk}}"
    done
  done
}

# ## string::numberToUniqueId
#
# Converts a number into a unique and human readable string of the same length.
#
# - $1: **number** _as int_:
#       The number to convert.
#
# Returns:
#
# - ${REPLY}: the unique string.
#
# ```bash
# string::numberToUniqueId 12345
# echo "${REPLY}"
# ```
function string::numberToUniqueId() {
  local number="${1}"

  # we convert numbers
  local vowels="aeiou"
  local consonants="bcdfmnprstgjklvwxz"
  REPLY=""
  local toConvert
  local -i index=0
  while ((index < ${#number})); do
    toConvert="${number:index:2}"
    if ((${#toConvert} == 2)); then
      REPLY+="${consonants:$((10#${toConvert} / 5 - 2)):1}${vowels:$((10#${toConvert} % 5)):1}"
    elif ((${#toConvert} == 1)); then
      REPLY+="${consonants:toConvert:1}"
    fi
    index+=2
  done
}

#===============================================================
# >>> Array utilities
#===============================================================

# ## regex::getFuzzySearchRegexFromSearchString
#
# Allows to get a regex that can be used to fuzzy search a string.
# the -> '([^t]*)(t[^h]*h[^e]*e)'
#
# - $1: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${_STRING_FUZZY_FILTER_REGEX}: the regex
#
# ```bash
# regex::getFuzzySearchRegexFromSearchString SEARCH_STRING
# echo "${_STRING_FUZZY_FILTER_REGEX}"
# ```
function regex::getFuzzySearchRegexFromSearchString() {
  local -n filterSearchString="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # nothing to filter
  if [[ -z ${filterSearchString} ]]; then
    _STRING_FUZZY_FILTER_REGEX=""
    return 0
  fi

  # \^$.|?*+[]{}()
  local escapedCharacter

  # prepare the regex for the searched string
  _STRING_FUZZY_FILTER_REGEX=""
  local -i index
  for ((index = 0; index < ${#filterSearchString}; index++)); do
    escapedCharacter=${filterSearchString:index:1}
    if [[ '\^$.|?*+[]{}()' == *"${escapedCharacter}"* ]]; then
      escapedCharacter="\\"${escapedCharacter}
    fi
    if ((index == 0)); then
      _STRING_FUZZY_FILTER_REGEX+="^([^${filterSearchString:index:1}]"'*'")(${escapedCharacter}"
    else
      _STRING_FUZZY_FILTER_REGEX+="[^${filterSearchString:index:1}]"'*'"${escapedCharacter}"
    fi
  done

  _STRING_FUZZY_FILTER_REGEX+=")(.?)"
}

#===============================================================
# >>> Array utilities
#===============================================================

# ## array::fuzzyFilterSort
#
# Allows to fuzzy sort an array against a given searched string.
# Returns an array containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
# - the original order in the list
#
# Also returns an array containing the indexes of the matched items in the original array.
#
# - $1: **array name** _as string_:
#       The array name to fuzzy filter and sort.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: An array containing the items sorted and filtered
# - ${REPLY_ARRAY2[@]}: An array containing the indexes of the matched items in the original array
#
# ```bash
# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING
# echo "${REPLY_ARRAY[*]}"
# ```
#
# > - All characters in the searched string must be found in the same order in the matched line.
# > - Use `shopt -s nocasematch` to make this function is case insensitive.
# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.
function array::fuzzyFilterSort() {
  local -n \
    arrayToFilter="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    filterSearchString="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # nothing to filter
  if ((${#filterSearchString} == 0 || ${#arrayToFilter[@]} == 0)); then
    REPLY_ARRAY=("${arrayToFilter[@]}")
    eval "REPLY_ARRAY2=( {0..$((${#arrayToFilter[@]} - 1))} )"
    return 0
  fi

  regex::getFuzzySearchRegexFromSearchString "${2}"

  # will contain a key that allows to sort the items, it is a combination of the length before the pattern,
  # the length of the matched pattern and the initial position of the item
  _ARRAY_FUZZY_FILTER_KEYS=()
  # will contain the original indexes corresponding to the sorted array
  REPLY_ARRAY2=()

  for ((index = 0; index < ${#arrayToFilter[@]}; index++)); do
    if [[ ${arrayToFilter[index]} =~ ${_STRING_FUZZY_FILTER_REGEX} ]]; then
      if ((${#BASH_REMATCH[3]} == 0 && ${#BASH_REMATCH[1]} == 0)); then
        _ARRAY_FUZZY_FILTER_KEYS+=($((index)))
      else
        _ARRAY_FUZZY_FILTER_KEYS+=($((${#BASH_REMATCH[1]} * 10000000 + ${#BASH_REMATCH[2]} * 10000 + index)))
      fi
      REPLY_ARRAY2+=($((index)))
    fi
  done

  if ((${#_ARRAY_FUZZY_FILTER_KEYS[@]} > 1)); then
    array_fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))
  fi

  # will contain the matched lines, sorted
  REPLY_ARRAY=()
  for ((index = 0; index < ${#REPLY_ARRAY2[@]}; index++)); do
    REPLY_ARRAY+=("${arrayToFilter[REPLY_ARRAY2[index]]}")
  done
  unset -v _ARRAY_FUZZY_FILTER_KEYS
}

# ## array_fuzzyFilterSortQuicksort (private)
#
# A special quicksort implementation dedicated to `array::fuzzyFilterSort`
# that only compare numbers and that uses _ARRAY_FUZZY_FILTER_KEYS as
# a global arrays to go faster. Check `array::quicksort` for an equivalent
# but clearer implementation.
#
# - $1: **low** _as int_:
#       The low index of the _ARRAY_FUZZY_FILTER_KEYS array.
# - $2: **high** _as int_:
#       The high index of the _ARRAY_FUZZY_FILTER_KEYS array.
#
# ```bash

# array_fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))
# ```
function array_fuzzyFilterSortQuicksort() {
  local -i left=${1} right=${2} tempValue pivotValue=${_ARRAY_FUZZY_FILTER_KEYS[${1} + (${2} - ${1}) / 2]}
  while :; do
    while ((_ARRAY_FUZZY_FILTER_KEYS[left] < pivotValue)); do
      left+=1
    done
    while ((pivotValue < _ARRAY_FUZZY_FILTER_KEYS[right])); do
      right=$((right - 1))
    done
    if ((left >= right)); then
      break
    fi
    tempKey=${_ARRAY_FUZZY_FILTER_KEYS[left]}
    _ARRAY_FUZZY_FILTER_KEYS[left]=${_ARRAY_FUZZY_FILTER_KEYS[right]}
    _ARRAY_FUZZY_FILTER_KEYS[right]=${tempKey}
    tempValue=${REPLY_ARRAY2[left]}
    REPLY_ARRAY2[left]=${REPLY_ARRAY2[right]}
    REPLY_ARRAY2[right]=${tempValue}
    left+=1
    right=$((right - 1))
  done
  if ((${1} < right)); then
    array_fuzzyFilterSortQuicksort ${1} ${right}
  fi
  if ((right + 1 < ${2})); then
    array_fuzzyFilterSortQuicksort $((right + 1)) ${2}
  fi
}

#===============================================================
# >>> Time utilities
#===============================================================

# ## time::getProgramElapsedMicroseconds
#
# Get the elapsed time in µs since the program started.
#
# Returns:
#
# - ${REPLY}: the elapsed time in µs since the program started.
#
# ```bash
# time::getProgramElapsedMicroseconds
# echo "${REPLY}"
# time::convertMicrosecondsToHuman "${REPLY}"
# echo "Human time: ${REPLY}"
# ```
#
# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.
# > The 10# forces the base 10 conversion to avoid issues with leading zeros.
# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.
function time::getProgramElapsedMicroseconds() {
  # the eval is here because sometimes bash does not expand the EPOCHREALTIME variable correctly, idk why
  eval "REPLY=\$(((${EPOCHREALTIME%%[.,]*} - GLOBAL_PROGRAM_STARTED_AT_SECOND) * 1000000 + (10#${EPOCHREALTIME##*[.,]} - 10#${GLOBAL_PROGRAM_STARTED_AT_MICROSECOND})))"
}

#===============================================================
# >>> Styles functions
#===============================================================

# ## styles::init (private)
#
# Initialize the valet styles variables.
# Also includes the esc-codes library (required for styles).
function styles::init() {
  builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/core-esc-codes"
  builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/core-styles"
}

#===============================================================
# >>> Command functions (called from user command functions)
#===============================================================

# ## command::sourceFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# command::sourceFunction "functionName"
# ```
function command::sourceFunction() {
  local functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # shellcheck disable=SC1091
  source command

  command::sourceCommandFunction "${functionName}"
}

# ## command::parseArguments
#
# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.
#
#
# - $@: **arguments** _as any_:
#       the arguments to parse
#
# Returns:
#
# - ${REPLY}: a string that can be evaluated to set the parsed variables
#
# Output example:
#
# ```
# local arg1 option1
# arg1="xxx"
# option1="xxx"
# ```
#
# ```bash
# command::parseArguments "$@" && eval "${REPLY}"
# ```
function command::parseArguments() {
  # get the function name of the calling function
  local functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  # shellcheck disable=SC1091
  source command

  command::parseCmdFunctionArgumentsOrGoInteractive "${functionName}" "$@"
}

# ## command::checkParsedResults
#
# A convenience function to check the parsing results and fails with an error message if there are
# parsing errors.
# Will also display the help if the help option is true.
#
# This should be called from a command function for which you want to check the parsing results.
#
# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed
# and if there are parsing errors.
#
# ```bash
# command::checkParsedResults
# ```
function command::checkParsedResults() {
  if [[ ${help:-false} == "true" ]]; then
    # shellcheck disable=SC1091
    source command
    command::printHelp function "${FUNCNAME[1]?"This function must be called from a command function."}"
    core::exit 0 silent=true
  fi
  if [[ -n ${commandArgumentsErrors:-} ]]; then
    core::fail "${commandArgumentsErrors}"
  fi
}

# ## command::showHelp
#
# Show the help for the current function.
# This should be called directly from a command function for which you want to display the help text.
#
# ```bash
# command::showHelp
# ```
function command::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  # shellcheck disable=SC1091
  source command

  command::printHelp function "${functionName}"
}
