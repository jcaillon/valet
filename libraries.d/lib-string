#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## string::cutField
#
# Allows to get the nth element of a string separated by a given separator.
# This is the equivalent of the cut command "cut -d"${separator}" -f"${fieldNumber}""
# but it uses pure bash to go faster.
#
# - $1: **string to cut** _as string_:
#       the string to cut
# - $2: **field number** _as int_:
#       the field number to get (starting at 0)
# - $3: separator _as string_:
#       the separator
#       (defaults to tab if not provided)
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted field
#
# ```bash
# string::cutField "field1 field2 field3" 1 " " && local field="${RETURNED_VALUE}"
# printf '%s' "${field}" # will output "field2"
# ```
#
# > This is faster than:
# >
# > - using read into an array from a here string
# > - using bash parameter expansion to remove before/after the separator
function string::cutField() {
  local str fieldNumber separator
  str="${1}"
  fieldNumber="${2}"
  separator="${3:-$'\t'}"

  local field IFS="${separator}"
  local -i index=0
  for field in ${str}; do
    if [[ index -eq fieldNumber ]]; then
      RETURNED_VALUE="${field}"
      return 0
    fi
    index=$((index + 1))
  done
  RETURNED_VALUE=""
}

# ## string::convertCamelCaseToSnakeCase
#
# This function convert a camelCase string to a SNAKE_CASE string.
# It uses pure bash.
# Removes all leading underscores.
#
# - $1: **camelCase string** _as string_:
#       The camelCase string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: The SNAKE_CASE string.
#
# ```bash
# string::convertCamelCaseToSnakeCase "myCamelCaseString" && local mySnakeCaseString="${RETURNED_VALUE}"
# ```
function string::convertCamelCaseToSnakeCase() {
  local camelCase="${1}"
  local snakeCase=""
  local -i charIndex strLength=${#camelCase}
  local char
  for ((charIndex = 0; charIndex < strLength; charIndex++)); do
    char="${camelCase:charIndex:1}"
    if [[ ${char} =~ ^[[:upper:]]$ ]]; then
      snakeCase+="_${char^}"
    else
      snakeCase+="${char^}"
    fi
  done
  while [[ ${snakeCase} == _* ]]; do
    snakeCase="${snakeCase:1}"
  done
  RETURNED_VALUE="${snakeCase}"
}

# ## string::convertKebabCaseToSnakeCase
#
# This function convert a kebab-case string to a SNAKE_CASE string.
# It uses pure bash.
# Removes all leading dashes.
#
# - $1: **kebab-case string** _as string_:
#       The kebab-case string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: The SNAKE_CASE string.
#
# ```bash
# string::convertKebabCaseToSnakeCase "my-kebab-case-string" && local mySnakeCaseString="${RETURNED_VALUE}"
# ```
function string::convertKebabCaseToSnakeCase() {
  local kebabCase="${1}"
  local snakeCase=""
  local -i charIndex strLength=${#kebabCase}
  local char
  for ((charIndex = 0; charIndex < strLength; charIndex++)); do
    char="${kebabCase:charIndex:1}"
    if [[ ${char} == "-" ]]; then
      snakeCase+="_"
    else
      snakeCase+="${char^}"
    fi
  done
  while [[ ${snakeCase} == _* ]]; do
    snakeCase="${snakeCase:1}"
  done
  RETURNED_VALUE="${snakeCase}"
}

# ## string::convertKebabCaseToCamelCase
#
# This function convert a kebab-case string to a camelCase string.
# It uses pure bash.
# Removes all leading dashes.
#
# - $1: **kebab-case string** _as string_:
#       The kebab-case string to convert.
#
# Returns:
#
# - ${RETURNED_VALUE}: The camelCase string.
#
# ```bash
# string::convertKebabCaseToCamelCase "my-kebab-case-string" && local myCamelCaseString="${RETURNED_VALUE}"
# ```
function string::convertKebabCaseToCamelCase() {
  local kebabCase="${1}"
  local camelCase=""
  local -i charIndex strLength=${#kebabCase}
  local char
  for ((charIndex = 0; charIndex < strLength; charIndex++)); do
    char="${kebabCase:charIndex:1}"
    if [[ ${char} == "-" ]]; then
      continue
    fi
    if [[ ${kebabCase:charIndex-1:1} == "-" ]]; then
      camelCase+="${char^}"
    else
      camelCase+="${char}"
    fi
  done
  RETURNED_VALUE="${camelCase,}"
}

# ## string::trimAll
#
# Trim all whitespaces and truncate spaces.
#
# - $1: **string to trim** _as string_:
#       The string to trim.
#
# Returns:
#
# - ${RETURNED_VALUE}: The trimmed string.
#
# ```bash
# string::trimAll "   example   string    " && local trimmedString="${RETURNED_VALUE}"
# ```
function string::trimAll() {
  set -o noglob +o braceexpand
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  local IFS=" "$'\t'$'\n'
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  set -- $*
  RETURNED_VALUE="$*"
  set +o noglob -o braceexpand
}

# ## string::trim
#
# Trim leading and trailing whitespaces.
#
# - $1: **string to trim** _as string_:
#       The string to trim.
#
# Returns:
#
# - ${RETURNED_VALUE}: The trimmed string.
#
# ```bash
# string::trim "   example string    " && local trimmedString="${RETURNED_VALUE}"
# ```
function string::trim() {
  RETURNED_VALUE="${1#"${1%%[^[:space:]]*}"}"
  RETURNED_VALUE="${RETURNED_VALUE%"${RETURNED_VALUE##*[^[:space:]]}"}"
}

# ## string::indexOf
#
# Find the first index of a string within another string.
#
# - $1: **string** _as string_:
#       the string in which to search
# - $2: **search** _as string_:
#       the string to search
# - $3: start index _as int_:
#       (optional) the starting index
#       (defaults to 0)
#
# Returns:
#
# - ${RETURNED_VALUE}: the index of the substring in the string or -1 if not found.
#
# ```bash
# string::indexOf "This is a long text" "long" && local index="${RETURNED_VALUE}"
# string::indexOf "This is a long text" "long" 10 && local index="${RETURNED_VALUE}"
# ```
function string::indexOf() {
  local search string
  local -i startingIndex
  string="${1}"
  search="${2}"
  startingIndex=${3:-0}

  local -i stringLength
  stringLength="${#string}"

  if [[ startingIndex -gt 0 ]]; then
    # if the starting index is greater than the length of the string, we return -1
    if [[ startingIndex -ge stringLength ]]; then
      RETURNED_VALUE=-1
      return 0
    fi

    # otherwise we keep only what is after this index
    string="${string:startingIndex}"
  fi

  stringLength="${#string}"

  # if the string starts with the search, we have our index
  if [[ ${string} == "${search}"* ]]; then
    RETURNED_VALUE=${startingIndex}
    return 0
  fi

  # cut everything after the search string
  local tempString
  tempString="${string%%"${search}"*}"
  local -i tempStringLength="${#tempString}"

  # the index is the length of the temp string if it is different than the initial string length
  if [[ tempStringLength -ne stringLength ]]; then
    RETURNED_VALUE=$((tempStringLength + startingIndex))
  else
    RETURNED_VALUE=-1
  fi
  return 0
}

# ## string::extractBetween
#
# Extract the text between two strings within a string.
# Search for the first occurrence of the start string and the first occurrence
# (after the start index) of the end string.
# Both start and end strings are excluded in the extracted text.
# Both start and end strings must be found to extract something.
#
# - $1: **string** _as string_:
#       the string in which to search
# - $2: **start string** _as string_:
#       the start string
#       (if empty, then it will extract from the beginning of the string)
# - $3: **end string** _as string_:
#       the end string
#       (if empty, then it will extract until the end of the string)
#
# Returns:
#
# - ${RETURNED_VALUE}: the extracted text
#
# ```bash
# string::extractBetween "This is a long text" "is a " " text"
# local extractedText="${RETURNED_VALUE}"
# ```
function string::extractBetween() {
  local string="${1}"
  local start="${2}"
  local end="${3}"

  local -i startIndex endIndex

  if [[ -n "${start}" ]]; then
    string::indexOf "${string}" "${start}" && startIndex="${RETURNED_VALUE}"
    if [[ startIndex -eq -1 ]]; then
      RETURNED_VALUE=""
      return 0
    fi
    startIndex=$((startIndex + ${#start}))
  else
    startIndex=0
  fi

  if [[ -n "${end}" ]]; then
    string::indexOf "${string}" "${end}" "${startIndex}" && endIndex="${RETURNED_VALUE}"
    if [[ endIndex -eq -1 ]]; then
      RETURNED_VALUE=""
      return 0
    fi
  else
    RETURNED_VALUE="${string:startIndex}"
    return 0
  fi

  local -i extractedLength
  extractedLength=$((endIndex - startIndex))
  RETURNED_VALUE="${string:startIndex:extractedLength}"
}

# ## string::count
#
# Counts the number of occurrences of a substring in a string.
#
# - $1: **string** _as string_:
#       the string in which to search
# - $2: **substring** _as string_:
#       the substring to count
#
# Returns:
#
# - ${RETURNED_VALUE}: the number of occurrences
#
# ```bash
# string::count "name,firstname,address" "," && local count="${RETURNED_VALUE}"
# ```
#
# > This is faster than looping over the string and check the substring.
function string::count() {
  local string="${1}"
  local newString="${string//"${2}"/}"
  RETURNED_VALUE=$(((${#string} - ${#newString}) / ${#2}))
}

# ## string::split
#
# Split a string into an array using a separator.
#
# - $1: **string** _as string_:
#       the string to split
# - $2: **separator** _as string_:
#       the separator (must be a single character!)
#
# Returns:
#
# - ${RETURNED_ARRAY}: the array of strings
#
# ```bash
# string::split "name,first name,address" "," && local -a array=("${RETURNED_ARRAY[@]}")
# ```
#
# > This is faster than using read into an array from a here string.
function string::split() {
  local IFS="${2}"
  # shellcheck disable=SC2206
  # shellcheck disable=SC2034
  RETURNED_ARRAY=(${1})
}

# ## string::head
#
# Get the first n lines of a string.
#
# - $1: **string** _as string_:
#       The string to extract from.
# - $2: **lines** _as int_:
#       The number of lines to extract.
#
# Returns:
#
# - ${RETURNED_VALUE}: The extracted string.
#
# ```bash
# string::head "line1\nline2\nline3" 2
# echo "${RETURNED_VALUE}"
# ```
function string::head() {
  local string="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more arguments."}"
  local -i nbLines="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more arguments."}"
  local chunk output
  local -i ii=0
  while ((ii < nbLines)); do
    chunk="${string%%$'\n'*}"
    string="${string:${#chunk} + 1}"
    output+="${chunk}"$'\n'
    if [[ -z ${string} ]]; then
      break
    fi
    ii+=1
  done
  RETURNED_VALUE="${output:-}"
}

# ## string::doForEachLine
#
# Execute a callback function for each line of a string.
#
# - $1: **string variable name** _as string_:
#       The name of the variable containing the string.
# - $2: **callback function** _as string_:
#       The name of the function to execute for each line.
#       The function is called with the following arguments:
#
#       - $1: the current line content
#
#       The function must return 0 if we should continue to the next line, 1 otherwise.
#       (defaults to empty)
#
# ```bash
# string::doForEachLine myString myCallback
# ```
#
# > This function provides a convenient way to avoid using a "here string" and handles extra
# > newlines (which is not the case with a "for loop" using parameter expansion and IFS=$'\n').
# > Here string is significantly slower than using this.
function string::doForEachLine() {
  local -n text="${1}"
  local chunk output
  while [[ -n ${text} ]]; do
    chunk="${text%%$'\n'*}"
    text="${text:${#chunk} + 1}"
    "${2}" "${chunk}"
  done
}