#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## string::trimAll
#
# Trim all whitespaces and truncate spaces.
# The replacement is done in place, for the given variable.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to trim.
#
# ```bash
# MY_STRING="   example "$'\t'"  string    "$'\n'
# string::trimAll MY_STRING
# echo "${MY_STRING}"
# ```
function string::trimAll() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  set -o noglob +o braceexpand
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  local IFS=$' \t\n'
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  set -- ${inputString_NameRef}
  inputString_NameRef="$*"
  set +o noglob -o braceexpand
}

# ## string::trimEdges
#
# Trim leading and trailing characters (defaults to whitespaces).
# The replacement is done in place, for the given variable.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to trim.
# - ${charsToTrim} _as string_:
#       The characters to trim.
#       (defaults to $' \t\n')
#
# ```bash
# MY_STRING="   example  string    "
# string::trimEdges MY_STRING
# echo "${MY_STRING}"
# ```
function string::trimEdges() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    charsToTrim=$' \t\n' \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  inputString_NameRef="${inputString_NameRef#"${inputString_NameRef%%[^"${2:-${charsToTrim}}"]*}"}"
  inputString_NameRef="${inputString_NameRef%"${inputString_NameRef##*[^"${2:-${charsToTrim}}"]}"}"
}

# ## string::getKebabCase
#
# This function convert a camelCase, PascalCase or SNAKE_CASE string to a kebab-case string.
# Removes all leading/trailing dashes.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${REPLY}: The converted string
#
# ```bash
# MY_STRING="myCamelCaseString"
# string::getKebabCase MY_STRING
# echo "${REPLY}"
# ```
function string::getKebabCase() {
  REPLY="${!1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ ${REPLY} == *[[:upper:]]* && ${REPLY} == *[[:lower:]]* ]]; then
    # from camelCase or PascalCase
    # it is faster to use a regex than loop over each char here
    while [[ ${REPLY} =~ [[:upper:]] ]]; do
      REPLY="${REPLY//"${BASH_REMATCH[0]}"/-"${BASH_REMATCH[0],}"}"
    done
  else
    # from SNAKE_CASE of already in kebab-case
    REPLY="${REPLY,,}"
  fi
  REPLY="${REPLY//[![:lower:][:digit:]-]/-}"
  while [[ ${REPLY} == -* ]]; do
    REPLY="${REPLY:1}"
  done
  while [[ ${REPLY} == *- ]]; do
    REPLY="${REPLY%-}"
  done
}

# ## string::getSnakeCase
#
# This function convert a camelCase, PascalCase or kebab-case string to a SNAKE_CASE string.
# Removes all leading/trailing underscores.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${REPLY}: The converted string
#
# ```bash
# MY_STRING="myCamelCaseString"
# string::getSnakeCase MY_STRING
# echo "${REPLY}"
# ```
function string::getSnakeCase() {
  REPLY="${!1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ ${REPLY} == *[[:upper:]]* && ${REPLY} == *[[:lower:]]* ]]; then
    # from camelCase or PascalCase
    while [[ ${REPLY} =~ [[:upper:]] ]]; do
      REPLY="${REPLY//"${BASH_REMATCH[0]}"/_"${BASH_REMATCH[0],}"}"
    done
    REPLY="${REPLY^^}"
  else
    # from kebab-case or already in SNAKE_CASE
    REPLY="${REPLY^^}"
  fi
  REPLY="${REPLY//[![:upper:][:digit:]_]/_}"
  while [[ ${REPLY} == _* ]]; do
    REPLY="${REPLY:1}"
  done
  while [[ ${REPLY} == *_ ]]; do
    REPLY="${REPLY%_}"
  done
}

# ## string::getCamelCase
#
# This function convert a SNAKE_CASE or kebab-case string to a camelCase string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${REPLY}: The converted string
#
# ```bash
# MY_STRING="my-kebab-case"
# string::getCamelCase MY_STRING
# echo "${REPLY}"
# ```
function string::getCamelCase() {
  REPLY="${!1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ ${REPLY} == *[[:upper:]]* && ${REPLY} == *[[:lower:]]* ]]; then
    # already camelCase or PascalCase
    :
  else
    # from kebab-case or SNAKE_CASE
    REPLY="${REPLY,,}"
    while [[ ${REPLY} =~ [-_]([[:alnum:]]) ]]; do
      REPLY="${REPLY//"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]^}"}"
    done
  fi
  REPLY="${REPLY//[![:alnum:]]/}"
  REPLY="${REPLY,}"
}

# ## string::getField
#
# Allows to get the nth element of a string separated by a given separator.
# This is the equivalent of the cut command "cut -d"${separator}" -f"${fieldNumber}""
# but it uses pure bash to go faster.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to extract from.
# - $2: **field number** _as int_:
#       The field number to get (starting at 0).
# - ${separator} _as string_:
#       The separator to use.
#       (defaults to $'\t')
#
# Returns:
#
# - ${REPLY}: the extracted field
#
# ```bash
# MY_STRING="field1 field2 field3"
# string::getField MY_STRING 1 separator=" "
# echo "${REPLY}"
# ```
#
# > This is faster than:
# >
# > - using read into an array from a here string
# > - using bash parameter expansion to remove before/after the separator
function string::getField() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    fieldNumber="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    separator=$'\t' \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local field IFS="${separator}"
  local -i index=0
  for field in ${inputString_NameRef}; do
    if [[ index -eq fieldNumber ]]; then
      REPLY="${field}"
      return 0
    fi
    index=$((index + 1))
  done
  REPLY=""
}

# ## string::getIndexOf
#
# Find the first index of a string within another string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to find an index.
# - $2: **search** _as string_:
#       the string to search
# - ${startingIndex} _as int_:
#       (optional) the starting index
#       (defaults to 0)
#
# Returns:
#
# - ${REPLY}: the index of the substring in the string or -1 if not found.
#
# ```bash
# MY_STRING="This is a long text"
# string::getIndexOf MY_STRING "long" startingIndex=2
# string::getIndexOf MY_STRING "long"
# echo "${REPLY}"
# ```
function string::getIndexOf() {
  local -i _STRING_INDEX_OF
  string_getIndexOf "${@}"
  REPLY="${_STRING_INDEX_OF}"
}

# string::getIndexOf is used inside string::extractBetween and we want it to work
# even if the passed string variable is named "REPLY" so we must not erase the value
# of reply mid function.
function string_getIndexOf() {
  local -n inputStringToSearch_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    search="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    startingIndex=0 \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  if ((startingIndex > 0)); then
    # if the starting index is greater than the length of the string, we return -1
    if ((startingIndex >= ${#inputStringToSearch_NameRef})); then
      _STRING_INDEX_OF=-1
      return 0
    fi

    # otherwise we keep only what is after this index
    local subStringToSearch="${inputStringToSearch_NameRef:startingIndex}"
  else
    local -n subStringToSearch=inputStringToSearch_NameRef
  fi

  local -i originalSubStringLength="${#subStringToSearch}"

  # cut everything after the search string
  local afterSearchedString="${subStringToSearch%%"${search}"*}"

  # the index is the length of the temp string if it is different than the initial string length
  if ((${#afterSearchedString} != originalSubStringLength)); then
    _STRING_INDEX_OF=$((${#afterSearchedString} + startingIndex))
  else
    _STRING_INDEX_OF=-1
  fi
}

# ## string::extractBetween
#
# Extract the text between two strings within a string.
# Search for the first occurrence of the start string and the first occurrence
# (after the start index) of the end string.
# Both start and end strings are excluded in the extracted text.
# Both start and end strings must be found to extract something.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to extract a text.
# - $2: **start string** _as string_:
#       the start string
#       (if empty, then it will extract from the beginning of the string)
# - $3: **end string** _as string_:
#       the end string
#       (if empty, then it will extract until the end of the string)
#
# Returns:
#
# - ${REPLY}: the extracted text
#
# ```bash
# MY_STRING="This is a long text"
# string::extractBetween MY_STRING "is a " " text"
# local extractedText="${REPLY}"
# ```
function string::extractBetween() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    start="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    end="${3?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  local -i startIndex endIndex _STRING_INDEX_OF
  if [[ -n ${start} ]]; then
    string_getIndexOf inputString_NameRef "${start}"
    startIndex=${_STRING_INDEX_OF}
    if ((startIndex == -1)); then
      REPLY=""
      return 0
    fi
    startIndex=$((startIndex + ${#start}))
  else
    startIndex=0
  fi

  if [[ -n ${end} ]]; then
    string_getIndexOf inputString_NameRef "${end}" startingIndex="${startIndex}"
    endIndex=${_STRING_INDEX_OF}
    if ((endIndex == -1)); then
      REPLY=""
      return 0
    fi
  else
    REPLY="${inputString_NameRef:startIndex}"
    return 0
  fi

  REPLY="${inputString_NameRef:startIndex:endIndex-startIndex}"
}

# ## string::count
#
# Counts the number of occurrences of a substring in a string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string in which to count occurrences.
# - $2: **substring** _as string_:
#       the substring to count
#
# Returns:
#
# - ${REPLY}: the number of occurrences
#
# ```bash
# MY_STRING="name,first_name,address"
# string::count MY_STRING ","
# echo "${REPLY}"
# ```
#
# > This is faster than looping over the string and check the substring.
function string::count() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local newString="${inputString_NameRef//"${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"/}"
  REPLY=$(((${#inputString_NameRef} - ${#newString}) / ${#2}))
}

# ## string::split
#
# Split a string into an array using a separator.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to split.
# - $2: **separators** _as string_:
#       The separator characters to use.
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: the array of strings
#
# ```bash
# MY_STRING="name,first_name,address"
# string::split MY_STRING ","
# ARRAY=("${REPLY_ARRAY[@]}")
# ```
function string::split() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # shellcheck disable=SC2034
  IFS="${2}" read -r -a REPLY_ARRAY <<<"${inputString_NameRef}"
}

# ## string::head
#
# Get the first nth items (e.g. lines) of a string.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string from which to get the first occurrences.
# - $2: **nb items** _as int_:
#       The number of items (lines) to extract.
# - ${separator} _as string_:
#       (optional) The separator character to use.
#       (defaults to $'\n')
#
# Returns:
#
# - ${REPLY}: The extracted string.
#
# ```bash
# MY_STRING="line1"$'\n'"line2"$'\n'"line3"
# string::head MY_STRING 2
# echo "${REPLY}"
# ```
function string::head() {
  local \
    variableName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    numberOfItems="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    separator=$'\n' \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local -i counter=0

  string::doForEachLine "${variableName}" string_headCallback separator="${separator}"

  REPLY="${REPLY%"${separator}"}"
}

function string_headCallback() {
  if ((counter == 0)); then
    REPLY=""
  fi
  if ((counter >= numberOfItems)); then
    return 0
  fi
  REPLY+="${1}${separator}"
  ((counter += 1))
  return 0
}

# ## string::doForEachLine
#
# Execute a callback function for each item (e.g. line) of a string.
# The string is split using a separator (default to a new line) and
# the callback function is called for each item.
#
# - $1: **string variable name** _as string_:
#       The name of the variable containing the string.
# - $2: **callback function** _as string_:
#       The name of the function to execute for each item (line).
#       The function is called with the following arguments:
#
#       - $1: the current item (line) content
#
#       The function must return 0 if we should continue to the next line, 1 otherwise.
#       (defaults to "")
# - ${separator} _as string_:
#       (optional) The separator character to use.
#       (defaults to $'\n')
#
# ```bash
# string::doForEachLine myString myCallback
# ```
#
# > This function provides a convenient way to avoid using a "here string" and handles extra
# > newlines (which is not the case with a "for loop" using parameter expansion and IFS=$'\n').
# > Here string is significantly slower than using this.
function string::doForEachLine() {
  local inputString="${!1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    callback="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    separator=$'\n' \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local chunk
  while [[ -n ${inputString} ]]; do
    chunk="${inputString%%"${separator}"*}"
    inputString="${inputString:${#chunk}+1}"
    if ! "${callback}" "${chunk}"; then
      break
    fi
  done
}

# ## string::getHexRepresentation
#
# Convert a string to its hexadecimal representation.
#
# - $1: **string variable name** _as string_:
#       The variable name that contains the string to convert.
#
# Returns:
#
# - ${REPLY}: the hexadecimal representation of the string
#
# ```bash
# MY_STRING="This is a string"
# string::getHexRepresentation MY_STRING
# echo "${REPLY}"
# ```
function string::getHexRepresentation() {
  local -n inputString_NameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i charIndex
  local hexChar output
  for ((charIndex = 0; charIndex < ${#inputString_NameRef}; charIndex++)); do
    printf -v hexChar "%x" "'${inputString_NameRef:charIndex:1}"
    output+="${hexChar}"
  done
  REPLY="${output}"
}
