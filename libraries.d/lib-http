#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-fs
source fs

# ## http::request (private)
#
# This function exists to demonstrate how to make a simple HTTP request using pure bash.
# It should not be used for anything serious as it is seriously limited.
# BUG: It only handles pure text responses (can't download anything else than plain text, json and such).
# **Seriously, use curl instead!**
#
# - $1: **verb** _as string_:
#       The HTTP verb to use (GET, POST, PUT, DELETE, etc.).
# - $2: **url** _as string_:
#       The URL to request. Can be http or https but it will only send a request to port 80 anyway.
# - ${failOnError} _as bool_:
#       (optional) If true, the function will use core::fail if the HTTP status code is not acceptable.
#       (defaults to false)
# - ${acceptableCodes} _as string_:
#       (optional) The list of acceptable status codes, comma separated.
#       (defaults to 200,201,202,204,301,304,308)
# - ${output} _as string_:
#       (optional) The file in which to save the output of the request.
#       (defaults to "" which means the body will be returned in the variable `REPLY`)
# - ${followRedirection} _as bool_:
#       (optional) If true, the function will follow redirections.
#       (defaults to true)
# - ${timeout} _as int_:
#       (optional) The timeout in seconds for the response (can be a decimal number).
#       (defaults to 5)
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${REPLY}: the body of the response or the path to the file where it was saved
# - ${REPLY2}: the headers of the response
# - ${REPLY3}: the http status code
#
# ```bash
# VALET_CONFIG_ENABLE_INSECURE_WEB_REQUESTS=true
# http::request GET http://example.com failOnError=true acceptableCodes=200,201 followRedirection=true
# http::request GET https://api.ip2location.io/ output=test.json
# http::request GET http://httpbin.org/get
# echo "Returns HTTP code was ${REPLY3}, response:"$'\n'"${REPLY2}"$'\n'"${REPLY}"
# ```
function http::request() {
  local \
    verb="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    url="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    failOnError=false \
    acceptableCodes="200,201,202,204,301,304,308" \
    output="" \
    followRedirection=true \
    responseTimeout=5
  shift 2
  eval "local a= ${*@Q}"

  if [[ ${VALET_CONFIG_ENABLE_INSECURE_WEB_REQUESTS:-} != "true" ]]; then
    core::fail "For security reasons, insecure web requests are disabled by default. Please explicitly enable them by setting the environment variable VALET_CONFIG_ENABLE_INSECURE_WEB_REQUESTS to true."
  fi

  if [[ -n ${output} ]]; then
    fs::createFileIfNeeded "${output}"
    : >"${output}"
  fi

  # parse url
  local host path
  if [[ ${url} =~ ^https?://([^/]+)(/.*)$ ]]; then
    host="${BASH_REMATCH[1]}"
    path="${BASH_REMATCH[2]}"
  else
    log::error "The URL is invalid: ⌜${url}⌝."
    return 1
  fi
  log::trace "Getting URL for host ⌜${host}⌝ and path ⌜${path}⌝."

  # open connection
  local -i requestFd
  exec {requestFd}<>"/dev/tcp/${host}/80"

  local IFS=$'\n'

  # send request with headers
  local -a requestHeaders=(
    "${verb} ${path} HTTP/1.1"
    "Host: ${host}"
    "Accept: */*"
    "Connection: close"
    ""
  )
  printf '%s\r\n' "${requestHeaders[@]}" >&${requestFd}
  log::trace "Headers sent:"
  if log::isDebugEnabled; then
    log::printString "${requestHeaders[*]}"
  fi

  # read response
  log::trace "Headers received:"
  local headers body httpCode line contentLength
  local -i exitCode=0
  while IFS=$'\n' read -r -d $'\n' -u "${requestFd}" -t "${responseTimeout}" line || [[ -n ${line:-} ]]; do

    if [[ -n ${line%$'\r'} ]]; then
      # we are still in the headers
      line="${line%$'\r'}"
      headers+="${line}"$'\n'
      if log::isDebugEnabled; then
        log::printString "${line}"
      fi
    else
      # we are at the end of the headers
      log::trace "Reading body with content length: ${contentLength:-0}"
      if [[ -n ${output} ]]; then
        # read the whole body to a file
        local buffer
        if [[ -n ${contentLength:-} ]]; then
          while IFS= read -sr -d '' -u ${requestFd} buffer || [[ -n ${buffer:-} ]]; do
            printf '%s' "${buffer}" >>"${output}"
          done
        else
          : >"${output}"
        fi
      else
        if [[ -n ${contentLength:-} ]]; then
          while IFS= read -sr -d '' -u ${requestFd} buffer || [[ -n ${buffer:-} ]]; do
            body+="${buffer}"
          done
        fi
      fi
      break
    fi

    # get http code and interpret headers
    if [[ -z ${httpCode:-} && ${line} =~ ^HTTP/1\.[01]\ ([0-9]{3})\ .*$ ]]; then
      httpCode="${BASH_REMATCH[1]}"
      log::trace "Got HTTP code ⌜${httpCode}⌝."

    elif [[ ${line} =~ ^Content-Length:\ ([0-9]+)$ ]]; then
      contentLength="${BASH_REMATCH[1]}"
      log::trace "Got Content-Length: ${contentLength}"

    elif [[ ${followRedirection} == "true" && ${httpCode:-} == 301 && ${line} =~ ^Location:\ (.*)$ ]]; then
      local location="${BASH_REMATCH[1]}"
      # test if it is the same URL but with https
      if [[ ${location} == "https://${host}${path}" ]]; then
        log::error "HTTPS redirection detected for ⌜${url}⌝, we cannot follow (HTTP request was sent but we got 301 and the location is the HTTPS url)."
        exitCode=1
      fi
      log::trace "Following redirection to: ${location}"
      http::request "${verb}" "${location}" "${@}"
      return 0
    fi
  done

  # close connection
  exec {requestFd}<&-
  exec {requestFd}>&-

  local

  if ((exitCode != 0)); then
    :
  elif [[ -z ${httpCode:-} ]]; then
    log::error "The HTTP response did not contain a valid HTTP code (or timed out)."
    exitCode=1
  elif [[ -n ${httpCode:-} && ,${acceptableCodes}, == *",${httpCode},"* ]]; then
    exitCode=0
    log::trace "The HTTP return code ⌜${httpCode}⌝ is acceptable and exit code has been reset to 0 from ⌜${exitCode}⌝."
  else
    exitCode=1
  fi

  if (( exitCode != 0 )); then
    if log::isDebugEnabled || [[ ${failOnError} == "true" ]]; then
      log::errorTrace "HTTP response:"
      log::printString "${headers}"$'\n'"${body:-}"
    fi
    local message="The HTTP return code ⌜${httpCode:-}⌝ is not acceptable for url ⌜${url}⌝."
    if [[ ${failOnError} == "true" ]]; then
      core::fail "${message}"
    fi
    log::trace "${message}"
  fi

  REPLY="${body:-${output}}"
  REPLY2="${headers}"
  REPLY3="${httpCode}"
  REPLY_CODE="${exitCode}"
  return 0
}
