#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-terminal
source terminal
# shellcheck source=lib-coproc
source coproc
# shellcheck source=lib-time
source time

# shellcheck disable=SC2317
function tui::test() {
  printf '%s\n' "Press any key to see the returned code (press CTRL+C to quit)." 1>&"${GLOBAL_FD_TUI}"

  # define the callback function called when a special key is pressed
  function onKeyPress() {
    printf "You pressed: ⌜%q⌝\n" "${1}" 1>&"${GLOBAL_FD_TUI}"
  }

  # define the callback function called when the screen needs to be redrawn
  function onRedrawRequired() {
    printf "The screen needs to be redrawn, terminal changed to: ⌜%s x %s⌝\n" "${GLOBAL_COLUMNS}" "${GLOBAL_LINES}" 1>&"${GLOBAL_FD_TUI}"
  }

  # define the callback function called on each loop iteration
  function onTick() {
    printf "%s\n" "1s has elapsed" 1>&"${GLOBAL_FD_TUI}"
  }

  tui::startMainLoop onKeyPress \
    onRedrawRequiredCallback=onRedrawRequired \
    onTickCallback=onTick \
    tickDelay=1.0 \
    trackAllMouseEvents=true
}

function tui::startMainLoop() {
  local \
    onKeyPressCallback="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    onTickCallback="" \
    onRedrawRequiredCallback="" \
    tickDelay=0.5 \
    trackAllMouseEvents=false \
    keyBindingsPrefix=":"
  shift 1
  eval "local a= ${*@Q}"

  local \
    _TUI_TRACK_ALL_MOUSE_EVENTS="${trackAllMouseEvents}" \
    _TUI_KEY_BINDINGS_PREFIX="${keyBindingsPrefix}"

  time::getSecondsToMicroseconds tickDelay
  local tickDelayMicroseconds="${REPLY}"

  if ! declare -F "${onKeyPressCallback}" &>/dev/null; then
    core::fail "The on key press callback function ⌜${onKeyPressCallback}⌝ does not exist."
  fi
  if [[ -n ${onTickCallback} ]] && ! declare -F "${onTickCallback}" &>/dev/null; then
    core::fail "The on each loop iteration callback function ⌜${onTickCallback}⌝ does not exist."
  fi
  if [[ -n ${onRedrawRequiredCallback} ]] && ! declare -F "${onRedrawRequiredCallback}" &>/dev/null; then
    core::fail "The on redraw required callback function ⌜${onRedrawRequiredCallback}⌝ does not exist."
  fi

  # setup the terminal to be ready for readline
  terminal::setRawMode
  # before starting to wait for inputs, we clear up the key pressed
  # terminal::clearKeyPressed
  terminal::rerouteLogs
  tui_startKeyPressListener

  # shellcheck disable=SC2034
  GLOBAL_WARN_ON_INTERRUPT_DISABLED=true
  GLOBAL_SCREEN_REDRAW_REQUIRED=true

  local -i nbCoprocRestart=0
  local IFS=" "

  # main loop
  while [[ -t ${GLOBAL_FD_TUI} ]]; do
    # call the on redraw required callback function if defined
    if [[ ${GLOBAL_SCREEN_REDRAW_REQUIRED} == "true" && -n ${onRedrawRequiredCallback} ]]; then
      "${onRedrawRequiredCallback}"
      GLOBAL_SCREEN_REDRAW_REQUIRED=false
    fi

    # call the on each loop iteration callback function if defined
    if [[ -n ${onTickCallback} ]]; then
      "${onTickCallback}"
    fi

    # read the key pressed from the key press listener coproc
    if coproc::receiveMessage KEY_PRESS_LISTENER -t "${tickDelay}"; then
      REPLY_CODE=0
      "${onKeyPressCallback}" "${REPLY}"
      if (( REPLY_CODE != 0)); then
        log::debug "The on key press callback function ⌜${onKeyPressCallback}⌝ returned non-zero exit code, stopping the main loop."
        break
      fi
    elif ! coproc::isRunning KEY_PRESS_LISTENER; then
      if (( nbCoprocRestart > 3 )); then
        log::error "Key press listener coproc is failing to start, check the logs for errors."
        break
      fi
      log::warning "Key press listener coproc is not already running, re-starting it."
      tui_startKeyPressListener
      nbCoprocRestart+=1
    fi
  done

  unset -v GLOBAL_WARN_ON_INTERRUPT_DISABLED

  coproc::kill KEY_PRESS_LISTENER
  terminal::restoreLogs
  terminal::restoreSettings
}

function tui_startKeyPressListener() {
  # if the key press listener is not already running, we start it
  if ! coproc::isRunning KEY_PRESS_LISTENER; then
    log::debug "Starting key press listener coproc."
    coproc::run KEY_PRESS_LISTENER \
      mainCommand=tui_keyPressListenerCoprocMain \
      loopCommand=tui_keyPressListenerCoprocLoop \
      onMessageCommand= \
      waitForMainEnd=true
  fi
}

function tui_keyPressListenerCoprocMain() {
  # rebind some keys to call the callback function
  terminal::rebindKeymap tui_keyPressListener_handleKeyBinding

  # activate bracketed paste mode and bind the paste event
  # https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Bracketed-Paste-Mode
  printf "%s" "${ESC__ENABLE_BRACKETED_PASTE}" 1>&"${GLOBAL_FD_TUI}"
  bind -x '"\e[200~": tui_keyPressListener_handlePaste'
  _TUI_RECEIVED_PASTE_EVENT=false

  # enable mouse tracking
  # https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Normal-tracking-mode
  if [[ ${_TUI_TRACK_ALL_MOUSE_EVENTS} == "true" ]]; then
    printf "%s" "${ESC__ENABLE_MOUSE_ANY_EVENT_TRACKING}" 1>&"${GLOBAL_FD_TUI}"
  else
    printf "%s" "${ESC__ENABLE_MOUSE_BUTTON_TRACKING}" 1>&"${GLOBAL_FD_TUI}"
  fi
  bind -x '"\e[<": tui_keyPressListener_handleMouseEvent'
  _TUI_RECEIVED_MOUSE_EVENT=false
}

function tui_keyPressListenerCoprocLoop() {
  while terminal::waitForKeyPress -u "${GLOBAL_FD_ORIGINAL_STDIN}"; do
    if [[ ${_TUI_RECEIVED_MOUSE_EVENT} == "true" ]]; then
      # we received a mouse event, we need to parse it
      tui_keyPressListener_parseMouseEvent "${LAST_KEY_PRESSED}${PREVIOUS_KEY_PRESSED_EXTRA_CHARS%%$'\e'*}"
      PREVIOUS_KEY_PRESSED_EXTRA_CHARS=""
      _TUI_RECEIVED_MOUSE_EVENT=false
      continue
    fi

    if [[ ${_TUI_RECEIVED_PASTE_EVENT} == "true" ]]; then
      # the user is pasting text, we handle it; pasted text will end with \e[201~
      printf "%s%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "PASTE" "=${LAST_KEY_PRESSED}${PREVIOUS_KEY_PRESSED_EXTRA_CHARS%%$'\e[201~'}"
      PREVIOUS_KEY_PRESSED_EXTRA_CHARS=""
      _TUI_RECEIVED_PASTE_EVENT=false
      continue
    fi

    case ${LAST_KEY_PRESSED} in
    $'\r') printf "%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "ENTER" ;;
    $'\n') printf "%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "CTRL+ENTER" ;;
    $'\t') printf "%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "TAB" ;;
    *) printf "%s\0" "${LAST_KEY_PRESSED}" ;;
    esac
  done
}

function tui_keyPressListener_handleKeyBinding() {
  # make sure we see any error happening in this function, since it is
  # executed as a callback of the readline process and we redirected the stderr
  # to /dev/null to avoid a bug with readline (see tui_waitForKeyPress)
  # exec 2>&"${GLOBAL_FD_LOG}"
  printf "%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "${1}"
}

function tui_keyPressListener_handlePaste() {
  _TUI_RECEIVED_PASTE_EVENT=true
}

function tui_keyPressListener_handleMouseEvent() {
  _TUI_RECEIVED_MOUSE_EVENT=true
}

function tui_keyPressListener_parseMouseEvent() {
  local mouseEventEncoded="${1}"
  # mouse event is encoded as: <ESC>[<button type>;<x position>;<y position>[M|m]

  local -i mouseEventType="${mouseEventEncoded%%;*}"
  local mouseEventDecoded=""

  # bitwise operations to decode the mouse event type
  if (( mouseEventType & 2#10000 )); then
    mouseEventDecoded+="CTRL+"
  fi
  if (( mouseEventType & 2#1000 )); then
    mouseEventDecoded+="ALT+"
  fi
  if (( mouseEventType & 2#100 )); then
    mouseEventDecoded+="SHIFT+"
  fi
  if (( mouseEventType & 2#100000 )); then
    mouseEventDecoded+="MOVE+"
  fi
  mouseEventType=$(( mouseEventType & 2#11000011 ))

  local mouseButtonStatus
  if [[ ${mouseEventEncoded} == *"M" ]]; then
    mouseButtonStatus="CLICK_"
  else
    mouseButtonStatus="RELEASE_"
  fi
  mouseEventEncoded="${mouseEventEncoded%[Mm]}"

  if (( mouseEventType == 0 )); then
    mouseEventDecoded+="${mouseButtonStatus}MB1 "
  elif (( mouseEventType == 1 )); then
    mouseEventDecoded+="${mouseButtonStatus}MB2 "
  elif (( mouseEventType == 2 )); then
    mouseEventDecoded+="${mouseButtonStatus}MB3 "
  elif (( mouseEventType == 3 )); then
    mouseEventDecoded="${mouseEventDecoded%+} "
  elif (( mouseEventType == 64 )); then
    mouseEventDecoded+="SCROLL_UP "
  elif (( mouseEventType == 65 )); then
    mouseEventDecoded+="SCROLL_DOWN "
  else
    mouseEventDecoded+="${mouseButtonStatus}MB${mouseEventType} "
  fi

  mouseEventDecoded+="${mouseEventEncoded#*;}"

  printf "%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "${mouseEventDecoded}"
}