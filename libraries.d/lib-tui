#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-terminal
source terminal
# shellcheck source=lib-coproc
source coproc
# shellcheck source=lib-time
source time

# shellcheck disable=SC2317
function tui::test() {
  printf '%s\n' "Press any key to see the returned code (press CTRL+C to quit)." 1>&"${GLOBAL_FD_TUI}"

  # define the callback function called when a special key is pressed
  function onKeyPress() {
    printf "You pressed: ⌜%q⌝\n" "${1}" 1>&"${GLOBAL_FD_TUI}"
  }

  # define the callback function called when the screen needs to be redrawn
  function onRedrawRequired() {
    printf "The screen needs to be redrawn, terminal changed to: ⌜%s x %s⌝\n" "${GLOBAL_COLUMNS}" "${GLOBAL_LINES}" 1>&"${GLOBAL_FD_TUI}"
  }

  # define the callback function called on each loop iteration
  function onTick() {
    printf "%s\n" "1s has elapsed" 1>&"${GLOBAL_FD_TUI}"
  }

  tui::startMainLoop onKeyPress \
    onRedrawRequiredCallback=onRedrawRequired \
    onTickCallback=onTick \
    tickDelay=1.00 \
    trackAllMouseEvents=true
}

function tui::startMainLoop() {
  local \
    onKeyPressCallback="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    onTickCallback="" \
    onRedrawRequiredCallback="" \
    tickDelay=0.5 \
    trackAllMouseEvents=false \
    keyBindingsPrefix=":"
  shift 1
  eval "local a= ${*@Q}"

  local \
    REPLY \
    REPLY_CODE \
    _TUI_TRACK_ALL_MOUSE_EVENTS="${trackAllMouseEvents}" \
    _TUI_KEY_BINDINGS_PREFIX="${keyBindingsPrefix}"

  time::getMicrosecondsFromSeconds "${tickDelay}"
  local tickDelayMicroseconds="${REPLY}"

  # take ~52% for the read delay to ensure we do not miss the tick
  time::getSecondsFromMicroseconds $((tickDelayMicroseconds * 52 / 100))
  local readDelay="${REPLY}"

  time::getProgramElapsedMicroseconds
  local lastTickTime="${REPLY}"

  if ! declare -F "${onKeyPressCallback}" &>/dev/null; then
    core::fail "The on key press callback function ⌜${onKeyPressCallback}⌝ does not exist."
  fi
  if [[ -n ${onTickCallback} ]] && ! declare -F "${onTickCallback}" &>/dev/null; then
    core::fail "The on each loop iteration callback function ⌜${onTickCallback}⌝ does not exist."
  fi
  if [[ -n ${onRedrawRequiredCallback} ]] && ! declare -F "${onRedrawRequiredCallback}" &>/dev/null; then
    core::fail "The on redraw required callback function ⌜${onRedrawRequiredCallback}⌝ does not exist."
  fi

  printf '%s' "${ESC__CURSOR_HIDE}" 1>&"${GLOBAL_FD_TUI}"

  # setup the terminal to be ready for readline
  terminal::setRawMode
  # before starting to wait for inputs, we clear up the key pressed
  # terminal::clearKeyPressed
  terminal::rerouteLogs
  tui_startKeyPressListener

  # shellcheck disable=SC2034
  GLOBAL_WARN_ON_INTERRUPT_DISABLED=true
  GLOBAL_SCREEN_REDRAW_REQUIRED=true

  local -i nbCoprocRestart=0 readDelayInMicroseconds
  local IFS=" "

  # main loop
  while [[ -t ${GLOBAL_FD_TUI} ]]; do
    # call the on redraw required callback function if defined
    if [[ ${GLOBAL_SCREEN_REDRAW_REQUIRED} == "true" && -n ${onRedrawRequiredCallback} ]]; then
      "${onRedrawRequiredCallback}"
      GLOBAL_SCREEN_REDRAW_REQUIRED=false
    fi

    time::getProgramElapsedMicroseconds
    readDelayInMicroseconds=$((tickDelayMicroseconds - (REPLY - lastTickTime)))
    while (( REPLY - lastTickTime <= tickDelayMicroseconds )); do
      readDelayInMicroseconds=$((readDelayInMicroseconds - (REPLY - lastTickTime)))

      time::getSecondsFromMicroseconds ${readDelayInMicroseconds}

      # read the key pressed from the key press listener coproc
      if coproc::receiveMessageWithTimeOut KEY_PRESS_LISTENER "${REPLY}"; then
        REPLY_CODE=0
        "${onKeyPressCallback}" "${REPLY}"
        if ((REPLY_CODE != 0)); then
          log::debug "The on key press callback function ⌜${onKeyPressCallback}⌝ returned non-zero exit code, stopping the main loop."
          break 2
        fi
      elif ! coproc::isRunning KEY_PRESS_LISTENER; then
        if ((nbCoprocRestart > 3)); then
          core::fail "Key press listener coproc is failing to start, check the logs for errors."
        fi
        log::warning "Key press listener coproc is not already running, re-starting it."
        tui_startKeyPressListener
        nbCoprocRestart+=1
      fi

      time::getProgramElapsedMicroseconds
    done
    lastTickTime="${REPLY}"

    # call the on each loop iteration callback function if defined
    if [[ -n ${onTickCallback} ]]; then
      "${onTickCallback}"
    fi
  done

  unset -v GLOBAL_WARN_ON_INTERRUPT_DISABLED

  coproc::kill KEY_PRESS_LISTENER
  terminal::restoreLogs
  terminal::restoreSettings

  printf '%s' "${ESC__CURSOR_SHOW}" 1>&"${GLOBAL_FD_TUI}"
}

function tui_startKeyPressListener() {
  local REPLY

  # if the key press listener is not already running, we start it
  if ! coproc::isRunning KEY_PRESS_LISTENER; then
    log::debug "Starting key press listener coproc."
    coproc::run KEY_PRESS_LISTENER \
      mainCommand=tui_keyPressListenerCoprocMain \
      loopCommand=tui_keyPressListenerCoprocLoop \
      onMessageCommand= \
      waitForMainEnd=true
  fi
}

# we send all messages to the main loop with the \0<message>\0 format.
# this is because the read command in the main loop can have a low timeout that would prevent
# it to read the whole message if it is sent slowly.
# so we read until we get the \0 string, then we read the message.
function tui_keyPressListenerCoprocMain() {
  # rebind some keys to call the callback function
  terminal::rebindKeymap tui_keyPressListener_handleKeyBinding

  # activate bracketed paste mode and bind the paste event
  # https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Bracketed-Paste-Mode
  printf "%s" "${ESC__ENABLE_BRACKETED_PASTE}" 1>&"${GLOBAL_FD_TUI}"
  bind -x '"\e[200~": tui_keyPressListener_handlePaste'
  _TUI_RECEIVED_PASTE_EVENT=false

  # enable mouse tracking
  # https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Normal-tracking-mode
  if [[ ${_TUI_TRACK_ALL_MOUSE_EVENTS} == "true" ]]; then
    printf "%s" "${ESC__ENABLE_MOUSE_ANY_EVENT_TRACKING}" 1>&"${GLOBAL_FD_TUI}"
  else
    printf "%s" "${ESC__ENABLE_MOUSE_BUTTON_TRACKING}" 1>&"${GLOBAL_FD_TUI}"
  fi
  bind -x '"\e[<": tui_keyPressListener_handleMouseEvent'
  _TUI_RECEIVED_MOUSE_EVENT=false
}

function tui_keyPressListenerCoprocLoop() {
  while terminal::waitForKeyPress -u "${GLOBAL_FD_ORIGINAL_STDIN}"; do
    if [[ ${_TUI_RECEIVED_MOUSE_EVENT} == "true" ]]; then
      # we received a mouse event, we need to parse it
      tui_keyPressListener_parseMouseEvent "${LAST_KEY_PRESSED}${PREVIOUS_KEY_PRESSED_EXTRA_CHARS%%$'\e'*}"
      PREVIOUS_KEY_PRESSED_EXTRA_CHARS=""
      _TUI_RECEIVED_MOUSE_EVENT=false
      continue
    fi

    if [[ ${_TUI_RECEIVED_PASTE_EVENT} == "true" ]]; then
      # the user is pasting text, we handle it; pasted text will end with \e[201~
      LAST_KEY_PRESSED="${LAST_KEY_PRESSED}${PREVIOUS_KEY_PRESSED_EXTRA_CHARS%%$'\e[201~'*}"
      printf "\0%s%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "PASTE" "=${LAST_KEY_PRESSED@Q}"
      PREVIOUS_KEY_PRESSED_EXTRA_CHARS=""
      _TUI_RECEIVED_PASTE_EVENT=false
      continue
    fi

    case ${LAST_KEY_PRESSED} in
    $'\r') printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "ENTER" ;;
    $'\n') printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "CTRL+ENTER" ;;
    $'\t') printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "TAB" ;;
    *) printf "\0%s\0" "${LAST_KEY_PRESSED}" ;;
    esac
  done
}

function tui_keyPressListener_handleKeyBinding() {
  # we will never see any error happening in this function, since it is
  # executed as a callback of the readline process and we redirected the stderr
  # to /dev/null to avoid a bug with readline (see tui_waitForKeyPress)
  # exec 2>&"${GLOBAL_FD_LOG}"
  printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "${1}"
}

function tui_keyPressListener_handleKeyBindingWithRateLimit() {
  # we will never see any error happening in this function, since it is
  # executed as a callback of the readline process and we redirected the stderr
  # to /dev/null to avoid a bug with readline (see tui_waitForKeyPress)
  # exec 2>&"${GLOBAL_FD_LOG}"
  # _TUI_LAST_KEY=""
  # time::getProgramElapsedMicroseconds
  # _TUI_LAST_KEY_TIME="${REPLY}"
  # _TUI_LAST_KEY_REPEATED_COUNT=0

  # if [[ ${1} == "${_TUI_LAST_KEY}" ]]; then
  #   time::getProgramElapsedMicroseconds
  #   if ((REPLY - _TUI_LAST_KEY_TIME < 100000)); then
  #     # same key pressed within 100ms, we ignore it to avoid flooding the main loop
  #     _TUI_LAST_KEY_REPEATED_COUNT=$((_TUI_LAST_KEY_REPEATED_COUNT + 1))
  #   else
  #     _TUI_LAST_KEY_REPEATED_COUNT=0
  #   fi
  #   if ((_TUI_LAST_KEY_REPEATED_COUNT > 5)); then
  #     return 0
  #   fi
  #   _TUI_LAST_KEY_TIME="${REPLY}"
  # else
  #   _TUI_LAST_KEY="${1}"
  #   _TUI_LAST_KEY_REPEATED_COUNT=0
  # fi
  printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "${1}"
}

function tui_keyPressListener_handlePaste() {
  _TUI_RECEIVED_PASTE_EVENT=true
}

function tui_keyPressListener_handleMouseEvent() {
  _TUI_RECEIVED_MOUSE_EVENT=true
}

function tui_keyPressListener_parseMouseEvent() {
  local mouseEventEncoded="${1}"
  # mouse event is encoded as: <ESC>[<button type>;<x position>;<y position>[M|m]

  local -i mouseEventType="${mouseEventEncoded%%;*}"
  local mouseEventDecoded=""

  # bitwise operations to decode the mouse event type
  if ((mouseEventType & 2#10000)); then
    mouseEventDecoded+="CTRL+"
  fi
  if ((mouseEventType & 2#1000)); then
    mouseEventDecoded+="ALT+"
  fi
  if ((mouseEventType & 2#100)); then
    mouseEventDecoded+="SHIFT+"
  fi
  if ((mouseEventType & 2#100000)); then
    mouseEventDecoded+="MOVE+"
  fi
  mouseEventType=$((mouseEventType & 2#11000011))

  local mouseButtonStatus
  if [[ ${mouseEventEncoded} == *"M" ]]; then
    mouseButtonStatus="CLICK_"
  else
    mouseButtonStatus="RELEASE_"
  fi
  mouseEventEncoded="${mouseEventEncoded%[Mm]}"

  if ((mouseEventType == 0)); then
    mouseEventDecoded+="${mouseButtonStatus}MB1 "
  elif ((mouseEventType == 1)); then
    mouseEventDecoded+="${mouseButtonStatus}MB2 "
  elif ((mouseEventType == 2)); then
    mouseEventDecoded+="${mouseButtonStatus}MB3 "
  elif ((mouseEventType == 3)); then
    mouseEventDecoded="${mouseEventDecoded%+} "
  elif ((mouseEventType == 64)); then
    mouseEventDecoded+="SCROLL_UP "
  elif ((mouseEventType == 65)); then
    mouseEventDecoded+="SCROLL_DOWN "
  else
    mouseEventDecoded+="${mouseButtonStatus}MB${mouseEventType} "
  fi

  mouseEventDecoded+="${mouseEventEncoded#*;}"

  printf "\0%s%s\0" "${_TUI_KEY_BINDINGS_PREFIX}" "${mouseEventDecoded}"
}
