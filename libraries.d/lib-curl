#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-exe
source exe
# shellcheck source=lib-fs
source fs

# ## curl::download
#
# This function is a wrapper around curl to save a request result in a file.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o ${2}.
#
# - $1: **url** _as string_:
#       The url to download
# - $@: **curl arguments** _as any_:
#       options for curl
# - ${output} _as string_:
#       (optional) the file in which to save the output of curl, created as a temporary file if not specified
#       (default to a temporary file)
# - ${failOnError} _as bool_:
#       (optional) true/false to indicate if the function should fail in case the execution fails
#       (default to false)
# - ${acceptableCodes} _as string_:
#       (optional) list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${REPLY}: the path to the file where the content was saved
# - ${REPLY2}: the content of curl stderr
# - ${REPLY3}: the http status code
#
# ```bash
# curl::download https://example.com --- output=/filePath
# curl::download https://example2.com -H "header: value" --- failOnError=true acceptableCodes=200,201 output=/filePath
# echo "The curl command ended with exit code ⌜${REPLY_CODE}⌝, the http return code was ⌜${REPLY2}⌝: ${REPLY}"
# ```
function curl::download() {
  local \
    url="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    output="" \
    failOnError=false \
    acceptableCodes="200,201,202,204,301,304,308"
  shift 1
  core::parseShellParameters "${@}"
  eval "${REPLY}"
  # temp file if no path is specified
  if [[ -z ${output} ]]; then
    fs::createTempFile pathOnly=true
    output="${REPLY}"
  fi

  # call curl
  local httpStatusCode errors
  exe::invoke curl --silent --show-error --location --write-out "%{response_code}" --output "${output}" "$@" "${url}" --- noFail=true
  local -i exitCode="${REPLY_CODE}"
  httpStatusCode="${REPLY}"
  errors="${REPLY2}"

  # workaround in case of unknown args in curl
  # and for a bug in curl https://github.com/Homebrew/homebrew-core/issues/173294
  if [[ ${exitCode} != "0" && (${errors} == *"bad argument"* || ${errors} == *"is unknown"*) ]]; then
    log::debug "Trying to use curl without the many options."
    exe::invoke curl --location -v --output "${output}" "$@" --- noFail=true
    exitCode="${REPLY_CODE}"
    if [[ ${REPLY}${REPLY2} =~ "< HTTP/"([0-9.]+)" "([0-9]+)" " ]]; then
      httpStatusCode="${BASH_REMATCH[2]}"
    else
      httpStatusCode="??? Could not read from verbose curl output."
    fi
    errors="${REPLY2}"
  fi

  log::debug "The curl command for url ⌜${url}⌝ ended with exit code ⌜${exitCode}⌝, the http return code was ⌜${httpStatusCode}⌝."

  # if the error code is acceptable, then we set it to 0
  if [[ ,${acceptableCodes}, == *",${httpStatusCode},"* ]]; then
    exitCode=0
    log::debug "The http return code ⌜${httpStatusCode}⌝ is acceptable and exit code has been reset to 0 from ⌜${exitCode}⌝."
  else
    exitCode=1
    if log::isDebugEnabled || [[ ${failOnError} == "true" ]]; then
      log::errorTrace "Curl error output stream:"
      log::saveFileString errors suffix="curl-stderr"
      log::printFileString errors maxLines=99
    fi
    local message="The http return code ⌜${httpStatusCode}⌝ is not acceptable for url ⌜${url}⌝ (acceptable codes are: ${acceptableCodes})."
    if [[ ${failOnError} == "true" ]]; then
      core::fail "${message}"
    fi
    log::debug "${message}"
  fi

  REPLY="${output}"
  REPLY2="${errors}"
  REPLY3="${httpStatusCode}"
  # shellcheck disable=SC2034
  REPLY_CODE="${exitCode}"
  return 0
}

# ## curl::request
#
# This function is a wrapper around curl to save the content of a request in a variable.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o "tempfile".
#
# - $1: **url** _as string_:
#       The url to request
# - $@: **curl arguments** _as any_:
#       options for curl
# - ${failOnError} _as bool_:
#       (optional) true/false to indicate if the function should fail in case the execution fails
#       (default to false)
# - ${acceptableCodes} _as string_:
#       (optional) list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${REPLY}: the content of the request
# - ${REPLY2}: the content of curl stderr
# - ${REPLY3}: the http status code
#
# ```bash
# curl::request https://example.com
# curl::request https://example.com -X POST -H 'Authorization: token' --- failOnError=true
# echo "The curl command ended with exit code ⌜${REPLY_CODE}⌝, the http return code was ⌜${REPLY2}⌝: ${REPLY}"
# ```
function curl::request() {
  local \
    url="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    failOnError=false \
    acceptableCodes="200,201,202,204,301,304,308"
  shift 1
  core::parseShellParameters "${@}"
  eval "${REPLY}"

  # reset the temporary file, only if needed
  if [[ -s "${GLOBAL_TEMPORARY_WORK_FILE}" ]]; then
    : >"${GLOBAL_TEMPORARY_WORK_FILE}"
  fi

  local -i exitCode=0
  local errors httpStatusCode
  curl::download "${url}" "$@" --- failOnError="${failOnError}" acceptableCodes="${acceptableCodes}" output="${GLOBAL_TEMPORARY_WORK_FILE}" || exitCode=$?
  errors="${REPLY2}"
  httpStatusCode="${REPLY3}"

  fs::readFile "${GLOBAL_TEMPORARY_WORK_FILE}"
  REPLY2="${errors}"
  # shellcheck disable=SC2034
  REPLY3="${httpStatusCode}"
  # shellcheck disable=SC2034
  REPLY_CODE="${exitCode}"
  return 0
}
