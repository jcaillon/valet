#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-exe
source exe
# shellcheck source=lib-fs
source fs

# ## curl::download
#
# This function is a wrapper around curl to save a request result in a file.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o ${2}.
#
# - $1: **url** _as string_:
#       The url to download
# - $@: **curl arguments** _as any_:
#       options for curl
# - ${path} _as string_:
#       the file in which to save the output of curl, created as a temporary file if not specified
# - ${failOnError} _as bool_:
#       true/false to indicate if the function should fail in case the execution fails
# - ${acceptableCodes} _as string_:
#       list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${REPLY}: the path to the file where the content was saved
# - ${REPLY2}: the content of curl stderr
# - ${REPLY3}: the http status code
#
# ```bash
# curl::download https://example.com --- path=/filePath
# curl::download https://example2.com -H "header: value" --- failOnError=true acceptableCodes=200,201 path=/filePath
# echo "The curl command ended with exit code ⌜${REPLY_CODE}⌝, the http return code was ⌜${REPLY2}⌝: ${REPLY}"
# ```
function curl::download() {
  local \
    url="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    path="" \
    failOnError=false \
    acceptableCodes="200,201,202,204,301,304,308"
  shift 1
  core::parseShellParameters "${@}"
  eval "${REPLY}"

  # temp file if no path is specified
  if [[ -z ${path} ]]; then
    fs::createTempFile pathOnly=true
    path="${REPLY}"
  fi

  # call curl
  local -i exitCode=0
  local httpStatusCode errors
  exe::invoke5 "false" "0" "false" "" "curl" "--silent" "--show-error" "--location" "--write-out" "%{response_code}" "--output" "${path}" "$@" "${url}" || exitCode=$?
  httpStatusCode="${REPLY}"
  errors="${REPLY2}"

  # workaround in case of unknown args in curl
  # and for a bug in curl https://github.com/Homebrew/homebrew-core/issues/173294
  if [[ ${exitCode} != "0" && (${errors} == *"bad argument"* || ${errors} == *"is unknown"*) ]]; then
    log::debug "Trying to use curl without the many options."
    exe::invoke5 "false" "0" "false" "" "curl" "--location" "-v" "--output" "${path}" "$@" || exitCode=$?
    if [[ ${REPLY}${REPLY2} =~ "< HTTP/"([0-9.]+)" "([0-9]+)" " ]]; then
      httpStatusCode="${BASH_REMATCH[2]}"
    else
      httpStatusCode="??? Could not read from verbose curl output."
    fi
    errors="${REPLY2}"
  fi

  log::debug "The curl command for url ⌜${url}⌝ ended with exit code ⌜${exitCode}⌝, the http return code was ⌜${httpStatusCode}⌝."

  # if the error code is acceptable, then we set it to 0
  if [[ ,${acceptableCodes}, == *",${httpStatusCode},"* ]]; then
    exitCode=0
    log::debug "The http return code ⌜${httpStatusCode}⌝ is acceptable and exit code has been reset to 0 from ⌜${exitCode}⌝."
  else
    exitCode=1
    if log::isDebugEnabled || [[ ${failOnError} == "true" ]]; then
      log::errorTrace "Curl error output stream:"
      log::saveFileString errors suffix="curl-stderr"
      log::printFileString errors maxLines=99
    fi
    local message="The http return code ⌜${httpStatusCode}⌝ is not acceptable for url ⌜${url}⌝."
    if [[ ${failOnError} == "true" ]]; then
      core::fail "${message}"
    fi
    log::debug "${message}"
  fi

  REPLY="${path}"
  REPLY2="${errors}"
  REPLY3="${httpStatusCode}"
  # shellcheck disable=SC2034
  REPLY_CODE="${exitCode}"
  return 0
}

# ## curl::request
#
# This function is a wrapper around curl to save the content of a request in a variable.
# It allows you to check the http status code and return 1 if it is not acceptable.
# It invokes curl with the following options (do not repeat them): -sSL -w "%{response_code}" -o "tempfile".
#
# - $1: **url** _as string_:
#       The url to request
# - $@: **curl arguments** _as any_:
#       options for curl
# - ${failOnError} _as bool_:
#       true/false to indicate if the function should fail in case the execution fails
# - ${acceptableCodes} _as string_:
#       list of http status codes that are acceptable, comma separated
#       (defaults to 200,201,202,204,301,304,308 if left empty)
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the http status code is acceptable
#   - 1 otherwise
# - ${REPLY}: the content of the request
# - ${REPLY2}: the content of curl stderr
# - ${REPLY3}: the http status code
#
# ```bash
# curl::request https://example.com
# curl::request https://example.com -X POST -H 'Authorization: token' --- failOnError=true
# echo "The curl command ended with exit code ⌜${REPLY_CODE}⌝, the http return code was ⌜${REPLY2}⌝: ${REPLY}"
# ```
function curl::request() {
  local \
    url="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    failOnError=false \
    acceptableCodes="200,201,202,204,301,304,308"
  shift 1
  core::parseShellParameters "${@}"
  eval "${REPLY}"

  # reset the temporary file, only if needed
  if [[ -s "${GLOBAL_TEMPORARY_WORK_FILE}" ]]; then
    : >"${GLOBAL_TEMPORARY_WORK_FILE}"
  fi

  local -i exitCode=0
  local errors httpStatusCode
  curl::download "${url}" "$@" --- failOnError="${failOnError}" acceptableCodes="${acceptableCodes}" path="${GLOBAL_TEMPORARY_WORK_FILE}" || exitCode=$?
  errors="${REPLY2}"
  httpStatusCode="${REPLY3}"

  fs::readFile "${GLOBAL_TEMPORARY_WORK_FILE}"
  REPLY2="${errors}"
  # shellcheck disable=SC2034
  REPLY3="${httpStatusCode}"
  # shellcheck disable=SC2034
  REPLY_CODE="${exitCode}"
  return 0
}
