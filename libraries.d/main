#!/usr/bin/env bash
# Title:          libraries.d/main
# Description:    this script contains the main code for our bash programs and
#                 it should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
GLOBAL_MAIN_INCLUDED=1

# Include core if not already included
if [[ ! -v GLOBAL_CORE_INCLUDED ]]; then
  # shellcheck source=core
  source "${BASH_SOURCE[0]%/*}/core"
fi

# set different options for the shell, to have consistent behavior on all machines
core::setShellOptions

# Remember the time the program started (nb of seconds since epoch)
GLOBAL_PROGRAM_STARTED_AT_SECOND="${EPOCHREALTIME%%[.,]*}"
GLOBAL_PROGRAM_STARTED_AT_MICROSECOND="${EPOCHREALTIME##*[.,]}"

# Remember the original working directory
GLOBAL_PROGRAM_STARTED_AT_DIRECTORY="${PWD}"

# To ensure we print errors even before log::init is called
GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG="printf \"%-8s %s\n\" \"\${level:-}\" \"\${!messageVariableName}\" 1>&2"
GLOBAL_LOG_PRINT_STATEMENT_STANDARD="printf \"%s\" \"\${rawStringToPrintInLog}\" 1>&2"
GLOBAL_LOG_WRAP_PADDING=''
GLOBAL_LOG_DISABLE_WRAP=true

# start the profiler
if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
  # profiler will need temp files
  fs::setupTempFileGlobalVariable
  # shellcheck source=lib-profiler
  source profiler
  printf -v _PROFILER_FILE_NAME "profiler-%(%FT%H-%M-%S%z)T--PID_%06d.log" "${EPOCHSECONDS}" "${BASHPID}"
  core::getUserStateDirectory
  profiler::enable "${VALET_CONFIG_STARTUP_PROFILING_FILE:-"${RETURNED_VALUE}/logs/${_PROFILER_FILE_NAME}"}"
fi

trap::register

# Source the valet configuration from the user config dir
GLOBAL_CONFIG_FILE="${VALET_CONFIG_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}/config"}"
if [[ -f ${GLOBAL_CONFIG_FILE} ]]; then
  GLOBAL_ON_EXIT_MESSAGE="Error sourcing the configuration file ⌜${GLOBAL_CONFIG_FILE}⌝."$'\n'"Check the file for error and try again, or delete the file to discard your config."
  builtin source "${GLOBAL_CONFIG_FILE}"
  unset -v GLOBAL_ON_EXIT_MESSAGE
fi

# Source the startup file
GLOBAL_STARTUP_FILE="${VALET_STARTUP_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}/startup"}"
if [[ -f ${GLOBAL_STARTUP_FILE} ]]; then
  GLOBAL_ON_EXIT_MESSAGE="Error sourcing the startup file ⌜${GLOBAL_STARTUP_FILE}⌝."$'\n'"Check the file for error and try again, or delete the file to discard your config."
  builtin source "${GLOBAL_STARTUP_FILE}"
  unset -v GLOBAL_ON_EXIT_MESSAGE
fi

# Source the env script
if [[ ${VALET_CONFIG_DOT_ENV_SCRIPT:-} != "false" && -f ${VALET_CONFIG_DOT_ENV_SCRIPT:-.env} ]]; then
  # shellcheck disable=SC2034
  GLOBAL_ON_EXIT_MESSAGE="Error sourcing the env file ⌜${VALET_CONFIG_DOT_ENV_SCRIPT:-.env}⌝."$'\n'"Check the file for error and try again, or delete the file to discard your config."
  builtin source "${VALET_CONFIG_DOT_ENV_SCRIPT:-.env}"
  unset -v GLOBAL_ON_EXIT_MESSAGE
fi

# Setup global variables that will be used for temporary files and folders.
fs::setupTempFileGlobalVariable

core::resetIncludedFiles

# Since we use _OPTION_* variables to pass optional options to functions, we want to make sure
# to not create collisions so we unset them here.
# shellcheck disable=SC2086
unset -v ${!_OPTION_*}

# determine if we support colors (can be overridden by the user with VALET_CONFIG_ENABLE_COLORS)
case "${TERM:-}" in
xterm-color | xterm-256color | linux) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}" ;;
xterm) if [[ -n "${COLORTERM:-}" ]]; then VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}"; fi ;;
*) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-false}" ;;
esac

# set the styles and esc codes
styles::init

# fd 7 will be where we write the TUI
exec 7>&2

# Export terminal size on window resize if we are in interactive mode.
if [[ -t 7 ]]; then
  tui::getTerminalSize
  if [[ ${GLOBAL_EXPORTED_FOR_PROMPT:-} != "true" ]]; then
    # hide the cursor (we restore on exit)
    printf "%s" "${ESC__CURSOR_HIDE}" 1>&7
  fi
else
  GLOBAL_COLUMNS="${VALET_CONFIG_DEFAULT_COLUMNS:-120}"
  # shellcheck disable=SC2034
  GLOBAL_LINES="${VALET_CONFIG_DEFAULT_LINES:-30}"
fi

# make sure the file descriptor (if any) is valid
if [[ -n ${VALET_CONFIG_LOG_FD:-} ]]; then
  _CORE_VALID_FD=false
  if [[ ${VALET_CONFIG_LOG_FD} =~ ^[0-9]+$ ]]; then
    if { : >&"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
      _CORE_VALID_FD=true
    fi
  elif { : >>"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
    # it is a file
    _CORE_VALID_FD=true
  fi
  if [[ ${_CORE_VALID_FD} != "true" ]]; then
    core::fail "The file descriptor for the logs VALET_CONFIG_LOG_FD is not valid: ⌜${VALET_CONFIG_LOG_FD}⌝."
  fi
fi

# Initialize the log system
log::init

# Parsing the options from environment variables
if [[ -v VALET_LOG_LEVEL ]]; then
  log::setLevel "${VALET_LOG_LEVEL}"
fi
if [[ ${VALET_VERBOSE:-} == "true" ]]; then
  log::setLevel debug
fi
if [[ ${VALET_VERY_VERBOSE:-} == "true" ]]; then
  log::setLevel trace
fi

# Load the commands
core::sourceUserCommands

#===============================================================
# >>> Help
#===============================================================

# Prints the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) the maximum columns for the help text.
#
# ```bash
# main::printHelp function "this" "${GLOBAL_COLUMNS}"
# ```
function main::printHelp() {
  main::getHelpText "$@"
  printf '%s' "${RETURNED_VALUE}"
}

# Get the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) the maximum columns for the help text.
#
# Returns:
#
# - ${RETURNED_VALUE}: the help text
# - ${RETURNED_VALUE2}: the command usage text
#
# ```bash
# main::getHelpText function "this" "false" "${GLOBAL_COLUMNS}"
# ```
function main::getHelpText() {
  local type=${1:-function}
  local name="${2:-this}"
  local maxColumns="${3:-${GLOBAL_COLUMNS}}"

  local -i helpWidth
  helpWidth="${maxColumns}"
  if (( helpWidth > GLOBAL_COLUMNS )); then helpWidth=${GLOBAL_COLUMNS}; fi

  if [[ ${type} == "function" ]]; then
    # case of a function; we will get the description from CMD_ vars directly
    functionName="${name}"
  else
    # case of a menu; we will the sub commands for it
    functionName="_menu"
    # shellcheck disable=SC2034
    CMD_COMMAND__menu="${name}"
    CMD_COMMANDS_NAME__menu=()
    CMD_COMMANDS_DESCRIPTION__menu=()
    local index subCommand
    for index in "${!CMD_COMMANDS_NAME_this[@]}"; do
      local subCommand="${CMD_COMMANDS_NAME_this[${index}]}"
      if [[ "${subCommand}" != "${name} "* ]]; then continue; fi
      CMD_COMMANDS_NAME__menu+=("${subCommand}")
      CMD_COMMANDS_DESCRIPTION__menu+=("${CMD_COMMANDS_DESCRIPTION_this[${index}]}")
    done
  fi

  local -n command="CMD_COMMAND_${functionName}"
  local -n description="CMD_DESCRIPTION_${functionName}"
  local -n functionOptions="CMD_OPTIONS_NAME_${functionName}"
  local -n functionArguments="CMD_ARGUMENTS_NAME_${functionName}"
  local -n functionCommands="CMD_COMMANDS_NAME_${functionName}"
  local -n functionExamples="CMD_EXAMPLES_NAME_${functionName}"

  # description
  string::wrapWords description "${helpWidth}" "  " "$((helpWidth - 2))"
  local wrappedDescription="  ${RETURNED_VALUE}"

  # usage
  local usage
  if [[ ${functionName} == "this" ]]; then
    usage="valet"
  else
    usage="valet ${STYLE_HELP_OPTION}[global options]${STYLE_RESET} ${command}"
  fi
  if [[ -n ${functionOptions:-} ]]; then
    if [[ ${functionName} == "this" ]]; then
      usage+=" ${STYLE_HELP_OPTION}[global options]${STYLE_RESET}"
    else
      usage+=" ${STYLE_HELP_OPTION}[options]${STYLE_RESET}"
    fi
  fi
  if [[ -n ${functionCommands:-} ]]; then
    usage+=" ${STYLE_HELP_COMMAND}[command]${STYLE_RESET}"
  else
    if [[ -n ${functionArguments:-} ]]; then
      usage+=" [--]"
      for argument in "${functionArguments[@]}"; do
        if [[ ${argument} == *\?* ]]; then
          usage+=" ${STYLE_HELP_ARGUMENT}[${argument//\?/}]${STYLE_RESET}"
        else
          usage+=" ${STYLE_HELP_ARGUMENT}<${argument}>${STYLE_RESET}"
        fi
      done
    fi
  fi
  RETURNED_VALUE2="${usage}"
  string::wrapWords usage "${helpWidth}" "  " "$((helpWidth - 2))"
  usage="  ${RETURNED_VALUE}"

  # global options
  local options="${STYLE_HELP_TITLE}GLOBAL OPTIONS${STYLE_RESET}"$'\n'$'\n'
  mainWriteAsTable "${helpWidth}" "${STYLE_HELP_OPTION}" "CMD_OPTIONS" "this"
  options+="${RETURNED_VALUE}"$'\n'

  # options
  if [[ ${functionName} != "this" ]]; then
    if [[ -n ${functionOptions:-} ]]; then
      options+="${STYLE_HELP_TITLE}OPTIONS${STYLE_RESET}"$'\n'$'\n'
      mainWriteAsTable "${helpWidth}" "${STYLE_HELP_OPTION}" "CMD_OPTIONS" "${functionName}"
      options+="${RETURNED_VALUE}"$'\n'
    fi
  fi

  # arguments
  local arguments
  if [[ -z ${functionCommands:-} && -n ${functionArguments:-} ]]; then
    arguments="${STYLE_HELP_TITLE}ARGUMENTS${STYLE_RESET}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${STYLE_HELP_ARGUMENT}" "CMD_ARGUMENTS" "${functionName}"
    arguments+="${RETURNED_VALUE}"$'\n'
  fi

  # commands
  local commands
  if [[ -n ${functionCommands:-} ]]; then
    commands="${STYLE_HELP_TITLE}COMMANDS${STYLE_RESET}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${STYLE_HELP_COMMAND}" "CMD_COMMANDS" "${functionName}"
    commands+="${RETURNED_VALUE}"$'\n'
  fi

  # examples
  local examples
  if [[ -n ${functionExamples:-} ]]; then
    examples="${STYLE_HELP_TITLE}EXAMPLES${STYLE_RESET}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${STYLE_HELP_COMMAND}" "CMD_EXAMPLES" "${functionName}"
    examples+="${RETURNED_VALUE}"$'\n'
  fi

  local output="${STYLE_HELP_TITLE}ABOUT${STYLE_RESET}

${wrappedDescription}

${STYLE_HELP_TITLE}USAGE${STYLE_RESET}

${usage}

${options:-}${arguments:-}${commands:-}${examples:-}"

  # surround "markdown like" _italic_ with italic color
  if [[ -n ${STYLE_HELP_HIGHLIGHT} ]]; then
    output="${output//⌜/${STYLE_HELP_HIGHLIGHT}⌜}"
    output="${output//⌝/⌝${STYLE_RESET}}"
  fi

  RETURNED_VALUE="${output}"
}

# used in show help to write a table of options, commands, arguments...
# transform text1\ttext2 to:
#   text1
#           text2
# text1 can be showed in color and we respect a maximum width
function mainWriteAsTable() {
  local width="${1}"
  local color="${2}"
  local prefix="${3}"
  local functionName="${4}"

  local -n names="${prefix}_NAME_${functionName}"
  local -n descriptions="${prefix}_DESCRIPTION_${functionName}"
  local output index

  output=""
  for index in "${!names[@]}"; do
    string::wrapWords "names[${index}]" "${width}" "  " "$((width - 2))"
    output+="  ${color}${RETURNED_VALUE}${STYLE_RESET:-}"$'\n'

    string::wrapWords "descriptions[${index}]" "${width}" "      " "$((width - 6))"
    output+="      ${RETURNED_VALUE}"$'\n'
  done

  RETURNED_VALUE="${output}"
}


#===============================================================
# >>> Main functions
#===============================================================

# parse the user arguments for the main program.
function main::parseMainArguments() {
  _PARSED_COMMANDS=()
  _PARSED_COMMAND_ARGS=()

  # for the main command, we parse the arguments manually
  # this is for performance reasons, we want to stop parsing as soon as possible
  while (( $# > 0 )); do
    if [[ ${#_PARSED_COMMANDS[@]} -gt 0 && "${1}" == "-"* ]]; then
      # we matched the commands and we found an option for the sub command
      break
    fi
    main::parseMainArgumentsSwitch "$@"
    if (( RETURNED_VALUE < 0 )); then
      break;
    elif (( RETURNED_VALUE > 0 )); then
      shift "${RETURNED_VALUE}"
    fi
    shift
  done

  log::trace "Command found ⌜${_PARSED_COMMANDS[*]}⌝."

  if (( ${#_PARSED_COMMANDS[@]} == 0 )); then
    # no command provided, we show the commands menu

    if [[ ${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3} -eq 0 ]]; then
      # if the user does not want to remember the last choices
      main::showCommandsMenuAndRun "main-menu" CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY
    else
      _COPIED_COMMANDS_ARRAY=("${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}")
      main::showCommandsMenuAndRun "main-menu" _COPIED_COMMANDS_ARRAY
    fi

    return 0
  fi

  local functionName nbArgs exactCommand
  main::fuzzyMatchCommandToFunctionNameOrFail "${_PARSED_COMMANDS[@]}"
  functionName="${RETURNED_VALUE:-}"
  nbArgs="${RETURNED_VALUE2:-}"
  exactCommand="${RETURNED_VALUE3:-}"

  log::trace "Function name found ⌜${functionName}⌝."

  if [[ ${functionName} == "_menu" ]]; then
    # run a menu with the list of sub commands
    main::runMenuWithSubCommands "${exactCommand}" "${_PARSED_COMMAND_ARGS[@]:nbArgs}"
  else
    # run the function without the matched commands in the arguments
    main::runFunction "${functionName}" "${_PARSED_COMMAND_ARGS[@]:nbArgs}"
  fi

  return 0
}

function main::parseMainArgumentsSwitch() {
  case "${1}" in
  --source)
    echo "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/core"
    exit 0
    ;;
  -x | --profiling)
    VALET_PROFILING=true
    ;;
  -l | --log | --log-level)
    if (( $# <= 1 )); then core::fail "Missing value for option ⌜${1}⌝."; fi
    shift
    log::setLevel "${1}"
    RETURNED_VALUE=1
    return 0
    ;;
  -v | --verbose)
    log::setLevel debug
    ;;
  -w | --very-verbose)
    log::setLevel trace
    ;;
  -a | --alternative-log)
    _OPTION_LOG_PATTERN="${VALET_CONFIG_LOG_PATTERN_ALTERNATIVE:-"<colorFaded><elapsedTime>{8s} (+<elapsedTimeSinceLastLog>{7s}) [<pid>{05s}:<subshell>{1s}] <sourceFile>{15s}:<line>{-4s}<levelColor><level>{7s}<colorDefault> <message>"}" log::init
    ;;
  -i | --force-interactive-mode)
    VALET_FORCE_INTERACTIVE_MODE=true
    ;;
  --disable-progress-bars)
    # shellcheck disable=SC2034
    VALET_DISABLE_PROGRESS_BARS=true
    ;;
  --version)
    core::getVersion
    printf '%s\n' "${RETURNED_VALUE}"
    exit 0
    ;;
  -h | --help)
    main::printHelp function "this"
    exit 0
    ;;
  --)
    RETURNED_VALUE=-1
    return 0
    ;;
  --*)
    # if we didn't match any known long option, try to fuzzy find it
    main::fuzzyFindOption "${1}" "${CMD_OPTS_this[@]}"

    if [[ -n ${RETURNED_VALUE2} ]]; then
      # we found a single match! need to parse it
      main::parseMainArgumentsSwitch "${RETURNED_VALUE2}" "${@:2}"
      return 0
    else
      # we found multiple matches or no match
      core::fail "${RETURNED_VALUE}"
    fi
    ;;
  -*)
    # a single dash and single letter, we don't have a match
    if (( ${#1} <= 2 )); then
      main::getSingleLetterOptions "${CMD_OPTS_this[@]}"
      core::fail "Unknown option letter ⌜${optionLetter}⌝ in group ⌜${1}⌝. ${RETURNED_VALUE}"
    fi

    # many letters, we can resolve each letter as an option
    local -i letterIndex optionLength=${#1}
    local optionLetter
    local -i argsToShift=0
    for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
      optionLetter="${1:letterIndex:1}"
      main::parseMainArgumentsSwitch "-${optionLetter}" "${@:2 + argsToShift}"
      if (( RETURNED_VALUE > 0 )); then
        argsToShift+=RETURNED_VALUE
      fi
    done
    RETURNED_VALUE=${argsToShift}
    return 0
    ;;
  *)
    _PARSED_COMMANDS+=("${1}")
    # we don't expect more than CMD_MAX_SUB_COMMAND_LEVEL + 1 commands so if we matched enough, break
    if (( ${#_PARSED_COMMANDS[@]} >= CMD_MAX_SUB_COMMAND_LEVEL + 1 )); then
      RETURNED_VALUE=-1
      return 0
    fi
    # if we matched the first command, we can extract the arguments for the sub command
    if [[ "${#_PARSED_COMMANDS[@]}" -eq "1" ]]; then
      _PARSED_COMMAND_ARGS=("$@")
    fi
    ;;
  esac
  RETURNED_VALUE=0
}

# Run a given function
# The first arguments should be the function name,
# the rest of the arguments are the user arguments starting
# from the command name. e.g.:
# sub cmd --opt1 arg1 arg2
#
# $1: the function name
# $2+: the user arguments
function main::runFunction() {
  local functionName
  functionName="${1}"
  shift

  if [[ -z ${functionName} ]]; then
    core::fail "No function name provided."
  fi

  # get command name of the function
  local -n command="CMD_COMMAND_${functionName}"

  # check for sudo if the function requires it
  local -n requiresSudo="CMD_SUDO_${functionName}"
  if [[ ${requiresSudo:-} == "true" ]]; then
    main::checkSudo
  fi

  # source the file in which the function is located if needed
  command::sourceFunction "${functionName}"

  if ! declare -F "${functionName}" 1>/dev/null 2>&1; then
    core::fail "The function ⌜${functionName}⌝ associated with the command ⌜${command}⌝ does not exist."
  fi

  local IFS=' '
  log::debug "Running the command ⌜${command}⌝ with the function ⌜${functionName}⌝ and the arguments ⌜$*⌝."

  # disable startup profile and enable command profile, if needed
  if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi
  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    # shellcheck source=lib-profiler
    source profiler
    local profilerFileName
    printf -v profilerFileName "profiler-%(%FT%H-%M-%S%z)T--PID_%06d--fun_%s.log" "${EPOCHSECONDS}" "${BASHPID}" "${functionName}"
    core::getUserStateDirectory
    profiler::enable "${VALET_CONFIG_COMMAND_PROFILING_FILE:-"${RETURNED_VALUE}/logs/${profilerFileName}"}"
  fi

  # reset IFS to ensure consistent behavior
  IFS=' '$'\t'$'\n'

  # execute the function
  "${functionName}" "$@"

  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi

  return 0
}

# This function checks if the user has sudo privileges.
# If the user has sudo, it will set the SUDO variable to "sudo".
# If the user does not have sudo, it will set the SUDO variable to "".
#
# Usage:
#  main::checkSudo
function main::checkSudo() {
  # sudo
  if command -v sudo 1>/dev/null 2>&1; then
    log::info "This command requires sudo privileges."
    SUDO="sudo"
    ${SUDO} printf '%s' "alright" 1>/dev/null || core::fail "Could not sudo but the command requires it."
  else
    SUDO=""
  fi
}

# Run the a command that has sub command:
# - either show an interactive menu for a command that has sub commands,
# - or display the help for this menu.
#
# $1: the command name
#
# Usage:
#   main::runMenuWithSubCommands "command"
function main::runMenuWithSubCommands() {
  local command="${1}"
  shift

  # export the command name for the menu
  # shellcheck disable=SC2034
  CMD_COMMAND__menu="${command}"

  local parsedArguments
  command::parseFunctionArguments "_menu" "$@"
  parsedArguments="${RETURNED_VALUE}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi
  eval "${parsedArguments}"

  if [[ -n ${help:-} ]]; then
    main::printHelp menu "${command}"
    return 0
  fi

  if [[ -n ${commandArgumentsErrors:-} ]]; then
    core::fail "${commandArgumentsErrors}"
  fi

  # filter the commands to only keep the sub commands of the function
  local line
  declare -g -a FILTERED_COMMANDS_FOR_SUB_MENU=()
  for line in "${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}"; do
    if [[ ${line} =~ ^(${command} [^ ]+ ) ]]; then
      FILTERED_COMMANDS_FOR_SUB_MENU+=("${line}")
    fi
  done

  if (( ${#FILTERED_COMMANDS_FOR_SUB_MENU[@]} == 0 )); then
    core::fail "No sub commands found for ⌜${command}⌝."
  fi

  main::showCommandsMenuAndRun "${command//[^[:alnum:]]/_}" FILTERED_COMMANDS_FOR_SUB_MENU
}

# Show the given commands in an interactive menu and then
# run the selected command if any.
# $1: the menu id
# $2: the command selection items array name
function main::showCommandsMenuAndRun() {
  local menuId commandSelectionItemsArrayName
  menuId="${1}"
  commandSelectionItemsArrayName="${2}"

  # sort the commands according to the last choices
  main::sortCommands "${menuId}" "${commandSelectionItemsArrayName}"

  local commandChoice
  main::showInteractiveCommandsMenu "Please select the command to run." "${commandSelectionItemsArrayName}"
  commandChoice="${RETURNED_VALUE}"

  log::trace "Command choice ⌜${commandChoice}⌝."

  if [[ -z ${commandChoice} ]]; then
    # the user pressed escape or ctrl-c
    return 0
  fi

  main::addLastChoice "${menuId}" "${commandChoice}"

  # get the function name from the command by replacing spaces and hyphens with _
  local functionName
  main::getFunctionNameFromCommand "${commandChoice}"
  functionName="${RETURNED_VALUE}"

  main::runFunction "${functionName}"
}

# This function sorts the commands in the menu by reading
# a file that contains the last used commands (last on top).
# The file is located in the configuration directory of the program.
# $1: the id of the menu (used in the file name)
# $2: the menu body
#
# Usage:
#  main::sortCommands "id" "${commands}" && sortedCommands="${RETURNED_VALUE}"
function main::sortCommands() {
  local menuId="${1}"
  local -n commands="${2}"

  # if the user does not want to remember the last choices, we return
  if [[ "${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}" -eq 0 ]]; then
    return 0
  fi

  local lastChoicesFile
  core::getUserDataDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ ! -f "${lastChoicesFile}" ]]; then
    return 0
  fi

  local lastChoices
  readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"

  local -a unplayedCommands=()
  local -a playedCommands=()

  # list all the unplayed commands
  local unplayedCommands line command lastChoice played
  local -a commandsArray
  for line in "${commands[@]}"; do
    command="${line%%  *}"
    # check if the command has not been played yet
    played=false
    for lastChoice in "${lastChoices[@]}"; do
      if [[ ${lastChoice} == "${command}" ]]; then
        played=true
        break
      fi
    done
    # if not played, add it to the list
    if [[ ${played} == "false" ]]; then
      unplayedCommands+=("${line}")
    fi
    commandsArray+=("${line}")
  done

  # list all the played commands
  local playedCommands
  for lastChoice in "${lastChoices[@]}"; do
    # find the corresponding line in the commands, if any
    for line in "${commandsArray[@]}"; do
      command="${line%%  *}"
      if [[ ${command} == "${lastChoice}" ]]; then
        playedCommands+=("${line}")
        break
      fi
    done
  done

  commands=("${playedCommands[@]}")
  commands+=("${unplayedCommands[@]}")
}

# This function adds the user command choice to the last choices file.
# It allows to sort the commands in the menu by the last used commands.
# $1: the id of the menu (used in the file name)
# $2: the command to add
#
# Usage:
#  main::addLastChoice "id" "command"
function main::addLastChoice() {
  local menuId command
  menuId="${1}"
  command="${2}"

  local maxNumberOfLastChoice=${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}

  # if the user does not want to remember the last choices, we return
  if [[ "${maxNumberOfLastChoice}" -eq 0 ]]; then
    return 0
  fi

  # load last choices from the file into an array
  local lastChoicesFile
  local -a lastChoices
  core::getUserDataDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ -f "${lastChoicesFile}" ]]; then
    readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"
  else
    lastChoices=()
  fi

  {
    # write the command first
    printf '%s\n' "${command}"

    # loop through the last choices and add them to the file, limit to 20 total
    local -i total index
    total="${#lastChoices[@]}"
    if [[ total -gt maxNumberOfLastChoice ]]; then total=$((maxNumberOfLastChoice - 1)); fi
    index=0
    for ((index = 0; index < total; index++)); do
      if [[ "${lastChoices[${index}]}" != "${command}" ]]; then
        printf '%s\n' "${lastChoices[${index}]}"
      else
        total+=1
        if [[ total -gt ${#lastChoices[@]} ]]; then total=${#lastChoices[@]}; fi
      fi
    done
  } >"${lastChoicesFile}"
}

# show an interactive menu for commands
# returns the selected command in standard output
# $1: the menu id
# $2: the menu header
# $3: the menu items array name (reference)
#
# Usage:
#  main::showInteractiveCommandsMenu "menuId" "header" ARRAY_NAME && choice="${RETURNED_VALUE}"
function main::showInteractiveCommandsMenu() {
  local menuHeader commandSelectionItemsArrayName
  menuHeader="${1}"
  commandSelectionItemsArrayName="${2}"

  # shellcheck source=lib-sfzf
  source sfzf

  sfzf::show "${menuHeader}" "${commandSelectionItemsArrayName}" "main::onFsfsItemSelectionChange" "Command help"

  choice="${RETURNED_VALUE}"
  if (( ${#choice} >= CMD_MAX_COMMAND_WIDTH)); then
    choice="${choice:0:CMD_MAX_COMMAND_WIDTH}  "
    choice="${choice%%  *}"
  else
    choice=""
  fi

  RETURNED_VALUE="${choice}"
}

function main::onFsfsItemSelectionChange() {
  local item="$1"
  local command="${item:0:CMD_MAX_COMMAND_WIDTH}  "
  command="${command%%  *}"
  main::getFunctionNameFromCommand "${command}"
  main::getHelpText function "${RETURNED_VALUE}" "${3}"
  return 0
}

#===============================================================
# >>> Find command/function from arguments
#===============================================================

# Get the function name of a command.
#
# Usage:
#  main::getFunctionNameFromCommand "self build" && printf '%s\n' "${RETURNED_VALUE}"
function main::getFunctionNameFromCommand() {
  local -n functionName="CMD_FUNCTION_NAME_${1//[^[:alnum:]]/_}"
  RETURNED_VALUE="${functionName:-}"
}

# Find the function name from arguments that represents the commands.
# If we do not find an exact match, we return try to fuzzy find the command
# and then return its function name.
#
# This function will fail with an error if the command does not match
# any function or if the command is ambiguous.
#
# - $@: the commands to find
#
# Returns:
#
# - ${RETURNED_VALUE}: The function name.
# - ${RETURNED_VALUE2}: The level of the command.
# - ${RETURNED_VALUE3}: The exact command.
#
# ```bash
# main::fuzzyMatchCommandToFunctionNameOrFail "self" "build" && printf '%s\n' "${RETURNED_VALUE}"
# ```
function main::fuzzyMatchCommandToFunctionNameOrFail() {
  if [[ $# -eq 0 ]]; then
    return 0
  fi

  # ignore case
  shopt -s nocasematch

  main::getMaxPossibleCommandLevel "$@"
  local level="${RETURNED_VALUE}"

  local IFS=" "

  # we put the arguments into an array so we can interpret 'my' 'sub'
  # and 'my sub' as the same command (we split everything by space)
  local -a commandArray
  # shellcheck disable=SC2206
  commandArray=($*)

  local loopI functionName command exactCommand
  for ((loopI = level; loopI >= 1; loopI--)); do
    command="${commandArray[*]:0:loopI}"

    # case where the command is exact, we can match the function immediately
    main::getFunctionNameFromCommand "${command}" && functionName="${RETURNED_VALUE}"
    if [[ -n ${functionName:-} ]]; then
      exactCommand="${command}"
      break
    fi

    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      continue
    fi

    # case where the command is not exact, we try to fuzzy match it
    array::fuzzyFilterSort CMD_ALL_COMMANDS_ARRAY command
    if (( ${#RETURNED_ARRAY[@]} > 1)); then
        # case of ambiguous command, show the list of possible commands
        main::getDisplayableFilteredArray RETURNED_ARRAY command
        core::fail "Found multiple matches for the command ⌜${command}⌝, please be more specific:"$'\n'"${RETURNED_VALUE}"
    elif (( ${#RETURNED_ARRAY[@]} == 1 )); then
      # case of a single match, we can match the function immediately
      exactCommand="${RETURNED_ARRAY[0]}"
      main::getFunctionNameFromCommand "${exactCommand}" && functionName="${RETURNED_VALUE}"
      log::info "Fuzzy matching the command ⌜${command}⌝ to ⌜${exactCommand}⌝."
      break
    fi
  done

  if [[ -z ${functionName:-} ]]; then
    local messageDetails
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      messageDetails="an exact command"
    else
      messageDetails="a matching command"
    fi
    core::fail "Could not find ${messageDetails} for ⌜${command}⌝, use ⌜--help⌝ to get a list of valid commands."
  fi

  shopt -u nocasematch

  RETURNED_VALUE="${functionName:-}"
  RETURNED_VALUE2="${loopI}"
  RETURNED_VALUE3="${exactCommand:-}"
}

# Return the maximum level of subcommands
# if in valet with have at max 2 level of commands
# e.g. cmd subcmd
# then there is no need to try to match a command with 5 arguments
# Same thing, if we provide only 1 argument to the cli, we
# can only match a simple command
# $@: the arguments
#
# Usage:
#  main::getMaxPossibleCommandLevel "cmd1" "subcmd2" "subsubcmd3" && level="${RETURNED_VALUE}"
function main::getMaxPossibleCommandLevel() {
  local level maxLevel
  local IFS=' '
  level=0
  # shellcheck disable=SC2048
  for _ in ${*}; do
    level=$((level + 1))
  done
  maxLevel=$((CMD_MAX_SUB_COMMAND_LEVEL + 1))
  if (( level > CMD_MAX_SUB_COMMAND_LEVEL + 1 )); then
    level="${maxLevel}"
  fi
  RETURNED_VALUE="${level}"
}

#===============================================================
# >>> Parsers
#===============================================================

# Parses the arguments and options of a function.
# Usage:
#  command::parseFunctionArguments "functionName" "$@" && eval "${RETURNED_VALUE}"
#
# Notes:
# - It will return a string that can be evaluated to set the variables
#   corresponding to the arguments and options; e.g.:
#     "local arg1 option1
#     arg1=\"\"
#     option1=\"\"
#     ..."
# - It will also set the variable commandArgumentsErrors if there are any errors.
# - Variable name for an option is taken from the first --long version of the option.
# - It will set the variable as an array if the (last) argument name ends with '...'
function command::parseFunctionArguments() {
  local functionName
  functionName="${1}"
  shift

  local IFS=$' '

  local -n argumentsName="CMD_ARGS_NAME_${functionName}"
  local -i totalNbArguments
  if [[ -v argumentsName && ${#argumentsName[@]} -gt 0 ]]; then
    totalNbArguments=${#argumentsName[@]};
  else
    totalNbArguments=0;
  fi
  local -n isLastArgumentAnArray="CMD_ARGS_LAST_IS_ARRAY_${functionName}"
  local -n nbOptionalArgsStr="CMD_ARGS_NB_OPTIONAL_${functionName}"
  local -i nbOptionalArgs="${nbOptionalArgsStr:-0}"
  if [[ -z ${isLastArgumentAnArray:-} ]]; then isLastArgumentAnArray=false; fi
  local -i argumentPosition=0

  # shellcheck disable=SC2178
  local -n options="CMD_OPTS_${functionName}"
  local -i totalNbOptions
  if [[ -v options && ${#options[@]} -gt 0 ]]; then
    totalNbOptions=${#options[@]};
  else
    totalNbOptions=0;
  fi
  # shellcheck disable=SC2034
  local -n optionsHasValue="CMD_OPTS_HAS_VALUE_${functionName}"
  local -n optionsName="CMD_OPTS_NAME_${functionName}"
  local -n optionsNameSc="CMD_OPTS_NAME_SC_${functionName}"
  local -n optionsDefault="CMD_OPTS_DEFAULT_${functionName}"

  # shortcut if the function expect no arguments and no options
  if [[ totalNbArguments -eq 0 && totalNbOptions -eq 0 ]]; then
    RETURNED_VALUE=""
    return 0
  fi

  local -a lastArgumentValues=()
  local -a outputErrors=()
  local -a outputSetLine
  local -a matchedOptionsIndex

  local badArguments=false

  # we define reusable pieces of code that will be used to parse the options
  # shellcheck disable=SC2016
  local optionFinder='
  # we are matching an option
  # try to match the argument with one of the option name
  if [[ totalNbOptions -gt 0 ]]; then
    for optionIndex in "${!options[@]}"; do
      for option in ${options[${optionIndex}]}; do
        if [[ ${option} == "${1}" ]]; then
          matchedIndex="${optionIndex}"
          break 2
        fi
      done
    done
  fi

  if [[ matchedIndex -ne -1 ]]; then
    # its a match!
    optionValue="${optionsHasValue[${matchedIndex}]:-}"
    optionName="${optionsName[${matchedIndex}]}"
    matchedOptionsIndex+=("${matchedIndex}")
  fi
  '

  # shellcheck disable=SC2016
  local registerOption='
  if [[ ${optionValue} == "true" ]]; then
    if (( $# == 1 )); then
      outputErrors+=("Missing value for option ⌜${optionName}⌝.")
    else
      shift
      outputSetLine+=("${optionName}=\"${1//\"/\\\"}\"")
    fi
  else
    outputSetLine+=("${optionName}=\"true\"")
  fi
  '

  # parse each arguments
  local -i optionIndex matchedIndex optionLength letterIndex
  # shellcheck disable=SC2034
  local optionValue
  local option startedArguments optionName argumentName optionLetter optionLetters
  startedArguments="false"
  while (( $# > 0 )); do

    if [[ ${1} == "-"* && ${startedArguments} != "true" ]]; then
      # we are matching an option, try to find the option index
      matchedIndex=-1
      eval "${optionFinder}"

      if [[ matchedIndex -ne -1 ]]; then
        # it's a match! register the option
        eval "${registerOption}"

      elif [[ ${1} == "--" ]]; then
        # if we have -- we stop parsing options
        startedArguments="true"

      elif [[ ${1} == "--"* ]]; then
        # if we didn't match any known long option, try to fuzzy find it
        main::fuzzyFindOption "${1}" "${options[@]}"

        if [[ -n ${RETURNED_VALUE2} ]]; then
          # we found a single match!
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"${RETURNED_VALUE2}"}"
          eval "${registerOption}"
        else
          # we found multiple matches or no match
          outputErrors+=("${RETURNED_VALUE}")
        fi

      else
        # a single dash, we can resolve each letter as an option
        optionLetters="${1}"
        optionLength=${#optionLetters}
        for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
          optionLetter="${optionLetters:letterIndex:1}"
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"-${optionLetter}"}"
          if [[ matchedIndex -ne -1 ]]; then
            eval "${registerOption}"
          else
            main::getSingleLetterOptions "${options[@]}"
            outputErrors+=("Unknown option letter ⌜${optionLetter}⌝ in group ⌜${optionLetters}⌝. ${RETURNED_VALUE}")
          fi
        done

      fi

    else
      # we are matching an argument

      if [[ argumentPosition -ge totalNbArguments ]]; then
        outputErrors+=("Expecting ${totalNbArguments} argument(s), got extra argument ⌜${1}⌝.")
        badArguments=true
      else
        argumentName="${argumentsName[${argumentPosition}]}"

        if [[ argumentPosition -eq $((totalNbArguments - 1)) && "${isLastArgumentAnArray}" = "true" ]]; then
          # if the arg ends with ... we expect an infinite amount of arguments
          lastArgumentValues+=("${1}")
        else
          argumentPosition+=1
          outputSetLine+=("${argumentName}=\"${1//\"/\\\"}\"")
        fi

      fi
    fi

    if (( $# > 0 )); then
      shift
    fi
  done

  # increase argument position if the last arg is an array because we don't do it in the loop
  if [[ ${#lastArgumentValues[@]} -gt 0 ]]; then
    argumentPosition=$((argumentPosition + 1))
  fi

  # check if we have missing arguments
  local -i nbExpectedArgs=$((totalNbArguments - nbOptionalArgs))
  if [[ argumentPosition -lt nbExpectedArgs ]]; then
    outputErrors+=("Expecting ⌜${nbExpectedArgs}⌝ argument(s) but got ⌜${argumentPosition}⌝.")
    badArguments=true
  fi

  if (( ${#outputErrors[@]} > 0 )); then
    local -n command="CMD_COMMAND_${functionName}"
    outputErrors+=("Use ⌜valet ${command} --help⌝ to get help.")
    if [[ ${badArguments} == "true" ]]; then
      main::getHelpText function "${functionName}"
      outputErrors+=($'\n'"Usage:"$'\n'"${RETURNED_VALUE2}")
    fi
  fi


  local outputString

  # define all the possible local variables for options and arguments
  local option argumentIndex nbScalarArguments
  outputString="local commandArgumentsErrors"
  for option in "${optionsName[@]}"; do
    outputString+=" ${option}"
  done
  nbScalarArguments="${totalNbArguments}"
  if [[ ${isLastArgumentAnArray} == "true" ]]; then nbScalarArguments=$((nbScalarArguments - 1)); fi
  for ((argumentIndex = 0; argumentIndex < nbScalarArguments; argumentIndex++)); do
    outputString+=" ${argumentsName[${argumentIndex}]}"
  done
  outputString+=$'\n'
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    outputString+="local -a ${argumentsName[${nbScalarArguments}]}"$'\n'
  fi

  # assign all unmatched options to the corresponding global variable
  local optionIndex optionName optionMatched matchedIndex optionNameSc optionDefault
  for optionIndex in "${!options[@]}"; do
    optionMatched="false"
    for matchedIndex in "${matchedOptionsIndex[@]}"; do
      if [[ ${optionIndex} == "${matchedIndex}" ]]; then
        optionMatched="true"
        break
      fi
    done
    if [[ ${optionMatched} == "false" ]]; then
      # shellcheck disable=SC2034
      optionName="${optionsName[${optionIndex}]}"
      optionNameSc="${optionsNameSc[${optionIndex}]:-}"
      optionDefault="${optionsDefault[${optionIndex}]:-}"
      if [[ -n ${optionNameSc} ]]; then
        if [[ -n ${optionDefault} ]]; then
          optionDefault="\"${optionDefault}\""
        fi
        outputString+="${optionsName[${optionIndex}]}=\"\${${optionNameSc}:-${optionDefault}}\""$'\n'
      else
        outputString+="${optionsName[${optionIndex}]}=\"${optionDefault}\""$'\n'
      fi
    fi
  done

  # output the parsing errors
  local -i outputErrorIndex
  outputString+="commandArgumentsErrors=\""
  for outputErrorIndex in "${!outputErrors[@]}"; do
    if [[ outputErrorIndex -gt 0 ]]; then
      outputString+=$'\n'
    fi
    outputString+="${outputErrors[${outputErrorIndex}]}"
  done
  outputString+="\""$'\n'

  # output the matched arguments/options values
  local outputSet
  for outputSet in "${outputSetLine[@]}"; do
    outputString+="${outputSet}"$'\n'
  done

  # output the last argument values
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    local lastArgumentValue
    outputString+="${argumentsName[${nbScalarArguments}]}=("$'\n'
    for lastArgumentValue in "${lastArgumentValues[@]}"; do
      outputString+="\"${lastArgumentValue//\"/\\\"}\""$'\n'
    done
    outputString+=")"
  fi

  RETURNED_VALUE="${outputString}"
}

# Tries to find a match for an inexact option.
# If the strict matching is enabled, we will only suggest a fix (if we find a match).
# If strict matching is disabled and we have found a single match, we can return it.
#
# - $1: the user string to match
# - $2+: list of options to match against
#
# Returns:
#
# - ${RETURNED_VALUE}: An error message with the suggested option(s).
# - ${RETURNED_VALUE2}: The single matched option that we can use.
#
# ```bash
# main::fuzzyFindOption opt1 option1 option2 option3 && fuzzyOption="${RETURNED_VALUE}"
# ```
function main::fuzzyFindOption() {
  local unknownOption suggestedOption
  unknownOption="${1}"
  shift
  # shellcheck disable=SC2206
  local IFS=$' '
  # shellcheck disable=SC2206
  _OPTIONS_TO_MATCH=($*)

  local singleMatchedOption
  IFS=$'\n'

  # ignore case
  shopt -s nocasematch

  # split to get one possible option per line
  array::fuzzyFilterSort _OPTIONS_TO_MATCH unknownOption
  if (( ${#RETURNED_ARRAY[@]} == 1 )); then
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, did you mean ⌜${RETURNED_ARRAY[0]}⌝?"
    else
      log::info "Fuzzy matching the option ⌜${unknownOption}⌝ to ⌜${RETURNED_ARRAY[0]}⌝."
      singleMatchedOption="${RETURNED_ARRAY[0]}"
    fi
  elif (( ${#RETURNED_ARRAY[@]} > 1 )); then
    main::getDisplayableFilteredArray RETURNED_ARRAY unknownOption
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, valid matches are:"$'\n'"${RETURNED_VALUE}"
    else
      suggestedOption="Found multiple matches for the option ⌜${unknownOption}⌝, please be more specific:"$'\n'"${RETURNED_VALUE}"
    fi
  else
    suggestedOption="Unknown option ⌜${unknownOption}⌝, valid options are:"$'\n'"$*"
  fi

  shopt -u nocasematch

  unset _OPTIONS_TO_MATCH

  RETURNED_VALUE="${suggestedOption:-}"
  RETURNED_VALUE2="${singleMatchedOption:-}"
}

# ## main::getDisplayableFilteredArray (private)
#
# Outputs a string that displays an array where each item gets highlighted
# characters.
#
# - $1: **array** _as string:
#       The name of the global array to display.
# - $2: **characters variable name** _as string_:
#       The characters to highlight in the array items.
#
# Returns:
#
# - ${RETURNED_VALUE}: The string to display.
#
function main::getDisplayableFilteredArray() {
  # shellcheck disable=SC2178
  local -n array="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # ignore case
  shopt -s nocasematch

  local line output=""
  local IFS=$'\n'
  for line in "${array[@]}"; do
    string::highlight line "${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
    output+="${RETURNED_VALUE}"$'\n'
  done

  shopt -u nocasematch

  RETURNED_VALUE="${output}"
}

# Helps to build a message for the user to inform them
# about the valid single letter options.
#
# - $@: the options
#
# Returns:
#
# - ${RETURNED_VALUE}: The message to display to the user.
#
# ```bash
# options=("opt1" "option1" "option2" "option3")
# main::getSingleLetterOptions "${options[@]}" && message="${RETURNED_VALUE}"
# ```
function main::getSingleLetterOptions() {
  local -a options
  # shellcheck disable=SC2206
  options=($*)

  RETURNED_VALUE="Valid single letter options are: "

  for option in "${options[@]}"; do
    if [[ ${#option} -eq 2 ]]; then
      RETURNED_VALUE+="⌜${option:1:1}⌝, "
    fi
  done

  RETURNED_VALUE="${RETURNED_VALUE%, }."
}

# Parse the arguments and options of a function.
# If no arguments are provided but some are expected, it will enter interactive mode.
# See the @command::parseArguments function for more details on parsing.
#
# Usage:
#   main::parseCmdFunctionArgumentsOrGoInteractive "functionName" "$@" && eval "${RETURNED_VALUE}"
function main::parseCmdFunctionArgumentsOrGoInteractive() {
  local functionName
  functionName="${1}"
  shift

  command::parseFunctionArguments "${functionName}" "$@"
  local parsedArguments="${RETURNED_VALUE}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi

  # check if the function is expecting arguments and/or options
  local expectArguments
  local -n arguments="CMD_ARGUMENTS_NAME_${functionName}"
  if [[ -v arguments && "${#arguments[@]}" -gt 0 ]]; then
    expectArguments="true"
  fi

  if [[ ("${expectArguments:-false}" == "true" && $# -eq 0) || "${VALET_FORCE_INTERACTIVE_MODE:-false}" == "true" ]]; then
    main::goInteractive "${functionName}" "${parsedArguments}"
  fi

  RETURNED_VALUE="${parsedArguments}"
}

function main::goInteractive() {
  local functionName parsedArguments
  functionName="${1}"
  parsedArguments="${2}"

  # TODO: go interactive
  log::warning "Entering interactive mode for the function ⌜${functionName}⌝. This is not yet implemented."

  # at the end, printf '%s\n' to the user the complete command that will be run
}
