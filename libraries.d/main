#!/usr/bin/env bash
set -Eeu -o pipefail
# Title:          libraries.d/main
# Description:    this script contains the main code for our bash programs and
#                 it should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
GLOBAL_MAIN_INCLUDED=1

if [[ -z "${GLOBAL_CORE_INCLUDED:-}" ]]; then
  # shellcheck source=core
  source "${BASH_SOURCE[0]%/*}/core"
fi

#===============================================================
# >>> Event handling
#===============================================================

function main::onErrorInternal() {
  if [[ ${GLOBAL_ERROR_DISPLAYED:-0} == "1" ]]; then
    return 0
  fi
  log::error "Error code ${1} in ${FUNCNAME[1]}(), stack:"
  log::printCallStack 2
  GLOBAL_ERROR_DISPLAYED=1
}

function main::onExitInternal() {
  local rc=$?

  # disable the profiler if still on
  if [[ ${_ACTIVE_PROFILER:-} == "1" ]]; then profiler::disable; fi

  # kill coproc (spinner/progress bar...) if still running
  if [[ -n ${GLOBAL_PROGRESS_BAR_JOB_PID:-} ]]; then
    kill "${GLOBAL_PROGRESS_BAR_JOB_PID}" 1>/dev/null || :
  fi

  # restore tty settings if needed
  if command -v interactive::sttyRestore &>/dev/null; then
    interactive::sttyRestore true
  fi

  log::debug "Exiting with code ${rc} after ${SECONDS}s."
  if command -v onExitTest &>/dev/null; then
    # this is for the self test command, we need to inform the user in case of an
    # unexpected exit because they would not see the logs otherwise
    onExitTest "${rc}"
  fi
  if command -v onExit &>/dev/null; then
    onExit
  fi

  # if we ran an interactive function, make sure to restore the cursor
  if [[ -n ${AC__CURSOR_SHOW:-} ]]; then
    printf '%s' "${AC__CURSOR_SHOW}"
  fi

  # always call cleanUp before exiting
  main::onCleanUpInternal
  if [[ "${GLOBAL_ERROR_DISPLAYED:-0}" != "1" && "${rc}" != "0" ]]; then
    log::print "ERROR" "${VALET_CONFIG_ICON_EXIT:-$'\uf14c'}" "EXIT" "Exiting with code ${rc}, stack:"
    log::printCallStack 2
    GLOBAL_ERROR_DISPLAYED=1
  fi
}

function main::onInterruptInternal() {
  printf '\n' # Set cursor to the next line of '^C'
  log::print "WARNING" "${VALET_CONFIG_ICON_STOPPED:-$'\uf256'}" "STOPPED" "Program interrupted by the user."

  if log::isDebugEnabled; then
    log::debug "Is your command stuck? Consider using the ⌜-x⌝ option to activate the profiler and identify what's wrong. Here is the current stack:"
    log::printCallStack 2
  fi

  # check if the function exists
  if command -v onInterrupt &>/dev/null; then
    if onInterrupt; then
      # if onInterrupt returns 0, then we cancel the interrupt
      return 0
    fi
  fi
  exit 1
}

function main::onTerminateInternal() {
  log::print "ERROR" "${VALET_CONFIG_ICON_KILLED:-$'\uf05e'}" "KILLED" "Program killed."
  # check if the function exists
  if command -v onTerminate 1>/dev/null 2>&1; then
    if onTerminate; then
      # if onTerminate returns 0, then we cancel the termination
      return 0
    fi
  fi
  exit 1
}

function main::registerTraps() {
  trap 'main::onErrorInternal $?' ERR
  trap main::onExitInternal EXIT
  # Register CTRL+C SIGINT (interrupt) and CTRL+\ QUIT (interrupt with a coredump) event handler
  trap main::onInterruptInternal SIGINT SIGQUIT
  # Register SIGHUP (hang up, terminal disconnected) and TERM (terminate the program) event handler
  trap main::onTerminateInternal SIGHUP SIGTERM
}

main::registerTraps

function main::onCleanUpInternal() {
  io::cleanupTempFiles
  if command -v cleanUp 1>/dev/null 2>&1; then
    cleanUp
  fi
  if command -v cleanUpTest &>/dev/null; then
    cleanUpTest
  fi
}

# Introducing our own function to handle commands not found, so we can display a better message.
# The name of this function is a bash convention.
function command_not_found_handle() {
  if [[ ${1:-} == "curl" ]]; then
    core::fail "This command requires ⌜curl⌝ to make https request to the internet."$'\n'"Please install it in your path and run this command again."
  fi
  # if the command contains :: it is one of our function, we can suggest to source the 'package'
  if [[ ${1} == *::* ]]; then
    core::fail "Command not found: ⌜${1}⌝."$'\n'"Did you forget to source the package? ⌜source ${1%%::*}⌝"
  fi
  core::fail "Command not found: ⌜${1}⌝."$'\n'"Please check your ⌜PATH⌝ variable."
}

#===============================================================
# >>> Profiler
#===============================================================
if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
  # shellcheck source=lib-profiler
  source profiler
  profiler::enable "${VALET_CONFIG_STARTUP_PROFILING_FILE:-"${HOME}/valet-profiler-${BASHPID}.txt"}"
fi

#===============================================================
# >>> Help
#===============================================================

# Prints the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) whether to use colors or not (true to not use color).
# - $4: (optional) the maximum columns for the help text.
#
# ```bash
# main::printHelp function "this" "false" "${GLOBAL_COLUMNS}"
# ```
function main::printHelp() {
  main::getHelpText "$@"
  printf '%s' "${RETURNED_VALUE}"
}

# Get the help text of a function or a command.
#
# - $1: the type help to print (function or menu).
# - $2: the name of the function or the command in the case of a menu.
# - $3: (optional) whether to use colors or not (true to not use colors).
# - $4: (optional) the maximum columns for the help text.
#
# Returns:
#
# - `RETURNED_VALUE`: the help text
# - `RETURNED_VALUE2`: the command usage text
#
# ```bash
# main::getHelpText function "this" "false" "${GLOBAL_COLUMNS}"
# ```
function main::getHelpText() {
  local type=${1:-function}
  local name="${2:-this}"
  local noColor="${3:-}"
  local maxColumns="${4:-${GLOBAL_COLUMNS}}"

  if [[ -z ${noColor:-} && ${VALET_CONFIG_ENABLE_COLORS:-false} != true ]]; then
    noColor=true
  fi

  local cDefault cTitle cHighlight cOption cArgument cCommand
  if [[ ${noColor} == "true" ]]; then
    cDefault=""
    cTitle=""
    cHighlight=""
    cOption=""
    cArgument=""
    cCommand=""
  else
    cDefault=${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}
    cTitle=${VALET_CONFIG_COLOR_TITLE:-$'\e'"[0;36m"}
    cHighlight=${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[0;35m"}
    cOption=${VALET_CONFIG_COLOR_OPTION:-$'\e'"[0;33m"}
    cArgument=${VALET_CONFIG_COLOR_ARGUMENT:-$'\e'"[0;31m"}
    cCommand=${VALET_CONFIG_COLOR_COMMAND:-$'\e'"[0;32m"}
  fi

  local -i helpWidth
  helpWidth="${maxColumns}"
  if (( helpWidth > GLOBAL_COLUMNS )); then helpWidth=${GLOBAL_COLUMNS}; fi

  if [[ ${type} == "function" ]]; then
    # case of a function; we will get the description from CMD_ vars directly
    functionName="${name}"
  else
    # case of a menu; we will the sub commands for it
    functionName="_menu"
    # shellcheck disable=SC2034
    CMD_COMMAND__menu="${name}"
    CMD_COMMANDS_NAME__menu=()
    CMD_COMMANDS_DESCRIPTION__menu=()
    local index subCommand
    for index in "${!CMD_COMMANDS_NAME_this[@]}"; do
      local subCommand="${CMD_COMMANDS_NAME_this[${index}]}"
      if [[ "${subCommand}" != "${name} "* ]]; then continue; fi
      CMD_COMMANDS_NAME__menu+=("${subCommand}")
      CMD_COMMANDS_DESCRIPTION__menu+=("${CMD_COMMANDS_DESCRIPTION_this[${index}]}")
    done
  fi

  local -n command="CMD_COMMAND_${functionName}"
  local -n description="CMD_DESCRIPTION_${functionName}"
  local -n functionOptions="CMD_OPTIONS_NAME_${functionName}"
  local -n functionArguments="CMD_ARGUMENTS_NAME_${functionName}"
  local -n functionCommands="CMD_COMMANDS_NAME_${functionName}"
  local -n functionExamples="CMD_EXAMPLES_NAME_${functionName}"

  # description
  string::wrapText "${description}" "${helpWidth}" 2 "true"
  local wrappedDescription="${RETURNED_VALUE}"

  # usage
  local usage
  if [[ ${functionName} == "this" ]]; then
    usage="valet"
  else
    usage="valet ${cOption}[global options]${cDefault} ${command}"
  fi
  if [[ -n "${functionOptions:-}" ]]; then
    if [[ ${functionName} == "this" ]]; then
      usage+=" ${cOption}[global options]${cDefault}"
    else
      usage+=" ${cOption}[options]${cDefault}"
    fi
  fi
  if [[ -n "${functionCommands:-}" ]]; then
    usage+=" ${cCommand}[command]${cDefault}"
  else
    if [[ -n "${functionArguments:-}" ]]; then
      usage+=" [--]"
      for argument in "${functionArguments[@]}"; do
        if [[ ${argument} == *\?* ]]; then
          usage+=" ${cArgument}[${argument//\?/}]${cDefault}"
        else
          usage+=" ${cArgument}<${argument}>${cDefault}"
        fi
      done
    fi
  fi
  RETURNED_VALUE2="${usage}"
  string::wrapText "${usage}" "${helpWidth}" 2 "true"
  usage="${RETURNED_VALUE}"

  # global options
  local options="${cTitle}GLOBAL OPTIONS${cDefault}"$'\n'$'\n'
  mainWriteAsTable "${helpWidth}" "${cOption}" "CMD_OPTIONS" "this"
  options+="${RETURNED_VALUE}"$'\n'

  # options
  if [[ ${functionName} != "this" ]]; then
    if [[ -n "${functionOptions:-}" ]]; then
      options+="${cTitle}OPTIONS${cDefault}"$'\n'$'\n'
      mainWriteAsTable "${helpWidth}" "${cOption}" "CMD_OPTIONS" "${functionName}"
      options+="${RETURNED_VALUE}"$'\n'
    fi
  fi

  # arguments
  local arguments
  if [[ -z "${functionCommands:-}" && -n "${functionArguments:-}" ]]; then
    arguments="${cTitle}ARGUMENTS${cDefault}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${cArgument}" "CMD_ARGUMENTS" "${functionName}"
    arguments+="${RETURNED_VALUE}"$'\n'
  fi

  # commands
  local commands
  if [[ -n "${functionCommands:-}" ]]; then
    commands="${cTitle}COMMANDS${cDefault}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${cCommand}" "CMD_COMMANDS" "${functionName}"
    commands+="${RETURNED_VALUE}"$'\n'
  fi

  # examples
  local examples
  if [[ -n "${functionExamples:-}" ]]; then
    examples="${cTitle}EXAMPLES${cDefault}"$'\n'$'\n'
    mainWriteAsTable "${helpWidth}" "${cCommand}" "CMD_EXAMPLES" "${functionName}"
    examples+="${RETURNED_VALUE}"$'\n'
  fi

  local output="${cTitle}ABOUT${cDefault}

${wrappedDescription}

${cTitle}USAGE${cDefault}

${usage}

${options:-}${arguments:-}${commands:-}${examples:-}"

  # surround "markdown like" _italic_ with italic color
  if [[ ${noColor:-false} == "false" ]]; then
    output="${output//⌜/${cHighlight}⌜}"
    output="${output//⌝/⌝${cDefault}}"
  fi

  RETURNED_VALUE="${output}"
}

# used in show help to write a table of options, commands, arguments...
# transform text1\ttext2 to:
#   text1
#           text2
# text1 can be showed in color and we respect a maximum width
function mainWriteAsTable() {
  local width color prefix functionName
  width="${1}"
  color="${2}"
  prefix="${3}"
  functionName="${4}"

  local -n names="${prefix}_NAME_${functionName}"
  local -n descriptions="${prefix}_DESCRIPTION_${functionName}"

  local cDefault output description index
  if [[ -n "${color:-}" ]]; then cDefault=$'\e'"[0m"; fi

  output=""
  for index in "${!names[@]}"; do
    string::wrapText "${names[${index}]}" "${helpWidth}" 2 "true"
    output+="${color}${RETURNED_VALUE}${cDefault:-}"$'\n'

    string::wrapText "${descriptions[${index}]}" "${helpWidth}" 6 "true"
    output+="${RETURNED_VALUE}"$'\n'
  done

  RETURNED_VALUE="${output}"
}


#===============================================================
# >>> Main functions
#===============================================================

# parse the user arguments for the main program.
function main::parseMainArguments() {
  _PARSED_COMMANDS=()
  _PARSED_COMMAND_ARGS=()

  # for the main command, we parse the arguments manually
  # this is for performance reasons, we want to stop parsing as soon as possible
  while (( $# > 0 )); do
    if [[ ${#_PARSED_COMMANDS[@]} -gt 0 && "${1}" == "-"* ]]; then
      # we matched the commands and we found an option for the sub command
      break
    fi
    main::parseMainArgumentsSwitch "$@"
    if (( RETURNED_VALUE < 0 )); then
      break;
    elif (( RETURNED_VALUE > 0 )); then
      shift "${RETURNED_VALUE}"
    fi
    shift
  done

  log::debug "Command found ⌜${_PARSED_COMMANDS[*]}⌝."

  if (( ${#_PARSED_COMMANDS[@]} == 0 )); then
    # no command provided, we show the commands menu

    if [[ ${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3} -eq 0 ]]; then
      # if the user does not want to remember the last choices
      main::showCommandsMenuAndRun "main-menu" CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY
    else
      _COPIED_COMMANDS_ARRAY=("${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}")
      main::showCommandsMenuAndRun "main-menu" _COPIED_COMMANDS_ARRAY
    fi

  fi

  local functionName nbArgs exactCommand
  main::fuzzyMatchCommandToFunctionNameOrFail "${_PARSED_COMMANDS[@]}"
  functionName="${RETURNED_VALUE:-}"
  nbArgs="${RETURNED_VALUE2:-}"
  exactCommand="${RETURNED_VALUE3:-}"

  log::debug "Function name found ⌜${functionName}⌝."

  if [[ ${functionName} == "_menu" ]]; then
    # run a menu with the list of sub commands
    main::runMenuWithSubCommands "${exactCommand}" "${_PARSED_COMMAND_ARGS[@]:${nbArgs}}"
  else
    # run the function without the matched commands in the arguments
    main::runFunction "${functionName}" "${_PARSED_COMMAND_ARGS[@]:${nbArgs}}"
  fi
}

function main::parseMainArgumentsSwitch() {
  case "${1}" in
  -x | --profiling)
    VALET_PROFILING=true
    ;;
  -l | --log | --log-level)
    if (( $# <= 1 )); then core::fail "Missing value for option ⌜${1}⌝."; fi
    shift
    log::setLevel "${1}"
    RETURNED_VALUE=1
    return 0
    ;;
  -v | --verbose)
    log::setLevel debug
    ;;
  -w | --very-verbose)
    log::setLevel trace
    ;;
  --disable-progress-bars)
    VALET_DISABLE_PROGRESS_BARS=true
    ;;
  --version)
    core::getVersion
    printf '%s\n' "${RETURNED_VALUE}"
    exit 0
    ;;
  -h | --help)
    main::printHelp function "this"
    exit 0
    ;;
  --)
    RETURNED_VALUE=-1
    return 0
    ;;
  --*)
    # if we didn't match any known long option, try to fuzzy find it
    main::fuzzyFindOption "${1}" "${CMD_OPTS_this[@]}"

    if [[ -n "${RETURNED_VALUE2}" ]]; then
      # we found a single match! need to parse it
      main::parseMainArgumentsSwitch "${RETURNED_VALUE2}" "${@:2}"
      return 0
    else
      # we found multiple matches or no match
      core::fail "${RETURNED_VALUE}"
    fi
    ;;
  -*)
    # a single dash and single letter, we don't have a match
    if (( ${#1} <= 2 )); then
      main::getSingleLetterOptions "${CMD_OPTS_this[@]}"
      core::fail "Unknown option letter ⌜${optionLetter}⌝ in group ⌜${1}⌝. ${RETURNED_VALUE}"
    fi

    # many letters, we can resolve each letter as an option
    local -i letterIndex optionLength=${#1}
    local optionLetter
    local -i argsToShift=0
    for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
      optionLetter="${1:${letterIndex}:1}"
      main::parseMainArgumentsSwitch "-${optionLetter}" "${@:$(( 2 + argsToShift ))}"
      if (( RETURNED_VALUE > 0 )); then
        argsToShift+=RETURNED_VALUE
      fi
    done
    RETURNED_VALUE=${argsToShift}
    return 0
    ;;
  *)
    _PARSED_COMMANDS+=("${1}")
    # we don't expect more than CMD_MAX_SUB_COMMAND_LEVEL + 1 commands so if we matched enough, break
    if (( ${#_PARSED_COMMANDS[@]} >= CMD_MAX_SUB_COMMAND_LEVEL + 1 )); then
      RETURNED_VALUE=-1
      return 0
    fi
    # if we matched the first command, we can extract the arguments for the sub command
    if [[ "${#_PARSED_COMMANDS[@]}" -eq "1" ]]; then
      _PARSED_COMMAND_ARGS=("$@")
    fi
    ;;
  esac
  RETURNED_VALUE=0
}

# Run a given function
# The first arguments should be the function name,
# the rest of the arguments are the user arguments starting
# from the command name. e.g.:
# sub cmd --opt1 arg1 arg2
#
# $1: the function name
# $2+: the user arguments
function main::runFunction() {
  local functionName
  functionName="${1}"
  shift

  if [[ -z "${functionName}" ]]; then
    core::fail "No function name provided."
  fi

  # get command name of the function
  local -n command="CMD_COMMAND_${functionName}"

  # check for sudo if the function requires it
  local -n requiresSudo="CMD_SUDO_${functionName}"
  if [[ ${requiresSudo:-} == "true" ]]; then
    main::checkSudo
  fi

  # source the file in which the function is located if needed
  core::sourceFunction "${functionName}"

  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    core::fail "The function ⌜${functionName}⌝ associated with the command ⌜${command}⌝ does not exist."
  fi

  log::debug "Running the command ⌜${command}⌝ with the function ⌜${functionName}⌝ and the arguments ⌜$*⌝."

  # disable startup profile and enable command profile, if needed
  if [[ ${VALET_CONFIG_STARTUP_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi
  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    # shellcheck source=lib-profiler
    source profiler
    profiler::enable "${VALET_CONFIG_COMMAND_PROFILING_FILE:-"${HOME}/valet-profiler-${BASHPID}-command.txt"}"
  fi

  # execute the function
  "${functionName}" "$@"

  if [[ ${VALET_PROFILING:-} == "true" ]]; then
    profiler::disable
  fi

  exit 0
}

# This function checks if the user has sudo privileges.
# If the user has sudo, it will set the SUDO variable to "sudo".
# If the user does not have sudo, it will set the SUDO variable to "".
#
# Usage:
#  main::checkSudo
function main::checkSudo() {
  # sudo
  if command -v sudo 1>/dev/null 2>&1; then
    log::info "This command requires sudo privileges."
    SUDO="sudo"
    ${SUDO} printf '%s' "alright" 1>/dev/null || core::fail "Could not sudo but the command requires it."
  else
    SUDO=""
  fi
}

# Run the a command that has sub command:
# - either show an interactive menu for a command that has sub commands,
# - or display the help for this menu.
#
# $1: the command name
#
# Usage:
#   main::runMenuWithSubCommands "command"
function main::runMenuWithSubCommands() {
  local command="${1}"
  shift

  # export the command name for the menu
  # shellcheck disable=SC2034
  CMD_COMMAND__menu="${command}"

  local parsedArguments
  main::parseFunctionArguments "_menu" "$@"
  parsedArguments="${RETURNED_VALUE}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi
  eval "${parsedArguments}"

  if [[ -n "${help:-}" ]]; then
    main::printHelp menu "${command}"
    exit 0
  fi

  if [[ -n "${parsingErrors:-}" ]]; then
    core::fail "${parsingErrors}"
  fi

  # filter the commands to only keep the sub commands of the function
  local line
  declare -g -a FILTERED_COMMANDS_FOR_SUB_MENU=()
  for line in "${CMD_ALL_COMMAND_SELECTION_ITEMS_ARRAY[@]}"; do
    if [[ ${line} =~ ^(${command} [^ ]+ ) ]]; then
      FILTERED_COMMANDS_FOR_SUB_MENU+=("${line}")
    fi
  done

  if (( ${#FILTERED_COMMANDS_FOR_SUB_MENU[@]} == 0 )); then
    core::fail "No sub commands found for ⌜${command}⌝."
  fi

  main::showCommandsMenuAndRun "${command//[^[:alnum:]]/_}" FILTERED_COMMANDS_FOR_SUB_MENU
}

# Show the given commands in an interactive menu and then
# run the selected command if any.
# $1: the menu id
# $2: the command selection items array name
function main::showCommandsMenuAndRun() {
  local menuId commandSelectionItemsArrayName
  menuId="${1}"
  commandSelectionItemsArrayName="${2}"

  # sort the commands according to the last choices
  main::sortCommands "${menuId}" "${commandSelectionItemsArrayName}"

  local commandChoice
  main::showInteractiveCommandsMenu "Please select the command to run." "${commandSelectionItemsArrayName}"
  commandChoice="${RETURNED_VALUE}"

  log::debug "Command choice ⌜${commandChoice}⌝."

  if [[ -z "${commandChoice}" ]]; then
    # the user pressed escape or ctrl-c
    exit 0
  fi

  main::addLastChoice "${menuId}" "${commandChoice}"

  # get the function name from the command by replacing spaces and hyphens with _
  local functionName
  main::getFunctionNameFromCommand "${commandChoice}"
  functionName="${RETURNED_VALUE}"

  main::runFunction "${functionName}"
}

# This function sorts the commands in the menu by reading
# a file that contains the last used commands (last on top).
# The file is located in the configuration directory of the program.
# $1: the id of the menu (used in the file name)
# $2: the menu body
#
# Usage:
#  main::sortCommands "id" "${commands}" && sortedCommands="${RETURNED_VALUE}"
function main::sortCommands() {
  local menuId="${1}"
  local -n commands="${2}"

  # if the user does not want to remember the last choices, we return
  if [[ "${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}" -eq 0 ]]; then
    return 0
  fi

  local lastChoicesFile
  core::getLocalStateDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ ! -f "${lastChoicesFile}" ]]; then
    return 0
  fi

  local lastChoices
  readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"

  local -a unplayedCommands=()
  local -a playedCommands=()

  # list all the unplayed commands
  local unplayedCommands line command lastChoice played
  local -a commandsArray
  for line in "${commands[@]}"; do
    command="${line%%  *}"
    # check if the command has not been played yet
    played=false
    for lastChoice in "${lastChoices[@]}"; do
      if [[ ${lastChoice} == "${command}" ]]; then
        played=true
        break
      fi
    done
    # if not played, add it to the list
    if [[ ${played} == "false" ]]; then
      unplayedCommands+=("${line}")
    fi
    commandsArray+=("${line}")
  done

  # list all the played commands
  local playedCommands
  for lastChoice in "${lastChoices[@]}"; do
    # find the corresponding line in the commands, if any
    for line in "${commandsArray[@]}"; do
      command="${line%%  *}"
      if [[ ${command} == "${lastChoice}" ]]; then
        playedCommands+=("${line}")
        break
      fi
    done
  done

  commands=("${playedCommands[@]}")
  commands+=("${unplayedCommands[@]}")
}

# This function adds the user command choice to the last choices file.
# It allows to sort the commands in the menu by the last used commands.
# $1: the id of the menu (used in the file name)
# $2: the command to add
#
# Usage:
#  main::addLastChoice "id" "command"
function main::addLastChoice() {
  local menuId command
  menuId="${1}"
  command="${2}"

  local maxNumberOfLastChoice=${VALET_CONFIG_REMEMBER_LAST_CHOICES:-3}

  # if the user does not want to remember the last choices, we return
  if [[ "${maxNumberOfLastChoice}" -eq 0 ]]; then
    return 0
  fi

  # load last choices from the file into an array
  local lastChoicesFile
  local -a lastChoices
  core::getLocalStateDirectory
  lastChoicesFile="${RETURNED_VALUE}/last-choices-${menuId}"
  if [[ -f "${lastChoicesFile}" ]]; then
    readarray -d $'\n' -t lastChoices <"${lastChoicesFile}"
  else
    lastChoices=()
  fi

  {
    # write the command first
    printf '%s\n' "${command}"

    # loop through the last choices and add them to the file, limit to 20 total
    local -i total index
    total="${#lastChoices[@]}"
    if [[ total -gt maxNumberOfLastChoice ]]; then total=$((maxNumberOfLastChoice - 1)); fi
    index=0
    for ((index = 0; index < total; index++)); do
      if [[ "${lastChoices[${index}]}" != "${command}" ]]; then
        printf '%s\n' "${lastChoices[${index}]}"
      else
        total+=1
        if [[ total -gt ${#lastChoices[@]} ]]; then total=${#lastChoices[@]}; fi
      fi
    done
  } >"${lastChoicesFile}"
}

# show an interactive menu for commands
# returns the selected command in standard output
# $1: the menu id
# $2: the menu header
# $3: the menu items array name (reference)
#
# Usage:
#  main::showInteractiveCommandsMenu "menuId" "header" ARRAY_NAME && choice="${RETURNED_VALUE}"
function main::showInteractiveCommandsMenu() {
  local menuHeader commandSelectionItemsArrayName
  menuHeader="${1}"
  commandSelectionItemsArrayName="${2}"

  # shellcheck source=lib-fsfs
  source fsfs

  fsfs::itemSelector "${menuHeader}" "${commandSelectionItemsArrayName}" "main::onFsfsItemSelectionChange" "Command help"

  choice="${RETURNED_VALUE}"
  if (( ${#choice} >= CMD_MAX_COMMAND_WIDTH)); then
    choice="${choice:0:${CMD_MAX_COMMAND_WIDTH}}  "
    choice="${choice%%  *}"
  else
    choice=""
  fi

  RETURNED_VALUE="${choice}"
}

function main::onFsfsItemSelectionChange() {
  local item="$1"
  local command="${item:0:${CMD_MAX_COMMAND_WIDTH}}  "
  command="${command%%  *}"
  main::getFunctionNameFromCommand "${command}"
  main::getHelpText function "${RETURNED_VALUE}" "" "${3}"
  return 0
}

#===============================================================
# >>> Find command/function from arguments
#===============================================================

# Get the function name of a command.
#
# Usage:
#  main::getFunctionNameFromCommand "self build" && printf '%s\n' "${RETURNED_VALUE}"
function main::getFunctionNameFromCommand() {
  local -n functionName="CMD_FUNCTION_NAME_${1//[^[:alnum:]]/_}"
  RETURNED_VALUE="${functionName:-}"
}

# Find the function name from arguments that represents the commands.
# If we do not find an exact match, we return try to fuzzy find the command
# and then return its function name.
#
# This function will fail with an error if the command does not match
# any function or if the command is ambiguous.
#
# - $@: the commands to find
#
# Returns:
#
# - `RETURNED_VALUE`: The function name.
# - `RETURNED_VALUE2`: The level of the command.
# - `RETURNED_VALUE3`: The exact command.
#
# ```bash
# main::fuzzyMatchCommandToFunctionNameOrFail "self" "build" && printf '%s\n' "${RETURNED_VALUE}"
# ```
function main::fuzzyMatchCommandToFunctionNameOrFail() {
  if [[ $# -eq 0 ]]; then
    return 0
  fi

  main::getMaxPossibleCommandLevel "$@"
  local level="${RETURNED_VALUE}"

  # we put the arguments into an array so we can interpret 'my' 'sub'
  # and 'my sub' as the same command (we split everything by space)
  local -a commandArray
  # shellcheck disable=SC2206
  commandArray=($*)

  local loopI functionName command exactCommand
  for ((loopI = level; loopI >= 1; loopI--)); do
    command="${commandArray[*]:0:${loopI}}"

    # case where the command is exact, we can match the function immediately
    main::getFunctionNameFromCommand "${command}" && functionName="${RETURNED_VALUE}"
    if [[ -n "${functionName:-}" ]]; then
      exactCommand="${command}"
      break
    fi

    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      continue
    fi

    # case where the command is not exact, we try to fuzzy match it
    array::fuzzyFilter "${command}" CMD_ALL_COMMANDS_ARRAY
    if (( ${#RETURNED_ARRAY[@]} > 1)); then
        # case of ambiguous command, show the list of possible commands
        # shellcheck disable=SC1091
        source array
        array::fuzzyFilterSort "${command}" RETURNED_ARRAY "${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"}" "${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}"
        local IFS=$'\n'
        core::fail "Found multiple matches for the command ⌜${command}⌝, please be more specific:"$'\n'"${RETURNED_ARRAY[*]}"
    elif (( ${#RETURNED_ARRAY[@]} == 1 )); then
      # case of a single match, we can match the function immediately
      exactCommand="${RETURNED_ARRAY[0]}"
      main::getFunctionNameFromCommand "${exactCommand}" && functionName="${RETURNED_VALUE}"
      log::info "Fuzzy matching the command ⌜${command}⌝ to ⌜${exactCommand}⌝."
      break
    fi
  done

  if [[ -z "${functionName:-}" ]]; then
    local messageDetails
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      messageDetails="an exact command"
    else
      messageDetails="a matching command"
    fi
    core::fail "Could not find ${messageDetails} for ⌜${command}⌝, use ⌜--help⌝ to get a list of valid commands."
  fi

  RETURNED_VALUE="${functionName:-}"
  RETURNED_VALUE2="${loopI}"
  RETURNED_VALUE3="${exactCommand:-}"
}

# Return the maximum level of subcommands
# if in valet with have at max 2 level of commands
# e.g. cmd subcmd
# then there is no need to try to match a command with 5 arguments
# Same thing, if we provide only 1 argument to the cli, we
# can only match a simple command
# $@: the arguments
#
# Usage:
#  main::getMaxPossibleCommandLevel "cmd1" "subcmd2" "subsubcmd3" && level="${RETURNED_VALUE}"
function main::getMaxPossibleCommandLevel() {
  local command commandPart level maxLevel
  # count the number of spaces
  command="${*}"
  level=0
  # shellcheck disable=SC2034
  for commandPart in ${command}; do
    level=$((level + 1))
  done
  maxLevel=$((CMD_MAX_SUB_COMMAND_LEVEL + 1))
  if [[ "${level}" -gt "${maxLevel}" ]]; then
    level="${maxLevel}"
  fi

  RETURNED_VALUE="${level}"
}

#===============================================================
# >>> Parsers
#===============================================================

# Parses the arguments and options of a function.
# Usage:
#  main::parseFunctionArguments "functionName" "$@" && eval "${RETURNED_VALUE}"
#
# Notes:
# - It will return a string that can be evaluated to set the variables
#   corresponding to the arguments and options; e.g.:
#     "local arg1 option1
#     arg1=\"\"
#     option1=\"\"
#     ..."
# - It will also set the variable parsingErrors if there are any errors.
# - Variable name for an option is taken from the first --long version of the option.
# - It will set the variable as an array if the (last) argument name ends with '...'
function main::parseFunctionArguments() {
  local functionName
  functionName="${1}"
  shift

  local IFS=$' '

  local -n argumentsName="CMD_ARGS_NAME_${functionName}"
  local -i totalNbArguments
  if [[ -v argumentsName && ${#argumentsName[@]} -gt 0 ]]; then
    totalNbArguments=${#argumentsName[@]};
  else
    totalNbArguments=0;
  fi
  local -n isLastArgumentAnArray="CMD_ARGS_LAST_IS_ARRAY_${functionName}"
  local -n nbOptionalArgsStr="CMD_ARGS_NB_OPTIONAL_${functionName}"
  local -i nbOptionalArgs="${nbOptionalArgsStr:-0}"
  if [[ -z "${isLastArgumentAnArray:-}" ]]; then isLastArgumentAnArray=false; fi
  local -i argumentPosition=0

  # shellcheck disable=SC2178
  local -n options="CMD_OPTS_${functionName}"
  local -i totalNbOptions
  if [[ -v options && ${#options[@]} -gt 0 ]]; then
    totalNbOptions=${#options[@]};
  else
    totalNbOptions=0;
  fi
  # shellcheck disable=SC2034
  local -n optionsHasValue="CMD_OPTS_HAS_VALUE_${functionName}"
  local -n optionsName="CMD_OPTS_NAME_${functionName}"
  local -n optionsNameSc="CMD_OPTS_NAME_SC_${functionName}"
  local -n optionsDefault="CMD_OPTS_DEFAULT_${functionName}"

  # shortcut if the function expect no arguments and no options
  if [[ totalNbArguments -eq 0 && totalNbOptions -eq 0 ]]; then
    RETURNED_VALUE=""
    return 0
  fi

  local -a lastArgumentValues=()
  local -a outputErrors=()
  local -a outputSetLine
  local -a matchedOptionsIndex

  local badArguments=false

  # we define reusable pieces of code that will be used to parse the options
  # shellcheck disable=SC2016
  local optionFinder='
  # we are matching an option
  # try to match the argument with one of the option name
  if [[ totalNbOptions -gt 0 ]]; then
    for optionIndex in "${!options[@]}"; do
      for option in ${options[${optionIndex}]}; do
        if [[ ${option} == "${1}" ]]; then
          matchedIndex="${optionIndex}"
          break 2
        fi
      done
    done
  fi

  if [[ matchedIndex -ne -1 ]]; then
    # its a match!
    optionValue="${optionsHasValue[${matchedIndex}]:-}"
    optionName="${optionsName[${matchedIndex}]}"
    matchedOptionsIndex+=("${matchedIndex}")
  fi
  '

  # shellcheck disable=SC2016
  local registerOption='
  if [[ ${optionValue} == "true" ]]; then
    if (( $# == 1 )); then
      outputErrors+=("Missing value for option ⌜${optionName}⌝.")
    else
      shift
      outputSetLine+=("${optionName}=\"${1//\"/\\\"}\"")
    fi
  else
    outputSetLine+=("${optionName}=\"true\"")
  fi
  '

  # parse each arguments
  local -i optionIndex matchedIndex optionLength letterIndex
  # shellcheck disable=SC2034
  local optionValue
  local option startedArguments optionName argumentName optionLetter optionLetters
  startedArguments="false"
  while (( $# > 0 )); do

    if [[ ${1} == "-"* && ${startedArguments} != "true" ]]; then
      # we are matching an option, try to find the option index
      matchedIndex=-1
      eval "${optionFinder}"

      if [[ matchedIndex -ne -1 ]]; then
        # it's a match! register the option
        eval "${registerOption}"

      elif [[ ${1} == "--" ]]; then
        # if we have -- we stop parsing options
        startedArguments="true"

      elif [[ ${1} == "--"* ]]; then
        # if we didn't match any known long option, try to fuzzy find it
        main::fuzzyFindOption "${1}" "${options[@]}"

        if [[ -n "${RETURNED_VALUE2}" ]]; then
          # we found a single match!
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"${RETURNED_VALUE2}"}"
          eval "${registerOption}"
        else
          # we found multiple matches or no match
          outputErrors+=("${RETURNED_VALUE}")
        fi

      else
        # a single dash, we can resolve each letter as an option
        optionLetters="${1}"
        optionLength=${#optionLetters}
        for ((letterIndex = 1; letterIndex < optionLength; letterIndex++)); do
          optionLetter="${optionLetters:${letterIndex}:1}"
          matchedIndex=-1
          eval "${optionFinder//"\${1}"/"-${optionLetter}"}"
          if [[ matchedIndex -ne -1 ]]; then
            eval "${registerOption}"
          else
            main::getSingleLetterOptions "${options[@]}"
            outputErrors+=("Unknown option letter ⌜${optionLetter}⌝ in group ⌜${optionLetters}⌝. ${RETURNED_VALUE}")
          fi
        done

      fi

    else
      # we are matching an argument

      if [[ argumentPosition -ge totalNbArguments ]]; then
        outputErrors+=("Expecting ${totalNbArguments} argument(s), got extra argument ⌜${1}⌝.")
        badArguments=true
      else
        argumentName="${argumentsName[${argumentPosition}]}"

        if [[ argumentPosition -eq $((totalNbArguments - 1)) && "${isLastArgumentAnArray}" = "true" ]]; then
          # if the arg ends with ... we expect an infinite amount of arguments
          lastArgumentValues+=("${1}")
        else
          argumentPosition+=1
          outputSetLine+=("${argumentName}=\"${1//\"/\\\"}\"")
        fi

      fi
    fi

    if (( $# > 0 )); then
      shift
    fi
  done

  # increase argument position if the last arg is an array because we don't do it in the loop
  if [[ ${#lastArgumentValues[@]} -gt 0 ]]; then
    argumentPosition=$((argumentPosition + 1))
  fi

  # check if we have missing arguments
  local -i nbExpectedArgs=$((totalNbArguments - nbOptionalArgs))
  if [[ argumentPosition -lt nbExpectedArgs ]]; then
    outputErrors+=("Expecting ⌜${nbExpectedArgs}⌝ argument(s) but got ⌜${argumentPosition}⌝.")
    badArguments=true
  fi

  if (( ${#outputErrors[@]} > 0 )); then
    local -n command="CMD_COMMAND_${functionName}"
    outputErrors+=("Use ⌜valet ${command} --help⌝ to get help.")
    if [[ ${badArguments} == "true" ]]; then
      main::getHelpText function "${functionName}" "true"
      outputErrors+=($'\n'"Usage:"$'\n'"${RETURNED_VALUE2}")
    fi
  fi


  local outputString

  # define all the possible local variables for options and arguments
  local option argumentIndex nbScalarArguments
  outputString="local parsingErrors"
  for option in "${optionsName[@]}"; do
    outputString+=" ${option}"
  done
  nbScalarArguments="${totalNbArguments}"
  if [[ ${isLastArgumentAnArray} == "true" ]]; then nbScalarArguments=$((nbScalarArguments - 1)); fi
  for ((argumentIndex = 0; argumentIndex < nbScalarArguments; argumentIndex++)); do
    outputString+=" ${argumentsName[${argumentIndex}]}"
  done
  outputString+=$'\n'
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    outputString+="local -a ${argumentsName[${nbScalarArguments}]}"$'\n'
  fi

  # assign all unmatched options to the corresponding global variable
  local optionIndex optionName optionMatched matchedIndex optionNameSc optionDefault
  for optionIndex in "${!options[@]}"; do
    optionMatched="false"
    for matchedIndex in "${matchedOptionsIndex[@]}"; do
      if [[ ${optionIndex} == "${matchedIndex}" ]]; then
        optionMatched="true"
        break
      fi
    done
    if [[ ${optionMatched} == "false" ]]; then
      # shellcheck disable=SC2034
      optionName="${optionsName[${optionIndex}]}"
      optionNameSc="${optionsNameSc[${optionIndex}]:-}"
      optionDefault="${optionsDefault[${optionIndex}]:-}"
      if [[ -n "${optionNameSc}" ]]; then
        if [[ -n "${optionDefault}" ]]; then
          optionDefault="\"${optionDefault}\""
        fi
        outputString+="${optionsName[${optionIndex}]}=\"\${${optionNameSc}:-${optionDefault}}\""$'\n'
      else
        outputString+="${optionsName[${optionIndex}]}=\"${optionDefault}\""$'\n'
      fi
    fi
  done

  # output the parsing errors
  local -i outputErrorIndex
  outputString+="parsingErrors=\""
  for outputErrorIndex in "${!outputErrors[@]}"; do
    if [[ outputErrorIndex -gt 0 ]]; then
      outputString+=$'\n'
    fi
    outputString+="${outputErrors[${outputErrorIndex}]}"
  done
  outputString+="\""$'\n'

  # output the matched arguments/options values
  local outputSet
  for outputSet in "${outputSetLine[@]}"; do
    outputString+="${outputSet}"$'\n'
  done

  # output the last argument values
  if [[ ${isLastArgumentAnArray} == "true" ]]; then
    local lastArgumentValue
    outputString+="${argumentsName[${nbScalarArguments}]}=("$'\n'
    for lastArgumentValue in "${lastArgumentValues[@]}"; do
      outputString+="\"${lastArgumentValue//\"/\\\"}\""$'\n'
    done
    outputString+=")"
  fi

  RETURNED_VALUE="${outputString}"
}

# Tries to find a match for an inexact option.
# If the strict matching is enabled, we will only suggest a fix (if we find a match).
# If strict matching is disabled and we have found a single match, we can return it.
#
# - $1: the user string to match
# - $2+: list of options to match against
#
# Returns:
#
# - `RETURNED_VALUE`: An error message with the suggested option(s).
# - `RETURNED_VALUE2`: The single matched option that we can use.
#
# ```bash
# main::fuzzyFindOption opt1 option1 option2 option3 && fuzzyOption="${RETURNED_VALUE}"
# ```
function main::fuzzyFindOption() {
  local unknownOption suggestedOption
  unknownOption="${1}"
  shift
  # shellcheck disable=SC2206
  local IFS=$' '
  # shellcheck disable=SC2206
  _OPTIONS_TO_MATCH=($*)

  local singleMatchedOption
  IFS=$'\n'

  # split to get one possible option per line
  array::fuzzyFilter "${unknownOption}" _OPTIONS_TO_MATCH
  if (( ${#RETURNED_ARRAY[@]} == 1 )); then
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, did you mean ⌜${RETURNED_ARRAY[0]}⌝?"
    else
      log::info "Fuzzy matching the option ⌜${unknownOption}⌝ to ⌜${RETURNED_ARRAY[0]}⌝."
      singleMatchedOption="${RETURNED_ARRAY[0]}"
    fi
  elif (( ${#RETURNED_ARRAY[@]} > 1 )); then
    # shellcheck disable=SC1091
    source array
    array::fuzzyFilterSort "${unknownOption}" _OPTIONS_TO_MATCH "${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"}" "${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}"
    if [[ ${VALET_CONFIG_STRICT_MATCHING:-} == "true" ]]; then
      suggestedOption="Unknown option ⌜${unknownOption}⌝, valid matches are:"$'\n'"${RETURNED_ARRAY[*]}"
    else
      suggestedOption="Found multiple matches for the option ⌜${unknownOption}⌝, please be more specific:"$'\n'"${RETURNED_ARRAY[*]}"
    fi
  else
    suggestedOption="Unknown option ⌜${unknownOption}⌝, valid options are:"$'\n'"$*"
  fi

  unset _OPTIONS_TO_MATCH

  RETURNED_VALUE="${suggestedOption:-}"
  RETURNED_VALUE2="${singleMatchedOption:-}"
}

# Helps to build a message for the user to inform them
# about the valid single letter options.
#
# - $@: the options
#
# Returns:
#
# - `RETURNED_VALUE`: The message to display to the user.
#
# ```bash
# options=("opt1" "option1" "option2" "option3")
# main::getSingleLetterOptions "${options[@]}" && message="${RETURNED_VALUE}"
# ```
function main::getSingleLetterOptions() {
  local -a options
  # shellcheck disable=SC2206
  options=($*)

  RETURNED_VALUE="Valid single letter options are: "

  for option in "${options[@]}"; do
    if [[ ${#option} -eq 2 ]]; then
      RETURNED_VALUE+="⌜${option:1:1}⌝, "
    fi
  done

  RETURNED_VALUE="${RETURNED_VALUE%, }."
}

# Parse the arguments and options of a function.
# If no arguments are provided but some are expected, it will enter interactive mode.
# See the @core::parseArguments function for more details on parsing.
#
# Usage:
#   main::parseFunctionArgumentsOrGoInteractive "functionName" "$@" && eval "${RETURNED_VALUE}"
function main::parseFunctionArgumentsOrGoInteractive() {
  local functionName
  functionName="${1}"
  shift

  main::parseFunctionArguments "${functionName}" "$@"
  local parsedArguments="${RETURNED_VALUE}"
  if log::isDebugEnabled; then
    log::debug "Parsed arguments:"
    log::printString "${parsedArguments}"
  fi

  # check if the function is expecting arguments and/or options
  local expectArguments
  local -n arguments="CMD_ARGUMENTS_NAME_${functionName}"
  if [[ -v arguments && "${#arguments[@]}" -gt 0 ]]; then
    expectArguments="true"
  fi

  if [[ ("${expectArguments:-false}" == "true" && $# -eq 0) || "${VALET_FORCE_INTERACTIVE_MODE:-false}" == "true" ]]; then
    main::goInteractive "${functionName}" "${parsedArguments}"
  fi

  RETURNED_VALUE="${parsedArguments}"
}

function main::goInteractive() {
  local functionName parsedArguments
  functionName="${1}"
  parsedArguments="${2}"

  # TODO: go interactive
  log::warning "Entering interactive mode for the function ⌜${functionName}⌝. This is not yet implemented."

  # at the end, printf '%s\n' to the user the complete command that will be run
}

#===============================================================
# >>> Load the commands
#===============================================================
core::sourceUserCommands
