#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-terminal
source terminal
# shellcheck source=lib-fs
source fs

# ## list::setOptions (private)
#
# Set up the options for a list display.
#
# - ${itemHeight} _as int_:
#       (optional) The height of each item in the list (num²ber of lines needed to display the item).
#       (defaults to 1)
# - ${enableReverseMode} _as bool_:
#       (optional) If true, the items are displayed from bottom to top.
#       (defaults to false)
# - ${disableItemsCount} _as bool_:
#       (optional) If true, the count of items is not displayed.
#       (defaults to false)
# - ${disableScrollbar} _as bool_:
#       (optional) If true, the scrollbar is not displayed.
#       (defaults to false)
# - ${disableCursor} _as bool_:
#       (optional) If true, the left cursors are not displayed.
#       (defaults to false)
# - ${disableTopSeparator} _as bool_:
#       (optional) If true, the top separator is not displayed.
#       (defaults to false)
# - ${showItemsCountAtTop} _as bool_:
#       (optional) If true, the count of items will be displayed at the top of the box instead of the bottom.
#       (defaults to false)
# - ${emptyListText} _as string_:
#       (optional) The text to display when the list is empty.
#       (defaults to "EMPTY")
# - ${itemsCountPattern} _as string_:
#       (optional) The pattern to use for displaying the count of items.
#
#       - <colorCount>: The color to use for the count of items.
#       - <colorFrame>: The color to use for items count frame.
#       - <colorReset>: The color reset code.
#       - <lastItemNumber>: The last item number displayed in the list.
#       - <firstItemNumber>: The first item number displayed in the list.
#       - <totalItems>: The total number of items in the list.
#       - <filteredItems>: The number of items that match the filter.
#       - <percentViewed>: The percentage of items viewed in the list.
#
#       (defaults to " <colorCount><firstItemNumber><colorFrame>-<lastItemNumber> of <colorReset><colorCount><filteredItems><colorReset><colorFrame>/<totalItems><colorReset> ")
# - ${itemsCountFilteringString} _as string_:
#       (optional) The string to display when the list is being filtered.
#       (defaults to " <colorCount>Filtering…<colorReset> ")
# - ${disableFiltering} _as bool_:
#       (optional) If true, the items can't be filtered using list::filter.
#       (defaults to false)
# - ${filterAsynchronousThreshold} _as int_:
#       (optional) The number of items at which the filtering is done asynchronously.
#       If the number of items is greater than this value, the filtering is done asynchronously.
#       Can be set to 0 to force asynchronous filtering.
#       (defaults to 242)
# - ${filterUsingExternalProgramThreshold} _as int_:
#       (optional) The number of items at which the filtering is done using an external program.
#       If the number of items is greater than this value, the filtering is done using an external program.
#       This is to avoid performance issues when filtering a large number of items using pure bash.
#       (defaults to 1042)
# - ${callbackFunctionOnListClosed} _as string_:
#       (optional) The name of a function to call when the autocompletion box is closed.
#       Can be used to clean up resources or to update the screen.
#       The function is called with arguments:
#
#       - $1: The top line number of the box that was just closed.
#       - $2: The left column of the box.
#       - $3: The width of the box.
#       - $4: The height of the box.
#
#       The function must return 0 to state that prompt does not have to be redrawn, 1 otherwise.
#       (defaults to empty)
# - ${callbackFunctionOnItemDisplayed} _as string_:
#       (optional) The name of a function to call when an item needs to be displayed in the list.
#       This can be used to change the text displayed for the item (which default to the item string).
#       The following variables are available:
#
#       - $1 _as int_:
#             the index of the item being displayed
#
#       The function should return:
#
#       - ${_PROMPT_ITEM_DISPLAYED}: the string to display
#
#       (defaults to empty)
function list::setOptions() {
  local IFS=$' '
  eval "local a= ${*@Q}"

  # display modes
  _LIST_ITEM_HEIGHT="${itemHeight:-1}"
  _LIST_ENABLE_REVERSE_MODE="${enableReverseMode:-false}"
  _LIST_DISABLE_ITEMS_COUNT="${disableItemsCount:-false}"
  _LIST_DISABLE_RIGHT_SCROLLBAR="${disableScrollbar:-false}"
  _LIST_DISABLE_TOP_SEPARATOR="${disableTopSeparator:-false}"
  _LIST_SHOW_ITEMS_COUNT_AT_TOP="${showItemsCountAtTop:-false}"

  # left cursor
  if [[ ${disableCursor:-false} != "true" ]]; then
    _LIST_SYMBOL_LEFT_LENGTH="${SYMBOL_LIST_LEFT_LENGTH}"
    _LIST_SYMBOL_LEFT_SELECTED_ITEM="${SYMBOL_LIST_LEFT_SELECTED_ITEM}"
    _LIST_SYMBOL_LEFT_UNSELECTED_ITEM="${SYMBOL_LIST_LEFT_UNSELECTED_ITEM}"
    _LIST_SYMBOL_LEFT_SEPARATOR_TOP="${SYMBOL_LIST_LEFT_SEPARATOR_TOP}"
    _LIST_SYMBOL_LEFT_SEPARATOR_BOTTOM="${SYMBOL_LIST_LEFT_SEPARATOR_BOTTOM}"
  else
    _LIST_SYMBOL_LEFT_LENGTH=0
    _LIST_SYMBOL_LEFT_SELECTED_ITEM=""
    _LIST_SYMBOL_LEFT_UNSELECTED_ITEM=""
    _LIST_SYMBOL_LEFT_SEPARATOR_TOP=""
    _LIST_SYMBOL_LEFT_SEPARATOR_BOTTOM=""
  fi

  # right scrollbar
  if [[ ${_LIST_DISABLE_RIGHT_SCROLLBAR:-false} != "true" ]]; then
    _LIST_SYMBOL_RIGHT_LENGTH="${SYMBOL_LIST_RIGHT_LENGTH}"
    _LIST_SYMBOL_RIGHT_WITH_SCROLL_BAR="${SYMBOL_LIST_RIGHT_WITH_SCROLL_BAR}"
    _LIST_SYMBOL_RIGHT_WITHOUT_SCROLL_BAR="${SYMBOL_LIST_RIGHT_WITHOUT_SCROLL_BAR}"
    _LIST_SYMBOL_RIGHT_SEPARATOR_TOP="${SYMBOL_LIST_RIGHT_SEPARATOR_TOP}"
    _LIST_SYMBOL_RIGHT_SEPARATOR_BOTTOM="${SYMBOL_LIST_RIGHT_SEPARATOR_BOTTOM}"
  else
    _LIST_SYMBOL_RIGHT_LENGTH=0
    _LIST_SYMBOL_RIGHT_WITH_SCROLL_BAR=""
    _LIST_SYMBOL_RIGHT_WITHOUT_SCROLL_BAR=""
    _LIST_SYMBOL_RIGHT_SEPARATOR_TOP=""
    _LIST_SYMBOL_RIGHT_SEPARATOR_BOTTOM=""
  fi

  # visual options
  _LIST_STYLE_LETTER_HIGHLIGHT="${STYLE_LIST_LETTER_HIGHLIGHT}"
  _LIST_STYLE_LETTER_HIGHLIGHT_RESET="${STYLE_LIST_LETTER_HIGHLIGHT_RESET}"

  _LIST_EMPTY_LIST_TEXT="${emptyListText:-"EMPTY"}"
  local visibleCharacters="${_LIST_EMPTY_LIST_TEXT}"
  string::removeTextFormatting visibleCharacters
  _LIST_EMPTY_LIST_TEXT_LENGTH=${#visibleCharacters}

  _LIST_ITEMS_COUNT_PATTERN="${itemsCountPattern:-" <colorCount><firstItemNumber><colorFrame>-<lastItemNumber> of <colorReset><colorCount><filteredItems><colorReset><colorFrame>/<totalItems><colorReset> "}"
  _LIST_ITEMS_COUNT_PATTERN="${_LIST_ITEMS_COUNT_PATTERN//"<colorCount>"/"${STYLE_LIST_COUNT_NUMBER}"}"
  _LIST_ITEMS_COUNT_PATTERN="${_LIST_ITEMS_COUNT_PATTERN//"<colorFrame>"/"${STYLE_LIST_COUNT_FRAME}"}"
  _LIST_ITEMS_COUNT_PATTERN="${_LIST_ITEMS_COUNT_PATTERN//"<colorReset>"/"${STYLE_RESET}"}"
  local visibleCharacters="${_LIST_ITEMS_COUNT_PATTERN}"
  string::removeTextFormatting visibleCharacters
  _LIST_ITEMS_COUNT_PATTERN_INVISIBLE_CHARS_LENGTH=$((${#_LIST_ITEMS_COUNT_PATTERN} - ${#visibleCharacters}))

  _LIST_ITEMS_COUNT_FILTERING_STRING="${itemsCountFilteringString:-" <colorCount>Filtering…<colorReset> "}"
  _LIST_ITEMS_COUNT_FILTERING_STRING="${_LIST_ITEMS_COUNT_FILTERING_STRING//"<colorCount>"/"${STYLE_LIST_COUNT_NUMBER}"}"
  _LIST_ITEMS_COUNT_FILTERING_STRING="${_LIST_ITEMS_COUNT_FILTERING_STRING//"<colorReset>"/"${STYLE_RESET}"}"
  visibleCharacters="${_LIST_ITEMS_COUNT_FILTERING_STRING}"
  string::removeTextFormatting visibleCharacters
  _LIST_ITEMS_COUNT_FILTERING_STRING_LENGTH=${#visibleCharacters}

  # callbacks
  _LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED="${callbackFunctionOnItemDisplayed:-}"
  if [[ -n ${_LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED} ]]; then
    if ! declare -F "${_LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED}" &>/dev/null; then
      core::fail "The callback function ⌜${_LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED}⌝ does not exist."
    fi
  fi
  if ((_LIST_ITEM_HEIGHT == 1)); then
    _LIST_APPEND_ITEM_STRING_FUNCTION="list_appendSingleLineItemDisplayString"
  else
    _LIST_APPEND_ITEM_STRING_FUNCTION="list_appendMultiLineItemDisplayString"
  fi

  # handle shortcuts, allow to override the default key mapping
  declare -g -A _LIST_KEY_MAPPING=(
    ["PAGE_UP"]="scroll-up"
    ["PAGE_DOWN"]="scroll-down"
    ["HOME"]="move-beginning"
    ["CTRL+UP"]="move-beginning"
    ["END"]="move-end"
    ["CTRL+DOWN"]="move-end"
    ["UP"]="move-up"
    ["DOWN"]="move-down"
  )
  if [[ -v VALET_CONFIG_LIST_KEY_MAPPING ]]; then
    local key
    for key in "${!VALET_CONFIG_LIST_KEY_MAPPING[@]}"; do
      _LIST_KEY_MAPPING["${key}"]="${VALET_CONFIG_LIST_KEY_MAPPING[${key}]}"
    done
  fi

  # filtering options
  _LIST_DISABLE_FILTERING="${disableFiltering:-false}"
  _LIST_FILTER_ASYNCHRONOUSLY_THRESHOLD="${filterAsynchronousThreshold:-242}"
  _LIST_FILTER_USING_EXTERNAL_PROGRAM_THRESHOLD="${filterUsingExternalProgramThreshold:-1042}"
}

# ## list::setViewport (private)
#
# Set up the viewport for a list display.
#
# - ${left} _as int_:
#       (optional) The left column at which to display the viewport of the list.
#       (defaults to 1)
# - ${top} _as int_:
#       (optional) The top line at which to display the viewport of the list.
#       (defaults to 1)
# - ${width} _as int_:
#       (optional) The width of the viewport of the list.
#       (defaults to GLOBAL_COLUMNS)
# - ${height} _as int_:
#       (optional) The height of the viewport of the list.
#       (defaults to GLOBAL_LINES)
#
# ```bash
# list::setViewport left=10 top=5 width=50 height=20
# ```
function list::setViewport() {
  local IFS=$' '
  eval "local a= ${*@Q}"

  # viewport size
  _LIST_LEFT="${left:-1}"
  _LIST_TOP="${top:-1}"
  _LIST_WIDTH="${width:-${GLOBAL_COLUMNS}}"
  _LIST_HEIGHT="${height:-${GLOBAL_LINES}}"

  # variables derived from options
  _LIST_ITEM_WIDTH="$((_LIST_WIDTH - _LIST_SYMBOL_LEFT_LENGTH - _LIST_SYMBOL_RIGHT_LENGTH))"
  printf -v _LIST_BLANKS_WIDTH "%${_LIST_WIDTH}s" " "
  printf -v _LIST_BLANKS_ITEM_WIDTH "%${_LIST_ITEM_WIDTH}s" " "

  bash::clearCachedVariables _LIST_itemCounterLength _LIST_itemsCounterString
}

# ## list::setItems (private)
#
# Set up the list of items to display.
#
# - $1 _as string_:
#       The name of the array that contains the items to display.
function list::setItems() {
  local itemsArrayName="${1:-}"
  local initialFilterString="${2:-}"

  if [[ -n ${itemsArrayName} ]]; then
    declare -g -n _LIST_ORIGINAL_ITEMS="${itemsArrayName}"
    _LIST_ORIGINAL_ITEMS_COUNT=${#_LIST_ORIGINAL_ITEMS[@]}
  else
    _LIST_ORIGINAL_ITEMS=()
    _LIST_ORIGINAL_ITEMS_COUNT=0
  fi

  _LIST_FILTERED_ITEMS_START_INDEX=0
  _LIST_FILTERED_ITEMS_SELECTED_INDEX=-1

  # Async filtering variables below
  # make sure to use async when we use an external program
  if ((_LIST_FILTER_ASYNCHRONOUSLY_THRESHOLD > _LIST_FILTER_USING_EXTERNAL_PROGRAM_THRESHOLD)); then
    _LIST_FILTER_ASYNCHRONOUSLY_THRESHOLD="${_LIST_FILTER_USING_EXTERNAL_PROGRAM_THRESHOLD}"
  fi

  # filter with an external program
  if [[ ${VALET_CONFIG_STRICT_PURE_BASH:-false} != "true" && _LIST_ORIGINAL_ITEMS_COUNT -ge _LIST_FILTER_USING_EXTERNAL_PROGRAM_THRESHOLD ]]; then

    fs::createTempFile pathOnly=true
    _ASYNC_FILTER_ORIGINAL_ITEMS_FILE="${REPLY}"

    if command -v fzf &>/dev/null && command -v awk &>/dev/null; then
      _LIST_FILTER_USING_EXTERNAL_PROGRAM="fzf+awk"
    elif command -v grep &>/dev/null && command -v gawk &>/dev/null; then
      _LIST_FILTER_USING_EXTERNAL_PROGRAM="grep+gawk"
    fi
  fi

  # if the items are too many, we will filter them asynchronously/filter with grep
  if ((_LIST_ORIGINAL_ITEMS_COUNT >= _LIST_FILTER_ASYNCHRONOUSLY_THRESHOLD)); then
    list_startAsyncFiltering
    _LIST_FILTER_SYNCHRONOUSLY=false
  else
    _LIST_FILTER_SYNCHRONOUSLY=true
  fi

  if [[ ${_LIST_DISABLE_FILTERING} == "true" || -n ${initialFilterString} ]]; then
    _LIST_FILTERED_ITEMS=("${_LIST_ORIGINAL_ITEMS[@]}")
    _LIST_FILTERED_ITEMS_CORRESPONDENCES=()
    _LIST_FILTER_STRING=""
    _LIST_ASYNC_FILTERING_RUNNING=false
  else
    list::filter "${initialFilterString}"
  fi
}

# Draw the list box.
function list::draw() {
  local finalStringToPrint=""

  if [[ ${_LIST_DISABLE_TOP_SEPARATOR} != "true" ]]; then
    list::drawTopSeparator finalStringToPrint
  fi

  if [[ ${_LIST_DISABLE_RIGHT_SCROLLBAR} != "true" ]]; then
    # calculate the size and position of the scroll bar
    local -i \
      firstLineWithScrollBar=0 \
      linesWithScrollBar=0 \
      filteredItems=${#_LIST_FILTERED_ITEMS[@]} \
      displayableItems=$((_LIST_NB_USABLE_LINES_FOR_ITEMS / _LIST_ITEM_HEIGHT))
    if ((filteredItems > displayableItems)); then
      local -i \
        percentViewed=$((filteredItems - displayableItems > 0 ? (_LIST_FILTERED_ITEMS_START_INDEX * 100) / (filteredItems - displayableItems) : 100))
      linesWithScrollBar=$((filteredItems > 0 ? _LIST_NB_USABLE_LINES_FOR_ITEMS * displayableItems / filteredItems : 0))
      firstLineWithScrollBar=$((((_LIST_NB_USABLE_LINES_FOR_ITEMS - linesWithScrollBar) * percentViewed) / 100))
    fi
  fi

  list::drawItems finalStringToPrint "${firstLineWithScrollBar:-"-1"}" "${linesWithScrollBar:-"-1"}"

  if [[ ${_LIST_DISABLE_ITEMS_COUNT} != "true" ]]; then
    list::drawCounter finalStringToPrint
  fi

  printf '%s%s%s' "${ESC__CURSOR_HIDE}" "${finalStringToPrint}" "${ESC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__ESC__TO}${STYLE_RESET}${ESC__CURSOR_SHOW_FORCE}" 1>&"${GLOBAL_FD_TUI}"
}

# Draw the autocompletion box
function list::drawItems() {
  local -n toPrint="${1}"
  local -i \
    firstLineWithScrollBar="${2:-0}" \
    linesWithScrollBar="${3:-0}"

  local -i line \
    displayableItems=$((_LIST_NB_USABLE_LINES_FOR_ITEMS / _LIST_ITEM_HEIGHT)) \
    index=${_LIST_FILTERED_ITEMS_START_INDEX}
  _LIST_NB_DISPLAYED_ITEMS=0

  for ((line = 0; line < _LIST_NB_USABLE_LINES_FOR_ITEMS; line++)); do
    # line at which to display the item
    if [[ ${_LIST_ENABLE_REVERSE_MODE} == "true" ]]; then
      _LIST_CURRENT_ITEM_SHOWN_AT_LINE=$((_LIST_TOP + _LIST_HEIGHT - 1 - _LIST_BOTTOM_SHIFT - line - (_LIST_ITEM_HEIGHT - 1)))
    else
      _LIST_CURRENT_ITEM_SHOWN_AT_LINE=$((_LIST_TOP + _LIST_TOP_SHIFT + line))
    fi

    # right side scrollbar character
    if ((line < firstLineWithScrollBar + linesWithScrollBar && line >= firstLineWithScrollBar)); then
      _LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL="${_LIST_SYMBOL_RIGHT_WITH_SCROLL_BAR}"
    else
      _LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL="${_LIST_SYMBOL_RIGHT_WITHOUT_SCROLL_BAR}"
    fi

    # position
    toPrint+="${ESC__CURSOR_MOVE__}${_LIST_CURRENT_ITEM_SHOWN_AT_LINE};${_LIST_LEFT}${__ESC__TO}"

    if ((index >= ${#_LIST_FILTERED_ITEMS[@]})); then
      # we displayed all the items, show empty lines
      toPrint+="${_LIST_SYMBOL_LEFT_UNSELECTED_ITEM}${STYLE_LIST_EMPTY}${_LIST_BLANKS_ITEM_WIDTH// /${SYMBOL_LIST_EMPTY}}${STYLE_RESET}${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"

    elif ((_LIST_NB_DISPLAYED_ITEMS >= displayableItems)); then
      # we reached the maximum number of items to display, show blank line
      toPrint+="${_LIST_SYMBOL_LEFT_UNSELECTED_ITEM}${STYLE_LIST_EMPTY}${_LIST_BLANKS_ITEM_WIDTH}${STYLE_RESET}${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"

    else
      # we can display an item
      # get the item string to display
      if [[ -n ${_LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED} ]]; then
        # case of a callback in which we want to change the displayed text
        list::convertToInitialItemsIndex "${index}"
        "${_LIST_CALLBACK_FUNCTION_ON_ITEM_DISPLAYED}" "${REPLY}"
      else
        _LIST_CURRENT_ITEM="${_LIST_FILTERED_ITEMS[${index}]}"
      fi

      # append the item display string (uses index and toPrint directly)
      "${_LIST_APPEND_ITEM_STRING_FUNCTION}"

      line=$((line + _LIST_ITEM_HEIGHT - 1))
      index=$((index + 1))
      _LIST_NB_DISPLAYED_ITEMS=$((_LIST_NB_DISPLAYED_ITEMS + 1))
    fi
  done

  # case of an empty list
  if ((_LIST_NB_DISPLAYED_ITEMS == 0)); then
    toPrint+="${ESC__CURSOR_MOVE__}$((_LIST_TOP + _LIST_NB_USABLE_LINES_FOR_ITEMS / 2));$((_LIST_LEFT + _LIST_WIDTH / 2 - _LIST_EMPTY_LIST_TEXT_LENGTH / 2))${__ESC__TO}${STYLE_LIST_UNSELECTED_ITEM}${_LIST_EMPTY_LIST_TEXT}${STYLE_RESET}"
  fi
}

# ## list_appendSingleLineItemDisplayString (private)
function list_appendSingleLineItemDisplayString() {
  if ((index == _LIST_FILTERED_ITEMS_SELECTED_INDEX)); then
    # highlight the selected item
    _LIST_STYLE_LETTER_HIGHLIGHT_RESET="${STYLE_LIST_LETTER_HIGHLIGHT_RESET}${STYLE_LIST_SELECTED_ITEM}"
    list::getCurrentItemDisplayableString
    toPrint+="${_LIST_SYMBOL_LEFT_SELECTED_ITEM}${STYLE_LIST_SELECTED_ITEM}${_LIST_CURRENT_ITEM}"
  else
    _LIST_STYLE_LETTER_HIGHLIGHT_RESET="${STYLE_LIST_LETTER_HIGHLIGHT_RESET}${STYLE_LIST_UNSELECTED_ITEM}"
    list::getCurrentItemDisplayableString
    toPrint+="${_LIST_SYMBOL_LEFT_UNSELECTED_ITEM}${STYLE_LIST_UNSELECTED_ITEM}${_LIST_CURRENT_ITEM}"
  fi
  if ((REPLY > 0)); then
    toPrint+="${_LIST_BLANKS_WIDTH:0:REPLY}${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"
  else
    toPrint+="${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"
  fi
}

# ## list_appendMultiLineItemDisplayString (private)
function list_appendMultiLineItemDisplayString() {
  if ((index == _LIST_FILTERED_ITEMS_SELECTED_INDEX)); then
    # highlight the selected item
    _LIST_STYLE_LETTER_HIGHLIGHT_RESET="${STYLE_LIST_LETTER_HIGHLIGHT_RESET}${STYLE_LIST_SELECTED_ITEM}"
  else
    _LIST_STYLE_LETTER_HIGHLIGHT_RESET="${STYLE_LIST_LETTER_HIGHLIGHT_RESET}${STYLE_LIST_UNSELECTED_ITEM}"
  fi

  string::highlight _LIST_CURRENT_ITEM _LIST_FILTER_STRING highlightCode="${_LIST_STYLE_LETTER_HIGHLIGHT}" resetCode="${_LIST_STYLE_LETTER_HIGHLIGHT_RESET}"
  _LIST_CURRENT_ITEM="${REPLY}"

  local IFS=$'\n' savedFilterString="${_LIST_FILTER_STRING}"
  _LIST_FILTER_STRING=""

  local -i nbLines=0
  for _LIST_CURRENT_ITEM in ${_LIST_CURRENT_ITEM}; do
    if ((nbLines > 0)); then
      toPrint+="${ESC__CURSOR_MOVE__}$((_LIST_CURRENT_ITEM_SHOWN_AT_LINE + nbLines));${_LIST_LEFT}${__ESC__TO}"
    fi

    list::getCurrentItemDisplayableString

    if ((index == _LIST_FILTERED_ITEMS_SELECTED_INDEX)); then
      toPrint+="${_LIST_SYMBOL_LEFT_SELECTED_ITEM}${STYLE_LIST_SELECTED_ITEM}${_LIST_CURRENT_ITEM}"
    else
      toPrint+="${_LIST_SYMBOL_LEFT_UNSELECTED_ITEM}${STYLE_LIST_UNSELECTED_ITEM}${_LIST_CURRENT_ITEM}"
    fi

    if ((REPLY > 0)); then
      toPrint+="${_LIST_BLANKS_WIDTH:0:REPLY}${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"
    else
      toPrint+="${_LIST_CURRENT_ITEM_SCROLL_BAR_SYMBOL}"
    fi

    nbLines=$((nbLines + 1))
  done

  _LIST_FILTER_STRING="${savedFilterString}"
}

# Draw the items count at the bottom/top of the list.
function list::drawCounter() {
  local -n toPrint="${1}"

  local -i \
    itemCounterLength \
    counterAvailableLength=$((_LIST_WIDTH - _LIST_SYMBOL_LEFT_LENGTH - _LIST_SYMBOL_RIGHT_LENGTH))
  local itemsCounterString
  if ((_LIST_ORIGINAL_ITEMS_COUNT == 0)); then
    itemsCounterString=""
    itemCounterLength=0
  elif [[ ${_LIST_ASYNC_FILTERING_RUNNING:-} == "true" ]]; then
    # case where we are filtering asynchronously, we display a loading message
    itemsCounterString=" ${_LIST_ITEMS_COUNT_FILTERING_STRING}"
    itemCounterLength=${_LIST_ITEMS_COUNT_FILTERING_STRING_LENGTH}
  else
    local lastItemNumber=$((_LIST_FILTERED_ITEMS_START_INDEX + _LIST_NB_DISPLAYED_ITEMS - 1))
    printf -v firstItemNumber "%0${#lastItemNumber}i" "${_LIST_FILTERED_ITEMS_START_INDEX}"
    local totalItems="${_LIST_ORIGINAL_ITEMS_COUNT}"
    printf -v filteredItems "%0${#totalItems}i" "${#_LIST_FILTERED_ITEMS[@]}"
    local percentViewed=$((_LIST_ORIGINAL_ITEMS_COUNT - _LIST_NB_DISPLAYED_ITEMS > 0 ? (_LIST_FILTERED_ITEMS_START_INDEX * 100) / (_LIST_ORIGINAL_ITEMS_COUNT - _LIST_NB_DISPLAYED_ITEMS) : 100))

    local itemsCounterString="${_LIST_ITEMS_COUNT_PATTERN//"<lastItemNumber>"/"${lastItemNumber}"}"
    itemsCounterString="${itemsCounterString//"<firstItemNumber>"/"${firstItemNumber}"}"
    itemsCounterString="${itemsCounterString//"<totalItems>"/"${totalItems}"}"
    itemsCounterString="${itemsCounterString//"<filteredItems>"/"${filteredItems}"}"
    itemsCounterString="${itemsCounterString//"<percentViewed>"/"${percentViewed}%"}"

    itemCounterLength=$((${#itemsCounterString} - _LIST_ITEMS_COUNT_PATTERN_INVISIBLE_CHARS_LENGTH))
  fi

  if ((itemCounterLength > counterAvailableLength)); then
    # case where we do not have the space to display the count
    itemCounterLength=0
    itemsCounterString=""
  fi

  local showAtLine leftSymbol rightSymbol
  if [[ ${_LIST_SHOW_ITEMS_COUNT_AT_TOP:-false} == "true" ]]; then
    showAtLine=${_LIST_TOP}
    leftSymbol="${_LIST_SYMBOL_LEFT_SEPARATOR_TOP}"
    rightSymbol="${_LIST_SYMBOL_RIGHT_SEPARATOR_TOP}"
  else
    showAtLine=$((_LIST_TOP + _LIST_HEIGHT - 1))
    leftSymbol="${_LIST_SYMBOL_LEFT_SEPARATOR_BOTTOM}"
    rightSymbol="${_LIST_SYMBOL_RIGHT_SEPARATOR_BOTTOM}"
  fi

  local counterFrame="${_LIST_BLANKS_WIDTH:0:counterAvailableLength-itemCounterLength}"

  toPrint+="${ESC__CURSOR_MOVE__}${showAtLine};${_LIST_LEFT}${__ESC__TO}${STYLE_LIST_COUNT_FRAME}${leftSymbol}${counterFrame// /"${SYMBOL_LIST_FRAME_HR}"}${STYLE_RESET}${itemsCounterString}${STYLE_LIST_COUNT_FRAME}${rightSymbol}${STYLE_RESET}"
}

# Draw the scroll bar top separator.
function list::drawTopSeparator() {
  local -n toPrint="${1}"

  local showAtLine leftSymbol rightSymbol
  if [[ ${_LIST_SHOW_ITEMS_COUNT_AT_TOP:-false} != "true" ]]; then
    showAtLine=${_LIST_TOP}
    leftSymbol="${_LIST_SYMBOL_LEFT_SEPARATOR_TOP}"
    rightSymbol="${_LIST_SYMBOL_RIGHT_SEPARATOR_TOP}"
  else
    showAtLine=$((_LIST_TOP + _LIST_HEIGHT - 1))
    leftSymbol="${_LIST_SYMBOL_LEFT_SEPARATOR_BOTTOM}"
    rightSymbol="${_LIST_SYMBOL_RIGHT_SEPARATOR_BOTTOM}"
  fi

  toPrint+="${ESC__CURSOR_MOVE__}${showAtLine};${_LIST_LEFT}${__ESC__TO}${STYLE_LIST_COUNT_FRAME}${leftSymbol}${_LIST_BLANKS_ITEM_WIDTH// /"${SYMBOL_LIST_FRAME_HR}"}${rightSymbol}${STYLE_RESET}"
}

# Filter the items of the autocompletion box, will either filter synchronously or asynchronously
function list::filter() {
  _LIST_FILTER_STRING="${1}"

  list_filter

  if [[ ${_LIST_ASYNC_FILTERING_RUNNING} != "true" ]]; then
    list_post_filter
  fi
}

# Filter the items of the autocompletion box, will either filter synchronously or asynchronously
function list_filter() {
  if [[ ${_LIST_DISABLE_FILTERING} == "true" ]]; then
    return 0
  fi

  _LIST_ASYNC_FILTERING_RUNNING=false

  # case where we can return the original items
  if [[ -z ${_LIST_FILTER_STRING} ]]; then
    _LIST_FILTERED_ITEMS=("${_LIST_ORIGINAL_ITEMS[@]}")
    _LIST_FILTERED_ITEMS_CORRESPONDENCES=()
    _LIST_CURRENT_FILTER_STRING=""
    return 0
  fi

  # if the current filter string is a prefix of the previous one, we can filter the already filtered items synchronously
  if [[ -n ${_LIST_CURRENT_FILTER_STRING:-} && ${_LIST_FILTER_STRING} == "${_LIST_CURRENT_FILTER_STRING}"* && (${_LIST_FILTER_SYNCHRONOUSLY} == "true" || ${#_LIST_FILTERED_ITEMS[@]} -lt _LIST_FILTER_ASYNCHRONOUSLY_THRESHOLD) ]]; then
    if ((${#_LIST_FILTERED_ITEMS[@]} == 0)); then
      return 0
    fi
    local -a _LIST_PRE_FILTERED_ITEMS=("${_LIST_FILTERED_ITEMS[@]}")
    local -a _LIST_PRE_FILTERED_ITEMS_CORRESPONDENCES=("${_LIST_FILTERED_ITEMS_CORRESPONDENCES[@]}")
    # We define these to allow array::fuzzyFilterSort to modify the arrays directly (avoiding a copy)
    # shellcheck disable=SC2178
    local -n REPLY_ARRAY=_LIST_FILTERED_ITEMS
    # shellcheck disable=SC2034
    local -n REPLY_ARRAY2=_LIST_FILTERED_ITEMS_CORRESPONDENCES
    array::fuzzyFilterSort _LIST_PRE_FILTERED_ITEMS _LIST_FILTER_STRING
    _LIST_CURRENT_FILTER_STRING="${_LIST_FILTER_STRING}"
    # we need to update the correspondences
    local -i index
    for ((index = 0; index < ${#_LIST_FILTERED_ITEMS_CORRESPONDENCES[@]}; index++)); do
      _LIST_FILTERED_ITEMS_CORRESPONDENCES[index]="${_LIST_PRE_FILTERED_ITEMS_CORRESPONDENCES[${_LIST_FILTERED_ITEMS_CORRESPONDENCES[index]}]}"
    done
    return 0
  fi

  if [[ ${_LIST_FILTER_SYNCHRONOUSLY} == "true" ]]; then
    # We define these to allow array::fuzzyFilterSort to modify the arrays directly (avoiding a copy)
    # shellcheck disable=SC2178
    local -n REPLY_ARRAY=_LIST_FILTERED_ITEMS
    # shellcheck disable=SC2034
    local -n REPLY_ARRAY2=_LIST_FILTERED_ITEMS_CORRESPONDENCES
    array::fuzzyFilterSort _LIST_ORIGINAL_ITEMS _LIST_FILTER_STRING
    _LIST_CURRENT_FILTER_STRING="${_LIST_FILTER_STRING}"
  else
    # asynchronous filtering
    if [[ ! -v _LIST_ASYNC_FILTER_JOB ]]; then
      list_startAsyncFiltering
    fi

    # send a message to the async filter job
    if ! { printf "filter=%s\0" "${_LIST_FILTER_STRING}" >&"${_LIST_ASYNC_FILTER_JOB[1]:-}"; } 2>/dev/null; then
      list_startAsyncFiltering
    fi

    _LIST_ASYNC_FILTERING_LAST_REQUESTED_STRING="${_LIST_FILTER_STRING}"
    _LIST_ASYNC_FILTERING_RUNNING=true
  fi
}

function list_post_filter() {
  # check if we display the item count
  _LIST_NB_USABLE_LINES_FOR_ITEMS="${_LIST_HEIGHT}"
  _LIST_BOTTOM_SHIFT=0
  _LIST_TOP_SHIFT=0

  if [[ ${_LIST_DISABLE_ITEMS_COUNT} != "true" ]]; then
    _LIST_NB_USABLE_LINES_FOR_ITEMS=$((_LIST_NB_USABLE_LINES_FOR_ITEMS - 1))
    # we display the items count at the top or bottom of the box
    if [[ ${_LIST_SHOW_ITEMS_COUNT_AT_TOP:-false} == "true" ]]; then
      _LIST_TOP_SHIFT=$((_LIST_TOP_SHIFT + 1))
    else
      _LIST_BOTTOM_SHIFT=$((_LIST_BOTTOM_SHIFT + 1))
    fi
  fi

  if [[ ${_LIST_DISABLE_TOP_SEPARATOR} != "true" ]]; then
    _LIST_NB_USABLE_LINES_FOR_ITEMS=$((_LIST_NB_USABLE_LINES_FOR_ITEMS - 1))
    # we display the top separator
    if [[ ${_LIST_SHOW_ITEMS_COUNT_AT_TOP:-false} == "true" ]]; then
      _LIST_BOTTOM_SHIFT=$((_LIST_BOTTOM_SHIFT + 1))
    else
      _LIST_TOP_SHIFT=$((_LIST_TOP_SHIFT + 1))
    fi
  fi

  # make sure to select an existing index regarding the filtered items +
  # make sure it is in the view
  list::changeSelectedItemIndex 0
}

# Clear the items box
function list::clearVieWport() {
  if [[ _LIST_HEIGHT -le 0 ]]; then
    return 0
  fi

  if [[ -n ${_LIST_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]]; then
    if "${_LIST_CALLBACK_FUNCTION_ON_BOX_CLOSED}" "${_LIST_TOP}" "${_LIST_LEFT}" "${_LIST_WIDTH}" "${_LIST_HEIGHT}"; then
      return 0
    fi
  fi

  terminal::clearBox top="${_LIST_TOP}" left="${_LIST_LEFT}" width="${_LIST_WIDTH}" height="${_LIST_HEIGHT}" 2>&3
}

function list::destroy() {
  # shellcheck disable=SC2086
  unset -v ${!_LIST_*}
}

# Called when a special key is pressed.
#
# - $1: **key** _as string_:
#       The special key that was pressed (UP, DOWN, etc...).
#
# define the callback function called when a special key is pressed
# shellcheck disable=SC2317
function list::onKeyBindingPress() {
  local action="${_LIST_KEY_MAPPING[${1}]:-}"
  if [[ -z ${action} ]]; then
    return 1
  fi

  # handle spamming of keys (the actions before this do not need to be protected from spam,
  # but the actions after this are slow to execute and should not be spammed)
  time::getProgramElapsedMicroseconds
  if ((REPLY - _LIST_LAST_KEY_PRESSED_TIME < 100000)); then
    # key pressed under 100ms of the last
    _LIST_NB_SUCCESSIVE_RAPID_KEY_PRESSED=$((_LIST_NB_SUCCESSIVE_RAPID_KEY_PRESSED + 1))
  else
    _LIST_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
  fi
  if ((_LIST_NB_SUCCESSIVE_RAPID_KEY_PRESSED > 3)); then
    # if we have 3 rapid successive key pressed
    return 0
  fi
  _LIST_LAST_KEY_PRESSED_TIME=${REPLY}

  case "${action}" in
  # autocompletion box selected item
  scroll-up)
    list::changeSelectedItemIndex "-$((${_LIST_NB_USABLE_LINES_FOR_ITEMS:-10} - 1))"
    list::draw
    ;;
  scroll-down)
    list::changeSelectedItemIndex "$((${_LIST_NB_USABLE_LINES_FOR_ITEMS:-10} - 1))"
    list::draw
    ;;
  move-beginning)
    list::changeSelectedItemIndex "-$((_LIST_ORIGINAL_ITEMS_COUNT + 1))"
    list::draw
    ;;
  move-end)
    list::changeSelectedItemIndex "$((_LIST_ORIGINAL_ITEMS_COUNT + 1))"
    list::draw
    ;;
  move-up)
    list::changeSelectedItemIndex -1
    list::draw
    ;;
  move-down)
    list::changeSelectedItemIndex 1
    list::draw
    ;;
  esac
}

# ## list::getCurrentItemDisplayableString (private)
#
# Truncate a string to a given number of visible characters,
# adds an ellipsis at the end if the string is truncated,
# and highlights the characters that match the filter string.
#
# This function will truncate a string without taking into account
# the ANSI escape sequences for text formatting (i.e. the `\e[*m` format).
#
# - ${_LIST_CURRENT_ITEM} _as string_:
#       the string to truncate
# - ${_LIST_ITEM_WIDTH} _as int_:
#       the number of visible characters
# - ${_LIST_FILTER_STRING} _as string_:
#       the string to search for in the string
# - ${_LIST_STYLE_LETTER_HIGHLIGHT} _as string_:
#       the color to use for highlighting the letters
# - ${_LIST_STYLE_LETTER_HIGHLIGHT_RESET} _as string_:
#       the color reset code to use after highlighting the letters
#
# Returns:
#
# - ${_LIST_CURRENT_ITEM}: the truncated string
# - ${REPLY}: the space left
#       i.e. (_LIST_ITEM_WIDTH - the length of visible characters in _LIST_CURRENT_ITEM)
#
# ```bash
# list::getCurrentItemDisplayableString "This is a long string that will be displayed in the screen." 20
# echo "${_LIST_CURRENT_ITEM}"
# ```
function list::getCurrentItemDisplayableString() {
  local -i stringLength=${#_LIST_CURRENT_ITEM}
  if [[ -z ${_LIST_FILTER_STRING} && ${stringLength} -le ${_LIST_ITEM_WIDTH} ]]; then
    # no filter string, no need to truncate
    if [[ ${_LIST_CURRENT_ITEM} == *$'\e'* ]]; then
      local visibleCharacters="${_LIST_CURRENT_ITEM}"
      string::removeTextFormatting visibleCharacters
      REPLY=$((_LIST_ITEM_WIDTH - ${#visibleCharacters}))
    else
      REPLY=$((_LIST_ITEM_WIDTH - stringLength))
    fi
    return 0
  fi

  local itemDisplayed="" itemChunk itemChunkPiece
  local -i searchStringIndex=0 itemDisplayedLength=0
  local searchStringCharacter="${_LIST_FILTER_STRING:0:1}"

  while ((${#_LIST_CURRENT_ITEM} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${_LIST_CURRENT_ITEM%%$'\e'*}"

    if ((itemDisplayedLength + ${#itemChunk} > _LIST_ITEM_WIDTH)); then
      # we reached the desired size
      itemChunk="${itemChunk:0:$((_LIST_ITEM_WIDTH - 1 - itemDisplayedLength))}…"
      _LIST_CURRENT_ITEM=""
      itemDisplayedLength=${_LIST_ITEM_WIDTH}
    else
      # otherwise we will continue in the next loop
      _LIST_CURRENT_ITEM="${_LIST_CURRENT_ITEM:${#itemChunk}}"
      itemDisplayedLength+=${#itemChunk}
    fi

    if [[ -n ${itemChunk} ]]; then
      # colorize the search string in this chunk
      while [[ -n ${searchStringCharacter} && ${itemChunk} == *"${searchStringCharacter}"* ]]; do
        itemChunkPiece="${itemChunk%%["${searchStringCharacter^}${searchStringCharacter,}"]*}"
        itemDisplayed+="${itemChunkPiece}${_LIST_STYLE_LETTER_HIGHLIGHT}${itemChunk:${#itemChunkPiece}:1}${_LIST_STYLE_LETTER_HIGHLIGHT_RESET}"
        itemChunk="${itemChunk:${#itemChunkPiece}+1}"
        searchStringIndex+=1
        searchStringCharacter="${_LIST_FILTER_STRING:searchStringIndex:1}"
      done

      itemDisplayed+="${itemChunk}"
    fi

    while [[ ${_LIST_CURRENT_ITEM} == $'\e'* ]]; do
      # case where we have an escape sequence at the beginning of the string
      # we only consider escape sequences for text formatting, they end with m
      itemChunk="${_LIST_CURRENT_ITEM%%"m"*}m"
      itemDisplayed+="${itemChunk}"
      _LIST_CURRENT_ITEM="${_LIST_CURRENT_ITEM:${#itemChunk}}"
    done
  done

  _LIST_CURRENT_ITEM="${itemDisplayed}"
  REPLY=$((_LIST_ITEM_WIDTH - itemDisplayedLength))
}

# Modifies the selected item index and adjust the start index if necessary.
#
# - $1: **delta** _as int_:
#       The delta to apply to the current index.
#
# Returns:
#
# - ${_LIST_FILTERED_ITEMS_SELECTED_INDEX}: The new index.
# - ${_LIST_FILTERED_ITEMS_START_INDEX}: The new start index if needed.
#
# ```bash
# list::changeSelectedItemIndex 1
# ```
function list::changeSelectedItemIndex() {
  local delta="${1:-0}"

  # if we have no items, we do nothing
  if [[ ${#_LIST_FILTERED_ITEMS[@]} -eq 0 ]]; then
    _LIST_FILTERED_ITEMS_SELECTED_INDEX=-1
    return 0
  fi

  # change the delta sign if we are in the reverse mode
  if [[ ${_LIST_ENABLE_REVERSE_MODE:-} == "true" ]]; then
    delta=$((delta * -1))
  fi

  local -i newIndex

  # compute the new index
  # cycle through if it was already at the end/beginning
  if ((_LIST_FILTERED_ITEMS_SELECTED_INDEX <= 0 && delta < 0)); then
    newIndex=$((${#_LIST_FILTERED_ITEMS[@]} - 1))
  elif ((_LIST_FILTERED_ITEMS_SELECTED_INDEX >= ${#_LIST_FILTERED_ITEMS[@]} - 1 && delta > 0)); then
    newIndex=0
  else
    newIndex=$((_LIST_FILTERED_ITEMS_SELECTED_INDEX + delta))
    if ((newIndex < 0)); then
      newIndex=0
    elif ((newIndex >= ${#_LIST_FILTERED_ITEMS[@]})); then
      newIndex=$((${#_LIST_FILTERED_ITEMS[@]} - 1))
    fi
  fi

  # now we need to adjust the start index if needed
  # to make sure that the new index is visible on the screen
  if ((newIndex < _LIST_FILTERED_ITEMS_START_INDEX)); then
    _LIST_FILTERED_ITEMS_START_INDEX=${newIndex}
  elif ((newIndex > _LIST_FILTERED_ITEMS_START_INDEX + _LIST_NB_USABLE_LINES_FOR_ITEMS - 1)); then
    _LIST_FILTERED_ITEMS_START_INDEX=$((newIndex - _LIST_NB_USABLE_LINES_FOR_ITEMS + 1))
  fi
  # also to make sure that we use all the space available on screen
  if ((_LIST_FILTERED_ITEMS_START_INDEX + _LIST_NB_USABLE_LINES_FOR_ITEMS > ${#_LIST_FILTERED_ITEMS[@]})); then
    _LIST_FILTERED_ITEMS_START_INDEX=$((${#_LIST_FILTERED_ITEMS[@]} - _LIST_NB_USABLE_LINES_FOR_ITEMS))
    if ((_LIST_FILTERED_ITEMS_START_INDEX < 0)); then
      _LIST_FILTERED_ITEMS_START_INDEX=0
    fi
  fi

  _LIST_FILTERED_ITEMS_SELECTED_INDEX=${newIndex}
}

# Returns the index of the item in the original array (if any, or -1).
# It returns in the REPLY variable.
function list::convertToInitialItemsIndex() {
  local -i filteredIndex=${1}
  if ((filteredIndex >= 0 && filteredIndex < ${#_LIST_FILTERED_ITEMS[@]})); then
    if ((${#_LIST_FILTERED_ITEMS_CORRESPONDENCES[@]} > 0)); then
      REPLY=${_LIST_FILTERED_ITEMS_CORRESPONDENCES[${filteredIndex}]}
    else
      REPLY=${filteredIndex}
    fi
    return 0
  fi
  REPLY=-1
}

function list_startAsyncFiltering() {
  if [[ -v _LIST_ASYNC_FILTER_JOB ]]; then
    return
  fi

  # initial setup of files for async filtering if not done
  if [[ -z ${_ASYNC_FILTERED_ITEMS_FILE:-} ]]; then
    fs::createTempFile pathOnly=true
    _ASYNC_FILTERED_ITEMS_FILE="${REPLY}"

    fs::createTempFile pathOnly=true
    _ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE="${REPLY}"
  fi

  { coproc _LIST_ASYNC_FILTER_JOB { list_asyncFilterJob; }; } 2>./tmp/f-err
  # shellcheck disable=SC2034
  GLOBAL_BACKGROUND_PROCESSES["LIST_ASYNC_FILTER_JOB"]="${_LIST_ASYNC_FILTER_JOB_PID}"

  echo "Async filtering job started" >>./tmp/f
}

function list_stopAsyncFiltering() {
  echo "Async filtering job stopped" >>./tmp/f
  if [[ ! -v _LIST_ASYNC_FILTER_JOB || ! -v _LIST_ASYNC_FILTER_JOB_PID ]]; then
    return
  fi

  kill "${_LIST_ASYNC_FILTER_JOB_PID}" &>/dev/null || :

  unset -v _LIST_ASYNC_FILTER_JOB "GLOBAL_BACKGROUND_PROCESSES[LIST_ASYNC_FILTER_JOB]"

  rm -f "${_ASYNC_FILTERED_ITEMS_FILE}" \
    "${_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
}

function list_asyncFilterWriteItemsToFile() {
  # initial setup of files for filtering with external programs
  case "${_LIST_FILTER_USING_EXTERNAL_PROGRAM:-}" in
  fzf+awk)
    IFS=$'\n'
    # for fzf, we need to display each item with number$'\t'item
    local index
    for ((index = 0; index < ${#_LIST_ORIGINAL_ITEMS[@]}; index++)); do
      printf "%s\t%s\n" "${index}" "${_LIST_ORIGINAL_ITEMS[index]}"
    done >"${_ASYNC_FILTER_ORIGINAL_ITEMS_FILE}"
    ;;
  grep+gawk)
    IFS=$'\n'
    echo "${_LIST_ORIGINAL_ITEMS[*]}" >"${_ASYNC_FILTER_ORIGINAL_ITEMS_FILE}"
    ;;
  esac
}

function list_asyncFilterJob() {
  local IFS

  # make all match case insensitive
  shopt -s nocasematch

  if [[ -n ${_LIST_FILTER_USING_EXTERNAL_PROGRAM:-} ]]; then

    fs::createTempFile pathOnly=true
    local intermediateItemsFile="${REPLY}"
    fs::createTempFile pathOnly=true
    local intermediateItemsCorrespondencesFile="${REPLY}"

    # initial setup of files for filtering with external programs
    case "${_LIST_FILTER_USING_EXTERNAL_PROGRAM:-}" in
    fzf+awk)
      fs::createTempFile pathOnly=true
      local fzfOutputFile="${REPLY}"
      fs::createTempFile pathOnly=true
      local fzfPreviousOutputFile="${REPLY}"
      ;;
    esac

    list_asyncFilterWriteItemsToFile
  fi

  local -a filteredItems filteredItemsCorrespondences

  local instruction filterString
  local lastFilterString=""
  # allows to know if we need to filter from the original items list,
  # or if we can continue to filter down from our last filtering operation
  local filterOriginalItems=true

  while true; do
    # loop and wait to read instructions until we read a filter instruction
    while true; do
      IFS='' read -rd '' instruction || [[ -v instruction ]]

      case "${instruction}" in
      filter=*)
        filterString="${instruction#"filter="}"
        ;;
      reloadItems)
        readarray -t _LIST_ORIGINAL_ITEMS <"${_ASYNC_FILTER_ORIGINAL_ITEMS_FILE}"
        continue
        ;;
      *)
        core::fail "Unknown instruction: ${instruction}"
        ;;
      esac

      if IFS='' read -t 0 -rd ''; then
        continue
      fi
      break
    done

    if [[ ${filterString} != "${lastFilterString}"* ]]; then
      filterOriginalItems=true
    fi

    # filter
    echo "Async filtering <${filterString}>, filterOriginalItems=${filterOriginalItems}, lastFilterString=<${lastFilterString}>" >>./tmp/f

    case "${_LIST_FILTER_USING_EXTERNAL_PROGRAM:-}" in
    fzf+awk)
      # sort with fzf and awk
      echo "using fzf" >>./tmp/f
      : >"${intermediateItemsFile}"
      : >"${intermediateItemsCorrespondencesFile}"

      local fzfInputFile
      if [[ ${filterOriginalItems} == "true" ]]; then
        fzfInputFile="${_ASYNC_FILTER_ORIGINAL_ITEMS_FILE}"
      else
        # reuse the previous output as input
        fzfInputFile="${fzfPreviousOutputFile}"
        mv -f "${fzfOutputFile}" "${fzfPreviousOutputFile}"
      fi

      fzf --ignore-case \
        --tiebreak=begin,end,index \
        --filter="${filterString}" \
        --nth=2 \
        --delimiter='\t' <"${fzfInputFile}" >"${fzfOutputFile}"

      awk "{print \$1 >\"${intermediateItemsCorrespondencesFile}\"; print \$2 >\"${intermediateItemsFile}\"}" "${fzfOutputFile}"

      mv -f "${intermediateItemsFile}" "${_ASYNC_FILTERED_ITEMS_FILE}"
      mv -f "${intermediateItemsCorrespondencesFile}" "${_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
      ;;
    grep+gawk)
      # sort with grep and gawk
      echo "using grep" >>./tmp/f
      : >"${intermediateItemsFile}"
      : >"${intermediateItemsCorrespondencesFile}"

      list_fuzzyFilterSortFileWithGrepAndGawk \
        "${_ASYNC_FILTER_ORIGINAL_ITEMS_FILE}" \
        filterString \
        "${intermediateItemsFile}" \
        "${intermediateItemsCorrespondencesFile}"

      mv -f "${intermediateItemsFile}" "${_ASYNC_FILTERED_ITEMS_FILE}"
      mv -f "${intermediateItemsCorrespondencesFile}" "${_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
      ;;
    *)
      # sort with bash
      echo "using bash" >>./tmp/f
      # We define these to allow array::fuzzyFilterSort to modify the arrays directly (avoiding a copy)
      # shellcheck disable=SC2178
      local -n REPLY_ARRAY=filteredItems
      # shellcheck disable=SC2034
      local -n REPLY_ARRAY2=filteredItemsCorrespondences

      if [[ ${filterOriginalItems} == "true" ]]; then
        echo "start fuzzy filter" >>./tmp/f
        array::fuzzyFilterSort _LIST_ORIGINAL_ITEMS filterString
        echo "end fuzzy filter" >>./tmp/f
      else
        # if the current filter string is a prefix of the previous one, we can filter the already filtered items
        echo "reuse previous filter" >>./tmp/f
        if ((${#filteredItems[@]} > 0)); then
          local -a preFilteredItems=("${filteredItems[@]}")
          local -a preFilteredItemsCorrespondences=("${filteredItemsCorrespondences[@]}")
          array::fuzzyFilterSort preFilteredItems filterString
          # we need to update the correspondences
          local -i index
          for ((index = 0; index < ${#filteredItemsCorrespondences[@]}; index++)); do
            filteredItemsCorrespondences[index]="${preFilteredItemsCorrespondences[${filteredItemsCorrespondences[index]}]}"
          done
        fi
        echo "exec----" >>./tmp/f
      fi

      echo "exec2 bash: filteredItems ${filteredItems:-}, filteredItemsCorrespondences ${filteredItemsCorrespondences:-}" >>./tmp/f

      if ((${#filteredItems[@]} > 0)); then
        IFS=$'\n'
        echo "${filteredItems[*]}" >"${_ASYNC_FILTERED_ITEMS_FILE}"
        echo "${filteredItemsCorrespondences[*]}" >"${_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
      else
        : >"${_ASYNC_FILTERED_ITEMS_FILE}"
      fi
      echo "done bash" >>./tmp/f
      ;;
    esac

    lastFilterString="${filterString}"
    filterOriginalItems=false

    # notify main process that it can read the filtered items
    printf "%s\0" "${lastFilterString}"
    echo "Async filtering done and main notified <${filterString}>" >>./tmp/f
  done

  echo "Async filtering job terminated" >>./tmp/f
}

function list_asyncFilterLoadFilteredItems() {
  if [[ ! -v _LIST_ASYNC_FILTER_JOB ]]; then
    list_startAsyncFiltering
    return 1
  fi
  if ! IFS='' read -rd '' -t 0 <&"${_LIST_ASYNC_FILTER_JOB[0]}"; then
    return 1
  fi

  # read the filter string from the stdout of the background job
  while true; do
    IFS='' read -rd '' _LIST_CURRENT_FILTER_STRING <&"${_LIST_ASYNC_FILTER_JOB[0]}" || [[ -v _LIST_CURRENT_FILTER_STRING ]]
    if IFS='' read -rd '' -t 0 <&"${_LIST_ASYNC_FILTER_JOB[0]}"; then
      continue
    fi
    break
  done

  echo "Loading filtered items for <${_LIST_CURRENT_FILTER_STRING}>" >>./tmp/f

  if [[ -z ${_LIST_CURRENT_FILTER_STRING} ]]; then
    return 1
  fi

  # read the items from the file
  if [[ -s ${_ASYNC_FILTERED_ITEMS_FILE} ]]; then
    readarray -t _LIST_FILTERED_ITEMS <"${_ASYNC_FILTERED_ITEMS_FILE}"
    readarray -t _LIST_FILTERED_ITEMS_CORRESPONDENCES <"${_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
  else
    _LIST_FILTERED_ITEMS=()
    _LIST_FILTERED_ITEMS_CORRESPONDENCES=()
  fi

  echo "Loaded ${#_LIST_FILTERED_ITEMS[@]} items" >>./tmp/f
}

# ## list_fuzzyFilterSortFileWithGrepAndGawk (private)
#
# Allows to fuzzy sort a file against a given searched string.
# Outputs a file containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
#
# Will also output a file containing the indexes of the matched lines in the original file.
#
# - $1: **file to filer** _as string_:
#       The input file to filter.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
# - $3: **output filtered file** _as string_:
#       The output file containing the filtered lines.
# - $4: **output correspondences file** _as string_:
#       The output file containing the indexes of the matched lines in the original file.
#
# ```bash
# list_fuzzyFilterSortFileWithGrepAndGawk file.txt filtered.txt correspondences.txt
# ```
#
# > This is not a pure bash function! Use `array::fuzzyFilterSort` for pure bash alternative.
# > This function is useful for very large arrays.
function list_fuzzyFilterSortFileWithGrepAndGawk() {
  local fileToFilter="${1}"
  regex::getFuzzySearchRegexFromSearchString "${2}"
  local outputFilteredFile="${3}"
  local outputCorrespondencesFile="${4}"

  if [[ -z ${_ARRAY_TEMP_FILTERED_FILE:-} ]]; then
    # shellcheck source=lib-fs
    source fs
    fs::createTempFile pathOnly=true
    _ARRAY_TEMP_FILTERED_FILE="${REPLY}"
  fi

  local grepRegex="${_STRING_FUZZY_FILTER_REGEX:0:${#_STRING_FUZZY_FILTER_REGEX}-4}"
  grepRegex="${grepRegex//[()]/}"
  _STRING_FUZZY_FILTER_REGEX="${_STRING_FUZZY_FILTER_REGEX:1}"

  # we use grep to pre-filter the lines.
  # We could do everything in gawk but it would be slower for huge files.
  grep --ignore-case --line-number "${grepRegex}" "${fileToFilter}" |
    gawk "
    BEGIN {
      # Ignore case when matching the searchString
      IGNORECASE = 1;
      idx = 0;
    }
    {
      # Store each line and its key for sorting (each line is prefixed by 'line_number:' from grep)
      if (match(\$0, /^([0-9]+):${_STRING_FUZZY_FILTER_REGEX}/, m)) {
        lines[idx] = \$0
        lineNumber = m[1] + 0
        if (length(m[2]) == 0 && length(m[4]) == 0) {
          # exact match should always be first
          keys[idx] = lineNumber
        } else {
          # Store the keys for sorting (size of the first match, size of the second match, original line number)
          keys[idx] = length(m[2]) * 10000000 + length(m[3]) * 10000 + lineNumber
        }
        idx++
      }
    }
    END {
      # Sort the lines
      nbLines = length(lines)
      if (nbLines > 1)
        quickSort(keys, lines, 0, nbLines - 1)

      # Output the sorted lines in one file, and the correspondences in another
      for (i = 0; i < nbLines; i++) {
        semiColonIndex = index(lines[i], \":\");
        idx = substr(lines[i], 0, semiColonIndex - 1) - 1;
        print substr(lines[i], semiColonIndex + 1) >> \"${_ARRAY_TEMP_FILTERED_FILE}\"
        print idx >> \"${outputCorrespondencesFile}\"
      }
    }
    function quickSort(keys, lines, low, high) {
      middle = low + (high - low) / 2
      # round to the nearest integer
      middle = middle - middle % 1
      pivot = keys[middle]
      left = low
      right = high
      do {
        while (keys[left] < pivot)
          left++
        while (pivot < keys[right])
          right--
        if (left >= right)
          break
        tempKey = keys[left]
        keys[left] = keys[right]
        keys[right] = tempKey
        tempLine = lines[left]
        lines[left] = lines[right]
        lines[right] = tempLine
        left++
        right--
      } while (0 == 0)
      if (low < right)
        quickSort(keys, lines, low, right)
      if (right + 1 < high)
        quickSort(keys, lines, right + 1, high)
    }
  "
  mv "${_ARRAY_TEMP_FILTERED_FILE}" "${outputFilteredFile}"
}
