#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-terminal
source terminal
# shellcheck source=lib-fs
source fs

# ## prompt::input (private)
#
# Displays a user prompt at a given location.
#
# Allows the user to type a text in the given row between a starting column and
# ending column (included). Longer text are shifted to fit between
# the two columns.
#
# This component is a replacement for the `read -e` command, which allows
# to limit the input to a single line and which provides autocompletion.
#
# The autocompletion box can be hidden, or displayed below/above the input text
# depending on the space available on the screen.
#
# The user can type character to filter down a list of suggestions,
# navigate up and down between suggestions, insert a suggestion using
# TAB or ENTER, press ESC to close the autocompletion box, and ALT+ENTER to
# submit the input (or just ENTER when the box is closed).
#
# The autocompletion box will position itself depending on the screen size
# and the starting position of the text.
#
# The multiple options allows to use this function to ask for any user input
# as long as it is on a single line.
#
# You can define several callback functions that are called on different events:
#
# - `autocompletionOnTextUpdate`: Called when the text is updated (after each key press).
#
# - $1: **start line** _as int_:
#       The line/row at which the autocompleted text starts (this is used to
#       compute how to display the box).
# - $2: **start column** _as int_:
#       The column at which the autocompleted text starts (this is used to
#       compute how to display the box).
# - ${stopColumn} _as int_:
#       (optional) The column at which to stop showing the autocompleted text.
#       Longer texts get shifted to display the end of the user input.
#       (defaults to the end of the screen)
# - ${itemsArrayName} _as string_:
#       (optional) The items to display (name of a global array which contains the items).
#       If left empty, the autocompletion box will not be displayed. Useful to turn this into a simple prompt.
#       (defaults to empty)
# - ${string} _as string_:
#       (optional) The initial string, which corresponds to the text already entered
#       by the user at the moment the autocompletion box shows up.
#       Allows to pre-filter the autocompletion.
#       (defaults to empty)
# - ${itemsBoxForceLeft} _as int_:
#       (optional) The left column at which to display the autocompletion box.
#       If left empty, the box will auto position itself according to the prompt.
#       (defaults to empty)
# - ${itemsBoxForceTop} _as int_:
#       (optional) The top line at which to display the autocompletion box.
#       If left empty, the box will auto position itself according to the prompt.
#       (defaults to empty)
# - ${itemsBoxForceWidth} _as int_:
#       (optional) The width of the autocompletion box.
#       If left empty, the box will auto compute its width according to the items.
#       (defaults to empty)
# - ${itemsBoxForceHeight} _as int_:
#       (optional) The height of the autocompletion box.
#       If left empty, the box will auto compute its height according to the items.
#       (defaults to empty)
# - ${itemsBoxMaxHeight} _as int_:
#       (optional) The maximum number of lines/rows to use for the autocompletion box.
#       If the number of items is greater than this value, the box will be scrollable.
#       (defaults to a maximized auto-computed value depending on the items and screen size)
# - ${itemsBoxForceBelow} _as bool_:
#       (optional) If true, the box is forced to be displayed below the input text.
#       Otherwise it will depend on the space required and space available below/above.
#       (defaults to false)
# - ${itemsBoxItemCountEnabled} _as bool_:
#       (optional) If true, the count of items can be displayed at the bottom of the box.
#       (defaults to true)
# - ${itemsBoxForceShowCount} _as bool_:
#       (optional) If true, the count of items is always displayed.
#       If false, the count is only displayed when we can't display all the items at once.
#       (defaults to false)
# - ${itemsBoxShowCountAtTop} _as bool_:
#       (optional) If true, the count of items will be displayed at the top of the box instead of the bottom.
#       (defaults to false)
# - ${itemsBoxFilterAsynchronouslyThreshold} _as int_:
#       (optional) The number of items at which the filtering is done asynchronously.
#       If the number of items is greater than this value, the filtering is done asynchronously.
#       Can be set to 0 to force asynchronous filtering.
#       (defaults to 242)
# - ${itemsBoxFilterUsingExternalProgramThreshold} _as int_:
#       (optional) The number of items at which the filtering is done using an external program.
#       If the number of items is greater than this value, the filtering is done using an external program.
#       This is to avoid performance issues when filtering a large number of items using pure bash.
#       (defaults to 1042)
# - ${enablePrompt} _as bool_:
#       (optional) If true, the prompt is displayed. If false, the prompt is hidden.
#       Useful to turn this into a simple multiple choice list.
#       (defaults to true)
# - ${showSymbol} _as bool_:
#       (optional) If true, the left cursors are displayed (> for prompt and the ◆ for selected item).
#       Useful to display the most simple auto-completion when false.
#       (defaults to true)
# - ${filterS_FROM_N_CHARS} _as int_:
#       (optional) The minimum number of characters to type before starting to filter the items.
#       By default, the list is shown full and the user can start typing to filter.
#       Put a value superior to 0 to make it behave like a standard autocompletion.
#       When non-zero, the user can TAB to show the full list.
#       (defaults to 0)
# - ${acceptAnyValue} _as bool_:
#       (optional) If true, the user can type any value, even if it is not in the list.
#       If false, the user can only select a value from the list.
#       (defaults to true)
# - ${placeholder} _as string_:
#       (optional) The placeholder to display when the input is empty.
#       (defaults to empty)
# - ${string_MAX_LENGTH} _as int_:
#       (optional) The maximum length of the input string.
#       If the user types more characters, they are truncated and an error message is displayed.
#       (defaults to 99999)
# - ${autocompleteWholeLine} _as bool_:
#       (optional) If true, the whole line is autocompleted (all characters are considered to filter)
#       the items. If false, only the word characters before the cursor are considered.
#       (defaults to false)
# - ${tabOpensItemsBox} _as bool_:
#       (optional) If true, the tab key opens the items box if it is not already open.
#       (defaults to true)
# - ${itemsBoxAllowFiltering} _as bool_:
#       (optional) If true, the items can be filtered by typing characters.
#       If false, the items are displayed as is.
#       (defaults to the value of `enablePrompt` or true)
# - ${passwordMode} _as bool_:
#       (optional) If true, the input is displayed as a series of stars *.
#       This mode can be activated/deactivated by pressing CTRL+P.
#       (defaults to false)
# - ${callbackFunctionOnTextUpdate} _as string_:
#       (optional) The name of a function to call each time the text is updated.
#       Can be used to validate the input and display an error message.
#       The function is called with no arguments but you can use the global variable `string` and
#       `string_INDEX` to access the current text and cursor position.
#       You must set:
#
#       - `REPLY`: The error message to display (or empty).
#       - `REPLY2`: A boolean to indicate if the autocompletion box should be redrawn.
#
#       (defaults to empty)
# - ${callbackFunctionOnKeyPressed} _as string_:
#       (optional) The name of a function to call each time a key is pressed.
#       Can be used to customize the behavior of the prompt.
#       The function is called with the following arguments:
#
#       - $1: The key that was pressed, including special keys (CTRL+, ALT+, TAB, etc...).
#       - $2: The last character that was sent by the terminal, if any (can be empty when key is not empty).
#
#       The function must return 0 if the key press was handled, 1 otherwise.
#       (defaults to empty)
# - ${callbackFunctionOnBoxClosed} _as string_:
#       (optional) The name of a function to call when the autocompletion box is closed.
#       Can be used to clean up resources or to update the screen.
#       The function is called with arguments:
#
#       - $1: The top line number of the box that was just closed.
#       - $2: The left column of the box.
#       - $3: The width of the box.
#       - $4: The height of the box.
#
#       The function must return 0 to state that prompt does not have to be redrawn, 1 otherwise.
#       (defaults to empty)
# - ${callbackFunctionOnItemDisplay} _as string_:
#       (optional) The name of a function to call when an item needs to be displayed in the list.
#       This will replace the default function that displays the item with highlighted characters.
#       The following variables are available:
#
#       - ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED} _as string_:
#             the string of the item as it is defined in the array
#       - ${_PROMPT_ITEMS_BOX_ITEM_WIDTH} _as int_:
#             the width of the item box (to truncate the string)
#       - ${_PROMPT_ITEMS_BOX_FILTER_STRING} _as string_:
#             the user current input string (to highlight the characters)
#
#       The function should return:
#
#       - ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}: the string to display
#       - ${REPLY}: the space left
#
#       (defaults to empty)
#
# Returns:
#
# - $?:
#   - 0: The user pressed ENTER to validate the text.
#   - 1: The user pressed ESC to close the text box.
# - ${REPLY}: The entered value (or empty).
# - ${REPLY2}: The string displayed on the screen between the 2 columns at the
#                      moment when the autocompletion was closed.
#
# ```bash
# prompt::input "Select an item" item_array_name "onItemSelected" "Details"
# ```
function prompt::input() {
  # shellcheck disable=SC2086
  unset -v ${!_PROMPT_*}

  _PROMPT_START_LINE="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  _PROMPT_START_COLUMN="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  _PROMPT_STOP_COLUMN="${stopColumn:-${GLOBAL_COLUMNS}}"
  _PROMPT_STOP_COLUMN_AT_END="false"
  if [[ -z ${stopColumn:-} ]]; then
    _PROMPT_STOP_COLUMN_AT_END="true"
  fi

  _PROMPT_ITEMS_ARRAY_NAME="${itemsArrayName:-}"

  _PROMPT_STRING="${string:-}"

  _PROMPT_ITEMS_BOX_FORCED_LEFT="${itemsBoxForceLeft:-}"
  _PROMPT_ITEMS_BOX_FORCED_TOP="${itemsBoxForceTop:-}"
  _PROMPT_ITEMS_BOX_FORCED_WIDTH="${itemsBoxForceWidth:-}"
  _PROMPT_ITEMS_BOX_FORCED_HEIGHT="${itemsBoxForceHeight:-}"

  _PROMPT_ITEMS_BOX_MAX_HEIGHT="${itemsBoxMaxHeight:-}"
  _PROMPT_ITEMS_BOX_FORCE_BELOW="${itemsBoxForceBelow:-false}"

  _PROMPT_ENABLE_PROMPT="${enablePrompt:-true}"
  _PROMPT_ITEMS_BOX_ITEM_COUNT_ENABLED="${itemsBoxItemCountEnabled:-true}"
  _PROMPT_ITEMS_BOX_FORCE_SHOW_COUNT="${itemsBoxForceShowCount:-false}"
  _PROMPT_ITEMS_BOX_SHOW_COUNT_AT_TOP="${itemsBoxShowCountAtTop:-false}"

  _PROMPT_SHOW_SYMBOL="${showSymbol:-true}"
  _PROMPT_FILTERS_FROM_N_CHARS="${filterS_FROM_N_CHARS:-0}"

  _PROMPT_ACCEPT_ANY_VALUE="${acceptAnyValue:-true}"

  _PROMPT_PLACEHOLDER="${placeholder:-}"
  _PROMPT_STRING_MAX_LENGTH="${string_MAX_LENGTH:-99999}"

  _PROMPT_AUTOCOMPLETE_WHOLE_LINE="${autocompleteWholeLine:-false}"
  _PROMPT_TAB_OPENS_ITEMS_BOX="${tabOpensItemsBox:-true}"
  _PROMPT_ITEMS_BOX_ALLOW_FILTERING="${itemsBoxAllowFiltering:-${_PROMPT_ENABLE_PROMPT}}"
  _PROMPT_PASSWORD_MODE="${passwordMode:-false}"

  _PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE="${callbackFunctionOnTextUpdate:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE} ]] && ! declare -F "${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED="${callbackFunctionOnKeyPressed:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]] && ! declare -F "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED="${callbackFunctionOnBoxClosed:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]] && ! declare -F "${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY="${callbackFunctionOnItemDisplay:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY} ]]; then
    if ! declare -F "${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY}" &>/dev/null; then
      core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY}⌝ does not exist."
    fi
  else
    _PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY="list::getCurrentItemDisplayableString"
  fi

  _PROMPT_ITEMS_BOX_FILTER_ASYNCHRONOUSLY_THRESHOLD="${itemsBoxFilterAsynchronouslyThreshold:-242}"
  _PROMPT_ITEMS_BOX_FILTER_USING_EXTERNAL_PROGRAM_THRESHOLD="${itemsBoxFilterUsingExternalProgramThreshold:-1042}"

  # default key mapping using the
  # - control characters: https://jvns.ca/ascii
  # - default emacs mapping for bash readline
  local -A _PROMPT_KEY_MAPPING=(
    ["CTRL+ALT+M"]="accept-line"
    ["CTRL+M"]="accept-line"
    ["CTRL+J"]="accept-line"
    ["NEWLINE"]="accept-line"
    ["TAB"]="complete"
    ["CTRL+I"]="complete"
    ["ESC"]="close"
    ["CTRL+Q"]="abort"
    ["CTRL+A"]="beginning-of-line"
    ["CTRL+E"]="end-of-line"
    ["LEFT"]="backward-char"
    ["CTRL+B"]="backward-char"
    ["RIGHT"]="forward-char"
    ["CTRL+F"]="forward-char"
    ["CTRL+LEFT"]="backward-word"
    ["CTRL+RIGHT"]="forward-word"
    ["CTRL+K"]="kill-end-of-line"
    ["CTRL+X"]="kill-line"
    ["CTRL+U"]="kill-line"
    ["CTRL+Y"]="yank"
    ["DEL"]="delete-char"
    ["CTRL+D"]="delete-char"
    #["CTRL+P"]="prev-line"
    #["CTRL+N"]="next-line"
    #["CTRL+L"]="clear-all"
    ["CTRL+H"]="backward-delete-char"
    ["CTRL+?"]="backward-delete-char"
    ["BACKSPACE"]="backward-delete-char"
    ["CTRL+DEL"]="kill-word"
    ["CTRL+BACKSPACE"]="backward-kill-word"
    ["CTRL+W"]="backward-kill-word"
    ["CTRL+P"]="toggle-password-mode"
    ["PAGE_UP"]="scroll-up"
    ["PAGE_DOWN"]="scroll-down"
    ["HOME"]="move-beginning"
    ["CTRL+UP"]="move-beginning"
    ["END"]="move-end"
    ["CTRL+DOWN"]="move-end"
    ["UP"]="move-up"
    ["DOWN"]="move-down"
  )
  if [[ -v VALET_CONFIG_PROMPT_KEY_MAPPING ]]; then
    local key
    for key in "${!VALET_CONFIG_PROMPT_KEY_MAPPING[@]}"; do
      _PROMPT_KEY_MAPPING["${key}"]="${VALET_CONFIG_PROMPT_KEY_MAPPING[${key}]}"
    done
  fi

  # set up the left symbols (> for prompt and the > for selected item)
  if [[ ${_PROMPT_SHOW_SYMBOL} == "true" ]]; then
    _PROMPT_SYMBOL="${SYMBOL_PROMPT}"
    _PROMPT_SYMBOL_LENGTH="${SYMBOL_PROMPT_LENGTH}"
    _PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM}"
    _PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM}"
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_COUNTER}"
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_BELOW="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_BELOW}"
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_ABOVE="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_ABOVE}"
    _PROMPT_ITEMS_BOX_SYMBOL_LENGTH="${STYLE_PROMPT_ITEMS_BOX_SYMBOL_LENGTH}"
    _PROMPT_ERROR_BOX_SYMBOL="${SYMBOL_PROMPT_ERROR_BOX}"
    _PROMPT_ERROR_BOX_SYMBOL_LENGTH="${SYMBOL_PROMPT_ERROR_BOX_LENGTH}"
  else
    _PROMPT_SYMBOL=""
    _PROMPT_SYMBOL_LENGTH=0
    _PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM=""
    _PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM=""
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER=""
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_ABOVE=""
    _PROMPT_ITEMS_BOX_SYMBOL_LENGTH=0
    _PROMPT_ERROR_BOX_SYMBOL=""
    _PROMPT_ERROR_BOX_SYMBOL_LENGTH=0
  fi

  _PROMPT_KILLED_STRING=""
  _PROMPT_STRING_INDEX=${#_PROMPT_STRING}
  GLOBAL_CURSOR_LINE="${_PROMPT_START_LINE}"
  GLOBAL_CURSOR_COLUMN=$((_PROMPT_START_COLUMN + _PROMPT_SYMBOL_LENGTH + _PROMPT_STRING_INDEX))

  prompt_setItemsListVariables

  # check if we display the autocompletion box, and the initial state of the box (shown or hidden)
  if ((_PROMPT_ORIGINAL_ITEMS_COUNT > 0)); then
    _PROMPT_ITEMS_BOX_ENABLED=true
    if ((${#_PROMPT_STRING} >= _PROMPT_FILTERS_FROM_N_CHARS)); then
      _PROMPT_ITEMS_BOX_SHOWN=true
    else
      _PROMPT_ITEMS_BOX_SHOWN=false
    fi
  else
    _PROMPT_ITEMS_BOX_ENABLED=false
    _PROMPT_ITEMS_BOX_SHOWN=false
  fi
  _PROMPT_ERROR_BOX_SHOWN=false

  _PROMPT_ITEMS_BOX_REVERSE_MODE=false

  if [[ ${_PROMPT_ITEMS_BOX_ENABLED} != "true" ]]; then
    # if we don't show the box, we necessarily accept any value
    _PROMPT_ACCEPT_ANY_VALUE=true
  elif [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    # if don't show the prompt, we don't accept any value
    _PROMPT_ACCEPT_ANY_VALUE=false
  fi

  # compute properties that depend on the screen size
  prompt_setSizeVariables

  _PROMPT_LAST_KEY_PRESSED_TIME=0
  _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
  _PROMPT_CANCELLED=true

  if prompt_main_loop; then
    return 0
  fi
  return 1
}

function prompt::setItems() {
  local itemsArrayName="${1:-}"

  if [[ -n ${itemsArrayName} ]]; then
    declare -g -n _LIST_ORIGINAL_ITEMS="${itemsArrayName}"
    _LIST_PREFERRED_WIDTH=0
    local item
    for item in "${_LIST_ORIGINAL_ITEMS[@]}"; do
      if ((${#item} > _LIST_PREFERRED_WIDTH)); then
        _LIST_PREFERRED_WIDTH=${#item}
        if ((_LIST_PREFERRED_WIDTH > GLOBAL_COLUMNS)); then
          break
        fi
      fi
    done
    _LIST_ORIGINAL_ITEMS_COUNT=${#_LIST_ORIGINAL_ITEMS[@]}
    _LIST_PREFERRED_HEIGHT=${#_LIST_ORIGINAL_ITEMS[@]}
  else
    _LIST_ORIGINAL_ITEMS=()
    _LIST_ORIGINAL_ITEMS_COUNT=0
    _LIST_PREFERRED_WIDTH=0
    _LIST_PREFERRED_HEIGHT=0
  fi

  if [[ ${_LIST_FORCE_SHOW_ITEMS_COUNT} == "true" ]]; then
    _LIST_PREFERRED_HEIGHT=$((_LIST_PREFERRED_HEIGHT + 1))
  fi

  _LIST_ORIGINAL_ITEMS_SELECTED_INDEX=-1

  local itemCountWidth=$((8 + ${#_LIST_ORIGINAL_ITEMS_COUNT} * 4))
  if ((_LIST_PREFERRED_WIDTH < itemCountWidth)); then
    # the width necessary to display the count of items
    _LIST_PREFERRED_WIDTH=${itemCountWidth}
  fi

  if [[ ${_LIST_SHOW_SYMBOL} == "true" ]]; then
    _LIST_PREFERRED_WIDTH=$((_LIST_PREFERRED_WIDTH + _LIST_SYMBOL_LENGTH))
  fi
}

function prompt_main_loop() {
  # set trap so that interrupt signal sets GLOBAL_SESSION_INTERRUPTED to true
  terminal::setInterruptTrap
  # before starting to wait for inputs, we clear up the key pressed
  terminal::clearKeyPressed
  # setup the terminal to be ready for readline
  terminal::setRawMode
  # rebind some keys to call the callback function prompt_onKeyBindingPress
  terminal::rebindKeymap prompt_onKeyBindingPress
  terminal::rerouteLogs
  # we redirect everything done in this function to fd 3 which prints to stderr
  # we need this because terminal::waitForKeyPress redirects stderr to /dev/null
  exec 3>&2

  # make all match case insensitive
  shopt -s nocasematch

  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
    prompt_showItemsBox
  fi
  prompt_drawPrompt

  # main loop
  while true; do
    if terminal::waitForKeyPress -t 0.2; then
      prompt_onKeyPressed "${LAST_KEY_PRESSED}"
    fi

    # in case of a terminal resize, we will have to redraw
    if [[ ${GLOBAL_SCREEN_REDRAW_REQUIRED:-} == "true" ]]; then
      local isItemBoxShown="${_PROMPT_ITEMS_BOX_SHOWN}"
      prompt_clearPrompt
      list::hide
      prompt_clearErrorBox
      prompt_setSizeVariables
      if [[ ${isItemBoxShown} == "true" ]]; then
        prompt_showItemsBox
      fi
      prompt_drawPrompt
      GLOBAL_SCREEN_REDRAW_REQUIRED=false
    fi

    # check if the background job for async filtering is done
    if [[ ${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY} != "true" ]] && list_asyncFilterLoadFilteredItems; then
      echo "redraw item box after async filtering ${_PROMPT_ASYNC_FILTERING_LAST_REQUESTED_STRING} vs ${_PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING}" >>./tmp/f
      if [[ ${_PROMPT_ASYNC_FILTERING_LAST_REQUESTED_STRING} == "${_PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING}" ]]; then
        _PROMPT_ASYNC_FILTERING_RUNNING=false
      fi
      list::draw
    fi

    # break if fd 0 is closed or does not refer to a terminal.
    if [[ ! -t 0 || ${GLOBAL_SESSION_INTERRUPTED} == "true" ]]; then
      break
    fi
  done

  # clean up
  list_stopAsyncFiltering
  prompt_clearErrorBox
  list::hide
  prompt_clearPrompt
  exec 3>&-

  terminal::restoreLogs
  terminal::restoreSettings
  terminal::restoreInterruptTrap
  shopt -u nocasematch

  if [[ ${_PROMPT_CANCELLED:-} == "true" ]]; then
    return 1
  else
    REPLY="${_PROMPT_STRING}"
    if ((_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX >= 0)); then
      REPLY2="${_PROMPT_ORIGINAL_ITEMS[${_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX}]}"
    else
      REPLY2=""
    fi
    # shellcheck disable=SC2034
    REPLY3=${_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX}
  fi

  # shellcheck disable=SC2086
  unset -v ${!_PROMPT_*}
}

# compute properties that depend on the screen size
function prompt_setSizeVariables() {
  if ((_PROMPT_START_LINE > GLOBAL_LINES)); then
    _PROMPT_START_LINE=${GLOBAL_LINES}
  fi
  if ((_PROMPT_START_COLUMN > GLOBAL_COLUMNS)); then
    _PROMPT_START_COLUMN=${GLOBAL_COLUMNS}
  fi
  if ((_PROMPT_STOP_COLUMN > GLOBAL_COLUMNS)); then
    _PROMPT_STOP_COLUMN=${GLOBAL_COLUMNS}
  fi
  if [[ ${_PROMPT_STOP_COLUMN_AT_END} == "true" ]]; then
    _PROMPT_STOP_COLUMN=${GLOBAL_COLUMNS}
  fi

  _PROMPT_WIDTH=$((_PROMPT_STOP_COLUMN - _PROMPT_START_COLUMN + 1))

  if [[ ${_PROMPT_SHOW_SYMBOL} == "true" ]]; then
    _PROMPT_STRING_SCREEN_WIDTH=$((_PROMPT_WIDTH - _PROMPT_SYMBOL_LENGTH))
  else
    _PROMPT_STRING_SCREEN_WIDTH=${_PROMPT_WIDTH}
  fi

  printf -v _PROMPT_STRING_BLANKS "%${_PROMPT_STRING_SCREEN_WIDTH}s" " "
}

# Called when a special key is pressed.
#
# - $1: **key** _as string_:
#       The special key that was pressed (CTRL+, ALT+, TAB, etc...).
#
# define the callback function called when a special key is pressed
# shellcheck disable=SC2317
function prompt_onKeyBindingPress() {
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" "" "${1}"; then
      return 0
    fi
  fi

  local action="${_PROMPT_KEY_MAPPING[${1}]:-}"
  if [[ -z ${action} ]]; then
    return 0
  fi

  case "${action}" in
  accept-line)
    # in autocompletion mode we can only validate if we autocompletion is closed, otherwise it autocompletes
    if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" && ${_PROMPT_ACCEPT_ANY_VALUE} == "true" ]]; then
      prompt_autocompleteWithSelectedItem
      return 0
    fi

    # if we selected index is within the range of the filtered items
    # we can return the corresponding index in the original items
    list::getCurrentInitialItemsIndex
    if [[ ${REPLY} == "-1" ]]; then
      if [[ ${_PROMPT_ACCEPT_ANY_VALUE} != "true" ]]; then
        # make enter have no effect if we are not on a valid item and we don't accept any value
        prompt_showError "No item matching your query!"
        return 0
      fi
      _PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX=${REPLY}
    fi
    if [[ ${_PROMPT_ACCEPT_ANY_VALUE} == "true" && ${_PROMPT_STRING} == "" ]]; then
      # make enter have no effect if we accept any value but we have an empty string
      prompt_showError "Please enter a value!"
      return 0
    fi
    GLOBAL_SESSION_INTERRUPTED=true
    _PROMPT_CANCELLED=false
    return 0
    ;;
  complete)
    # autocompletes if the box is shown, otherwise it opens the box (if allowed)
    if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
      prompt_autocompleteWithSelectedItem
    elif [[ ${_PROMPT_TAB_OPENS_ITEMS_BOX} == "true" ]]; then
      prompt_showItemsBox
    else
      prompt_insertTextAtCurrentIndex $'\t'
      prompt_onTextChanged
    fi
    ;;
  close)
    if [[ ${_PROMPT_ERROR_BOX_SHOWN} == "true" ]]; then
      prompt_clearErrorBox
      return 0
    fi
    # interrupt the prompt session or close the autocompletion box
    if [[ ${_PROMPT_ACCEPT_ANY_VALUE} == "true" && ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
      list::hide
      return 0
    fi
    GLOBAL_SESSION_INTERRUPTED=true
    ;;
  abort)
    GLOBAL_SESSION_INTERRUPTED=true
    ;;

  # move the cursor
  beginning-of-line)
    prompt_changePromptCursorIndex -9999999
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  end-of-line)
    prompt_changePromptCursorIndex 9999999
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  backward-char)
    prompt_changePromptCursorIndex -1
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  forward-char)
    prompt_changePromptCursorIndex 1
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  backward-word)
    # move to beginning of the previous word
    prompt_getIndexDeltaToBeginningOfWord
    prompt_changePromptCursorIndex "${REPLY}"
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  forward-word)
    prompt_getIndexDeltaToEndOfWord
    prompt_changePromptCursorIndex "${REPLY}"
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;

  # modify the text
  kill-end-of-line)
    # kill the line from cursor to the end
    _PROMPT_KILLED_STRING="${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    if ((_PROMPT_STRING_INDEX > 0)); then
      _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}"
    else
      _PROMPT_STRING=""
    fi
    list::hide
    prompt_onTextChanged
    ;;
  kill-line)
    # kill the line
    _PROMPT_KILLED_STRING="${_PROMPT_STRING}"
    _PROMPT_STRING=""
    _PROMPT_STRING_INDEX=0
    list::hide
    prompt_onTextChanged
    ;;
  yank)
    # yank the killed string at cursor position
    if [[ -n ${_PROMPT_KILLED_STRING:-} ]]; then
      prompt_insertTextAtCurrentIndex "${_PROMPT_KILLED_STRING}"
      prompt_onTextChanged
    fi
    ;;
  delete-char)
    # delete the character under the cursor
    local tempUserString
    if ((_PROMPT_STRING_INDEX > 0)); then
      tempUserString="${_PROMPT_STRING:0:${_PROMPT_STRING_INDEX}}"
    else
      tempUserString=""
    fi
    if ((_PROMPT_STRING_INDEX < ${#_PROMPT_STRING} - 1)); then
      tempUserString+="${_PROMPT_STRING:_PROMPT_STRING_INDEX+1}"
    fi
    _PROMPT_STRING="${tempUserString}"
    prompt_onTextChanged
    ;;
  backward-delete-char)
    # delete the character before the cursor
    if ((_PROMPT_STRING_INDEX > 0)); then
      if ((_PROMPT_STRING_INDEX > 1)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX-1}${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      fi
    fi
    prompt_changePromptCursorIndex -1
    prompt_onTextChanged
    ;;
  kill-word)
    # delete all chars from the cursor to the end of (this or next) word
    local -i oldIndex=${_PROMPT_STRING_INDEX}
    prompt_getIndexDeltaToEndOfWord
    prompt_changePromptCursorIndex "${REPLY}"
    if ((_PROMPT_STRING_INDEX > oldIndex)); then
      _PROMPT_KILLED_STRING="${_PROMPT_STRING:${oldIndex}:_PROMPT_STRING_INDEX-oldIndex}"
      if ((oldIndex > 0)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:${oldIndex}}${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      fi
      _PROMPT_STRING_INDEX=${oldIndex}
    fi
    prompt_onTextChanged
    ;;
  backward-kill-word)
    # delete all chars before the cursor until reaching a space
    local -i oldIndex=${_PROMPT_STRING_INDEX}
    prompt_getIndexDeltaToBeginningOfWord
    prompt_changePromptCursorIndex "${REPLY}"
    if ((oldIndex > _PROMPT_STRING_INDEX)); then
      _PROMPT_KILLED_STRING="${_PROMPT_STRING:_PROMPT_STRING_INDEX:oldIndex-_PROMPT_STRING_INDEX}"
      if ((_PROMPT_STRING_INDEX > 0)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}${_PROMPT_STRING:oldIndex}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:oldIndex}"
      fi
    fi
    prompt_onTextChanged
    ;;
  toggle-password-mode)
    # reveal/hide the prompt
    if [[ ${_PROMPT_PASSWORD_MODE} == "true" ]]; then
      _PROMPT_PASSWORD_MODE=false
    else
      _PROMPT_PASSWORD_MODE=true
    fi
    prompt_drawPrompt
    ;;
  *)
    # handle spamming of keys (the actions before this do not need to be protected from spam,
    # but the actions after this are slow to execute and should not be spammed)
    time::getProgramElapsedMicroseconds
    if ((REPLY - _PROMPT_LAST_KEY_PRESSED_TIME < 100000)); then
      # key pressed under 100ms of the last
      _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=$((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED + 1))
    else
      _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
    fi
    if ((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED > 3)); then
      # if we have 3 rapid successive key pressed
      return 0
    fi
    _PROMPT_LAST_KEY_PRESSED_TIME=${REPLY}


    case "${action}" in
    # autocompletion box selected item
    scroll-up)
      list::changeSelectedItemIndex "-$((${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS:-10} - 1))"
      list::draw
      ;;
    scroll-down)
      list::changeSelectedItemIndex "$((${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS:-10} - 1))"
      list::draw
      ;;
    move-beginning)
      list::changeSelectedItemIndex "-$((_PROMPT_ORIGINAL_ITEMS_COUNT + 1))"
      list::draw
      ;;
    move-end)
      list::changeSelectedItemIndex "$((_PROMPT_ORIGINAL_ITEMS_COUNT + 1))"
      list::draw
      ;;
    move-up)
      list::changeSelectedItemIndex -1
      list::draw
      ;;
    move-down)
      list::changeSelectedItemIndex 1
      list::draw
      ;;
    esac
  esac
}

# Called when a key is pressed.
#
# - $1: **char sent** _as string_:
#       The last character that was sent by the terminal
#
function prompt_onKeyPressed() {
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" "${1}" ""; then
      return 0
    fi
  fi

  # if the key is actually a special keys
  case ${1} in
  $'\b' | $'\177')
    prompt_onKeyBindingPress "BACKSPACE"
    return 0
    ;;
  $'\023')
    prompt_onKeyBindingPress "CTRL+BACKSPACE"
    return 0
    ;;
  $'\r' | $'\n')
    prompt_onKeyBindingPress "NEWLINE"
    return 0
    ;;
  esac

  # if it is too long warn the user
  if ((${#_PROMPT_STRING} >= _PROMPT_STRING_MAX_LENGTH)); then
    prompt_showError "The input can't exceed a maximum of ${_PROMPT_STRING_MAX_LENGTH} characters."
    # read the stream until the end to clear the buffer
    local IFS=''
    read -d '' -sr -t 0.2 _ || :
    return 0
  fi

  prompt_insertTextAtCurrentIndex "${1}"
  prompt_onTextChanged

  # here we handle the case where the user pastes a string (or spam a key)
  time::getProgramElapsedMicroseconds
  if ((REPLY - _PROMPT_LAST_KEY_PRESSED_TIME < 200000)); then
    # key pressed under 200ms of the last
    _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=$((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED + 1))
  else
    _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
  fi
  if ((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED > 10)); then
    # if we have 10 rapid successive key pressed, we consider it as a paste
    local IFS='' copiedText
    read -d '' -s -r -t 0.2 copiedText 2>/dev/null || :
    if [[ -n ${copiedText:-} ]]; then
      prompt_insertTextAtCurrentIndex "${copiedText}"
      prompt_onTextChanged
      return 0
    fi
  fi
  _PROMPT_LAST_KEY_PRESSED_TIME=${REPLY}

  # check if we need to open the items box
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" && ${1} != " " ]]; then
    if [[ ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} == "true" ]]; then
      if ((${#_PROMPT_STRING} >= _PROMPT_FILTERS_FROM_N_CHARS)); then
        prompt_showItemsBox
        return 0
      fi
    else
      # count the number of characters that are not spaces before the cursor
      local -i count=0
      while [[ ${count} -lt ${_PROMPT_FILTERS_FROM_N_CHARS} && $((_PROMPT_STRING_INDEX - count - 1)) -gt 0 && ${_PROMPT_STRING:_PROMPT_STRING_INDEX-count-1:1} == [^[:space:]] ]]; do
        count+=1
      done
      if ((count >= _PROMPT_FILTERS_FROM_N_CHARS)); then
        prompt_showItemsBox
        return 0
      fi
    fi
  fi
}

# Called when the prompt string changes
function prompt_onTextChanged() {
  local shownError=false

  # close error box if shown
  if [[ ${_PROMPT_ERROR_BOX_SHOWN} == "true" ]]; then
    prompt_clearErrorBox
  fi

  # truncate the string if it is too long and warn the user
  if ((${#_PROMPT_STRING} > _PROMPT_STRING_MAX_LENGTH)); then
    _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_MAX_LENGTH}"
    if ((_PROMPT_STRING_INDEX > _PROMPT_STRING_MAX_LENGTH)); then
      _PROMPT_STRING_INDEX=${_PROMPT_STRING_MAX_LENGTH}
    fi
    prompt_showError "The input exceeds the maximum of ${_PROMPT_STRING_MAX_LENGTH} characters, it has been truncated."
    shownError=true

    # read the stream until the end to clear the buffer
    local IFS
    IFS='' read -d '' -sr -t 0.2 _ || :
  fi

  # call the callback function on text update if it is enabled (and we did not just update the cursor)
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE} ]]; then
    ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}
    if [[ -n ${REPLY} ]]; then
      prompt_showError "${REPLY}"
      shownError=true
    fi
    if [[ ${REPLY2:-false} == "true" ]]; then
      list::draw
    fi
  fi

  # update the prompt
  prompt_drawPrompt

  # filter the items and update the items box
  if [[ ${shownError} != "true" ]]; then
    prompt_updateItemsBox
  fi
}

# Draw the prompt line
function prompt_drawPrompt() {
  if [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    return 0
  fi

  # use interactive::showStringInScreen with global the variables: _PROMPT_STRING, _PROMPT_STRING_INDEX, _PROMPT_STRING_SCREEN_WIDTH
  prompt_getDisplayedPromptString
  GLOBAL_CURSOR_LINE="${_PROMPT_START_LINE}"
  GLOBAL_CURSOR_COLUMN=$((_PROMPT_START_COLUMN + _PROMPT_SYMBOL_LENGTH + REPLY2))
  local -i spaceLeft=$((_PROMPT_STRING_SCREEN_WIDTH - ${#REPLY}))

  if [[ ${_PROMPT_PASSWORD_MODE} == "true" ]]; then
    REPLY="${REPLY//[^…]/*}"
  fi
  if [[ -z ${REPLY} && -n ${_PROMPT_PLACEHOLDER} ]]; then
    REPLY="${STYLE_FRAMES}${_PROMPT_PLACEHOLDER}${STYLE_RESET}"
    spaceLeft=$((_PROMPT_STRING_SCREEN_WIDTH - ${#_PROMPT_PLACEHOLDER}))
  fi
  local spaces=""
  if ((spaceLeft > 0)); then
    spaces="${_PROMPT_STRING_BLANKS:0:spaceLeft}"
  fi

  printf '%s' "${ESC__CURSOR_HIDE}${ESC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__ESC__TO}${STYLE_FRAMES}${_PROMPT_SYMBOL}${STYLE_RESET}${STYLE_PROMPT_STRING}${REPLY}${spaces}${STYLE_RESET}${ESC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__ESC__TO}${ESC__CURSOR_SHOW_FORCE}" 1>&3
}

# Clear the prompt line
function prompt_clearPrompt() {
  if [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    return 0
  fi

  printf '%s' "${ESC__CURSOR_HIDE}${ESC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__ESC__TO}${ESC__ERASE__}${_PROMPT_WIDTH}${__ECS__CHARS}${ESC__CURSOR_SHOW_FORCE}" 1>&3
}

# Update the completion box by filtering the items and redrawing it; possibly close it
function prompt_updateItemsBox() {
  # if the box is opened and the previous character is a space, we close the box
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" && ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} != "true" && ${_PROMPT_STRING_INDEX} -gt 0 && ${_PROMPT_STRING:_PROMPT_STRING_INDEX-1:1} == [[:space:]] ]]; then
    list::hide
    # in that case, we also reset the items
    _PROMPT_FILTERED_ITEMS=("${_PROMPT_ORIGINAL_ITEMS[@]}")
    _PROMPT_FILTERED_ITEMS_CORRESPONDENCES=()
    _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING=""
  fi

  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  # filter the items and update the items box
  prompt_setCurrentWord
  list::filter
  list::draw
}

# Assign _PROMPT_CURRENT_WORD to the currently edited word (if any)
function prompt_setCurrentWord() {
  if [[ ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} == "true" ]]; then
    _PROMPT_CURRENT_WORD="${_PROMPT_STRING}"
  else
    # we take the current word
    if [[ ${_PROMPT_STRING_INDEX} -eq 0 || ${_PROMPT_STRING:_PROMPT_STRING_INDEX-1:1} == [[:space:]] ]]; then
      # if we are at the beginning of the line, or the previous character is a space
      _PROMPT_CURRENT_WORD=""
    else
      prompt_getIndexDeltaToBeginningOfWord
      if ((REPLY < 0)); then
        _PROMPT_CURRENT_WORD="${_PROMPT_STRING:_PROMPT_STRING_INDEX+REPLY:-1*REPLY}"
      else
        _PROMPT_CURRENT_WORD=""
      fi
    fi
  fi
}

function prompt_showItemsBox() {
  _LIST_SHOWN=true

  # position the box aligned with the current word
  prompt_setCurrentWord
  local preferredLeftPosition="$((GLOBAL_CURSOR_COLUMN - ${#_LIST_CURRENT_WORD} - _LIST_SYMBOL_LENGTH))"
  if ((preferredLeftPosition < _LIST_START_COLUMN)); then
    preferredLeftPosition="${_LIST_START_COLUMN}"
  fi

  # compute the size of the autocomplete box
  terminal::getBestAutocompleteBox top="${_LIST_FORCED_TOP:-${_LIST_START_LINE}}" left="${_LIST_FORCED_LEFT:-${preferredLeftPosition}}" desiredHeight="${_LIST_FORCED_HEIGHT:-${_LIST_PREFERRED_HEIGHT}}" desiredWidth="${_LIST_FORCED_WIDTH:-${_LIST_PREFERRED_WIDTH}}" maxHeight="${_LIST_MAX_HEIGHT}" forceBelow="${_LIST_FORCE_BELOW}" notOnCurrentLine="${_LIST_ENABLE_PROMPT}"
  _LIST_TOP="${REPLY}"
  _LIST_LEFT="${REPLY2}"
  _LIST_WIDTH="${REPLY3}"
  _LIST_HEIGHT="${REPLY4}"

  printf -v _LIST_BLANKS "%${_LIST_WIDTH}s" " "

  if [[ ${_LIST_ENABLED} != "true" || ${_LIST_SHOWN} != "true" || _LIST_HEIGHT -le 0 ]]; then
    return 0
  fi
  # clear the error box
  if [[ ${_LIST_ERROR_BOX_SHOWN} == "true" ]]; then
    prompt_clearErrorBox
  fi

  list::filter
  list::draw
}

# A function to show an error message
function prompt_showError() {
  local _message="${1:-}"

  # clear the autocompletion box / existing error box if any
  list::hide
  prompt_clearErrorBox

  string::wrapWords _message width=$((${_PROMPT_ITEMS_BOX_FORCED_WIDTH:-${_PROMPT_WIDTH}} - ${#_PROMPT_ERROR_BOX_SYMBOL_LENGTH}))
  local IFS=$'\n'
  local text="${REPLY}"
  local -i errorLinesNeeded=0
  set -o noglob
  for _ in ${text}; do
    errorLinesNeeded+=1
  done
  set +o noglob

  # compute the height of the box where we can display error messages
  # This box should fit within the autocomplete width
  terminal::getBestAutocompleteBox top="${_PROMPT_ITEMS_BOX_FORCED_TOP:-${_PROMPT_START_LINE}}" left="${_PROMPT_ITEMS_BOX_FORCED_LEFT:-${_PROMPT_START_COLUMN}}" desiredHeight="${_PROMPT_ITEMS_BOX_FORCED_HEIGHT:-${errorLinesNeeded}}" desiredWidth="${_PROMPT_ITEMS_BOX_FORCED_WIDTH:-${_PROMPT_WIDTH}}" maxHeight="${_PROMPT_ITEMS_BOX_MAX_HEIGHT}" forceBelow="${_PROMPT_ITEMS_BOX_FORCE_BELOW}" notOnCurrentLine="${_PROMPT_ENABLE_PROMPT}"
  _PROMPT_ERROR_BOX_TOP="${REPLY}"
  _PROMPT_ERROR_BOX_LEFT="${REPLY2}"
  _PROMPT_ERROR_BOX_WIDTH="${REPLY3}"
  _PROMPT_ERROR_BOX_HEIGHT="${REPLY4}"

  if ((_PROMPT_ERROR_BOX_HEIGHT <= 0)); then
    return 0
  fi

  local toPrint="${ESC__CURSOR_HIDE}"
  local line
  local -i lineNumber=0
  set -o noglob
  for line in ${text}; do
    toPrint+="${ESC__CURSOR_MOVE__}$((_PROMPT_ERROR_BOX_TOP + lineNumber));${_PROMPT_ERROR_BOX_LEFT}${__ESC__TO}${STYLE_PROMPT_VALIDATION_ERROR}${_PROMPT_ERROR_BOX_SYMBOL}${line}${STYLE_RESET}"
    lineNumber+=1
    if ((lineNumber >= _PROMPT_ERROR_BOX_HEIGHT)); then
      break
    fi
  done
  set +o noglob
  printf '%s%s' "${toPrint}" "${ESC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__ESC__TO}${ESC__CURSOR_SHOW_FORCE}" 1>&3

  _PROMPT_ERROR_BOX_SHOWN=true
}

# Clear the error box
function prompt_clearErrorBox() {
  if [[ ${_PROMPT_ERROR_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}" "${_PROMPT_ERROR_BOX_TOP}" "${_PROMPT_ERROR_BOX_LEFT}" "${_PROMPT_ERROR_BOX_WIDTH}" "${_PROMPT_ERROR_BOX_HEIGHT}"; then
      return 0
    fi
  fi

  terminal::clearBox top="${_PROMPT_ERROR_BOX_TOP}" left="${_PROMPT_ERROR_BOX_LEFT}" width="${_PROMPT_ERROR_BOX_WIDTH}" height="${_PROMPT_ERROR_BOX_HEIGHT}" 2>&3

  _PROMPT_ERROR_BOX_SHOWN=false
}

# Modifies the cursor index in the user string.
# Makes sure that the index is within the string boundaries.
#
# - $1: **delta** _as int_:
#       The delta to apply to the current cursor index.
#
# Returns:
#
# - `string_INDEX`: The new index.
#
# ```bash
# prompt_changePromptCursorIndex 1
# ```
function prompt_changePromptCursorIndex() {
  local delta="${1:-0}"

  _PROMPT_STRING_INDEX=$((_PROMPT_STRING_INDEX + delta))

  if ((_PROMPT_STRING_INDEX < 0)); then
    _PROMPT_STRING_INDEX=0
  elif ((_PROMPT_STRING_INDEX > ${#_PROMPT_STRING})); then
    _PROMPT_STRING_INDEX=${#_PROMPT_STRING}
  fi
}

# Insert a text at the cursor position.
#
# - $1: **text** _as string_:
#       The text to insert.
#
# ```bash
# prompt_insertTextAtCurrentIndex "text to insert"
# ```
function prompt_insertTextAtCurrentIndex() {
  if ((_PROMPT_STRING_INDEX > 0)); then
    if ((_PROMPT_STRING_INDEX >= ${#_PROMPT_STRING})); then
      _PROMPT_STRING="${_PROMPT_STRING}${1}"
    else
      _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}${1}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    fi
  else
    _PROMPT_STRING="${1}${_PROMPT_STRING}"
  fi
  prompt_changePromptCursorIndex ${#1}
}

# Change the prompt text, replacing the whole line or the word under the cursor
# by the currently selected item in the items box.
#
# If no item is selected, nothing is done.
#
# ```bash
# prompt_autocompleteWithSelectedItem
# ```
function prompt_autocompleteWithSelectedItem() {
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  # get the current selected item
  list::getCurrentInitialItemsIndex
  if [[ ${REPLY} == "-1" ]]; then
    return 0
  fi

  local selectedItem="${_PROMPT_ORIGINAL_ITEMS[${REPLY}]}"

  # get the current word
  prompt_setCurrentWord

  if [[ -z ${_PROMPT_CURRENT_WORD} ]]; then
    # not current autocompleting a word, we insert at caret position
    prompt_insertTextAtCurrentIndex "${selectedItem}"
  else
    # we replace the current word with the autocompleted one
    local -i beginIndexToReplace=$((_PROMPT_STRING_INDEX - ${#_PROMPT_CURRENT_WORD}))
    if ((beginIndexToReplace > 0)); then
      _PROMPT_STRING="${_PROMPT_STRING:0:beginIndexToReplace}${selectedItem}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    else
      _PROMPT_STRING="${selectedItem}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    fi
    _PROMPT_STRING_INDEX=$((beginIndexToReplace + ${#selectedItem}))
  fi

  list::hide
  prompt_onTextChanged
}

# Get the index delta to move to the beginning of the word (or previous).
function prompt_getIndexDeltaToBeginningOfWord() {
  # move to beginning of the previous word
  local -i index=${_PROMPT_STRING_INDEX}
  index+=-1
  while [[ ${index} -gt 0 && ${_PROMPT_STRING:index:1} == [[:space:]] ]]; do
    index+=-1
  done
  while [[ ${index} -gt 0 && ${_PROMPT_STRING:index:1} == [^[:space:]] ]]; do
    if [[ ${index} -ge 1 && ${_PROMPT_STRING:index-1:1} == [[:space:]] ]]; then
      break
    fi
    index=$((index - 1))
  done
  REPLY=$(((index >= 0 ? index : 0) - _PROMPT_STRING_INDEX))
}

# Get the index delta to move to the end of the word (or next).
function prompt_getIndexDeltaToEndOfWord() {
  # move to the end of the word
  local -i index=${_PROMPT_STRING_INDEX}
  while [[ ${index} -lt ${#_PROMPT_STRING} && ${_PROMPT_STRING:index:1} == [[:space:]] ]]; do
    index+=1
  done
  while [[ ${index} -lt ${#_PROMPT_STRING} && ${_PROMPT_STRING:index:1} == [^[:space:]] ]]; do
    index=$((index + 1))
  done
  REPLY=$(((index <= ${#_PROMPT_STRING} ? index : ${#_PROMPT_STRING}) - _PROMPT_STRING_INDEX))
}

# ## prompt_getDisplayedPromptString (private)
#
# This function return a string that can be printed in a terminal in order to display a text
# and position the cursor at a given index in the input text.
#
# If the string is too long to fit in the screen, it will be truncated and ellipsis will be displayed
# at the beginning and/or at the end of the string.
#
# The cursor will be displayed under the character at the given index of the input text and
# it makes sure that the cursor is always visible in the screen.
#
# This function is useful to display a long prompt on a single line.
#
# An example:
#
# ```text
# _PROMPT_STRING_SCREEN_WIDTH=10
# _PROMPT_STRING_INDEX=20
# _PROMPT_STRING="This is a long string that will be displayed in the screen."
# #                                ^ input index 20
# prompt_getDisplayedPromptString 20 10
# # output: "…g string…"
# #                  ^ screen cursor (at index 8)
# ```
#
# - $_PROMPT_STRING: **input string** _as string_:
#       the string to display
# - $_PROMPT_STRING_INDEX: **input index** _as int_:
#       the index of the character (in the input string) that should be under the cursor
# - $_PROMPT_STRING_SCREEN_WIDTH: **screen width** _as int_:
#       the width of the screen
#
# Returns:
#
# - ${REPLY}: the string to display in the screen
# - ${REPLY2}: the index at which to position the cursor on screen
#
# ```bash
# prompt_getDisplayedPromptString "This is a long string that will be displayed in the screen." 20 10
# ```
function prompt_getDisplayedPromptString() {
  local -i inputLength=${#_PROMPT_STRING}
  local -i screenIndex

  # compute where we will display the cursor in the display
  if ((_PROMPT_STRING_INDEX >= _PROMPT_STRING_SCREEN_WIDTH)); then
    if ((_PROMPT_STRING_INDEX >= inputLength - 1)); then
      # we display it in the last position if it is at the end of the string
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 1))
    else
      # we display at the second last position if it is not at the end
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
    fi
  else
    if ((inputLength > _PROMPT_STRING_SCREEN_WIDTH && inputLength - _PROMPT_STRING_INDEX == 2)); then
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
    else
      if ((inputLength > _PROMPT_STRING_SCREEN_WIDTH && _PROMPT_STRING_SCREEN_WIDTH - _PROMPT_STRING_INDEX == 1)); then
        # if within the display but at the last character and we will need to display ellipsis...
        screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
      else
        # if it is already within the display, we display it at the right position
        screenIndex=${_PROMPT_STRING_INDEX}
      fi
    fi
  fi

  local -i screenLeftLength=$((screenIndex))
  local -i realLeftLength=$((_PROMPT_STRING_INDEX))

  local screenString=""

  # compute what to display at the left of the character under the caret (if any)
  if ((screenLeftLength > 0)); then
    if ((realLeftLength > screenLeftLength)); then
      # we can't display the whole left string, so we display ellipsis
      if ((screenLeftLength > 1)); then
        screenString+="…${_PROMPT_STRING:realLeftLength-screenLeftLength+1:screenLeftLength-1}"
      else
        screenString+="…"
      fi
    else
      screenString+="${_PROMPT_STRING:realLeftLength-screenLeftLength:screenLeftLength}"
    fi
  fi

  # compute the character to display under the caret (if any)
  if ((inputLength > 0 && _PROMPT_STRING_INDEX <= inputLength)); then
    screenString+="${_PROMPT_STRING:_PROMPT_STRING_INDEX:1}"
  fi

  # compute what to display at the right of the character under the caret (if any)
  local -i screenRightLength=$((_PROMPT_STRING_SCREEN_WIDTH - screenIndex - 1))
  local -i realRightLength=$((inputLength - _PROMPT_STRING_INDEX - 1))

  if ((screenRightLength > 0)); then
    if ((realRightLength > screenRightLength)); then
      # we can't display the whole right string, so we display ellipsis
      if ((screenRightLength > 1)); then
        screenString+="${_PROMPT_STRING:inputLength-realRightLength:screenRightLength-1}…"
      else
        screenString+="…"
      fi
    else
      screenString+="${_PROMPT_STRING:inputLength-realRightLength:screenRightLength}"
    fi
  fi

  REPLY="${screenString}"
  REPLY2=${screenIndex}
}


# Clear the multi-line prompt
function prompt_clearMultiLinePrompt() {
  terminal::clearBox top="${_PROMPT_START_LINE}" left="${_PROMPT_START_COLUMN}" width="${_PROMPT_WIDTH}" height="${_PROMPT_NB_PROMPT_LINES}"
}

function prompt_drawMultiLinePrompt() {
  # we need to draw the prompt on multiple lines
  local promptLines=()
  local promptLinesStartIndex=()
  prompt_drawMultiLinePromptRefreshLines _PROMPT_STRING

  prompt_getMultiLinePrompt
  printf '%s' "${ESC__CURSOR_HIDE}${ESC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__ESC__TO}${REPLY}${ESC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__ESC__TO}${ESC__CURSOR_SHOW}"
}

function prompt_drawMultiLinePromptRefreshLines() {
  local -n textToWrapAtWords="${1}"

  local -i linesIndex=0

  # short cut in case the text is already shorter than the width
  if [[ ${#textToWrapAtWords} -le ${_PROMPT_STRING_SCREEN_WIDTH} && ${textToWrapAtWords} != *$'\n'* ]]; then
    REPLY="${textToWrapAtWords}"
    return 0
  fi

  local text="${textToWrapAtWords}"
  local IFS=$' \t' line word realWord REPLY2
  local -i realWordLength=0 firstWord=1
  local -i lineLength=0

  while ((${#text} > 0)); do
    line="${text%%$'\n'*}"
    text="${text:${#line}+1}"

    output+=$'\n'""

    # short cut in case the text is already shorter than the width
    if ((lineLength + ${#line} <= _PROMPT_STRING_SCREEN_WIDTH)); then
      output+="${line}"
      continue
    fi

    firstWord=1

    set -o noglob
    for word in ${line}; do
      if [[ ${word} == *$'\e'* ]]; then
        realWord="${word}"
        string::removeTextFormatting realWord
        realWordLength="${#realWord}"
      else
        realWordLength="${#word}"
      fi

      if ((lineLength < _PROMPT_STRING_SCREEN_WIDTH && firstWord == 0)); then
        output+=" "
        lineLength+=1
      else
        firstWord=0
      fi

      if ((lineLength + realWordLength <= _PROMPT_STRING_SCREEN_WIDTH)); then
        # add the word to the current line
        output+="${word}"
        lineLength+=realWordLength
      else
        # not enough space left, check if the word fits on the next line
        if ((realWordLength <= _PROMPT_STRING_SCREEN_WIDTH)); then
          output+=$'\n'"${word}"
          lineLength=realWordLength
        else
          # the word is too long to fit on a line, split it in multiple lines
          string::wrapCharacters word width="${_PROMPT_STRING_SCREEN_WIDTH}" newLinePadString="" firstLineWidth=$((_PROMPT_STRING_SCREEN_WIDTH - lineLength))
          output+="${REPLY}"
          lineLength=${REPLY2}
        fi
      fi

    done
    set +o noglob

    lineLength=0
  done

  REPLY="${output#$'\n'""}"



  string::wrapWords _PROMPT_STRING width="${_PROMPT_STRING_SCREEN_WIDTH}" newLinePadString="  " firstLineWidth="$((_PROMPT_STRING_SCREEN_WIDTH - _PROMPT_SYMBOL_LENGTH))"

  prompt_getMultiLinePrompt
  printf '%s' "${ESC__CURSOR_HIDE}${ESC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__ESC__TO}${REPLY}${ESC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__ESC__TO}${ESC__CURSOR_SHOW}"
}