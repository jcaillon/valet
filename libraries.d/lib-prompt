#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-ansi-codes
source ansi-codes
# shellcheck source=lib-tui
source tui
# shellcheck source=lib-fs
source fs

# ## prompt::input (private)
#
# Displays a user prompt at a given location.
#
# Allows the user to type a text in the given row between a starting column and
# ending column (included). Longer text are shifted to fit between
# the two columns.
#
# This component is a replacement for the `read -e` command, which allows
# to limit the input to a single line and which provides autocompletion.
#
# The autocompletion box can be hidden, or displayed below/above the input text
# depending on the space available on the screen.
#
# The user can type character to filter down a list of suggestions,
# navigate up and down between suggestions, insert a suggestion using
# TAB or ENTER, press ESC to close the autocompletion box, and ALT+ENTER to
# submit the input (or just ENTER when the box is closed).
#
# The autocompletion box will position itself depending on the screen size
# and the starting position of the text.
#
# The multiple options allows to use this function to ask for any user input
# as long as it is on a single line.
#
# You can define several callback functions that are called on different events:
#
# - `autocompletionOnTextUpdate`: Called when the text is updated (after each key press).
#
# - $1: **start line** _as int_:
#       The line/row at which the autocompleted text starts (this is used to
#       compute how to display the box).
# - $2: **start column** _as int_:
#       The column at which the autocompleted text starts (this is used to
#       compute how to display the box).
# - ${_OPTION_STOP_COLUMN} _as int_:
#       (optional) The column at which to stop showing the autocompleted text.
#       Longer texts get shifted to display the end of the user input.
#       (defaults to the end of the screen)
# - ${_OPTION_ITEMS_ARRAY_NAME} _as string_:
#       (optional) The items to display (name of a global array which contains the items).
#       If left empty, the autocompletion box will not be displayed. Useful to turn this into a simple prompt.
#       (defaults to empty)
# - ${_OPTION_STRING} _as string_:
#       (optional) The initial string, which corresponds to the text already entered
#       by the user at the moment the autocompletion box shows up.
#       Allows to pre-filter the autocompletion.
#       (defaults to empty)
# - ${_OPTION_ITEMS_BOX_FORCE_LEFT} _as int_:
#       (optional) The left column at which to display the autocompletion box.
#       If left empty, the box will auto position itself according to the prompt.
#       (defaults to empty)
# - ${_OPTION_ITEMS_BOX_FORCE_TOP} _as int_:
#       (optional) The top line at which to display the autocompletion box.
#       If left empty, the box will auto position itself according to the prompt.
#       (defaults to empty)
# - ${_OPTION_ITEMS_BOX_FORCE_WIDTH} _as int_:
#       (optional) The width of the autocompletion box.
#       If left empty, the box will auto compute its width according to the items.
#       (defaults to empty)
# - ${_OPTION_ITEMS_BOX_FORCE_HEIGHT} _as int_:
#       (optional) The height of the autocompletion box.
#       If left empty, the box will auto compute its height according to the items.
#       (defaults to empty)
# - ${_OPTION_ITEMS_BOX_MAX_HEIGHT} _as int_:
#       (optional) The maximum number of lines/rows to use for the autocompletion box.
#       If the number of items is greater than this value, the box will be scrollable.
#       (defaults to a maximized auto-computed value depending on the items and screen size)
# - ${_OPTION_ITEMS_BOX_FORCE_BELOW} _as bool_:
#       (optional) If true, the box is forced to be displayed below the input text.
#       Otherwise it will depend on the space required and space available below/above.
#       (defaults to false)
# - ${_OPTION_ENABLE_PROMPT} _as bool_:
#       (optional) If true, the prompt is displayed. If false, the prompt is hidden.
#       Useful to turn this into a simple multiple choice list.
#       (defaults to true)
# - ${_OPTION_NB_PROMPT_LINES} _as integer_:
#       (optional) The number of lines to display for the prompt.
#       A number above 1 allows a multi-line prompt.
#       In which case, a new line is not used for validation but adds a new line in the prompt.
#       (defaults to 1)
# - ${_OPTION_ITEMS_BOX_ITEM_COUNT_ENABLED} _as bool_:
#       (optional) If true, the count of items can be displayed at the bottom of the box.
#       (defaults to true)
# - ${_OPTION_ITEMS_BOX_FORCE_SHOW_COUNT} _as bool_:
#       (optional) Can be set using the variable `_OPTION_ITEMS_BOX_FORCE_SHOW_COUNT`.
#       If true, the count of items is always displayed.
#       If false, the count is only displayed when we can't display all the items at once.
#       (defaults to false)
# - ${_OPTION_ITEMS_BOX_SHOW_COUNT_AT_TOP} _as bool_:
#       (optional) If true, the count of items will be displayed at the top of the box instead of the bottom.
#       (defaults to false)
# - ${_OPTION_SHOW_SYMBOL} _as bool_:
#       (optional) If true, the left cursors are displayed (> for prompt and the ◆ for selected item).
#       Useful to display the most simple auto-completion when false.
#       (defaults to true)
# - ${_OPTION_FILTERS_FROM_N_CHARS} _as int_:
#       (optional) The minimum number of characters to type before starting to filter the items.
#       By default, the list is shown full and the user can start typing to filter.
#       Put a value superior to 0 to make it behave like a standard autocompletion.
#       When non-zero, the user can TAB to show the full list.
#       (defaults to 0)
# - ${_OPTION_ACCEPT_ANY_VALUE} _as bool_:
#       (optional) If true, the left cursors are displayed (> for prompt and the > for selected item).
#       Useful to display the most simple auto-completion when false.
#       (defaults to true)
# - ${_OPTION_PLACEHOLDER} _as string_:
#       (optional) The placeholder to display when the input is empty.
#       (defaults to empty)
# - ${_OPTION_STRING_MAX_LENGTH} _as int_:
#       (optional) The maximum length of the input string.
#       If the user types more characters, they are truncated and an error message is displayed.
#       (defaults to 99999)
# - ${_OPTION_AUTOCOMPLETE_WHOLE_LINE} _as bool_:
#       (optional) If true, the whole line is autocompleted (all characters are considered to filter)
#       the items. If false, only the word characters before the cursor are considered.
#       (defaults to true)
# - ${_OPTION_TAB_OPENS_ITEMS_BOX} _as bool_:
#       (optional) If true, the tab key opens the items box if it is not already open.
#       (defaults to true)
# - ${_OPTION_ITEMS_BOX_ALLOW_FILTERING} _as bool_:
#       (optional) If true, the items can be filtered by typing characters.
#       If false, the items are displayed as is.
#       (defaults to the value of `_OPTION_ENABLE_PROMPT` or true)
# - ${_OPTION_PASSWORD_MODE} _as bool_:
#       (optional) If true, the input is displayed as a series of stars *.
#       This mode can be activated/deactivated by pressing CTRL+P.
#       (defaults to false)
# - ${_OPTION_CALLBACK_FUNCTION_ON_TEXT_UPDATE} _as string_:
#       (optional) The name of a function to call each time the text is updated.
#       Can be used to validate the input and display an error message.
#       The function is called with no arguments but you can use the global variable `_OPTION_STRING` and
#       `_OPTION_STRING_INDEX` to access the current text and cursor position.
#       You must set:
#
#       - `RETURNED_VALUE`: The error message to display (or empty).
#       - `RETURNED_VALUE2`: A boolean to indicate if the autocompletion box should be redrawn.
#
#       (defaults to empty)
# - ${_OPTION_CALLBACK_FUNCTION_ON_KEY_PRESSED} _as string_:
#       (optional) The name of a function to call each time a key is pressed.
#       Can be used to customize the behavior of the prompt.
#       The function is called with the following arguments:
#
#       - $1: The key that was pressed, including special keys (CTRL+, ALT+, TAB, etc...).
#       - $2: The last character that was sent by the terminal, if any (can be empty when key is not empty).
#
#       The function must return 0 if the key press was handled, 1 otherwise.
#       (defaults to empty)
# - ${_OPTION_CALLBACK_FUNCTION_ON_BOX_CLOSED} _as string_:
#       (optional) The name of a function to call when the autocompletion box is closed.
#       Can be used to clean up resources or to update the screen.
#       The function is called with arguments:
#
#       - $1: The top line number of the box that was just closed.
#       - $2: The left column of the box.
#       - $3: The width of the box.
#       - $4: The height of the box.
#
#       The function must return 0 to state that prompt does not have to be redrawn, 1 otherwise.
#       (defaults to empty)
#
# Returns:
#
# - $?:
#   - 0: The user pressed ENTER to validate the text.
#   - 1: The user pressed ESC to close the text box.
# - ${RETURNED_VALUE}: The entered value (or empty).
# - ${RETURNED_VALUE2}: The string displayed on the screen between the 2 columns at the
#                      moment when the autocompletion was closed.
#
# ```bash
# prompt::input "Select an item" item_array_name "onItemSelected" "Details"
# ```
function prompt::input() {
  # shellcheck disable=SC2086
  unset -v ${!_PROMPT_*}

  _PROMPT_START_LINE="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  _PROMPT_START_COLUMN="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  _PROMPT_STOP_COLUMN="${_OPTION_STOP_COLUMN:-${GLOBAL_COLUMNS}}"
  _PROMPT_STOP_COLUMN_AT_END="false"
  if [[ -z ${_OPTION_STOP_COLUMN:-} ]]; then
    _PROMPT_STOP_COLUMN_AT_END="true"
  fi

  _PROMPT_ITEMS_ARRAY_NAME="${_OPTION_ITEMS_ARRAY_NAME:-}"

  _PROMPT_STRING="${_OPTION_STRING:-}"

  _PROMPT_ITEMS_BOX_FORCED_LEFT="${_OPTION_ITEMS_BOX_FORCE_LEFT:-}"
  _PROMPT_ITEMS_BOX_FORCED_TOP="${_OPTION_ITEMS_BOX_FORCE_TOP:-}"
  _PROMPT_ITEMS_BOX_FORCED_WIDTH="${_OPTION_ITEMS_BOX_FORCE_WIDTH:-}"
  _PROMPT_ITEMS_BOX_FORCED_HEIGHT="${_OPTION_ITEMS_BOX_FORCE_HEIGHT:-}"

  _PROMPT_ITEMS_BOX_MAX_HEIGHT="${_OPTION_ITEMS_BOX_MAX_HEIGHT:-}"
  _PROMPT_ITEMS_BOX_FORCE_BELOW="${_OPTION_ITEMS_BOX_FORCE_BELOW:-false}"

  _PROMPT_ENABLE_PROMPT="${_OPTION_ENABLE_PROMPT:-true}"
  _PROMPT_ITEMS_BOX_ITEM_COUNT_ENABLED="${_OPTION_ITEMS_BOX_ITEM_COUNT_ENABLED:-true}"
  _PROMPT_ITEMS_BOX_FORCE_SHOW_COUNT="${_OPTION_ITEMS_BOX_FORCE_SHOW_COUNT:-false}"
  _PROMPT_ITEMS_BOX_SHOW_COUNT_AT_TOP="${_OPTION_ITEMS_BOX_SHOW_COUNT_AT_TOP:-false}"

  _PROMPT_SHOW_SYMBOL="${_OPTION_SHOW_SYMBOL:-true}"
  _PROMPT_FILTERS_FROM_N_CHARS="${_OPTION_FILTERS_FROM_N_CHARS:-0}"

  _PROMPT_ACCEPT_ANY_VALUE="${_OPTION_ACCEPT_ANY_VALUE:-true}"

  _PROMPT_PLACEHOLDER="${_OPTION_PLACEHOLDER:-}"
  _PROMPT_STRING_MAX_LENGTH="${_OPTION_STRING_MAX_LENGTH:-99999}"

  _PROMPT_AUTOCOMPLETE_WHOLE_LINE="${_OPTION_AUTOCOMPLETE_WHOLE_LINE:-true}"
  _PROMPT_TAB_OPENS_ITEMS_BOX="${_OPTION_TAB_OPENS_ITEMS_BOX:-true}"
  _PROMPT_ITEMS_BOX_ALLOW_FILTERING="${_OPTION_ITEMS_BOX_ALLOW_FILTERING:-${_PROMPT_ENABLE_PROMPT}}"
  _PROMPT_PASSWORD_MODE="${_OPTION_PASSWORD_MODE:-false}"

  _PROMPT_NB_PROMPT_LINES="${_OPTION_NB_PROMPT_LINES:-1}"
  _PROMPT_MULTI_LINE=false
  if ((_PROMPT_NB_PROMPT_LINES > 1)); then
    _PROMPT_MULTI_LINE=true
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE="${_OPTION_CALLBACK_FUNCTION_ON_TEXT_UPDATE:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE} ]] && ! command -v "${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED="${_OPTION_CALLBACK_FUNCTION_ON_KEY_PRESSED:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]] && ! command -v "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED="${_OPTION_CALLBACK_FUNCTION_ON_BOX_CLOSED:-}"
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]] && ! command -v "${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}" &>/dev/null; then
    core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}⌝ does not exist."
  fi

  _PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY=""
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY} ]]; then
    if ! command -v "${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY}" &>/dev/null; then
      core::fail "The callback function ⌜${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY}⌝ does not exist."
    fi
  else
    _PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY="prompt::getItemDisplayedString"
  fi

  _PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY=""
  _PROMPT_ITEMS_BOX_FILTER_USING_GREP=""

  local -A _PROMPT_KEY_MAPPING=(
    ["CTRL+ALT+M"]="accept-line"
    ["CTRL+M"]="accept-line"
    ["CTRL+J"]="accept-line"
    ["NEWLINE"]="accept-line"
    ["TAB"]="complete"
    ["CTRL+I"]="complete"
    ["ESC"]="close"
    ["CTRL+Q"]="abort"
    ["CTRL+A"]="beginning-of-line"
    ["CTRL+E"]="end-of-line"
    ["LEFT"]="backward-char"
    ["CTRL+B"]="backward-char"
    ["RIGHT"]="forward-char"
    ["CTRL+F"]="forward-char"
    ["CTRL+LEFT"]="backward-word"
    ["CTRL+RIGHT"]="forward-word"
    ["CTRL+K"]="kill-end-of-line"
    ["CTRL+X"]="kill-line"
    ["CTRL+Y"]="yank"
    ["DEL"]="delete-char"
    ["CTRL+D"]="delete-char"
    ["CTRL+H"]="backward-delete-char"
    ["BACKSPACE"]="backward-delete-char"
    ["CTRL+DEL"]="kill-word"
    ["CTRL+BACKSPACE"]="backward-kill-word"
    ["CTRL+W"]="backward-kill-word"
    ["CTRL+P"]="toggle-password-mode"
    ["PAGE_UP"]="scroll-up"
    ["PAGE_DOWN"]="scroll-down"
    ["HOME"]="move-beginning"
    ["CTRL+UP"]="move-beginning"
    ["END"]="move-end"
    ["CTRL+DOWN"]="move-end"
    ["UP"]="move-up"
    ["DOWN"]="move-down"
  )
  if [[ -v VALET_CONFIG_PROMPT_KEY_MAPPING ]]; then
    local key
    for key in "${!VALET_CONFIG_PROMPT_KEY_MAPPING[@]}"; do
      _PROMPT_KEY_MAPPING["${key}"]="${VALET_CONFIG_PROMPT_KEY_MAPPING[${key}]}"
    done
  fi

  # set up colors
  if [[ ${VALET_CONFIG_ENABLE_COLORS:-} == "true" ]]; then
    _PROMPT_COLOR_STRING="${VALET_CONFIG_PROMPT_COLOR_STRING:-"${AC__FG_MAGENTA}"}"
    _PROMPT_COLOR_STRING_RESET="${VALET_CONFIG_PROMPT_COLOR_STRING_RESET:-"${AC__FG_RESET}"}"
    _PROMPT_COLOR_STATIC="${VALET_CONFIG_PROMPT_COLOR_STATIC:-"${AC__FG_BRIGHT_BLACK}"}"
    _PROMPT_COLOR_STATIC_RESET="${VALET_CONFIG_PROMPT_COLOR_STATIC_RESET:-"${AC__FG_RESET}"}"
    _PROMPT_COLOR_LETTER_HIGHLIGHT="${VALET_CONFIG_PROMPT_COLOR_LETTER_HIGHLIGHT:-"${AC__TEXT_INVERSE}${AC__FG_MAGENTA}"}"
    _PROMPT_COLOR_LETTER_HIGHLIGHT_RESET="${VALET_CONFIG_PROMPT_COLOR_LETTER_HIGHLIGHT_RESET:-"${AC__TEXT_NO_INVERSE}${AC__FG_RESET}"}"
    _PROMPT_COLOR_SELECTED_ITEM="${VALET_CONFIG_PROMPT_COLOR_SELECTED_ITEM:-"${AC__BG_BLACK}${AC__FG_WHITE}"}"
    _PROMPT_COLOR_SELECTED_ITEM_RESET="${VALET_CONFIG_PROMPT_COLOR_SELECTED_ITEM_RESET:-"${AC__BG_RESET}${AC__FG_RESET}"}"
    _PROMPT_COLOR_SELECTED_ITEM_SYMBOL="${VALET_CONFIG_PROMPT_COLOR_SELECTED_ITEM_SYMBOL:-"${AC__BG_BLACK}${AC__FG_MAGENTA}"}"
    _PROMPT_COLOR_SELECTED_ITEM_SYMBOL_RESET="${VALET_CONFIG_PROMPT_COLOR_SELECTED_ITEM_SYMBOL_RESET:-"${AC__BG_RESET}${AC__FG_RESET}"}"
    _PROMPT_COLOR_UNSELECTED_ITEM="${VALET_CONFIG_PROMPT_COLOR_UNSELECTED_ITEM:-""}"
    _PROMPT_COLOR_UNSELECTED_ITEM_RESET="${VALET_CONFIG_PROMPT_COLOR_UNSELECTED_ITEM_RESET:-""}"
    _PROMPT_COLOR_COUNT="${VALET_CONFIG_PROMPT_COLOR_COUNT:-"${AC__FG_YELLOW}"}"
    _PROMPT_COLOR_COUNT_RESET="${VALET_CONFIG_PROMPT_COLOR_COUNT_RESET:-"${AC__FG_RESET}"}"
    _PROMPT_COLOR_VALIDATION_ERROR="${VALET_CONFIG_PROMPT_COLOR_VALIDATION_ERROR:-"${AC__FG_RED}"}"
    _PROMPT_COLOR_VALIDATION_ERROR_RESET="${VALET_CONFIG_PROMPT_COLOR_VALIDATION_ERROR_RESET:-"${AC__FG_RESET}"}"
  else
    _PROMPT_COLOR_STRING=""
    _PROMPT_COLOR_STRING_RESET=""
    _PROMPT_COLOR_STATIC=""
    _PROMPT_COLOR_STATIC_RESET=""
    _PROMPT_COLOR_LETTER_HIGHLIGHT="${AC__TEXT_UNDERLINE}"
    _PROMPT_COLOR_LETTER_HIGHLIGHT_RESET="${AC__TEXT_NO_UNDERLINE}"
    _PROMPT_COLOR_SELECTED_ITEM="${AC__TEXT_INVERSE}"
    _PROMPT_COLOR_SELECTED_ITEM_RESET="${AC__TEXT_NO_INVERSE}"
    _PROMPT_COLOR_SELECTED_ITEM_SYMBOL="${AC__TEXT_INVERSE}"
    _PROMPT_COLOR_SELECTED_ITEM_SYMBOL_RESET="${AC__TEXT_NO_INVERSE}"
    _PROMPT_COLOR_UNSELECTED_ITEM=""
    _PROMPT_COLOR_UNSELECTED_ITEM_RESET=""
    _PROMPT_COLOR_COUNT=""
    _PROMPT_COLOR_COUNT_RESET=""
    _PROMPT_COLOR_VALIDATION_ERROR="${AC__TEXT_INVERSE}"
    _PROMPT_COLOR_VALIDATION_ERROR_RESET="${AC__TEXT_NO_INVERSE}"
  fi

  # set up the left symbols (> for prompt and the > for selected item)
  if [[ ${_PROMPT_SHOW_SYMBOL} == "true" ]]; then
    _PROMPT_SYMBOL="${VALET_CONFIG_INTERACTIVE_SELECTED_ITEM_CHARACTER:-"> "}"
    _PROMPT_SYMBOL_LENGTH=${#_PROMPT_SYMBOL}
    _PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM="${VALET_CONFIG_INTERACTIVE_SELECTED_ITEM_CHARACTER:-"█ "}"
    _PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM="│ "
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER="──"
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_BELOW="┌─"
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_ABOVE="└─"
    _PROMPT_ITEMS_BOX_SYMBOL_LENGTH=${#_PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM}
    _PROMPT_ERROR_BOX_SYMBOL="█ "
    _PROMPT_ERROR_BOX_SYMBOL_LENGTH=2
  else
    _PROMPT_SYMBOL=""
    _PROMPT_SYMBOL_LENGTH=0
    _PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM=""
    _PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM=""
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER=""
    _PROMPT_ITEMS_BOX_SYMBOL_COUNTER_ABOVE=""
    _PROMPT_ITEMS_BOX_SYMBOL_LENGTH=0
    _PROMPT_ERROR_BOX_SYMBOL=""
    _PROMPT_ERROR_BOX_SYMBOL_LENGTH=0
  fi

  _PROMPT_KILLED_STRING=""
  _PROMPT_STRING_INDEX=${#_PROMPT_STRING}
  GLOBAL_CURSOR_LINE="${_PROMPT_START_LINE}"
  GLOBAL_CURSOR_COLUMN=$((_PROMPT_START_COLUMN + _PROMPT_SYMBOL_LENGTH + _PROMPT_STRING_INDEX))

  prompt_setItemsListVariables

  # check if we display the autocompletion box, and the initial state of the box (shown or hidden)
  if ((_PROMPT_ORIGINAL_ITEMS_COUNT > 0)); then
    _PROMPT_ITEMS_BOX_ENABLED=true
    if ((${#_PROMPT_STRING} >= _PROMPT_FILTERS_FROM_N_CHARS)); then
      _PROMPT_ITEMS_BOX_SHOWN=true
    else
      _PROMPT_ITEMS_BOX_SHOWN=false
    fi
  else
    _PROMPT_ITEMS_BOX_ENABLED=false
    _PROMPT_ITEMS_BOX_SHOWN=false
  fi
  _PROMPT_ERROR_BOX_SHOWN=false

  _PROMPT_ITEMS_BOX_REVERSE_MODE=false

  if [[ ${_PROMPT_ITEMS_BOX_ENABLED} != "true" ]]; then
    # if we don't show the box, we necessarily accept any value
    _PROMPT_ACCEPT_ANY_VALUE=true
  elif [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    # if don't show the prompt, we don't accept any value
    _PROMPT_ACCEPT_ANY_VALUE=false
  fi

  # compute properties that depend on the screen size
  prompt_setSizeVariables

  _PROMPT_LAST_KEY_PRESSED_TIME=0
  _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
  _PROMPT_CANCELLED=true

  # set trap so that interrupt signal sets GLOBAL_SESSION_INTERRUPTED to true
  tui::setInterruptTrap
  # before starting to wait for inputs, we clear up the key pressed
  tui::clearKeyPressed
  # setup the terminal to be ready for readline
  tui::setTerminalOptions
  # rebind some keys to call the callback function prompt_onKeyBindingPress
  tui::rebindKeymap prompt_onKeyBindingPress

  # make all match case insensitive
  shopt -s nocasematch

  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
    prompt_openItemsBox
  fi
  prompt_drawPrompt

  # main loop
  while true; do
    if tui::waitForKeyPress -t 0.2; then
      prompt_onKeyPressed "${LAST_KEY_PRESSED}"
    fi

    # in case of a terminal resize, we will have to redraw
    if [[ ${GLOBAL_SCREEN_REDRAW_REQUIRED:-} == "true" ]]; then
      local isItemBoxShown="${_PROMPT_ITEMS_BOX_SHOWN}"
      prompt_clearPrompt
      prompt_clearItemsBox
      prompt_clearErrorBox
      prompt_setSizeVariables
      if [[ ${isItemBoxShown} == "true" ]]; then
        prompt_openItemsBox
      fi
      prompt_drawPrompt
      GLOBAL_SCREEN_REDRAW_REQUIRED=false
    fi

    # check if the background job for async filtering is done
    if [[ -n ${GLOBAL_BACKGROUND_JOB1_PID:-} && -f ${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE:-} ]]; then
      unset -v GLOBAL_BACKGROUND_JOB1_PID
      # read the items from the file
      if [[ -s ${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE} ]]; then
        readarray -t _PROMPT_FILTERED_ITEMS <"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}"
        readarray -t _PROMPT_FILTERED_ITEMS_CORRESPONDENCES <"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
      else
        _PROMPT_FILTERED_ITEMS=()
        _PROMPT_FILTERED_ITEMS_CORRESPONDENCES=()
      fi
      fs::readFile "${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILTER_STRING}"
      _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING="${RETURNED_VALUE%%[[:space:]]}"
      prompt_drawItemsBox
    fi

    # break if fd 0 is closed or does not refer to a terminal.
    if [[ ! -t 0 || ${GLOBAL_SESSION_INTERRUPTED} == "true" ]]; then
      break
    fi
  done

  # clean up
  prompt_filterItemsAsyncKill
  prompt_clearErrorBox
  prompt_clearItemsBox
  prompt_clearPrompt
  tui::restoreTerminalOptions
  tui::restoreInterruptTrap
  shopt -u nocasematch

  if [[ ${_PROMPT_CANCELLED:-} == "true" ]]; then
    return 1
  else
    RETURNED_VALUE="${_PROMPT_STRING}"
    if ((_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX >= 0)); then
      RETURNED_VALUE2="${_PROMPT_ORIGINAL_ITEMS[${_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX}]}"
    else
      RETURNED_VALUE2=""
    fi
    # shellcheck disable=SC2034
    RETURNED_VALUE3=${_PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX}
  fi

  # shellcheck disable=SC2086
  unset -v ${!_PROMPT_*}

  return 0
}

# compute properties that depend on the screen size
function prompt_setSizeVariables() {
  if ((_PROMPT_START_LINE > GLOBAL_LINES)); then
    _PROMPT_START_LINE=${GLOBAL_LINES}
  fi
  if ((_PROMPT_START_COLUMN > GLOBAL_COLUMNS)); then
    _PROMPT_START_COLUMN=${GLOBAL_COLUMNS}
  fi
  if ((_PROMPT_STOP_COLUMN > GLOBAL_COLUMNS)); then
    _PROMPT_STOP_COLUMN=${GLOBAL_COLUMNS}
  fi
  if [[ ${_PROMPT_STOP_COLUMN_AT_END} == "true" ]]; then
    _PROMPT_STOP_COLUMN=${GLOBAL_COLUMNS}
  fi

  _PROMPT_WIDTH=$((_PROMPT_STOP_COLUMN - _PROMPT_START_COLUMN + 1))

  if [[ ${_PROMPT_SHOW_SYMBOL} == "true" ]]; then
    _PROMPT_STRING_SCREEN_WIDTH=$((_PROMPT_WIDTH - _PROMPT_SYMBOL_LENGTH))
  else
    _PROMPT_STRING_SCREEN_WIDTH=${_PROMPT_WIDTH}
  fi
}

# set up the variables that depend on the items list
function prompt_setItemsListVariables() {
  if [[ -n ${_PROMPT_ITEMS_ARRAY_NAME} ]]; then
    declare -g -n _PROMPT_ORIGINAL_ITEMS="${_PROMPT_ITEMS_ARRAY_NAME}"
    _PROMPT_ITEMS_BOX_PREFERRED_WIDTH=0
    local item
    for item in "${_PROMPT_ORIGINAL_ITEMS[@]}"; do
      if ((${#item} > _PROMPT_ITEMS_BOX_PREFERRED_WIDTH)); then
        _PROMPT_ITEMS_BOX_PREFERRED_WIDTH=${#item}
        if ((_PROMPT_ITEMS_BOX_PREFERRED_WIDTH > GLOBAL_COLUMNS)); then
          break
        fi
      fi
    done
    _PROMPT_ORIGINAL_ITEMS_COUNT=${#_PROMPT_ORIGINAL_ITEMS[@]}
    _PROMPT_ITEMS_BOX_PREFERRED_HEIGHT=${#_PROMPT_ORIGINAL_ITEMS[@]}
  else
    _PROMPT_ORIGINAL_ITEMS=()
    _PROMPT_ORIGINAL_ITEMS_COUNT=0
    _PROMPT_ITEMS_BOX_PREFERRED_WIDTH=0
    _PROMPT_ITEMS_BOX_PREFERRED_HEIGHT=0
  fi

  if [[ ${_PROMPT_ITEMS_BOX_FORCE_SHOW_COUNT} == "true" ]]; then
    _PROMPT_ITEMS_BOX_PREFERRED_HEIGHT=$((_PROMPT_ITEMS_BOX_PREFERRED_HEIGHT + 1))
  fi

  _PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX=-1

  local itemCountWidth=$((8 + ${#_PROMPT_ORIGINAL_ITEMS_COUNT} * 4))
  if ((_PROMPT_ITEMS_BOX_PREFERRED_WIDTH < itemCountWidth)); then
    # the width necessary to display the count of items
    _PROMPT_ITEMS_BOX_PREFERRED_WIDTH=${itemCountWidth}
  fi

  if [[ ${_PROMPT_SHOW_SYMBOL} == "true" ]]; then
    _PROMPT_ITEMS_BOX_PREFERRED_WIDTH=$((_PROMPT_ITEMS_BOX_PREFERRED_WIDTH + _PROMPT_ITEMS_BOX_SYMBOL_LENGTH))
  fi

  if [[ ${_PROMPT_ITEMS_BOX_ALLOW_FILTERING} == "true" ]]; then
    _PROMPT_FILTERED_ITEMS=()
  else
    _PROMPT_FILTERED_ITEMS=("${_PROMPT_ORIGINAL_ITEMS[@]}")
  fi
  _PROMPT_FILTERED_ITEMS_CORRESPONDENCES=()
  _PROMPT_FILTERED_ITEMS_START_INDEX=0
  _PROMPT_FILTERED_ITEMS_SELECTED_INDEX=-1
  _PROMPT_ITEMS_BOX_FILTER_STRING=""

  # if the items are too many, we will filter them asynchronously/filter with grep
  if [[ -z ${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY} && _PROMPT_ORIGINAL_ITEMS_COUNT -gt 242 ]]; then
    _PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY="false"
  fi
  if [[ -z ${_PROMPT_ITEMS_BOX_FILTER_USING_GREP} && _PROMPT_ORIGINAL_ITEMS_COUNT -gt 1042 ]]; then
    if [[ ${VALET_CONFIG_STRICT_PURE_BASH:-false} != "true" ]] && command -v grep &>/dev/null && command -v gawk &>/dev/null; then
      _PROMPT_ITEMS_BOX_FILTER_USING_GREP="true"
      # shellcheck source=lib-array
      source array
    fi
  fi

  # initial setup of files for async filtering if not done
  if [[ ${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY:-true} != "true" && -z ${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE:-} ]]; then
    _OPTION_PATH_ONLY=true fs::createTempFile
    _PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE="${RETURNED_VALUE}"
    _OPTION_PATH_ONLY=true fs::createTempFile
    _PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE="${RETURNED_VALUE}"
    _OPTION_PATH_ONLY=true fs::createTempFile
    _PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILTER_STRING="${RETURNED_VALUE}"
  fi

  # initial setup of files for grep filtering
  if [[ ${_PROMPT_ITEMS_BOX_FILTER_USING_GREP:-true} == "true" ]]; then
    if [[ -z ${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_ORIGINAL_ITEMS:-} ]]; then
      _OPTION_PATH_ONLY=true fs::createTempFile
      _PROMPT_ITEMS_BOX_FILTER_USING_GREP_ORIGINAL_ITEMS="${RETURNED_VALUE}"
      _OPTION_PATH_ONLY=true fs::createTempFile
      _PROMPT_ITEMS_BOX_FILTER_USING_GREP_TEMP1="${RETURNED_VALUE}"
    fi
    local IFS=$'\n'
    echo "${_PROMPT_ORIGINAL_ITEMS[*]}" >"${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_ORIGINAL_ITEMS}"
  fi
}

# Called when a special key is pressed.
#
# - $1: **key** _as string_:
#       The special key that was pressed (CTRL+, ALT+, TAB, etc...).
#
# define the callback function called when a special key is pressed
# shellcheck disable=SC2317
function prompt_onKeyBindingPress() {
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" "" "${1}"; then
      return 0
    fi
  fi

  local action="${_PROMPT_KEY_MAPPING[${1}]:-}"
  if [[ -z ${action} ]]; then
    return 0
  fi

  case "${action}" in
  accept-line)
    # in autocompletion mode we can only validate if we autocompletion is closed, otherwise it autocompletes
    if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" && ${_PROMPT_ACCEPT_ANY_VALUE} == "true" ]]; then
      prompt_autocompleteWithSelectedItem
      return 0
    fi

    # if we selected index is within the range of the filtered items
    # we can return the corresponding index in the original items
    prompt_getCurrentInitialItemsIndex
    if [[ ${RETURNED_VALUE} == "-1" ]]; then
      if [[ ${_PROMPT_ACCEPT_ANY_VALUE} != "true" ]]; then
        # make enter have no effect if we are not on a valid item and we don't accept any value
        prompt_showError "No item matching your query!"
        return 0
      fi
      _PROMPT_ORIGINAL_ITEMS_SELECTED_INDEX=${RETURNED_VALUE}
    fi
    if [[ ${_PROMPT_ACCEPT_ANY_VALUE} == "true" && ${_PROMPT_STRING} == "" ]]; then
      # make enter have no effect if we accept any value but we have an empty string
      prompt_showError "Please enter a value!"
      return 0
    fi
    GLOBAL_SESSION_INTERRUPTED=true
    _PROMPT_CANCELLED=false
    return 0
    ;;
  complete)
    # autocompletes if the box is shown, otherwise it opens the box (if allowed)
    if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
      prompt_autocompleteWithSelectedItem
    elif [[ ${_PROMPT_TAB_OPENS_ITEMS_BOX} == "true" ]]; then
      prompt_openItemsBox
    else
      prompt_insertTextAtCurrentIndex $'\t'
      prompt_onTextChanged
    fi
    ;;
  close)
    if [[ ${_PROMPT_ERROR_BOX_SHOWN} == "true" ]]; then
      prompt_clearErrorBox
      return 0
    fi
    # interrupt the prompt session or close the autocompletion box
    if [[ ${_PROMPT_ACCEPT_ANY_VALUE} == "true" && ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]]; then
      prompt_clearItemsBox
      return 0
    fi
    GLOBAL_SESSION_INTERRUPTED=true
    ;;
  abort)
    GLOBAL_SESSION_INTERRUPTED=true
    ;;

  # move the cursor
  beginning-of-line)
    prompt_changePromptCursorIndex -9999999
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  end-of-line)
    prompt_changePromptCursorIndex 9999999
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  backward-char)
    prompt_changePromptCursorIndex -1
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  forward-char)
    prompt_changePromptCursorIndex 1
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  backward-word)
    # move to beginning of the previous word
    prompt_getIndexDeltaToBeginningOfWord
    prompt_changePromptCursorIndex "${RETURNED_VALUE}"
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;
  forward-word)
    prompt_getIndexDeltaToEndOfWord
    prompt_changePromptCursorIndex "${RETURNED_VALUE}"
    prompt_updateItemsBox
    prompt_drawPrompt
    ;;

  # modify the text
  kill-end-of-line)
    # kill the line from cursor to the end
    _PROMPT_KILLED_STRING="${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    if ((_PROMPT_STRING_INDEX > 0)); then
      _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}"
    else
      _PROMPT_STRING=""
    fi
    prompt_clearItemsBox
    prompt_onTextChanged
    ;;
  kill-line)
    # kill the line
    _PROMPT_KILLED_STRING="${_PROMPT_STRING}"
    _PROMPT_STRING=""
    _PROMPT_STRING_INDEX=0
    prompt_clearItemsBox
    prompt_onTextChanged
    ;;
  yank)
    # yank the killed string at cursor position
    if [[ -n ${_PROMPT_KILLED_STRING:-} ]]; then
      prompt_insertTextAtCurrentIndex "${_PROMPT_KILLED_STRING}"
      prompt_onTextChanged
    fi
    ;;
  delete-char)
    # delete the character under the cursor
    local tempUserString
    if ((_PROMPT_STRING_INDEX > 0)); then
      tempUserString="${_PROMPT_STRING:0:${_PROMPT_STRING_INDEX}}"
    else
      tempUserString=""
    fi
    if ((_PROMPT_STRING_INDEX < ${#_PROMPT_STRING} - 1)); then
      tempUserString+="${_PROMPT_STRING:_PROMPT_STRING_INDEX+1}"
    fi
    _PROMPT_STRING="${tempUserString}"
    prompt_onTextChanged
    ;;
  backward-delete-char)
    # delete the character before the cursor
    if ((_PROMPT_STRING_INDEX > 0)); then
      if ((_PROMPT_STRING_INDEX > 1)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX-1}${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      fi
    fi
    prompt_changePromptCursorIndex -1
    prompt_onTextChanged
    ;;
  kill-word)
    # delete all chars from the cursor to the end of (this or next) word
    local -i oldIndex=${_PROMPT_STRING_INDEX}
    prompt_getIndexDeltaToEndOfWord
    prompt_changePromptCursorIndex "${RETURNED_VALUE}"
    if ((_PROMPT_STRING_INDEX > oldIndex)); then
      _PROMPT_KILLED_STRING="${_PROMPT_STRING:${oldIndex}:_PROMPT_STRING_INDEX-oldIndex}"
      if ((oldIndex > 0)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:${oldIndex}}${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:${_PROMPT_STRING_INDEX}}"
      fi
      _PROMPT_STRING_INDEX=${oldIndex}
    fi
    prompt_onTextChanged
    ;;
  backward-kill-word)
    # delete all chars before the cursor until reaching a space
    local -i oldIndex=${_PROMPT_STRING_INDEX}
    prompt_getIndexDeltaToBeginningOfWord
    prompt_changePromptCursorIndex "${RETURNED_VALUE}"
    if ((oldIndex > _PROMPT_STRING_INDEX)); then
      _PROMPT_KILLED_STRING="${_PROMPT_STRING:_PROMPT_STRING_INDEX:oldIndex-_PROMPT_STRING_INDEX}"
      if ((_PROMPT_STRING_INDEX > 0)); then
        _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}${_PROMPT_STRING:oldIndex}"
      else
        _PROMPT_STRING="${_PROMPT_STRING:oldIndex}"
      fi
    fi
    prompt_onTextChanged
    ;;
  toggle-password-mode)
    # reveal/hide the prompt
    if [[ ${_PROMPT_PASSWORD_MODE} == "true" ]]; then
      _PROMPT_PASSWORD_MODE=false
    else
      _PROMPT_PASSWORD_MODE=true
    fi
    prompt_drawPrompt
    ;;
  *)
    # handle spamming of keys (the actions before this do not need to be protected from spam,
    # but the actions after this are slow to execute and should not be spammed)
    time::getProgramElapsedMicroseconds
    if ((RETURNED_VALUE - _PROMPT_LAST_KEY_PRESSED_TIME < 100000)); then
      # key pressed under 100ms of the last
      _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=$((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED + 1))
    else
      _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
    fi
    if ((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED > 3)); then
      # if we have 3 rapid successive key pressed
      return 0
    fi
    _PROMPT_LAST_KEY_PRESSED_TIME=${RETURNED_VALUE}


    case "${action}" in
    # autocompletion box selected item
    scroll-up)
      prompt_changeSelectedItemIndex "-$((${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS:-10} - 1))"
      prompt_drawItemsBox
      ;;
    scroll-down)
      prompt_changeSelectedItemIndex "$((${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS:-10} - 1))"
      prompt_drawItemsBox
      ;;
    move-beginning)
      prompt_changeSelectedItemIndex "-$((_PROMPT_ORIGINAL_ITEMS_COUNT + 1))"
      prompt_drawItemsBox
      ;;
    move-end)
      prompt_changeSelectedItemIndex "$((_PROMPT_ORIGINAL_ITEMS_COUNT + 1))"
      prompt_drawItemsBox
      ;;
    move-up)
      prompt_changeSelectedItemIndex -1
      prompt_drawItemsBox
      ;;
    move-down)
      prompt_changeSelectedItemIndex 1
      prompt_drawItemsBox
      ;;
    esac
  esac
}

# Called when a key is pressed.
#
# - $1: **char sent** _as string_:
#       The last character that was sent by the terminal
#
function prompt_onKeyPressed() {
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_KEY_PRESSED}" "${1}" ""; then
      return 0
    fi
  fi

  # if the key is actually a special keys
  case ${1} in
  $'\b' | $'\177')
    prompt_onKeyBindingPress "BACKSPACE"
    return 0
    ;;
  $'\023')
    prompt_onKeyBindingPress "CTRL+BACKSPACE"
    return 0
    ;;
  $'\r' | $'\n')
    prompt_onKeyBindingPress "NEWLINE"
    return 0
    ;;
  esac

  # if it is too long warn the user
  if ((${#_PROMPT_STRING} >= _PROMPT_STRING_MAX_LENGTH)); then
    prompt_showError "The input can't exceed a maximum of ${_PROMPT_STRING_MAX_LENGTH} characters."
    # read the stream until the end to clear the buffer
    local IFS=''
    read -d '' -sr -t 0.2 _ || :
    return 0
  fi

  prompt_insertTextAtCurrentIndex "${1}"
  prompt_onTextChanged

  # here we handle the case where the user pastes a string (or spam a key)
  time::getProgramElapsedMicroseconds
  if ((RETURNED_VALUE - _PROMPT_LAST_KEY_PRESSED_TIME < 200000)); then
    # key pressed under 200ms of the last
    _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=$((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED + 1))
  else
    _PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED=0
  fi
  if ((_PROMPT_NB_SUCCESSIVE_RAPID_KEY_PRESSED > 10)); then
    # if we have 10 rapid successive key pressed, we consider it as a paste
    local IFS='' copiedText
    read -d '' -s -r -t 0.2 copiedText 2>/dev/null || :
    if [[ -n ${copiedText:-} ]]; then
      prompt_insertTextAtCurrentIndex "${copiedText}"
      prompt_onTextChanged
      return 0
    fi
  fi
  _PROMPT_LAST_KEY_PRESSED_TIME=${RETURNED_VALUE}

  # check if we need to open the items box
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" && ${1} != " " ]]; then
    if [[ ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} == "true" ]]; then
      if ((${#_PROMPT_STRING} >= _PROMPT_FILTERS_FROM_N_CHARS)); then
        prompt_openItemsBox
        return 0
      fi
    else
      # count the number of characters that are not spaces before the cursor
      local -i count=0
      while [[ ${count} -lt ${_PROMPT_FILTERS_FROM_N_CHARS} && $((_PROMPT_STRING_INDEX - count - 1)) -gt 0 && ${_PROMPT_STRING:_PROMPT_STRING_INDEX-count-1:1} == [^[:space:]] ]]; do
        count+=1
      done
      if ((count >= _PROMPT_FILTERS_FROM_N_CHARS)); then
        prompt_openItemsBox
        return 0
      fi
    fi
  fi
}

# Called when the prompt string changes
function prompt_onTextChanged() {
  local shownError=false

  # close error box if shown
  if [[ ${_PROMPT_ERROR_BOX_SHOWN} == "true" ]]; then
    prompt_clearErrorBox
  fi

  # truncate the string if it is too long and warn the user
  if ((${#_PROMPT_STRING} > _PROMPT_STRING_MAX_LENGTH)); then
    _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_MAX_LENGTH}"
    if ((_PROMPT_STRING_INDEX > _PROMPT_STRING_MAX_LENGTH)); then
      _PROMPT_STRING_INDEX=${_PROMPT_STRING_MAX_LENGTH}
    fi
    prompt_showError "The input exceeds the maximum of ${_PROMPT_STRING_MAX_LENGTH} characters, it has been truncated."
    shownError=true

    # read the stream until the end to clear the buffer
    local IFS
    IFS='' read -d '' -sr -t 0.2 _ || :
  fi

  # call the callback function on text update if it is enabled (and we did not just update the cursor)
  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE} ]]; then
    ${_PROMPT_CALLBACK_FUNCTION_ON_TEXT_UPDATE}
    if [[ -n ${RETURNED_VALUE} ]]; then
      prompt_showError "${RETURNED_VALUE}"
      shownError=true
    fi
    if [[ ${RETURNED_VALUE2:-false} == "true" ]]; then
      prompt_drawItemsBox
    fi
  fi

  # update the prompt
  prompt_drawPrompt

  # filter the items and update the items box
  if [[ ${shownError} != "true" ]]; then
    prompt_updateItemsBox
  fi
}

# Draw the prompt line
function prompt_drawPrompt() {
  if [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    return 0
  fi
  if [[ ${_PROMPT_MULTI_LINE} == "true" ]]; then
    prompt_drawMultiLinePrompt
    return 0
  fi

  # use interactive::showStringInScreen with global the variables: _PROMPT_STRING, _PROMPT_STRING_INDEX, _PROMPT_STRING_SCREEN_WIDTH
  prompt_getDisplayedPromptString
  GLOBAL_CURSOR_LINE="${_PROMPT_START_LINE}"
  GLOBAL_CURSOR_COLUMN=$((_PROMPT_START_COLUMN + _PROMPT_SYMBOL_LENGTH + RETURNED_VALUE2))
  local -i spaceLeft=$((_PROMPT_STRING_SCREEN_WIDTH - ${#RETURNED_VALUE}))

  if [[ ${_PROMPT_PASSWORD_MODE} == "true" ]]; then
    RETURNED_VALUE="${RETURNED_VALUE//[^…]/*}"
  fi
  if [[ -z ${RETURNED_VALUE} && -n ${_PROMPT_PLACEHOLDER} ]]; then
    RETURNED_VALUE="${_PROMPT_COLOR_STATIC}${_PROMPT_PLACEHOLDER}${_PROMPT_COLOR_STATIC_RESET}"
    spaceLeft=$((_PROMPT_STRING_SCREEN_WIDTH - ${#_PROMPT_PLACEHOLDER}))
  fi
  local spaces=""
  if ((spaceLeft > 0)); then
    if ((spaceLeft == 1)); then
      spaces=" "
    else
      spaces=" ${AC__REPEAT__}$((spaceLeft - 1))${__AC__LAST_CHAR}"
    fi
  fi

  printf '%s' "${AC__CURSOR_HIDE}${AC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__AC__TO}${_PROMPT_COLOR_STATIC}${_PROMPT_SYMBOL}${_PROMPT_COLOR_STATIC_RESET}${_PROMPT_COLOR_STRING}${RETURNED_VALUE}${spaces}${_PROMPT_COLOR_STRING_RESET}${AC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__AC__TO}${AC__CURSOR_SHOW}"
}

# Clear the prompt line
function prompt_clearPrompt() {
  if [[ ${_PROMPT_ENABLE_PROMPT} != "true" ]]; then
    return 0
  fi
  if [[ ${_PROMPT_MULTI_LINE} == "true" ]]; then
    prompt_clearMultiLinePrompt
    return 0
  fi

  printf '%s' "${AC__CURSOR_HIDE}${AC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__AC__TO}${AC__ERASE__}${_PROMPT_WIDTH}${__AC_CHARS}${AC__CURSOR_SHOW}"
}

function prompt_drawMultiLinePrompt() {
  prompt_getMultiLinePrompt
  printf '%s' "${AC__CURSOR_HIDE}${AC__CURSOR_MOVE__}${_PROMPT_START_LINE};${_PROMPT_START_COLUMN}${__AC__TO}${RETURNED_VALUE}${AC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__AC__TO}${AC__CURSOR_SHOW}"
}

# Clear the multi-line prompt
function prompt_clearMultiLinePrompt() {
  tui::clearBox "${_PROMPT_START_LINE}" "${_PROMPT_START_COLUMN}" "${_PROMPT_WIDTH}" "${_PROMPT_NB_PROMPT_LINES}"
}

# Open the item box (position it, filter items, and draw it)
function prompt_openItemsBox() {
  _PROMPT_ITEMS_BOX_SHOWN=true

  # position the box aligned with the current word
  prompt_setCurrentWord
  local preferredLeftPosition="$((GLOBAL_CURSOR_COLUMN - ${#_PROMPT_CURRENT_WORD} - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH))"
  if ((preferredLeftPosition < _PROMPT_START_COLUMN)); then
    preferredLeftPosition="${_PROMPT_START_COLUMN}"
  fi

  # compute the size of the autocomplete box
  tui::getBestAutocompleteBox "${_PROMPT_ITEMS_BOX_FORCED_TOP:-${_PROMPT_START_LINE}}" "${_PROMPT_ITEMS_BOX_FORCED_LEFT:-${preferredLeftPosition}}" "${_PROMPT_ITEMS_BOX_FORCED_HEIGHT:-${_PROMPT_ITEMS_BOX_PREFERRED_HEIGHT}}" "${_PROMPT_ITEMS_BOX_FORCED_WIDTH:-${_PROMPT_ITEMS_BOX_PREFERRED_WIDTH}}" "${_PROMPT_ITEMS_BOX_MAX_HEIGHT}" "${_PROMPT_ITEMS_BOX_FORCE_BELOW}" "${_PROMPT_ENABLE_PROMPT}"
  _PROMPT_ITEMS_BOX_TOP="${RETURNED_VALUE}"
  _PROMPT_ITEMS_BOX_LEFT="${RETURNED_VALUE2}"
  _PROMPT_ITEMS_BOX_WIDTH="${RETURNED_VALUE3}"
  _PROMPT_ITEMS_BOX_HEIGHT="${RETURNED_VALUE4}"

  _PROMPT_ITEMS_BOX_REVERSE_MODE="false"
  if ((_PROMPT_ITEMS_BOX_TOP < _PROMPT_START_LINE)); then
    _PROMPT_ITEMS_BOX_REVERSE_MODE="true"
  fi

  prompt_filterItems
  prompt_drawItemsBox
}

# Update the completion box by filtering the items and redrawing it; possibly close it
function prompt_updateItemsBox() {
  # if the box is opened and the previous character is a space, we close the box
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" && ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} != "true" && ${_PROMPT_STRING_INDEX} -gt 0 && ${_PROMPT_STRING:_PROMPT_STRING_INDEX-1:1} == [[:space:]] ]]; then
    prompt_clearItemsBox
    # in that case, we also reset the items
    _PROMPT_FILTERED_ITEMS=("${_PROMPT_ORIGINAL_ITEMS[@]}")
    _PROMPT_FILTERED_ITEMS_CORRESPONDENCES=()
    _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING=""
  fi

  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  # filter the items and update the items box
  prompt_setCurrentWord
  prompt_filterItems
  prompt_drawItemsBox
}

# Assign _PROMPT_CURRENT_WORD to the currently edited word (if any)
function prompt_setCurrentWord() {
  if [[ ${_PROMPT_AUTOCOMPLETE_WHOLE_LINE} == "true" ]]; then
    _PROMPT_CURRENT_WORD="${_PROMPT_STRING}"
  else
    # we take the current word
    if [[ ${_PROMPT_STRING_INDEX} -eq 0 || ${_PROMPT_STRING:_PROMPT_STRING_INDEX-1:1} == [[:space:]] ]]; then
      # if we are at the beginning of the line, or the previous character is a space
      _PROMPT_CURRENT_WORD=""
    else
      prompt_getIndexDeltaToBeginningOfWord
      if ((RETURNED_VALUE < 0)); then
        _PROMPT_CURRENT_WORD="${_PROMPT_STRING:_PROMPT_STRING_INDEX+RETURNED_VALUE:-1*RETURNED_VALUE}"
      else
        _PROMPT_CURRENT_WORD=""
      fi
    fi
  fi
}

# Filter the items of the autocompletion box, will either filter synchronously or asynchronously
function prompt_filterItems() {
  if [[ ${_PROMPT_ITEMS_BOX_ALLOW_FILTERING} != "true" ]]; then
    return 0
  fi

  if [[ ${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY:-true} != "true" ]]; then
    # asynchronous filtering, kill an already running background job
    prompt_filterItemsAsyncKill
  fi

  _PROMPT_ITEMS_BOX_FILTER_STRING="${_PROMPT_CURRENT_WORD}"

  # case where we can return the original items
  if [[ -z ${_PROMPT_ITEMS_BOX_FILTER_STRING} ]]; then
    _PROMPT_FILTERED_ITEMS=("${_PROMPT_ORIGINAL_ITEMS[@]}")
    _PROMPT_FILTERED_ITEMS_CORRESPONDENCES=()
    _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING=""
    return 0
  fi

  # We define these to allow array::fuzzyFilterSort to modify the arrays directly (avoiding a copy)
  # shellcheck disable=SC2178
  local -n RETURNED_ARRAY=_PROMPT_FILTERED_ITEMS
  # shellcheck disable=SC2034
  local -n RETURNED_ARRAY2=_PROMPT_FILTERED_ITEMS_CORRESPONDENCES

  if [[ -n ${_PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING:-} && ${_PROMPT_ITEMS_BOX_FILTER_STRING} == "${_PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING}"* && (${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY} == "true" || ${#_PROMPT_FILTERED_ITEMS[@]} -lt 242) ]]; then
    if ((${#_PROMPT_FILTERED_ITEMS[@]} == 0)); then
      return 0
    fi
    # if the current filter string is a prefix of the previous one, we can filter the already filtered items
    local -a _PROMPT_PRE_FILTERED_ITEMS=("${_PROMPT_FILTERED_ITEMS[@]}")
    local -a _PROMPT_PRE_FILTERED_ITEMS_CORRESPONDENCES=("${_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[@]}")
    array::fuzzyFilterSort _PROMPT_PRE_FILTERED_ITEMS _PROMPT_ITEMS_BOX_FILTER_STRING
    _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING="${_PROMPT_ITEMS_BOX_FILTER_STRING}"
    # we need to update the correspondences
    local -i index
    for index in "${!_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[@]}"; do
      _PROMPT_FILTERED_ITEMS_CORRESPONDENCES[index]="${_PROMPT_PRE_FILTERED_ITEMS_CORRESPONDENCES[${_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[index]}]}"
    done
    return 0
  fi

  if [[ ${_PROMPT_ITEMS_BOX_FILTER_SYNCHRONOUSLY} == "true" ]]; then
    array::fuzzyFilterSort _PROMPT_ORIGINAL_ITEMS _PROMPT_ITEMS_BOX_FILTER_STRING
    _PROMPT_ITEMS_BOX_CURRENT_FILTER_STRING="${_PROMPT_ITEMS_BOX_FILTER_STRING}"
  else
    # asynchronous filtering
    rm -f "${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}" &>/dev/null || :
    prompt_filterItemsAsync 1>&2 &
    GLOBAL_BACKGROUND_JOB1_PID="$!"
  fi
}

# Filter the items of the autocompletion box asynchronously
function prompt_filterItemsAsync() {
  echo "${_PROMPT_ITEMS_BOX_FILTER_STRING}" >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILTER_STRING}"

  if [[ ${_PROMPT_ITEMS_BOX_FILTER_USING_GREP} == "true" ]]; then
    # sort with grep and awk
    : >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
    rm "${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_TEMP1}" &>/dev/null || :

    array::fuzzyFilterSortFileWithGrepAndGawk "${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_ORIGINAL_ITEMS}" _PROMPT_ITEMS_BOX_FILTER_STRING "${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_TEMP1}" "${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"

    if [[ -f ${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_TEMP1} ]]; then
      mv "${_PROMPT_ITEMS_BOX_FILTER_USING_GREP_TEMP1}" "${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}"
    else
      : >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}"
    fi
  else
    # We define these to allow array::fuzzyFilterSort to modify the arrays directly (avoiding a copy)
    # shellcheck disable=SC2178
    local -n RETURNED_ARRAY=_PROMPT_FILTERED_ITEMS
    # shellcheck disable=SC2034
    local -n RETURNED_ARRAY2=_PROMPT_FILTERED_ITEMS_CORRESPONDENCES

    # sort with bash
    array::fuzzyFilterSort _PROMPT_ORIGINAL_ITEMS _PROMPT_ITEMS_BOX_FILTER_STRING
    local IFS=$'\n'
    if ((${#_PROMPT_FILTERED_ITEMS[@]} > 0)); then
      echo "${_PROMPT_FILTERED_ITEMS[*]}" >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}"
      echo "${_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[*]}" >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_CORRESPONDENCES_FILE}"
    else
      : >"${_PROMPT_ITEMS_BOX_ASYNC_FILTERED_ITEMS_FILE}"
    fi
  fi
}

# Kill the background job that filters the items asynchronously
function prompt_filterItemsAsyncKill() {
  if [[ -n ${GLOBAL_BACKGROUND_JOB1_PID:-} ]]; then
    kill "${GLOBAL_BACKGROUND_JOB1_PID}" &>/dev/null || :
    unset -v GLOBAL_BACKGROUND_JOB1_PID
  fi
}

# Draw the autocompletion box
function prompt_drawItemsBox() {
  if [[ ${_PROMPT_ITEMS_BOX_ENABLED} != "true" || ${_PROMPT_ITEMS_BOX_SHOWN} != "true" || _PROMPT_ITEMS_BOX_HEIGHT -le 0 ]]; then
    return 0
  fi

  # clear the error box
  if [[ ${_PROMPT_ERROR_BOX_SHOWN} == "true" ]]; then
    prompt_clearErrorBox
  fi

  # check if we display the item count
  _PROMPT_ITEM_COUNT_SHOWN=false
  _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS="${_PROMPT_ITEMS_BOX_HEIGHT}"
  if [[ ${_PROMPT_ITEMS_BOX_ITEM_COUNT_ENABLED} == "true" ]]; then
    if [[ ${_PROMPT_ITEMS_BOX_FORCE_SHOW_COUNT} == "true" || ${#_PROMPT_FILTERED_ITEMS[@]} -gt ${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS} || ${#_PROMPT_FILTERED_ITEMS[@]} -ne ${_PROMPT_ORIGINAL_ITEMS_COUNT} ]]; then
      # we show the count if:
      # - we force its display
      # - we have more items than the box can display
      # - we display less items than the original items
      if ((_PROMPT_ITEMS_BOX_HEIGHT > 1 || (_PROMPT_ITEMS_BOX_HEIGHT == 1 && ${#_PROMPT_FILTERED_ITEMS[@]} == 0))); then
        # display if we have more than one line or if we have no items
        _PROMPT_ITEM_COUNT_SHOWN=true
        _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS=$((_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS - 1))
      fi
    fi
  fi

  #TODO: callback to compute the _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS, _PROMPT_ITEM_COUNT_SHOWN

  local showCountAtTop=0
  if [[ ${_PROMPT_ITEMS_BOX_SHOW_COUNT_AT_TOP} == "true" ]]; then
    showCountAtTop=1
  fi

  # make sure to select an existing index regarding the filtered items +
  # make sure it is in the view
  prompt_changeSelectedItemIndex 0

  local toPrint="${AC__CURSOR_HIDE}"

  # draw the items
  _PROMPT_ITEMS_BOX_ITEM_WIDTH="$((_PROMPT_ITEMS_BOX_WIDTH - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH))"
  _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS="${_PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS}"
  if ((${#_PROMPT_FILTERED_ITEMS[@]} < _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS)); then
    _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS=${#_PROMPT_FILTERED_ITEMS[@]}
  fi

  local -i line showAtLine index
  local spaces
  for ((line = 0; line < _PROMPT_ITEMS_BOX_HEIGHT - showCountAtTop; line++)); do
    if [[ ${_PROMPT_ITEMS_BOX_REVERSE_MODE} == "true" ]]; then
      showAtLine=$((_PROMPT_ITEMS_BOX_TOP + _PROMPT_ITEMS_BOX_HEIGHT - 1 - line - showCountAtTop))
    else
      showAtLine=$((_PROMPT_ITEMS_BOX_TOP + line + showCountAtTop))
    fi
    index=$((_PROMPT_FILTERED_ITEMS_START_INDEX + line))

    # position
    toPrint+="${AC__CURSOR_MOVE__}${showAtLine};${_PROMPT_ITEMS_BOX_LEFT}${__AC__TO}"

    if ((index >= ${#_PROMPT_FILTERED_ITEMS[@]})); then
      # nothing to show for this line
      toPrint+="${AC__ERASE__}${_PROMPT_ITEMS_BOX_WIDTH}${__AC_CHARS}"
      continue
    fi

    # get the item display string in _PROMPT_ITEMS_BOX_ITEM_DISPLAYED
    _PROMPT_ITEMS_BOX_ITEM_DISPLAYED="${_PROMPT_FILTERED_ITEMS[${index}]}"
    if "${_PROMPT_CALLBACK_FUNCTION_ON_ITEM_DISPLAY}"; then
      if ((RETURNED_VALUE > 0)); then
        if ((RETURNED_VALUE == 1)); then
          spaces=" "
        else
          spaces=" ${AC__REPEAT__}$((RETURNED_VALUE - 1))${__AC__LAST_CHAR}"
        fi
      else
        spaces=""
      fi
      if ((index == _PROMPT_FILTERED_ITEMS_SELECTED_INDEX)); then
        # highlight the selected item
        toPrint+="${_PROMPT_COLOR_SELECTED_ITEM_SYMBOL}${_PROMPT_ITEMS_BOX_SYMBOL_SELECTED_ITEM}${_PROMPT_COLOR_SELECTED_ITEM_SYMBOL_RESET}${_PROMPT_COLOR_SELECTED_ITEM}${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}${spaces}${_PROMPT_COLOR_SELECTED_ITEM_RESET}"
      else
        toPrint+="${_PROMPT_COLOR_STATIC}${_PROMPT_ITEMS_BOX_SYMBOL_UNSELECTED_ITEM}${_PROMPT_COLOR_STATIC_RESET}${_PROMPT_COLOR_UNSELECTED_ITEM}${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}${spaces}${_PROMPT_COLOR_UNSELECTED_ITEM_RESET}"
      fi
    fi
  done

  # display the items count (nb filtered items/nb total items)
  if [[ ${_PROMPT_ITEM_COUNT_SHOWN} == "true" ]]; then
    local itemsCounter
    local -i itemCounterLength

    if [[ -n ${GLOBAL_BACKGROUND_JOB1_PID:-} ]]; then
      # case where we are filtering asynchronously, we display a loading message
      if ((_PROMPT_ITEMS_BOX_WIDTH - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH >= 11)); then
        itemsCounter=" ${_PROMPT_COLOR_COUNT}Filtering…${_PROMPT_COLOR_COUNT_RESET}"
        itemCounterLength=11
      else
        itemsCounter=" ${_PROMPT_COLOR_COUNT}…${_PROMPT_COLOR_COUNT_RESET}"
        itemCounterLength=2
      fi
    else
      # case where we display the count
      local lastItemNumber=$((_PROMPT_FILTERED_ITEMS_START_INDEX + _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS))
      if [[ ${_PROMPT_ITEMS_BOX_ALLOW_FILTERING} != "true" ]]; then
        # case of ' 00-00'
        local itemCounterLength=$((2 + ${#lastItemNumber} * 2))
        printf -v itemsCounter " %s%0${#lastItemNumber}i-%i%s" "${_PROMPT_COLOR_COUNT}" "${_PROMPT_FILTERED_ITEMS_START_INDEX}" "${lastItemNumber}" "${_PROMPT_COLOR_COUNT_RESET}"
      else
        itemCounterLength=$((7 + ${#_PROMPT_ORIGINAL_ITEMS_COUNT} * 2 + ${#lastItemNumber} * 2))
        if ((_PROMPT_ITEMS_BOX_WIDTH - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH >= itemCounterLength && _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS > 1)); then
          # case of ' 00-00 of 00/00'
          printf -v itemsCounter " %s%0${#lastItemNumber}i-%i%s of %s%0${#_PROMPT_ORIGINAL_ITEMS_COUNT}i%s/%i%s" "${_PROMPT_COLOR_COUNT}" "${_PROMPT_FILTERED_ITEMS_START_INDEX}" "${lastItemNumber}" "${_PROMPT_COLOR_COUNT_RESET}${_PROMPT_COLOR_STATIC}" "${_PROMPT_COLOR_STATIC_RESET}${_PROMPT_COLOR_COUNT}" "${#_PROMPT_FILTERED_ITEMS[@]}" "${_PROMPT_COLOR_COUNT_RESET}${_PROMPT_COLOR_STATIC}" "${_PROMPT_ORIGINAL_ITEMS_COUNT}" "${_PROMPT_COLOR_STATIC_RESET}"
        else
          # case of ' 00/00'
          local itemCounterLength=$((2 + ${#_PROMPT_ORIGINAL_ITEMS_COUNT} * 2))
          printf -v itemsCounter " %s%0${#_PROMPT_ORIGINAL_ITEMS_COUNT}i%s/%i%s" "${_PROMPT_COLOR_COUNT}" "${#_PROMPT_FILTERED_ITEMS[@]}" "${_PROMPT_COLOR_COUNT_RESET}${_PROMPT_COLOR_STATIC}" "${_PROMPT_ORIGINAL_ITEMS_COUNT}" "${_PROMPT_COLOR_STATIC_RESET}"
        fi
      fi

      if ((itemCounterLength > _PROMPT_ITEMS_BOX_WIDTH - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH)); then
        # case where we do not have the space to display the count
        itemCounterLength=0
        itemsCounter=""
      fi
    fi

    if [[ ${_PROMPT_ITEMS_BOX_REVERSE_MODE} == "true" ]]; then
      showAtLine=$((showCountAtTop == 1 ? _PROMPT_ITEMS_BOX_TOP + _PROMPT_ITEMS_BOX_HEIGHT - 1 : _PROMPT_ITEMS_BOX_TOP + _PROMPT_ITEMS_BOX_HEIGHT - 1 - _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS))

    else
      showAtLine=$((showCountAtTop == 1 ? _PROMPT_ITEMS_BOX_TOP : _PROMPT_ITEMS_BOX_TOP + _PROMPT_ITEMS_BOX_NB_DISPLAYED_ITEMS))
    fi

    local counterSymbol
    if ((${#_PROMPT_FILTERED_ITEMS[@]} == 0)); then
      counterSymbol="${_PROMPT_ITEMS_BOX_SYMBOL_COUNTER}"
    elif [[ (${_PROMPT_ITEMS_BOX_REVERSE_MODE} == "true" && ${showCountAtTop} -eq 1) || (${_PROMPT_ITEMS_BOX_REVERSE_MODE} != "true" && ${showCountAtTop} -eq 0) ]]; then
      counterSymbol="${_PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_ABOVE}"
    else
      counterSymbol="${_PROMPT_ITEMS_BOX_SYMBOL_COUNTER_BOX_BELOW}"
    fi

    toPrint+="${AC__CURSOR_MOVE__}${showAtLine};${_PROMPT_ITEMS_BOX_LEFT}${__AC__TO}${_PROMPT_COLOR_STATIC}${counterSymbol}${AC__REPEAT__}$((_PROMPT_ITEMS_BOX_WIDTH - _PROMPT_ITEMS_BOX_SYMBOL_LENGTH - itemCounterLength))${__AC__LAST_CHAR}${_PROMPT_COLOR_STATIC_RESET}${itemsCounter}"
  fi

  printf '%s%s' "${toPrint}" "${AC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__AC__TO}${AC__CURSOR_SHOW}"
}

# Clear the items box
function prompt_clearItemsBox() {
  if [[ ${_PROMPT_ITEMS_BOX_ENABLED} != "true" || ${_PROMPT_ITEMS_BOX_SHOWN} != "true" || _PROMPT_ITEMS_BOX_HEIGHT -le 0 ]]; then
    return 0
  fi

  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}" "${_PROMPT_ITEMS_BOX_TOP}" "${_PROMPT_ITEMS_BOX_LEFT}" "${_PROMPT_ITEMS_BOX_WIDTH}" "${_PROMPT_ITEMS_BOX_HEIGHT}"; then
      return 0
    fi
  fi

  tui::clearBox "${_PROMPT_ITEMS_BOX_TOP}" "${_PROMPT_ITEMS_BOX_LEFT}" "${_PROMPT_ITEMS_BOX_WIDTH}" "${_PROMPT_ITEMS_BOX_HEIGHT}"

  _PROMPT_ITEMS_BOX_SHOWN=false
}

# ## prompt::getItemDisplayedString (private)
#
# Truncate a string to a given number of visible characters.
# Adds an ellipsis at the end if the string is truncated.
#
# This function will truncate a string without taking into account
# the ANSI escape sequences for text formatting (i.e. the `\e[*m` format).
#
# - ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED} _as string_:
#       the string to truncate
# - ${_PROMPT_ITEMS_BOX_ITEM_WIDTH} _as int_:
#       the number of visible characters
# - ${_PROMPT_ITEMS_BOX_FILTER_STRING} _as string_:
#       the string to search for in the string
#
# Returns:
#
# - ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}: the truncated string
# - ${RETURNED_VALUE}: the space left
#       i.e. (_PROMPT_ITEMS_BOX_ITEM_WIDTH - the length of visible characters in _PROMPT_ITEMS_BOX_ITEM_DISPLAYED)
#
# ```bash
# prompt::getItemDisplayedString "This is a long string that will be displayed in the screen." 20
# echo "${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}"
# ```
function prompt::getItemDisplayedString() {
  local -i stringLength=${#_PROMPT_ITEMS_BOX_ITEM_DISPLAYED}
  if [[ -z ${_PROMPT_ITEMS_BOX_FILTER_STRING} && ${stringLength} -le ${_PROMPT_ITEMS_BOX_ITEM_WIDTH} ]]; then
    # no filter string, no need to truncate
    if [[ ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED} == *$'\e'* ]]; then
      local realWord="${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED//$'\e['[0-9][0-9]m/}"
      realWord="${realWord//$'\e['[0-9]m/}"
      RETURNED_VALUE=$((_PROMPT_ITEMS_BOX_ITEM_WIDTH - ${#realWord}))
    else
      RETURNED_VALUE=$((_PROMPT_ITEMS_BOX_ITEM_WIDTH - stringLength))
    fi
    return 0
  fi

  local itemDisplayed="" itemChunk itemChunkPiece
  local -i searchStringIndex=0 itemDisplayedLength=0
  local searchStringCharacter="${_PROMPT_ITEMS_BOX_FILTER_STRING:0:1}"

  while ((${#_PROMPT_ITEMS_BOX_ITEM_DISPLAYED} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED%%$'\e'*}"

    if ((itemDisplayedLength + ${#itemChunk} > _PROMPT_ITEMS_BOX_ITEM_WIDTH)); then
      # we reached the desired size
      itemChunk="${itemChunk:0:$((_PROMPT_ITEMS_BOX_ITEM_WIDTH - 1 - itemDisplayedLength))}…"
      _PROMPT_ITEMS_BOX_ITEM_DISPLAYED=""
      itemDisplayedLength=${_PROMPT_ITEMS_BOX_ITEM_WIDTH}
    else
      # otherwise we will continue in the next loop
      _PROMPT_ITEMS_BOX_ITEM_DISPLAYED="${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED:${#itemChunk}}"
      itemDisplayedLength+=${#itemChunk}
    fi

    if [[ -n ${itemChunk} ]]; then
      # colorize the search string in this chunk
      while [[ -n ${searchStringCharacter} && ${itemChunk} == *"${searchStringCharacter}"* ]]; do
        itemChunkPiece="${itemChunk%%["${searchStringCharacter^}${searchStringCharacter,}"]*}"
        itemDisplayed+="${itemChunkPiece}${_PROMPT_COLOR_LETTER_HIGHLIGHT}${itemChunk:${#itemChunkPiece}:1}${_PROMPT_COLOR_LETTER_HIGHLIGHT_RESET}"
        itemChunk="${itemChunk:${#itemChunkPiece}+1}"
        searchStringIndex+=1
        searchStringCharacter="${_PROMPT_ITEMS_BOX_FILTER_STRING:searchStringIndex:1}"
      done

      itemDisplayed+="${itemChunk}"
    fi

    while [[ ${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED} == $'\e'* ]]; do
      # case where we have an escape sequence at the beginning of the string
      # we only consider escape sequences for text formatting, they end with m
      itemChunk="${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED%%"m"*}m"
      itemDisplayed+="${itemChunk}"
      _PROMPT_ITEMS_BOX_ITEM_DISPLAYED="${_PROMPT_ITEMS_BOX_ITEM_DISPLAYED:${#itemChunk}}"
    done
  done

  _PROMPT_ITEMS_BOX_ITEM_DISPLAYED="${itemDisplayed}"
  RETURNED_VALUE=$((_PROMPT_ITEMS_BOX_ITEM_WIDTH - itemDisplayedLength))
}

# A function to show an error message
function prompt_showError() {
  local message="${1:-}"

  # clear the autocompletion box / existing error box if any
  prompt_clearItemsBox
  prompt_clearErrorBox

  string::wrapWords message $((${_PROMPT_ITEMS_BOX_FORCED_WIDTH:-${_PROMPT_WIDTH}} - ${#_PROMPT_ERROR_BOX_SYMBOL_LENGTH}))
  local IFS=$'\n'
  local text="${RETURNED_VALUE}"
  local -i errorLinesNeeded=0
  for _ in ${text}; do
    errorLinesNeeded+=1
  done

  # compute the height of the box where we can display error messages
  # This box should fit within the autocomplete width
  tui::getBestAutocompleteBox "${_PROMPT_ITEMS_BOX_FORCED_TOP:-${_PROMPT_START_LINE}}" "${_PROMPT_ITEMS_BOX_FORCED_LEFT:-${_PROMPT_START_COLUMN}}" "${_PROMPT_ITEMS_BOX_FORCED_HEIGHT:-${errorLinesNeeded}}" "${_PROMPT_ITEMS_BOX_FORCED_WIDTH:-${_PROMPT_WIDTH}}" "${_PROMPT_ITEMS_BOX_MAX_HEIGHT}" "${_PROMPT_ITEMS_BOX_FORCE_BELOW}" "${_PROMPT_ENABLE_PROMPT}"
  _PROMPT_ERROR_BOX_TOP="${RETURNED_VALUE}"
  _PROMPT_ERROR_BOX_LEFT="${RETURNED_VALUE2}"
  _PROMPT_ERROR_BOX_WIDTH="${RETURNED_VALUE3}"
  _PROMPT_ERROR_BOX_HEIGHT="${RETURNED_VALUE4}"

  if ((_PROMPT_ERROR_BOX_HEIGHT <= 0)); then
    return 0
  fi

  local toPrint="${AC__CURSOR_HIDE}"
  local line
  local -i lineNumber=0
  for line in ${text}; do
    toPrint+="${AC__CURSOR_MOVE__}$((_PROMPT_ERROR_BOX_TOP + lineNumber));${_PROMPT_ERROR_BOX_LEFT}${__AC__TO}${_PROMPT_COLOR_VALIDATION_ERROR}${_PROMPT_ERROR_BOX_SYMBOL}${line}${_PROMPT_COLOR_VALIDATION_ERROR_RESET}"
    lineNumber+=1
    if ((lineNumber >= _PROMPT_ERROR_BOX_HEIGHT)); then
      break
    fi
  done
  printf '%s%s' "${toPrint}" "${AC__CURSOR_MOVE__}${GLOBAL_CURSOR_LINE};${GLOBAL_CURSOR_COLUMN}${__AC__TO}${AC__CURSOR_SHOW}"

  _PROMPT_ERROR_BOX_SHOWN=true
}

# Clear the autocompletion box
function prompt_clearErrorBox() {
  if [[ ${_PROMPT_ERROR_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  if [[ -n ${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED} ]]; then
    if "${_PROMPT_CALLBACK_FUNCTION_ON_BOX_CLOSED}" "${_PROMPT_ERROR_BOX_TOP}" "${_PROMPT_ERROR_BOX_LEFT}" "${_PROMPT_ERROR_BOX_WIDTH}" "${_PROMPT_ERROR_BOX_HEIGHT}"; then
      return 0
    fi
  fi

  tui::clearBox "${_PROMPT_ERROR_BOX_TOP}" "${_PROMPT_ERROR_BOX_LEFT}" "${_PROMPT_ERROR_BOX_WIDTH}" "${_PROMPT_ERROR_BOX_HEIGHT}"

  _PROMPT_ERROR_BOX_SHOWN=false
}

# Modifies the selected item index and adjust the start index if necessary.
#
# - $1: **delta** _as integer_:
#       The delta to apply to the current index.
#
# Returns:
#
# - ${_OPTION_FILTERED_ITEMS_SELECTED_INDEX}: The new index.
# - ${_OPTION_FILTERED_ITEMS_START_INDEX}: The new start index if needed.
#
# ```bash
# prompt_changeSelectedItemIndex 1
# ```
function prompt_changeSelectedItemIndex() {
  local delta="${1:-0}"

  # if we have no items, we do nothing
  if [[ ${#_PROMPT_FILTERED_ITEMS[@]} -eq 0 ]]; then
    _PROMPT_FILTERED_ITEMS_SELECTED_INDEX=-1
    return 0
  fi

  # change the delta sign if we are in the reverse mode
  if [[ ${_PROMPT_ITEMS_BOX_REVERSE_MODE:-} == "true" ]]; then
    delta=$((delta * -1))
  fi

  local -i newIndex

  # compute the new index
  # cycle through if it was already at the end/beginning
  if ((_PROMPT_FILTERED_ITEMS_SELECTED_INDEX <= 0 && delta < 0)); then
    newIndex=$((${#_PROMPT_FILTERED_ITEMS[@]} - 1))
  elif ((_PROMPT_FILTERED_ITEMS_SELECTED_INDEX >= ${#_PROMPT_FILTERED_ITEMS[@]} - 1 && delta > 0)); then
    newIndex=0
  else
    newIndex=$((_PROMPT_FILTERED_ITEMS_SELECTED_INDEX + delta))
    if ((newIndex < 0)); then
      newIndex=0
    elif ((newIndex >= ${#_PROMPT_FILTERED_ITEMS[@]})); then
      newIndex=$((${#_PROMPT_FILTERED_ITEMS[@]} - 1))
    fi
  fi

  # now we need to adjust the start index if needed
  # to make sure that the new index is visible on the screen
  if ((newIndex < _PROMPT_FILTERED_ITEMS_START_INDEX)); then
    _PROMPT_FILTERED_ITEMS_START_INDEX=${newIndex}
  elif ((newIndex > _PROMPT_FILTERED_ITEMS_START_INDEX + _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS - 1)); then
    _PROMPT_FILTERED_ITEMS_START_INDEX=$((newIndex - _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS + 1))
  fi
  # also to make sure that we use all the space available on screen
  if ((_PROMPT_FILTERED_ITEMS_START_INDEX + _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS > ${#_PROMPT_FILTERED_ITEMS[@]})); then
    _PROMPT_FILTERED_ITEMS_START_INDEX=$((${#_PROMPT_FILTERED_ITEMS[@]} - _PROMPT_ITEMS_BOX_NB_DISPLAYABLE_ITEMS))
    if ((_PROMPT_FILTERED_ITEMS_START_INDEX < 0)); then
      _PROMPT_FILTERED_ITEMS_START_INDEX=0
    fi
  fi

  _PROMPT_FILTERED_ITEMS_SELECTED_INDEX=${newIndex}
}

# Modifies the cursor index in the user string.
# Makes sure that the index is within the string boundaries.
#
# - $1: **delta** _as integer_:
#       The delta to apply to the current cursor index.
#
# Returns:
#
# - `_OPTION_STRING_INDEX`: The new index.
#
# ```bash
# prompt_changePromptCursorIndex 1
# ```
function prompt_changePromptCursorIndex() {
  local delta="${1:-0}"

  _PROMPT_STRING_INDEX=$((_PROMPT_STRING_INDEX + delta))

  if ((_PROMPT_STRING_INDEX < 0)); then
    _PROMPT_STRING_INDEX=0
  elif ((_PROMPT_STRING_INDEX > ${#_PROMPT_STRING})); then
    _PROMPT_STRING_INDEX=${#_PROMPT_STRING}
  fi
}

# Insert a text at the cursor position.
#
# - $1: **text** _as string_:
#       The text to insert.
#
# ```bash
# prompt_insertTextAtCurrentIndex "text to insert"
# ```
function prompt_insertTextAtCurrentIndex() {
  if ((_PROMPT_STRING_INDEX > 0)); then
    if ((_PROMPT_STRING_INDEX >= ${#_PROMPT_STRING})); then
      _PROMPT_STRING="${_PROMPT_STRING}${1}"
    else
      _PROMPT_STRING="${_PROMPT_STRING:0:_PROMPT_STRING_INDEX}${1}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    fi
  else
    _PROMPT_STRING="${1}${_PROMPT_STRING}"
  fi
  prompt_changePromptCursorIndex ${#1}
}

# Change the prompt text, replacing the whole line or the word under the cursor
# by the currently selected item in the items box.
#
# If no item is selected, nothing is done.
#
# ```bash
# prompt_autocompleteWithSelectedItem
# ```
function prompt_autocompleteWithSelectedItem() {
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} != "true" ]]; then
    return 0
  fi

  # get the current selected item
  prompt_getCurrentInitialItemsIndex
  if [[ ${RETURNED_VALUE} == "-1" ]]; then
    return 0
  fi

  local selectedItem="${_PROMPT_ORIGINAL_ITEMS[${RETURNED_VALUE}]}"

  # get the current word
  prompt_setCurrentWord

  if [[ -z ${_PROMPT_CURRENT_WORD} ]]; then
    # not current autocompleting a word, we insert at caret position
    prompt_insertTextAtCurrentIndex "${selectedItem}"
  else
    # we replace the current word with the autocompleted one
    local -i beginIndexToReplace=$((_PROMPT_STRING_INDEX - ${#_PROMPT_CURRENT_WORD}))
    if ((beginIndexToReplace > 0)); then
      _PROMPT_STRING="${_PROMPT_STRING:0:beginIndexToReplace}${selectedItem}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    else
      _PROMPT_STRING="${selectedItem}${_PROMPT_STRING:_PROMPT_STRING_INDEX}"
    fi
    _PROMPT_STRING_INDEX=$((beginIndexToReplace + ${#selectedItem}))
  fi

  prompt_clearItemsBox
  prompt_onTextChanged
}

# Get the index delta to move to the beginning of the word (or previous).
function prompt_getIndexDeltaToBeginningOfWord() {
  # move to beginning of the previous word
  local -i index=${_PROMPT_STRING_INDEX}
  index+=-1
  while [[ ${index} -gt 0 && ${_PROMPT_STRING:index:1} == [[:space:]] ]]; do
    index+=-1
  done
  while [[ ${index} -gt 0 && ${_PROMPT_STRING:index:1} == [^[:space:]] ]]; do
    if [[ ${index} -ge 1 && ${_PROMPT_STRING:index-1:1} == [[:space:]] ]]; then
      break
    fi
    index=$((index - 1))
  done
  RETURNED_VALUE=$(((index >= 0 ? index : 0) - _PROMPT_STRING_INDEX))
}

# Get the index delta to move to the end of the word (or next).
function prompt_getIndexDeltaToEndOfWord() {
  # move to the end of the word
  local -i index=${_PROMPT_STRING_INDEX}
  while [[ ${index} -lt ${#_PROMPT_STRING} && ${_PROMPT_STRING:index:1} == [[:space:]] ]]; do
    index+=1
  done
  while [[ ${index} -lt ${#_PROMPT_STRING} && ${_PROMPT_STRING:index:1} == [^[:space:]] ]]; do
    index=$((index + 1))
  done
  RETURNED_VALUE=$(((index <= ${#_PROMPT_STRING} ? index : ${#_PROMPT_STRING}) - _PROMPT_STRING_INDEX))
}

# Returns the index of the item in the original array (if any, or -1).
# It returns in the RETURNED_VALUE variable.
function prompt_getCurrentInitialItemsIndex() {
  if [[ ${_PROMPT_ITEMS_BOX_SHOWN} == "true" ]] && ((_PROMPT_FILTERED_ITEMS_SELECTED_INDEX >= 0 && _PROMPT_FILTERED_ITEMS_SELECTED_INDEX < ${#_PROMPT_FILTERED_ITEMS[@]})); then
    if ((${#_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[@]} > 0)); then
      RETURNED_VALUE=${_PROMPT_FILTERED_ITEMS_CORRESPONDENCES[${_PROMPT_FILTERED_ITEMS_SELECTED_INDEX}]}
    else
      RETURNED_VALUE=${_PROMPT_FILTERED_ITEMS_SELECTED_INDEX}
    fi
    return 0
  fi
  RETURNED_VALUE=-1
}

# ## prompt_getDisplayedPromptString (private)
#
# This function return a string that can be printed in a terminal in order to display a text
# and position the cursor at a given index in the input text.
#
# If the string is too long to fit in the screen, it will be truncated and ellipsis will be displayed
# at the beginning and/or at the end of the string.
#
# The cursor will be displayed under the character at the given index of the input text and
# it makes sure that the cursor is always visible in the screen.
#
# This function is useful to display a long prompt on a single line.
#
# An example:
#
# ```text
# _PROMPT_STRING_SCREEN_WIDTH=10
# _PROMPT_STRING_INDEX=20
# _PROMPT_STRING="This is a long string that will be displayed in the screen."
# #                                ^ input index 20
# prompt_getDisplayedPromptString 20 10
# # output: "…g string…"
# #                  ^ screen cursor (at index 8)
# ```
#
# - $_PROMPT_STRING: **input string** _as string_:
#       the string to display
# - $_PROMPT_STRING_INDEX: **input index** _as int_:
#       the index of the character (in the input string) that should be under the cursor
# - $_PROMPT_STRING_SCREEN_WIDTH: **screen width** _as int_:
#       the width of the screen
#
# Returns:
#
# - ${RETURNED_VALUE}: the string to display in the screen
# - ${RETURNED_VALUE2}: the index at which to position the cursor on screen
#
# ```bash
# prompt_getDisplayedPromptString "This is a long string that will be displayed in the screen." 20 10
# ```
function prompt_getDisplayedPromptString() {
  local -i inputLength=${#_PROMPT_STRING}
  local -i screenIndex

  # compute where we will display the cursor in the display
  if ((_PROMPT_STRING_INDEX >= _PROMPT_STRING_SCREEN_WIDTH)); then
    if ((_PROMPT_STRING_INDEX >= inputLength - 1)); then
      # we display it in the last position if it is at the end of the string
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 1))
    else
      # we display at the second last position if it is not at the end
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
    fi
  else
    if ((inputLength > _PROMPT_STRING_SCREEN_WIDTH && inputLength - _PROMPT_STRING_INDEX == 2)); then
      screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
    else
      if ((inputLength > _PROMPT_STRING_SCREEN_WIDTH && _PROMPT_STRING_SCREEN_WIDTH - _PROMPT_STRING_INDEX == 1)); then
        # if within the display but at the last character and we will need to display ellipsis...
        screenIndex=$((_PROMPT_STRING_SCREEN_WIDTH - 2))
      else
        # if it is already within the display, we display it at the right position
        screenIndex=${_PROMPT_STRING_INDEX}
      fi
    fi
  fi

  local -i screenLeftLength=$((screenIndex))
  local -i realLeftLength=$((_PROMPT_STRING_INDEX))

  local screenString=""

  # compute what to display at the left of the character under the caret (if any)
  if ((screenLeftLength > 0)); then
    if ((realLeftLength > screenLeftLength)); then
      # we can't display the whole left string, so we display ellipsis
      if ((screenLeftLength > 1)); then
        screenString+="…${_PROMPT_STRING:realLeftLength-screenLeftLength+1:screenLeftLength-1}"
      else
        screenString+="…"
      fi
    else
      screenString+="${_PROMPT_STRING:realLeftLength-screenLeftLength:screenLeftLength}"
    fi
  fi

  # compute the character to display under the caret (if any)
  if ((inputLength > 0 && _PROMPT_STRING_INDEX <= inputLength)); then
    screenString+="${_PROMPT_STRING:_PROMPT_STRING_INDEX:1}"
  fi

  # compute what to display at the right of the character under the caret (if any)
  local -i screenRightLength=$((_PROMPT_STRING_SCREEN_WIDTH - screenIndex - 1))
  local -i realRightLength=$((inputLength - _PROMPT_STRING_INDEX - 1))

  if ((screenRightLength > 0)); then
    if ((realRightLength > screenRightLength)); then
      # we can't display the whole right string, so we display ellipsis
      if ((screenRightLength > 1)); then
        screenString+="${_PROMPT_STRING:inputLength-realRightLength:screenRightLength-1}…"
      else
        screenString+="…"
      fi
    else
      screenString+="${_PROMPT_STRING:inputLength-realRightLength:screenRightLength}"
    fi
  fi

  RETURNED_VALUE="${screenString}"
  RETURNED_VALUE2=${screenIndex}
}

