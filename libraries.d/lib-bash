#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## bash::catchErrors
#
# This function runs a command and will catch any error that occurs instead of failing the program.
# The execution will continue if an error occurs in the command, but each error will be stored for later processing.
# For a function closer to a try/catch block, see `bash::runInSubshell`.
#
# - $@: **command with args** _as string_:
#       The command to run.
#
# Returns:
#
# - ${GLOBAL_ERROR_TRAP_LAST_ERROR_CODE}: the last error code encountered (or zero if none).
# - ${GLOBAL_ERROR_TRAP_ERROR_CODES}: the list of error codes that occurred during the execution of the command.
# - ${GLOBAL_ERROR_TRAP_ERROR_STACKS}: the list of error stacks that occurred during the execution of the command.
#
# ```bash
# bash::catchErrors myFunction "arg1" "arg2"
# if (( GLOBAL_ERROR_TRAP_LAST_ERROR_CODE != 0 )); then
#   core::fail "The command failed with code ${GLOBAL_ERROR_TRAP_LAST_ERROR_CODE}."
# fi
# ```
#
# > While you can also put the execution of a command in an `if` (or in a pipeline) statement to effectively
# > discard any errors happening in that command, the advantage of using this function is that the ERR trap
# > is still triggered and you can use trace level debugging to see the caught issues.
# > Additionally, it will report all the errors that occurred during the execution of the command.
function bash::catchErrors() {
  # temporarily disable errexit in the main shell
  set +o errexit
  GLOBAL_ERROR_TRAP_TRY_MODE_ENABLED=true
  # shellcheck disable=SC2034
  declare -g -a \
    GLOBAL_ERROR_TRAP_ERROR_CODES=() \
    GLOBAL_ERROR_TRAP_ERROR_STACKS=()
  "${@}"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_TRAP_TRY_MODE_ENABLED=false
  set -o errexit

  GLOBAL_ERROR_TRAP_LAST_ERROR_CODE=0
  if ((${#GLOBAL_ERROR_TRAP_ERROR_CODES[@]} > 0)) && ((${GLOBAL_ERROR_TRAP_ERROR_CODES[-1]} > 0)); then
    # shellcheck disable=SC2034
    GLOBAL_ERROR_TRAP_LAST_ERROR_CODE="${GLOBAL_ERROR_TRAP_ERROR_CODES[-1]}"
  fi
}

# ## bash::runInSubshell
#
# This functions runs a command in a subshell.
# The command can fail and can trigger errors; it will be caught and this function will return
# the exit code of the subshell.
# This function can almost be considered as a try/catch block for bash as the execution will stop on error
# but the error will be caught and stored for later processing instead of exiting the program.
#
# - $@: **command with args** _as string_:
#       The command to run in the subshell.
# - $_OPTION_EXIT_ON_FAIL _as bool_:
#       (optional) If set to true, the main program will exit with code 1 if the command fails.
#       (defaults to false)
#
# Returns:
#
# - ${REPLY_CODE}: the exit code of the subshell.
#
# ```bash
# bash::runInSubshell myFunction
# if (( REPLY_CODE != 0 )); then
#   core::fail "The subshell failed with code ${REPLY_CODE}"
# fi
# _OPTION_EXIT_ON_FAIL=true bash::runInSubshell myFunction
# ```
#
# > This function exists because the behavior of bash subshells are not what you would expect.
# > This function ensures that errors are properly handled and make the command list fail,
# > it ensures that we run the exit trap and it gives you the correct exit code of the subshell.
# > As a reminder, the error trap is not triggered for commands part of until while if ! || && tests,
# > see <https://www.gnu.org/software/bash/manual/bash.html#index-trap> and
# > <https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin-1>.
function bash::runInSubshell() {
  local exitOnFail="${_OPTION_EXIT_ON_FAIL:-false}"

  # ensure terminal settings are saved if needed because if that happens in the subshell
  # we would not be able to restore it in the main shell
  if [[ -z ${GLOBAL_STTY_SAVED_CONFIG:-} ]]; then
    include terminal
    terminal::saveSettings
  fi

  # disable the ERR trap or we would catch the subshell failure with it and not restore
  # the errexit and the original trap (and we would display an error message that we do
  # not want to display because we already displayed an error from the subshell).
  trap ERR
  # disable errexit in the main shell
  set +o errexit
  (
    # re-enable errexit in the subshell
    set -o errexit

    # we are inside a coproc, init the subshell correctly
    core::initSubshell

    # unset options or they will be visible from the subshell and might interfere
    local IFS=' '$'\t'$'\n'
    unset -v _OPTION_EXIT_ON_FAIL

    "${@}"
  )
  local subshellExitCode=${PIPESTATUS[0]:-}
  set -o errexit
  # restore the original ERR trap
  trap trap::onErrorInternal ERR
  if [[ ${exitOnFail} == "true" && ${subshellExitCode} -gt 0 ]]; then
    # shellcheck disable=SC2034
    core::exit "${subshellExitCode}" silent=true
  fi
  # shellcheck disable=SC2034
  REPLY_CODE="${subshellExitCode}"
}

# ## bash::injectCodeInFunction
#
# This function injects code at the beginning or the end of a function and
# returns the modified function to be evaluated.
#
# Creates an empty function if the function does not exist initially.
#
# - $1: **function name** _as string_:
#       The name of the function to inject the code into.
# - $2: **code** _as string_:
#       The code to inject.
# - ${injectAtBeginning} _as bool_:
#       (optional) Whether to inject the code at the beginning of the function (or at the end).
#       (defaults to false)
#
# Returns:
#
# - ${REPLY}: the modified function.
# - ${REPLY2}: the original function.
#
# ```bash
# bash::injectCodeInFunction myFunction "echo 'Hello!'" injectAtBeginning=true
# bash::injectCodeInFunction myFunction "echo 'world!'"
# eval "${REPLY}"
# myFunction
# ```
function bash::injectCodeInFunction() {
  local \
    functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    code="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    injectAtBeginning=false \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local functionDefinition modifiedFunctionDefinition
  if declare -f "${functionName}" 1>"${GLOBAL_TEMPORARY_STDOUT_FILE}"; then
    IFS='' read -rd '' functionDefinition <"${GLOBAL_TEMPORARY_STDOUT_FILE}" || [[ -n ${functionDefinition} ]]
    modifiedFunctionDefinition="${functionDefinition}"
  else
    modifiedFunctionDefinition="function ${functionName}() {"$'\n'"}"
  fi

  if [[ ${injectAtBeginning} == true ]]; then
    modifiedFunctionDefinition="${modifiedFunctionDefinition%%"{"*}{"$'\n'"${code}""${modifiedFunctionDefinition#*"{"}"
  else
    modifiedFunctionDefinition="${modifiedFunctionDefinition%"}"*}${code}"$'\n'"}"
  fi

  REPLY="${modifiedFunctionDefinition}"
  REPLY2="${functionDefinition:-}"
}

# ## bash::sleep
#
# Sleep for the given amount of time.
# This is a pure bash replacement of sleep.
#
# - $1: **time** _as float_:
#       the time to sleep in seconds (can be a float)
#       If 0, waits indefinitely.
#
# ```bash
# bash::sleep 1.5
# ```
#
# > The sleep command is not a built-in command in bash, but a separate executable. When you use sleep, you are creating a new process.
function bash::sleep() {
  local timeout="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if [[ ! -v GLOBAL_FD_BASH_SLEEP ]]; then
    exec {GLOBAL_FD_BASH_SLEEP}<>/dev/udp/127.0.0.1/0
  fi
  if [[ ${timeout} == "0" ]]; then
    # wait indefinitely
    read -r -u "${GLOBAL_FD_BASH_SLEEP}" || :
    return 0
  fi
  read -rt "${timeout}" -u "${GLOBAL_FD_BASH_SLEEP}" || :
}

# ## bash::readStdIn
#
# Read the content of the standard input.
# Will immediately return if the standard input is empty.
#
# Returns:
#
# - ${REPLY}: The content of the standard input.
#
# ```bash
# bash::readStdIn
# echo "${REPLY}"
# ```
function bash::readStdIn() {
  local IFS=''
  if read -t 0 -u 0 -rd ''; then
    read -u 0 -rd '' REPLY || [[ -n ${REPLY} ]] || REPLY=""
  else
    REPLY=""
  fi
}

# ## bash::countArgs
#
# Returns the number of arguments passed.
#
# A convenient function that can be used to:
#
# - count the files/directories in a directory:
#   `bash::countArgs "${PWD}"/* && local numberOfFiles="${REPLY}"`
# - count the number of variables starting with VALET_
#   `bash::countArgs "${!VALET_@}" && local numberOfVariables="${REPLY}"`
#
# Inputs:
#
# - $@: **arguments** _as any_:
#       the arguments to count
#
# Returns:
#
# - ${REPLY}: The number of arguments passed.
#
# ```bash
# bash::countArgs 1 2 3
# ```
function bash::countArgs() {
  REPLY="$#"
}

# ## bash::getMissingVariables
#
# This function returns the list of undeclared variables for the given names.
#
# - $@: **variable names** _as string_:
#       the list of variable names to check.
#
# Returns:
#
# - $?
#   - 0 if there are variable undeclared
#   - 1 otherwise.
# - ${REPLY_ARRAY[@]}: the list of undeclared variables.
#
# ```bash
# if bash::getMissingVariables "var1" "var2"; then
#   printf 'The following variables are not declared: %s' "${REPLY_ARRAY[*]}"
# fi
# ```
function bash::getMissingVariables() {
  REPLY_ARRAY=()
  local var
  for var in "$@"; do
    if [[ ! -v "${var}" ]]; then
      REPLY_ARRAY+=("${var}")
    fi
  done
  if [[ ${#REPLY_ARRAY[@]} -gt 0 ]]; then
    return 0
  fi
  return 1
}

# ## bash::getMissingCommands
#
# This function returns the list of not existing commands for the given names.
#
# - $@: **command names** _as string_:
#       the list of command names to check.
#
# Returns:
#
# - $?
#   - 0 if there are not existing commands
#   - 1 otherwise.
# - ${REPLY_ARRAY[@]}: the list of not existing commands.
#
# ```bash
# if bash::getMissingCommands "command1" "command2"; then
#   printf 'The following commands do not exist: %s' "${REPLY_ARRAY[*]}"
# fi
# ```
function bash::getMissingCommands() {
  REPLY_ARRAY=()
  local cmd
  for cmd in "$@"; do
    if ! command -v "${cmd}" &>/dev/null; then
      REPLY_ARRAY+=("${cmd}")
    fi
  done
  if [[ ${#REPLY_ARRAY[@]} -gt 0 ]]; then
    return 0
  fi
  return 1
}

# ## bash::isCommand
#
# Check if the given command exists.
#
# - $1: **command name** _as string_:
#       the command name to check.
#
# Returns:
#
# - $?
#   - 0 if the command exists
#   - 1 otherwise.
#
# ```bash
# if bash::isCommand "command1"; then
#   printf 'The command exists.'
# fi
# ```
function bash::isCommand() {
  if command -v "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" &>/dev/null; then
    return 0
  fi
  return 1
}

# ## bash::isFunction
#
# Check if the given function exists.
#
# - $1: **function name** _as string_:
#       the function name to check.
#
# Returns:
#
# - $?
#   - 0 if the function exists
#   - 1 otherwise.
#
# ```bash
# if bash::isFunction "function1"; then
#   printf 'The function exists.'
# fi
# ```
function bash::isFunction() {
  if declare -F "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" &>/dev/null; then
    return 0
  fi
  return 1
}

# ## bash::getFunctionDefinitionWithGlobalVars (private)
#
# This function can be used to get the definition of an existing function,
# rename it, and replace the use of positional parameters by global variables.
#
# This can be useful for performance reasons when a function is called many times,
# to avoid copying the positional parameters each time.
#
# - $1: **function name** _as string_:
#       the name of the function to re-export
# - $2: **new function name** _as string_:
#       the name of the new function to create
# - $@: global variable name _as string_:
#       the name of the global variable to use instead of the positional parameters
#       (can be repeated multiple times, for each parameter)
#
# Returns:
#
# - ${REPLY}: the modified function definition
# - ${REPLY2}: the original function
#
# ```bash
# bash::getFunctionDefinitionWithGlobalVars "myFunction" "myFunctionWithGlobalVars" "MY_VAR1" "MY_VAR2"
# eval "${REPLY}"
# myFunctionWithGlobalVars
# ```
function bash::getFunctionDefinitionWithGlobalVars() {
  local \
    functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    newFunctionName="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  shift 2

  local IFS=''
  declare -f "${functionName}" 1>"${GLOBAL_TEMPORARY_STDOUT_FILE}" || core::fail "The function ⌜${functionName}⌝ does not exist."
  read -rd '' REPLY2 <"${GLOBAL_TEMPORARY_STDOUT_FILE}" || [[ -n ${REPLY2} ]]
  local functionDefinition
  functionDefinition="${REPLY2/"${functionName}"/"${newFunctionName}"}"

  if (($# == 0)); then
    REPLY="${functionDefinition}"
    return 0
  fi

  # find the mapping between the positional parameters and the new global variable names
  local -A globalVars=()
  local -a positionalParameters=("$@")
  local IFS=$'\n'
  local line varName varPosition
  local modifiedFunctionDefinition=""
  for line in ${functionDefinition}; do
    if ((${#positionalParameters[@]} != ${#globalVars[@]})); then
      if [[ "${line}" =~ ^\ *local\ +(-[[:alpha:]]+\ )?([[:alpha:]]+)=[^$]*\$\{?([[:digit:]]+) ]]; then
        varName="${BASH_REMATCH[2]}"
        varPosition="${BASH_REMATCH[3]}"
        if [[ -n ${positionalParameters[$((varPosition - 1))]} ]]; then
          globalVars["${varName}"]="${positionalParameters[$((varPosition - 1))]}"
          log::trace "found local ${varName}=\${${varPosition}} -> remapped to ${globalVars[${varName}]}"
          continue
        fi
      fi
    fi
    modifiedFunctionDefinition+="${line}"$'\n'
  done

  # modify the function to use the global variables instead of the positional parameters
  for varName in "${!globalVars[@]}"; do
    modifiedFunctionDefinition="${modifiedFunctionDefinition//${varName}/"${globalVars[${varName}]}"}"
  done

  REPLY="${modifiedFunctionDefinition}"
}

# ## bash::getBuiltinOutput
#
# Capture the output of a builtin command. Can be used on bash builtins that produce output.
# It captures the stdout and stderr of said command.
#
# This function is a lot more basic than `exe::invoke` and does not support all its features.
#
# - $@: **command with arguments** _as string_:
#       The command to run.
#
# Returns:
#
# - ${REPLY_CODE}:
#   - 0 if the command was successful
#   - 1 otherwise.
# - ${REPLY}: The captured output.
#
# ```bash
# bash::getBuiltinOutput declare -f bash::getBuiltinOutput
# echo "${REPLY}"
# ```
function bash::getBuiltinOutput() {
  local IFS=' '
  REPLY=""
  # shellcheck disable=SC2068
  if "${@}" &>"${GLOBAL_TEMPORARY_STDOUT_FILE}"; then
    IFS='' read -rd '' REPLY <"${GLOBAL_TEMPORARY_STDOUT_FILE}" || :
    REPLY_CODE=0
  else
    # shellcheck disable=SC2034
    REPLY_CODE=$?
  fi
}

# ## bash::isFdValid
#
# Check if the given file descriptor is valid.
#
# - $1: **file descriptor** _as string_:
#       The file descriptor to check.
#
# Returns:
#
# - $?
#   - 0 if the file descriptor is valid
#   - 1 otherwise.
#
# ```bash
# if bash::isFdValid 1; then
#   echo "File descriptor 1 is valid."
# fi
# ```
function bash::isFdValid() {
  local fd="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local test keepStderr
  exec {keepStderr}>&2
  if [[ ${fd} =~ ^[0-9]+$ ]]; then
    if { exec {test}>&"${fd}"; } 2>/dev/null; then
      exec 2>&${keepStderr} {test}>&- {keepStderr}>&-
      return 0
    fi
  else
    if { exec {test}>>"${fd}"; } 2>/dev/null; then
      exec 2>&${keepStderr} {test}>&- {keepStderr}>&-
      return 0
    fi
  fi
  exec 2>&${keepStderr} {keepStderr}>&-
  return 1
}

# ## bash::isVariableCachedWithValue
#
# Check if one or more variables are cached with the given value.
# If all the variables given already have the same value cached,
# the function will return true.
# Otherwise, it will return false and cache the given value in the variables.
#
# - $1: **variable name** _as string_:
#       the name of the variable to check
# - $2: **value** _as any_:
#       the value to check against the variable
# - $@: **variable/value pair** _as any_:
#       additional variable/value pairs to check
#
# Returns:
#
# - $?:
#   - 0 if all the variables have the same value as the given value
#   - 1 otherwise
#
# ```bash
# if bash::isVariableCachedWithValue "MY_VAR" "my_value"; then
#   echo "MY_VAR is cached with the value 'my_value'"
# else
#   echo "MY_VAR is not cached with the value 'my_value'"
# fi
# ```
function bash::isVariableCachedWithValue() {
  local -i nbNotCached=0
  local varName varValue
  while (($# > 0)); do
    varName="_BASH_VAR_CACHED_${1}"
    varValue="${2}"
    shift 2
    if [[ ! -v "${varName}" || ${!varName} != "${varValue}" ]]; then
      nbNotCached=$((nbNotCached + 1))
      eval "${varName}=\"${varValue}\""
    fi
  done
  return $((nbNotCached == 0 ? 0 : 1))
}

# ## bash::clearCachedVariables
#
# Clear the cached variables used by bash::isVariableCachedWithValue.
# This will unset all variables starting with _TUI_CACHED_.
#
# - $@ : **variable names** _as any_:
#       (optional) the names of the variables to clear
#       (defaults to all cached variables)
#
# ```bash
# bash::clearCachedVariables
# bash::clearCachedVariables "MY_VAR" "ANOTHER_VAR"
# ```
function bash::clearCachedVariables() {
  if (($# == 0)); then
    # shellcheck disable=SC2086
    unset -v ${!_TUI_CACHED_*}
  else
    while (($# > 0)); do
      unset -v "_BASH_VAR_CACHED_${1}"
      shift
    done
  fi
}
