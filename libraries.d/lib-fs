#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## fs::toAbsolutePath
#
# This function returns the absolute path of a path.
#
# If the path exists, it can be resolved to the real path, following symlinks,
# using the option `realpath=true`.
#
# - $1: **path** _as string_:
#       The path to translate to absolute path.
# - ${realpath} _as bool_:
#       (optional) true to resolve the path to the real path, following symlinks.
#       (defaults to false)
#
# Returns:
#
# - ${REPLY}: The absolute path of the path.
#
# ```bash
# fs::toAbsolutePath "myPath"
# fs::toAbsolutePath "myPath" realpath=true
# echo "${REPLY}"
# ```
#
# > This is a pure bash alternative to `realpath` or `readlink`.
# > The `..` will be processed before following any symlinks, by removing
# > the immediate pathname component.
function fs::toAbsolutePath() {
  local \
    path="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    realpath="false" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  path="${path%/}"

  # if path starts with ~, we replace it with the home directory
  if [[ ${path} == "~"* ]]; then
    path="${HOME}${path:1}"
  fi

  # check if the path is an existing directory
  if cd "${path}" &>/dev/null; then
    if [[ ${realpath:-} == "true" ]]; then
      fs::getPwdRealPath
    else
      REPLY="${PWD}"
    fi
    cd "${OLDPWD}" &>/dev/null || core::fail "Failed to cd back to the previous directory."
    return 0
  fi

  # check if the path is an existing file
  if cd "${path%/*}" &>/dev/null; then
    if [[ ${realpath:-} == "true" ]]; then
      fs::getPwdRealPath
      REPLY="${REPLY}/${path##*/}"
    else
      REPLY="${PWD}/${path##*/}"
    fi
    cd "${OLDPWD}" &>/dev/null || core::fail "Failed to cd back to the previous directory."
    return 0
  fi

  local currentDirectoryPath
  if [[ ${realpath:-} == "true" ]]; then
    fs::getPwdRealPath
    currentDirectoryPath="${REPLY}"
  else
    currentDirectoryPath="${PWD}"
  fi

  # TODO: from this point and for non existing path, we could loop on the path components
  # to resolve the real path starting from the left until we have a missing path component

  # if the file is already an absolute path, we return it
  if [[ ${path} == "/"* ]]; then
    REPLY="${path}"
    return 0
  fi

  # other cases of relative paths not handled
  REPLY="${currentDirectoryPath}/${path#./}"
}

# ## fs::getPwdRealPath
#
# Get the real path of the current directory.
# By default, the `${PWD}` variable is the logical path, which may contain symlinks.
#
# ```bash
# fs::getPwdRealPath
# echo "${REPLY}"
# ```
#
# Returns:
#
# - ${REPLY}: The realpath for the current directory.
#
# > This is a pure bash alternative to `realpath` or `readlink`.
function fs::getPwdRealPath() {
  local IFS=''
  pwd -P &>"${GLOBAL_TEMPORARY_STDOUT_FILE}"
  IFS='' read -rd '' REPLY <"${GLOBAL_TEMPORARY_STDOUT_FILE}" || :
  REPLY="${REPLY%[[:space:]]}"
}

# ## fs::readFile
#
# Reads the content of a file and returns it in the global variable REPLY.
# Uses pure bash.
#
# - $1: **path** _as string_:
#       the file path to read
# - ${maxCharacters} _as int_:
#       (optional) the maximum number of characters to read
#       If set to 0, the whole file will be read.
#       (defaults to 0)
#
# > If the file does not exist, the function will return an empty string instead of failing.
#
# Returns:
#
# - ${REPLY}: The content of the file.
#
# ```bash
# fs::readFile /path/to/file
# fs::readFile /path/to/file maxCharacters=100
# echo "${REPLY}"
# ```
function fs::readFile() {
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    maxCharacters="0" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if [[ ! -s "${filePath}" ]]; then
    REPLY=""
    return 0
  fi

  if [[ "${maxCharacters}" -gt 0 ]]; then
    read -rd '' -n "${maxCharacters}" REPLY <"${filePath}" || [[ -n ${REPLY} ]]
  else
    read -rd '' REPLY <"${filePath}" || [[ -n ${REPLY} ]] || REPLY=""
    # fail safe for cases where the file is suppose to not be empty but we get null string
    if [[ -z ${REPLY} ]]; then
      REPLY="$(<"${filePath}")"
    fi
  fi
}

## fs::writeToFile
#
# Write the content to a file.
#
# - $1: **path** _as string_:
#       the file path to write
# - $2: **content** _as string_:
#       The variable containing the content to write.
# - ${append} _as bool_:
#       (optional) true to append the content to the file, false otherwise
#       (defaults to false)
#
# ```bash
# fs::writeToFile /path/to/file content
# fs::writeToFile /path/to/file content append=true
# ```
#
# > - This function will overwrite the file if it already exists.
# > - If the file path does not exist, the function will create the directory tree.
# > - The main use case is to be able to mock this function during tests...
function fs::writeToFile() {
  local -n contentToWriteInFile="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    append="false" \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  fs::createFileIfNeeded "${filePath}"
  if [[ ${append} == "true" ]]; then
    printf '%s' "${contentToWriteInFile}" >>"${filePath}"
  else
    printf '%s' "${contentToWriteInFile}" >"${filePath}"
  fi
}

# ## fs::createDirectoryIfNeeded
#
# Create the directory tree if needed.
#
# - $1: **path** _as string_:
#       The directory path to create.
#
# Returns:
#
# - ${REPLY}: The absolute path to the directory.
#
# ```bash
# fs::createDirectoryIfNeeded "/my/directory"
# echo "${REPLY}"
# ```
function fs::createDirectoryIfNeeded() {
  fs::toAbsolutePath "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if [[ -d "${REPLY}" ]]; then
    return 0
  fi

  local dirPath="${REPLY}"

  if [[ ! -d "${dirPath}" ]]; then
    if ! mkdir -p "${dirPath}" 1>/dev/null; then
      core::fail "Failed to create the directory ⌜${dirPath}⌝."
    fi
  fi

  REPLY="${dirPath}"
}

# ## fs::createFileIfNeeded
#
# Make sure that the given file exists.
# Create the directory tree and the file if needed.
#
# - $1: **path** _as string_:
#       the file path to create
#
# Returns:
#
# - ${REPLY}: The absolute path of the file.
#
# ```bash
# fs::createFileIfNeeded "myFile"
# echo "${REPLY}"
# ```
function fs::createFileIfNeeded() {
  fs::toAbsolutePath "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if [[ -f "${REPLY}" ]]; then
    return 0
  fi

  local filePath="${REPLY}"
  local parentDir="${filePath%/*}"

  fs::createDirectoryIfNeeded "${parentDir}"

  if [[ ! -f "${filePath}" ]]; then
    : >"${filePath}"
  fi

  REPLY="${filePath}"
}

# ## fs::cat
#
# Print the content of a file to stdout.
# This is a pure bash equivalent of cat.
#
# - $1: **path** _as string_:
#       the file to print
#
# ```bash
# fs::cat myFile
# ```
#
# > Also see log::printFile if you want to print a file for a user.
function fs::cat() {
  fs::readFile "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  printf '%s\n' "${REPLY}"
}

# ## fs::head
#
# Print the first lines of a file to stdout.
# This is a pure bash equivalent of head.
#
# - $1: **path** _as string_:
#       The file to print.
# - $2: **number of lines** _as int_:
#       The number of lines to print.
# - ${toArray} _as bool_:
#       (optional) If true, the output will be stored in the variable `REPLY_ARRAY`
#       instead of being printed to stdout.
#       (defaults to false)
#
# ```bash
# fs::head myFile 10
# fs::head myFile 10 toArray=true
# ```
#
# > #TODO: faster with mapfile + quantum?
function fs::head() {
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    numberOfLines="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    toArray="false" \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  REPLY_ARRAY=()
  local line
  local -i nb=0
  while IFS=$'\n' read -rd $'\n' line || [[ -n ${line:-} ]]; do
    if ((nb++ >= numberOfLines)); then
      break
    fi
    if [[ ${toArray} == "true" ]]; then
      REPLY_ARRAY+=("${line}")
    else
      printf '%s\n' "${line}"
    fi
  done <"${filePath}"
}

# ## fs::tail
#
# Print the last lines of a file to stdout.
# This is a pure bash equivalent of tail.
# However, because we have to read the whole file, it is not efficient for large files.
#
# - $1: **path** _as string_:
#       The file to print.
# - $2: **number of lines** _as int_:
#       The number of lines to print from the end of the file.
# - ${toArray} _as bool_:
#       (optional) If true, the output will be stored in the variable `REPLY_ARRAY`
#       instead of being printed to stdout.
#       (defaults to false)
#
# ```bash
# fs::tail myFile 10
# ```
#
# > #TODO: use mapfile quantum to not have to read the whole file in a single go.
function fs::tail() {
  local \
    filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    numberOfLines="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    toArray="false" \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  REPLY_ARRAY=()
  local -a lines
  mapfile -t lines <"${filePath}"
  local -i startLine=$((${#lines[@]} - numberOfLines))
  if [[ ${startLine} -lt 0 ]]; then
    startLine=0
  fi
  if [[ ${toArray} == "true" ]]; then
    REPLY_ARRAY=("${lines[@]:${startLine}}")
  else
    printf '%s\n' "${lines[@]:${startLine}}"
  fi
}

# ## fs::listPaths
#
# List all the paths in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - ${recursive} _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - ${includeHidden} _as bool_:
#       (optional) true to list hidden paths, false otherwise
#       (defaults to false)
# - ${filter} _as string_:
#       (optional) A function name that is called to filter the paths that will be listed
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
# - ${filterDirectory} _as string_:
#       (optional) A function name that is called to filter the directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: An array with the list of all the paths.
#
# ```bash
# fs::listPaths "/path/to/directory" true true myFilterFunction myFilterDirectoryFunction
# for path in "${REPLY_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
#
# > - It will correctly list files under symbolic link directories.
function fs::listPaths() {
  local \
    directory="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    recursive="false" \
    includeHidden="false" \
    filter="" \
    filterDirectory="" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if [[ ${includeHidden} == "true" ]]; then
    log::trace "Activating the dotglob shell option to include hidden files."
    shopt -s dotglob
  fi

  REPLY_ARRAY=()

  local path listOfDirectories currentDirectory

  listOfDirectories="${directory}"$'\n'
  while [[ -n ${listOfDirectories} ]]; do
    currentDirectory="${listOfDirectories%%$'\n'*}"
    listOfDirectories="${listOfDirectories#*$'\n'}"

    log::trace "Listing paths in ⌜${currentDirectory}⌝."

    for path in "${currentDirectory}"/*; do
      if [[ ${recursive} == "true" && -d "${path}" ]]; then
        if [[ -z ${filterDirectory} ]] || ${filterDirectory} "${path}"; then
          listOfDirectories+="${path}"$'\n'
          log::trace "Adding directory ⌜${path}⌝ to the search list."
        fi
      fi
      if [[ -n ${filter} ]] && ! ${filter} "${path}"; then
        continue
      fi
      REPLY_ARRAY+=("${path}")
    done
  done

  if [[ ${includeHidden} == "true" ]]; then
    shopt -u dotglob
  fi
}

# ## fs::listFiles
#
# List all the files in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - ${recursive} _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - ${includeHidden} _as bool_:
#       (optional) true to list hidden files, false otherwise
#       (defaults to false)
# - ${filter} _as string_:
#       (optional) A function name that is called to filter the files that will be listed
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
# - ${filterDirectory} _as string_:
#       (optional) A function name that is called to filter the directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: An array with the list of all the files.
#
# ```bash
# fs::listFiles "/path/to/directory" true true myFilterFunction
# for path in "${REPLY_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
function fs::listFiles() {
  local \
    directory="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    recursive="false" \
    includeHidden="false" \
    filter="" \
    filterDirectory="" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  # Helper function to check if the path is a file
  eval "function fs_listFilesReturnTrueIfFile() {
    if [[ ! -f \${1} ]]; then return 1; fi
    if ! ${filter:-":"} \"\${1}\"; then
      return 1
    fi
  }"

  fs::listPaths "${directory}" recursive="${recursive}" includeHidden="${includeHidden}" filter=fs_listFilesReturnTrueIfFile filterDirectory="${filterDirectory}"

  unset -f fs_listFilesReturnTrueIfFile
}

# ## fs::listDirectories
#
# List all the directories in the given directory.
#
# - $1: **directory** _as string_:
#       the directory to list
# - ${recursive} _as bool_:
#       (optional) true to list recursively, false otherwise
#       (defaults to false)
# - ${includeHidden} _as bool_:
#       (optional) true to list hidden directories, false otherwise
#       (defaults to false)
# - ${filter} _as string_:
#       (optional) A function name that is called to filter the directories that will be listed
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
# - ${filterDirectory} _as string_:
#       (optional) A function name that is called to filter the directories (for recursive listing)
#       The function should return 0 if the path is to be kept, 1 otherwise.
#       The function is called with the path as the first argument.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY_ARRAY[@]}: An array with the list of all the files.
#
# ```bash
# fs::listDirectories "/path/to/directory" true true myFilterFunction
# for path in "${REPLY_ARRAY[@]}"; do
#   printf '%s' "${path}"
# done
# ```
function fs::listDirectories() {
  local \
    directory="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    recursive="false" \
    includeHidden="false" \
    filter="" \
    filterDirectory="" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  # Helper function to check if the path is a file
  eval "function fs_listDirectoriesReturnTrueIfDirectory() {
    if [[ ! -d \${1} ]]; then return 1; fi
    if ! ${filter:-":"} \"\${1}\"; then
      return 1
    fi
  }"

  fs::listPaths "${directory}" recursive="${recursive}" includeHidden="${includeHidden}" filter=fs_listDirectoriesReturnTrueIfDirectory filterDirectory="${filterDirectory}"

  unset -f fs_listDirectoriesReturnTrueIfDirectory
}

# ## fs::isDirectoryWritable
#
# Check if the directory is writable. Creates the directory if it does not exist.
#
# - $1: **directory** _as string_:
#       the directory to check
# - ${testFileName} _as string_:
#       (optional) The name of the file to create in the directory to test the write access
#       (defaults to "writable-test-${BASHPID}")
#
# Returns:
#
# - $?:
#   - 0 if the directory is writable
#   - 1 otherwise
#
# ```bash
# if fs::isDirectoryWritable "/path/to/directory"; then
#   echo "The directory is writable."
# fi
# ```
function fs::isDirectoryWritable() {
  local \
    directory="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    testFileName="writable-test-${BASHPID}" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  directory="${directory%/}"
  if ! mkdir -p "${directory}" &>/dev/null; then
    return 1
  fi
  local path="${directory}/${testFileName}"
  if { : >"${path}"; } &>/dev/null; then
    if ! rm -f "${path}" 1>/dev/null; then
      return 1
    fi
    return 0
  fi
  return 1
}

# ## fs::createLink
#
# Create a soft or hard link (original ← link).
#
# Reminder:
#
# - A soft (symbolic) link is a new file that contains a reference to another file or directory in the
#   form of an absolute or relative path.
# - A hard link is a directory entry that associates a new pathname with an existing
#   file (inode + data block) on a file system.
#
# See `windows::createLink` for Windows.
#
# - $1: **linked path** _as string_:
#       the path to link to (the original file)
# - $2: **link path** _as string_:
#       the path where to create the link
# - ${hardlink} _as boolean_:
#       (optional) True to create a hard link, false to create a symbolic link
#       (defaults to false)
# - ${force} _as boolean_:
#       (optional) True to overwrite the link or file if it already exists.
#       Otherwise, the function will fail on an existing link.
#       (defaults to false)
#
# ```bash
# fs::createLink "/path/to/link" "/path/to/linked"
# fs::createLink "/path/to/link" "/path/to/linked" hardlink=true force=true
# ```
#
# > The function uses the `ln` command.
function fs::createLink() {
  local \
    linkedPath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    linkPath="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    hardlink="false" \
    force="false" \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  fs::toAbsolutePath "${linkedPath}"
  linkedPath="${REPLY}"
  fs::toAbsolutePath "${linkPath}"
  linkPath="${REPLY}"

  # check if the linked path exists
  if [[ ! -e "${linkedPath}" ]]; then
    core::fail "Failed to create a link ⌜${linkedPath}⌝ ← ⌜${linkPath}⌝, the linked path does not exist."
  fi

  # check the link path
  if [[ -f ${linkPath} || -L ${linkPath} ]]; then
    # if force, delete the link (or file) if it exists
    if [[ ${force} == true ]]; then
      if ! rm -f "${linkPath}"; then
        core::fail "Failed to delete the existing link ⌜${linkPath}⌝ to replace it."
      fi
    else
      core::fail "Failed to create a link to ⌜${linkedPath}⌝ ← ⌜${linkPath}⌝, the link pathname already exists."
    fi
  fi

  # create link parent directory if needed
  local linkParentPath="${linkPath%/*}"
  fs::createDirectoryIfNeeded "${linkParentPath}"

  # create link
  if [[ ${hardlink} == "true" ]]; then
    if ! ln "${linkedPath}" "${linkPath}"; then
      core::fail "Failed to create the hard link ⌜${linkedPath}⌝ ← ⌜${linkPath}⌝."
    fi
  else
    if ! ln -s "${linkedPath}" "${linkPath}"; then
      core::fail "Failed to create the symbolic link ⌜${linkedPath}⌝ ← ⌜${linkPath}⌝."
    fi
  fi

  local linkType="symbolic"
  if [[ ${hardlink} == "true" ]]; then
    linkType="hard"
  fi
  log::debug "Created ${linkType} link: ⌜${linkedPath}⌝ ← ⌜${linkPath}⌝."
}

# ## fs::getFileLineCount
#
# Get the number of lines in a file.
#
# - $1: **path** _as string_:
#       the file path to read
#
# Returns:
#
# - ${REPLY}: The number of lines in the file.
#
# ```bash
# fs::getFileLineCount "/path/to/file"
# echo "${REPLY}"
# ```
#
# TODO: fails to count the last line if empty
function fs::getFileLineCount() {
  local filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i lineCount=0
  while IFS=$'\n' read -rd $'\n' || [[ -n ${REPLY:-} ]]; do
    lineCount+=1
  done <"${filePath}"
  REPLY="${lineCount}"
}

# ## fs::getScriptDirectory
#
# This function returns the absolute path of the directory of the script that called it.
#
# Returns:
#
# - ${REPLY}: the directory of the script that called it.
#
# ```bash
# fs::getScriptDirectory
# echo "${REPLY}"
# ```
function fs::getScriptDirectory() {
  local scriptDirectory
  local scriptDirectory="${BASH_SOURCE[1]}"
  if [[ "${scriptDirectory}" != /* ]]; then
    # resolve relative path
    if pushd "${scriptDirectory%/*}" &>/dev/null; then
      scriptDirectory="${PWD}"
      popd &>/dev/null || :
    else
      scriptDirectory="${PWD}"
    fi
  else
    # strip filename
    scriptDirectory="${scriptDirectory%/*}"
  fi
  fs::toAbsolutePath "${scriptDirectory}"
  REPLY="${scriptDirectory}"
}

# ## fs::getCommandPath
#
# Get the absolute path of a command.
#
# - $1: **command** _as string_:
#       the command to find
#
# Returns:
#
# - ${REPLY}: The absolute path of the command (or empty if command not found).
#
# ```bash
# fs::getCommandPath "command"
# echo "${REPLY}"
# ```
function fs::getCommandPath() {
  local command="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if [[ -v BASH_CMDS && -n ${BASH_CMDS[${command}]:-} ]]; then
    fs::toAbsolutePath "${BASH_CMDS[${command}]}"
    return 0
  fi

  if command -v "${command}" &>"${GLOBAL_TEMPORARY_STDOUT_FILE}"; then
    IFS='' read -rd '' REPLY <"${GLOBAL_TEMPORARY_STDOUT_FILE}" || :
    REPLY="${REPLY%[[:space:]]}"
    fs::toAbsolutePath "${REPLY}"
    return 0
  fi

  REPLY=""
}
