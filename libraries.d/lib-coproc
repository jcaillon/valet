#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## coproc::runInParallel
#
# This function runs a list of commands in parallel with a maximum number of parallel coprocs.
#
# - $1: **job commands array name** _as string_:
#       The name of the array containing the commands to run.
#       Each command string will be evaluated in a subshell.
#       Each command should explicitly exit with a non-zero code if it fails and with zero if it succeeds.
# - ${maxInParallel} _as int_:
#       (optional) The maximum number of parallel coprocs to run.
#       (defaults to 8)
# - ${completedCallback} _as string_:
#       (optional) The name of the function to call when a coproc is completed (successfully or not).
#       The function will receive the following arguments:
#       - $1 the coproc index
#       - $2 the coproc exit code
#       - $3 the percentage of coprocs already completed
#       - $4 the path of the file containing the accumulated logs of the coproc
#       If the function sets REPLY to 1, the script will exit early. Otherwise it should set REPLY to 0.
#       Set to an empty string to not call any callback function.
#       (defaults to "")
# - ${redirectLogs} _as bool_:
#       (optional) Redirect the logs of the coproc instead of printing them in the current file descriptor.
#       The accumulated logs of the coproc will be available in the completed callback function.
#       (defaults to false)
# - ${printRedirectedLogs} _as bool_:
#       (optional) This option allows to automatically redirect the logs of the coproc to a file and
#       print the accumulated logs of a coproc when it is completed (successfully or not).
#       (defaults to false)
# - ${simulateSequentialRun} _as bool_:
#       (optional) If true, this will:
#       - redirect the logs of each task to a file
#       - at the end of all execution, print the logs of each task, in natural order (not as they finish)
#       - exit at the first error, showing the logs of the task in error
#       Tasks will run as if they are called in a for loop; except they actually run in parallel.
#       (defaults to false)
# - ${coprocNamePrefix} _as string_:
#       (optional) The prefix to use for the coproc variable names.
#       This is useful to avoid conflicts with other coproc variables.
#       (defaults to "_COPROC_PARALLEL_")
#
# Returns:
#
# - ${REPLY}: The number of jobs that did not completed (i.e. not executed until the end, successfully or not)
# - ${REPLY2}: The number of successfully completed jobs.
# - ${REPLY_ARRAY[@]}: an array containing the exit codes of the jobs.
#
# ```bash
# declare -a jobCommands=("sleep 1" "sleep 2" "sleep 3")
# coproc::runInParallel jobCommands maxParallelCoprocs=2
# ```
# TODO: implement unit tests for this function
function coproc::runInParallel() {
  local -n jobCommands_nameRef="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    maxInParallel=8 \
    completedCallback="" \
    redirectLogs=false \
    printRedirectedLogs=false \
    simulateSequentialRun=false \
    coprocNamePrefix="_COPROC_PARALLEL_" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if ((BASH_SUBSHELL > 0)); then
    coprocNamePrefix+="${BASH_SUBSHELL}_"
  fi

  maxInParallel=$((maxInParallel < 1 ? 1 : maxInParallel))

  local -a -i pids=() runningPids=() exitCodes=()
  local -i index pid endedCoprocPid endedCoprocExitStatus endedCoprocIndex
  local -a logFiles=()
  local logFile="" coprocName

  for ((index = 0; index < ${#jobCommands_nameRef[@]}; index++)); do
    if [[ ${redirectLogs} == "true" || ${printRedirectedLogs} == "true" || ${simulateSequentialRun} == "true" ]]; then
      fs::createTempFile pathOnly=true
      logFile="${REPLY}"
    fi
    logFiles+=("${logFile}")

    coprocName="${coprocNamePrefix}${index}"

    coproc::run "${coprocName}" \
      initCommand="${jobCommands_nameRef[index]}" \
      redirectLogsToFile="${logFile}"

    pid="${REPLY}"
    pids+=("${pid}")
    runningPids+=("${pid}")

    log::debug "Running parallel coproc ${index} with PID ${pid}."
    log::trace "Command: ${jobCommands_nameRef[index]}"

    while ((${#runningPids[@]} >= maxInParallel || index == ${#jobCommands_nameRef[@]} - 1)); do
      # wait for one of the coproc to finish (or all of them if they are all scheduled)
      endedCoprocExitStatus=0
      wait -n -p endedCoprocPid "${runningPids[@]}" || endedCoprocExitStatus=$?
      exitCodes+=("${endedCoprocExitStatus}")

      if [[ -z ${endedCoprocPid:-} ]]; then
        continue
      fi

      # find the index of the ended coproc in the pids array
      for endedCoprocIndex in "${!pids[@]}"; do
        if [[ ${pids[endedCoprocIndex]} == "${endedCoprocPid}" ]]; then
          log::debug "The coproc with PID ${endedCoprocPid} is at index ${endedCoprocIndex} in ${pids[*]}."
          break
        fi
      done
      coprocName="${coprocNamePrefix}${endedCoprocIndex}"

      log::debug "The parallel coproc ${endedCoprocIndex} with PID ${endedCoprocPid} is completed with code ${endedCoprocExitStatus}."

      # remove the coproc from the list of running pids
      coproc_cleanBackgroundProcess "${coprocName}"
      local pidIndex
      for pidIndex in "${!runningPids[@]}"; do
        if [[ ${runningPids[pidIndex]} == "${endedCoprocPid}" ]]; then
          unset -v 'runningPids[pidIndex]'
          break
        fi
      done

      if [[ ${printRedirectedLogs} == "true" ]]; then
        # display the accumulated logs
        if [[ -n ${logFiles[endedCoprocIndex]} && -s ${logFiles[endedCoprocIndex]} ]]; then
          fs::readFile "${logFiles[endedCoprocIndex]}"
          log::printRaw REPLY
        fi
      fi

      # execute the completed callback if defined
      if [[ -n ${completedCallback} ]]; then
        local -i percentageCompleted=$((${#exitCodes[@]} * 100 / ${#jobCommands_nameRef[@]}))
        REPLY=0
        "${completedCallback}" "${endedCoprocIndex}" "${endedCoprocExitStatus}" "${percentageCompleted}" "${logFiles[endedCoprocIndex]}"
        if ((REPLY != 0)); then
          log::debug "The completed callback function ${completedCallback} requested to stop the parallel execution."
          REPLY=1
          break 2
        fi
      fi

      # in "pseudo sequential" run, we exit at the first error and display the log
      if [[ ${simulateSequentialRun} == "true" && ${endedCoprocExitStatus} != 0 ]]; then
        log::debug "The coproc ${coprocName} failed with exit code ${endedCoprocExitStatus}."
        # display the accumulated logs
        if [[ -n ${logFiles[endedCoprocIndex]} && -s ${logFiles[endedCoprocIndex]} ]]; then
          fs::readFile "${logFiles[endedCoprocIndex]}"
          log::printRaw REPLY
        fi
        core::exit 1 silent=true
      fi

      # if all coproc are scheduled and completed, we can exit the loop
      if ((${#exitCodes[@]} == ${#jobCommands_nameRef[@]})); then
        REPLY=0
        break 2
      fi
    done
  done

  # in pseudo sequential run, we display the logs in order
  if [[ ${simulateSequentialRun} == "true" ]]; then
    for ((index = 0; index < ${#logFiles[@]}; index++)); do
      if [[ -s ${logFiles[index]} ]]; then
        fs::readFile "${logFiles[index]}"
        log::printRaw REPLY
      fi
    done
  fi

  REPLY=$((${#jobCommands_nameRef[@]} - ${#exitCodes[@]}))
  REPLY2=0
  local -i exitCode
  for exitCode in "${exitCodes[@]}"; do
    if ((exitCode == 0)); then
      REPLY2=$((REPLY2 + 1))
    fi
  done

  # shellcheck disable=SC2034
  REPLY_ARRAY=("${exitCodes[@]}")
}

# ## coproc::run
#
# This function runs commands in a coproc.
# Each command can be set to ":" in order to do nothing.
# It returns the file descriptors/PID of the coproc and defines functions to easily
# interact with the coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#       It will be used to store the coproc file descriptors and PID.
#       <coproc_variable_name>[0] will be the input pipe file descriptor,
#       <coproc_variable_name>[1] will be the output pipe file descriptor,
#       <coproc_variable_name>_PID will be the PID of the coproc.
# - ${initCommand} _as string_:
#       (optional) The command (will be evaluated) to run at the start of the coproc.
#       Can exit to stop the coproc.
#       Set to ":" to do nothing.
#       (defaults to ":")
# - ${loopCommand} _as string_:
#       (optional) The command (will be evaluated) to run in the coproc loop.
#       Can exit to stop the coproc, can break or continue the loop.
#       Set to ":" to do nothing.
#       (defaults to ":")
# - ${onMessageCommand} _as string_:
#       (optional) The command (will be evaluated) to run in the coproc loop when a message
#       is received from the main thread.
#       The command can expect to use the variable REPLY which contains
#       the message (string) received from the main thread.
#       The command can send messages to the main thread using the syntax
#       printf "%s\0" "message"
#       Can exit to stop the coproc, can break or continue the loop.
#       Set to an empty string to not run any command on message.
#       (defaults to "")
# - ${endCommand} _as string_:
#       (optional) The command (will be evaluated) to run at the end of the coproc.
#       Set to ":" to do nothing.
#       (defaults to ":")
# - ${waitForReadiness} _as bool_:
#       (optional) If true, the main thread will wait for the coproc to be ready
#       before returning from this function (readiness is achieved after executing
#       the init command in the coproc).
#       (defaults to false)
# - ${keepOnlyLastMessage} _as bool_:
#       (optional) If true, the coproc will only keep the last message received
#       from the main thread to evaluate the on message command.
#       (defaults to false)
# - ${redirectLogsToFile} _as string_:
#       (optional) The path to a file where the logs of the coproc will be redirected.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY}: The PID of the coproc.
#
# ```bash
# waitForReadiness=true coproc::run "_MY_COPROC" initCommand loopCommand onMessageCommand
# ```
function coproc::run() {
  local \
    coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    initCommand=":" \
    loopCommand=":" \
    onMessageCommand="" \
    endCommand=":" \
    waitForReadiness=false \
    keepOnlyLastMessage=false \
    redirectLogsToFile="" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if [[ -v "GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}]" ]]; then
    core::fail "The coproc ⌜${coprocVarName}⌝ is already running."
  fi

  log::debug "Starting coproc ${coprocVarName}"
  log::trace "Init command: ${initCommand}"$'\n'"loop command: ${loopCommand}."$'\n'"on message command: ${onMessageCommand}"$'\n'"end command: ${endCommand}"$'\n'"wait for readiness: ${waitForReadiness}"$'\n'"keep only last message: ${keepOnlyLastMessage}"

  # Start the coproc
  eval "{ coproc ${coprocVarName} { coproc_program ${initCommand@Q} ${loopCommand@Q} ${onMessageCommand@Q} ${endCommand@Q} ${waitForReadiness} ${keepOnlyLastMessage} ${redirectLogsToFile@Q} 2>&${GLOBAL_FD_LOG}; } } 2>/dev/null"

  # wait for pid variable to be set by bash (we should never enter the loop)
  local -i loopNumber=0
  while [[ ! -v "${coprocVarName}_PID" && ${loopNumber} -lt 500 ]]; do
    # shellcheck disable=SC1091
    source bash
    bash::sleep 0.01
    loopNumber+=1
  done

  # get the PID (store it in another var because _PID gets deleted once the coproc ends)
  if ! eval "local pid=\${${coprocVarName}_PID:-}" || [[ -z ${pid} ]]; then
    core::fail "Failed to get the PID for coproc ⌜${coprocVarName}⌝."
  fi

  GLOBAL_BACKGROUND_PROCESSES["${coprocVarName}"]="${pid}"

  if [[ -n ${redirectLogsToFile} ]]; then
    # shellcheck disable=SC2034
    GLOBAL_BACKGROUND_PROCESSES_LOGS["${coprocVarName}"]="${redirectLogsToFile}"
  fi

  # tell the coproc to resume (it is waiting for the main thread to retrieve its PID)
  coproc::sendMessage "${coprocVarName}" ":"

  # wait for readiness if requested
  if [[ ${waitForReadiness} == "true" ]]; then
    if ! coproc::receiveMessage "${coprocVarName}"; then
      core::fail "The coproc ⌜${coprocVarName}⌝ did not start correctly."
    elif [[ ${REPLY} != "ready" ]]; then
      core::fail "The coproc ⌜${coprocVarName}⌝ did not send the expected readiness message."
    else
      log::debug "The coproc ⌜${coprocVarName}⌝ is ready."
    fi
  fi

  log::trace "Coproc ⌜${coprocVarName}⌝ started with PID ${pid}."

  REPLY="${pid}"
}

# The function that will run in the coproc.
function coproc_program() {
  local initCommand="${1}"
  local loopCommand="${2}"
  local onMessageCommand="${3}"
  local endCommand="${4}"
  local waitForReadiness="${5}"
  local keepOnlyLastMessage="${6}"
  local redirectLogsToFile="${7}"

  # we are inside a coproc, init the subshell correctly
  core::initSubshell

  local IFS=' '$'\t'$'\n'
  if [[ -n ${redirectLogsToFile} ]]; then
    log::init logFileDescriptor="${redirectLogsToFile}"
  fi

  # wait for the main process to retrieve our PID
  if ! kill -0 "${GLOBAL_PROGRAM_MAIN_PID}" 2>/dev/null || ! IFS=$'\0' read -rd $'\0' REPLY; then
    log::debug "Main process is not running, exiting coproc."
    return 0
  fi

  log::trace "Coproc is running, continuing with the coproc program."

  # Run the initialization command
  eval "${initCommand}"

  if [[ ${waitForReadiness} == "true" ]]; then
    # Send a readiness message to the main thread
    printf "%s\0" "ready"
  fi

  if [[ ${loopCommand} != ":" || ${onMessageCommand} != "" ]]; then
    while kill -0 "${GLOBAL_PROGRAM_MAIN_PID}" 2>/dev/null; do
      eval "${loopCommand}"

      if [[ -n "${onMessageCommand}" ]]; then
        # Read messages from the main thread
        if IFS=$'\0' read -rd $'\0' REPLY; then

          # if we keep only the last message, we read until no more messages are available
          while [[ ${keepOnlyLastMessage} == "true" ]] && IFS=$'\0' read -rd $'\0' -t 0; do
            IFS=$'\0' read -rd $'\0' REPLY
          done

          # Execute the on message command with the received message
          eval "${onMessageCommand}"
        fi
      fi
    done
  fi

  eval "${endCommand}"
}

# ## coproc::sendMessage
#
# This function sends a message to a given coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
# - $2: **message** _as string_:
#       The message to send to the coproc.
#
# Returns:
#
# - $?:
#   - 0 if the message was sent successfully.
#   - 1 if the coproc is not running or the message could not be sent.
#
# ```bash
# coproc::sendMessage "myCoproc" "Hello, coproc!"
# ```
#
# > This printf call can cause the whole shell to exit with code 141 if there is an issue with the coproc.
# > You will want to run this in a subshell to avoid exiting the main shell if your coproc is unstable.
function coproc::sendMessage() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if eval "local coprocFd=\${${coprocVarName}[1]:-}" && [[ -n ${coprocFd} ]]; then
    # This printf call can cause the whole shell to exit with code 141 if there is an issue
    if { printf '%s\0' "${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" >&"${coprocFd}"; } 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

# ## coproc::receiveMessage
#
# This function receives a message from a given coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
#
# - $?:
#   - 0 if a message was received successfully.
#   - 1 if the coproc is not running or no message could be received.
# - ${REPLY}: The received message.
#
# ```bash
# if coproc::receiveMessage "myCoproc"; then
#   echo "Received message: ${REPLY}"
# fi
# ```
function coproc::receiveMessage() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  REPLY=""
  if eval "local coprocFd=\${${coprocVarName}[0]:-}" && [[ -n ${coprocFd} ]]; then
    if { IFS=$'\0' read -rd $'\0' -u "${coprocFd}" REPLY; } 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

# ## coproc::isRunning
#
# This function checks if a coproc is running.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
#
# - $?:
#   - 0 if the coproc is running
#   - 1 if it is not
#
# ```bash
# if coproc::isRunning "myCoproc"; then
#   echo "The coproc is running."
# fi
# ```
function coproc::isRunning() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ -v GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}] ]]; then
    if kill -0 "${GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}]}" 2>/dev/null; then
      return 0
    fi
  fi
  return 1
}

# ## coproc::wait
#
# This function waits for a coproc to finish.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
# - ${REPLY_CODE}: The exit status of the coproc (or -1 if the coproc is not running).
#
# ```bash
# coproc::wait "myCoproc"
# ```
function coproc::wait() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ ! -v GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}] ]]; then
    REPLY_CODE=-1
    return 0
  fi
  local pid="${GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}]}"

  log::debug "Waiting for coproc ⌜${coprocVarName}⌝ (PID: ${pid}) to finish."

  local -i exitStatus=0
  if ! wait -f "${pid}"; then
    exitStatus="${PIPESTATUS[0]:-}"
  fi

  coproc_cleanBackgroundProcess "${coprocVarName}"
  REPLY_CODE="${exitStatus}"
}

# ## coproc::kill
#
# This function kills a coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# ```bash
# coproc::kill "myCoproc"
# ```
function coproc::kill() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if [[ ! -v GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}] ]]; then
    return 0
  fi
  local pid="${GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}]}"

  log::debug "Killing coproc ⌜${coprocVarName}⌝ (PID: ${pid})."

  kill -INT "${pid}" &>/dev/null || :
  kill -HUP "${pid}" &>/dev/null || :

  coproc_cleanBackgroundProcess "${coprocVarName}"
}

# Remove the coproc from GLOBAL_BACKGROUND_PROCESSES
function coproc_cleanBackgroundProcess() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  unset -v "GLOBAL_BACKGROUND_PROCESSES[${coprocVarName}]" \
    "GLOBAL_BACKGROUND_PROCESSES_LOGS[${coprocVarName}]" \
    "${coprocVarName}" \
    "${coprocVarName}_PID"
}
