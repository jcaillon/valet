#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## coproc::runInParallel
#
# This function runs a list of commands in parallel with a maximum number of parallel coprocs.
#
# - $1: **job commands array name** _as string_:
#       The name of the array containing the commands to run.
#       Each command string will be evaluated in a subshell.
#       Each command should explicitly exit with a non-zero code if it fails and with zero if it succeeds.
# - ${maxInParallel} _as int_:
#       (optional) The maximum number of parallel coprocs to run.
#       (defaults to 8)
# - ${completedCallback} _as string_:
#       (optional) The name of the function to call when a coproc is completed (successfully or not).
#       The function will receive the following arguments:
#       - $1 the coproc index
#       - $2 the coproc exit code
#       - $3 the percentage of coprocs already completed
#       - $4 the path of the file containing the accumulated logs of the coproc
#       If the function sets REPLY to 1, the script will exit early. Otherwise it should set REPLY to 0.
#       (defaults to "" which does nothing)
# - ${redirectLogs} _as bool_:
#       (optional) Redirect the logs of the coproc instead of printing them in the current file descriptor.
#       The accumulated logs of the coproc will be available in the completed callback function.
#       (defaults to false)
# - ${printRedirectedLogs} _as bool_:
#       (optional) This option allows to automatically redirect the logs of the coproc to a file and
#       print the accumulated logs of a coproc when it is completed (successfully or not).
#       (defaults to false)
# - ${coprocNamePrefix} _as string_:
#       (optional) The prefix to use for the coproc variable names.
#       This is useful to avoid conflicts with other coproc variables.
#       (defaults to "_COPROC_PARALLEL_")
#
# Returns:
#
# - ${REPLY}: 0 if all the jobs completed, 1 if the completed callback function returned 1.
# - ${REPLY2}: The number of successfully completed jobs.
# - ${REPLY_ARRAY[@]}: an array containing the exit codes of the jobs.
#
# ```bash
# declare -a jobCommands=("sleep 1" "sleep 2" "sleep 3")
# coproc::runInParallel jobCommands maxParallelCoprocs=2
# ```
function coproc::runInParallel() {
  local -n jobCommands="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local \
    maxInParallel=8 \
    completedCallback="" \
    redirectLogs=false \
    printRedirectedLogs=false \
    coprocNamePrefix="_COPROC_PARALLEL_" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if ((BASH_SUBSHELL > 0)); then
    coprocNamePrefix+="${BASH_SUBSHELL}_"
  fi

  local logOnErrorExit=false
  if [[ -z ${completedCallback} ]]; then
    # if no callback is defined, we want to log on error exit
    logOnErrorExit=true
  fi

  maxInParallel=$((maxInParallel < 1 ? 1 : maxInParallel))

  local -a -i pids=() runningPids=() exitCodes=()
  local -i index pid endedCoprocPid endedCoprocExitStatus endedCoprocIndex
  local -a logFiles=()
  local logFile=""

  for ((index = 0; index < ${#jobCommands[@]}; index++)); do
    if [[ ${redirectLogs} == "true" || ${printRedirectedLogs} == "true" ]]; then
      fs::createTempFile pathOnly=true
      logFile="${REPLY}"
    fi
    logFiles+=("${logFile}")

    coproc::run "${coprocNamePrefix}${index}" \
      initCommand="${jobCommands[index]}" \
      redirectLogsToFile="${logFile}" \
      logOnErrorExit="${logOnErrorExit}"

    pid="${REPLY}"
    pids+=("${pid}")
    runningPids+=("${pid}")

    log::debug "Running parallel coproc ${index} with PID ${pid}."
    log::trace $'\n'"Command: ${jobCommands[index]}"

    while ((${#runningPids[@]} >= maxInParallel || index == ${#jobCommands[@]} - 1)); do
      # wait for one of the coproc to finish (or all of them if they are all scheduled)
      endedCoprocExitStatus=0
      wait -n -p endedCoprocPid "${runningPids[@]}" || endedCoprocExitStatus=$?
      exitCodes+=("${endedCoprocExitStatus}")

      # find the index of the ended coproc in the pids array
      for endedCoprocIndex in "${!pids[@]}"; do
        if [[ ${pids[endedCoprocIndex]} == "${endedCoprocPid}" ]]; then
          log::debug "The coproc with PID ${endedCoprocPid} is at index ${endedCoprocIndex} in ${pids[*]}."
          break
        fi
      done

      log::debug "The parallel coproc ${endedCoprocIndex} with PID ${endedCoprocPid} is completed with code ${endedCoprocExitStatus}."

      # remove the coproc from the list of running pids
      coproc_removePidFromBackgroundPids "${endedCoprocPid}"
      local pidIndex
      for pidIndex in "${!runningPids[@]}"; do
        if [[ ${runningPids[pidIndex]} == "${endedCoprocPid}" ]]; then
          unset -v 'runningPids[pidIndex]'
          break
        fi
      done

      # execute the completed callback if defined
      if [[ -n ${completedCallback} ]]; then
        local -i percentageCompleted=$((${#exitCodes[@]} * 100 / ${#jobCommands[@]}))

        if [[ ${printRedirectedLogs} == "true" ]]; then
          # display the accumulated logs
          if [[ -n ${logFiles[endedCoprocIndex]} && -s ${logFiles[endedCoprocIndex]} ]]; then
            fs::readFile "${logFiles[endedCoprocIndex]}"
            log::printRaw REPLY
          fi
        fi

        REPLY=0
        "${completedCallback}" "${endedCoprocIndex}" "${endedCoprocExitStatus}" "${percentageCompleted}" "${logFiles[endedCoprocIndex]}"
        if ((REPLY != 0)); then
          log::debug "The completed callback function ⌜${completedCallback}⌝ requested to stop the parallel execution."
          REPLY=1
          break 2
        fi
      fi

      # if all coproc are scheduled and completed, we can exit the loop
      if ((${#exitCodes[@]} == ${#jobCommands[@]})); then
        REPLY=0
        break 2
      fi
    done
  done

  REPLY2=0
  local -i exitCode
  for exitCode in "${exitCodes[@]}"; do
    if ((exitCode == 0)); then
      REPLY2=$((REPLY2 + 1))
    fi
  done

  # shellcheck disable=SC2034
  REPLY_ARRAY=("${exitCodes[@]}")
}

# ## coproc::run
#
# This function runs commands in a coproc.
# Each command can be set to ":" in order to do nothing.
# It returns the file descriptors/PID of the coproc and defines functions to easily
# interact with the coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#       It will be used to store the coproc file descriptors and PID.
#       <coproc_variable_name>[0] will be the input pipe file descriptor,
#       <coproc_variable_name>[1] will be the output pipe file descriptor,
#       <coproc_variable_name>_PID will be the PID of the coproc.
# - ${initCommand} _as string_:
#       (optional) The command (will be evaluated) to run at the start of the coproc.
#       Can exit to stop the coproc.
#       (defaults to ":" which does nothing)
# - ${loopCommand} _as string_:
#       (optional) The command (will be evaluated) to run in the coproc loop.
#       Can exit to stop the coproc, can break or continue the loop.
#      (defaults to ":" which does nothing)
# - ${onMessageCommand} _as string_:
#       (optional) The command (will be evaluated) to run in the coproc loop when a message
#       is received from the main thread.
#       The command can expect to use the variable REPLY which contains
#       the message (string) received from the main thread.
#       The command can send messages to the main thread using the syntax
#       printf "%s\0" "message"
#       Can exit to stop the coproc, can break or continue the loop.
#       (defaults to "" which does nothing)
# - ${endCommand} _as string_:
#       (optional) The command (will be evaluated) to run at the end of the coproc.
#       (defaults to ":" which does nothing)
# - ${waitForReadiness} _as bool_:
#       (optional) If true, the main thread will wait for the coproc to be ready
#       before returning from this function (readiness is achieved after executing
#       the init command in the coproc).
#       (defaults to false)
# - ${keepOnlyLastMessage} _as bool_:
#       (optional) If true, the coproc will only keep the last message received
#       from the main thread to evaluate the on message command.
#       (defaults to false)
# - ${redirectLogsToFile} _as string_:
#       (optional) The path to a file where the logs of the coproc will be redirected.
#       (defaults to "")
# - ${logOnErrorExit} _as bool_:
#       (optional) If true, will display an error if the coproc exits with a non zero code
#       (defaults to true)
#
# Returns:
#
# - ${REPLY}: The PID of the coproc.
#
# ```bash
# waitForReadiness=true coproc::run "_MY_COPROC" initCommand loopCommand onMessageCommand
# ```
function coproc::run() {
  local \
    coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    initCommand=":" \
    loopCommand=":" \
    onMessageCommand="" \
    endCommand=":" \
    waitForReadiness=false \
    keepOnlyLastMessage=false \
    redirectLogsToFile="" \
    logOnErrorExit=true
  IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  if [[ -v "${coprocVarName}" ]]; then
    core::fail "The coproc ⌜${coprocVarName}⌝ is already running."
  fi

  log::debug "Starting coproc ${coprocVarName}"
  log::trace $'\n'"Init command: ${initCommand}"$'\n'"loop command: ${loopCommand}."$'\n'"on message command: ${onMessageCommand}"$'\n'"end command: ${endCommand}"$'\n'"wait for readiness: ${waitForReadiness}"$'\n'"keep only last message: ${keepOnlyLastMessage}"

  # Start the coproc
  eval "{ coproc ${coprocVarName} { coproc_program \"${initCommand}\" \"${loopCommand}\" \"${onMessageCommand}\" \"${endCommand}\" ${waitForReadiness} ${keepOnlyLastMessage} \"${redirectLogsToFile}\" ${logOnErrorExit} 2>&${GLOBAL_FD_LOG}; } } 2>/dev/null"

  # wait for pid variable to be set by bash (we should never enter the loop)
  local -i loopNumber=0
  while [[ ! -v "${coprocVarName}_PID" && ${loopNumber} -lt 500 ]]; do
    sleep 0.01
    loopNumber+=1
  done

  # get the PID (store it in another var because _PID gets deleted once the coproc ends)
  if ! eval "local pid=\${${coprocVarName}_PID:-}" || [[ -z ${pid} ]]; then
    core::fail "Failed to get the PID for coproc ⌜${coprocVarName}⌝."
  fi
  GLOBAL_BACKGROUND_PIDS+=("${pid}")

  # tell the coproc to resume (it is waiting for the main thread to retrieve its PID)
  coproc::sendMessage "${coprocVarName}" ":"

  # wait for readiness if requested
  if [[ ${waitForReadiness} == "true" ]]; then
    if ! kill -0 "${pid}" 2>/dev/null || ! coproc::receiveMessage "${coprocVarName}"; then
      core::fail "The coproc ⌜${coprocVarName}⌝ did not start correctly."
    elif [[ ${REPLY} != "ready" ]]; then
      core::fail "The coproc ⌜${coprocVarName}⌝ did not send the expected readiness message."
    else
      log::debug "The coproc ⌜${coprocVarName}⌝ is ready."
    fi
  fi

  log::trace "Coproc ⌜${coprocVarName}⌝ started with PID ${pid}."

  REPLY="${pid}"
}

# The function that will run in the coproc.
function coproc_program() {
  local initCommand="${1}"
  local loopCommand="${2}"
  local onMessageCommand="${3}"
  local endCommand="${4}"
  local waitForReadiness="${5}"
  local keepOnlyLastMessage="${6}"
  local redirectLogsToFile="${7}"
  local logOnErrorExit="${8}"

  # we are inside a coproc, register the correct traps
  logOnErrorExit="${logOnErrorExit}" trap::registerSubshell

  # the coproc must have its own set of temp files
  fs::setupSubshellTempFileGlobalVariable

  # unset options or they will be visible from the subshell and might interfere
  local IFS=' '$'\t'$'\n'
  unset -v ${!_OPTION_*}

  if [[ -n ${redirectLogsToFile} ]]; then
    log::init "${redirectLogsToFile}"
  fi

  # wait for the main process to retrieve our PID
  if ! kill -0 "${GLOBAL_PROGRAM_MAIN_PID}" 2>/dev/null || ! IFS=$'\0' read -rd $'\0' REPLY; then
    log::debug "Main process is not running, exiting coproc."
    return 0
  fi

  log::trace "Coproc is running, continuing with the coproc program."

  # Run the initialization command
  eval "${initCommand}"

  if [[ ${waitForReadiness} == "true" ]]; then
    # Send a readiness message to the main thread
    printf "%s\0" "ready"
  fi

  if [[ ${loopCommand} != ":" || ${onMessageCommand} != "" ]]; then
    while kill -0 "${GLOBAL_PROGRAM_MAIN_PID}" 2>/dev/null; do
      eval "${loopCommand}"

      if [[ -n "${onMessageCommand}" ]]; then
        # Read messages from the main thread
        if IFS=$'\0' read -rd $'\0' REPLY; then

          # if we keep only the last message, we read until no more messages are available
          while [[ ${keepOnlyLastMessage} == "true" ]] && IFS=$'\0' read -rd $'\0' -t 0; do
            IFS=$'\0' read -rd $'\0' REPLY
          done

          # Execute the on message command with the received message
          eval "${onMessageCommand}"
        fi
      fi
    done
  fi

  eval "${endCommand}"
}

# ## coproc::sendMessage
#
# This function sends a message to a given coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
# - $2: **message** _as string_:
#       The message to send to the coproc.
#
# Returns:
#
# - $?:
#   - 0 if the message was sent successfully.
#   - 1 if the coproc is not running or the message could not be sent.
#
# ```bash
# coproc::sendMessage "myCoproc" "Hello, coproc!"
# ```
function coproc::sendMessage() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if ! eval "local coprocFd=\${${coprocVarName}[1]:-}" || [[ -z ${coprocFd} ]]; then
    return 1
  fi

  if { printf '%s\0' "${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" >&"${coprocFd}"; } 2>/dev/null; then
    return 0
  fi

  return 1
}

# ## coproc::receiveMessage
#
# This function receives a message from a given coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
#
# - $?:
#   - 0 if a message was received successfully.
#   - 1 if the coproc is not running or no message could be received.
# - ${REPLY}: The received message.
#
# ```bash
# if coproc::receiveMessage "myCoproc"; then
#   echo "Received message: ${REPLY}"
# fi
# ```
function coproc::receiveMessage() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if ! eval "local coprocFd=\${${coprocVarName}[0]:-}" || [[ -z ${coprocFd} ]]; then
    return 1
  fi

  if { IFS=$'\0' read -rd $'\0' -u "${coprocFd}" REPLY; } 2>/dev/null; then
    return 0
  fi

  return 1
}

# ## coproc::wait
#
# This function waits for a coproc to finish.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
# - $?: The exit status of the coproc (or 0 if the coproc is not running).
#
# ```bash
# coproc::wait "myCoproc"
# ```
function coproc::wait() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if ! eval "local pid=\${${coprocVarName}_PID:-}" || [[ -z ${pid} ]]; then
    return 0
  fi

  log::debug "Waiting for coproc ⌜${coprocVarName}⌝ (PID: ${pid}) to finish."

  local -i exitStatus=0
  if ! wait -f "${pid}"; then
    exitStatus="${PIPESTATUS[0]:-}"
  fi

  coproc_removePidFromBackgroundPids "${pid}"
  return "${exitStatus}"
}

# ## coproc::isRunning
#
# This function checks if a coproc is running.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# Returns:
#
# - $?:
#   - 0 if the coproc is running
#   - 1 if it is not
#
# ```bash
# if coproc::isRunning "myCoproc"; then
#   echo "The coproc is running."
# fi
# ```
function coproc::isRunning() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if ! eval "local pid=\${${coprocVarName}_PID:-}" || [[ -z ${pid} ]]; then
    return 1
  fi

  if ! kill -0 "${pid}" 2>/dev/null; then
    return 1
  fi
}

# ## coproc::kill
#
# This function kills a coproc.
#
# - $1: **coproc variable name** _as string_:
#       The variable name to use for the coproc.
#
# ```bash
# coproc::kill "myCoproc"
# ```
function coproc::kill() {
  local coprocVarName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  if ! eval "local pid=\${${coprocVarName}_PID:-}" || [[ -z ${pid} ]]; then
    return 0
  fi

  log::debug "Killing coproc ⌜${coprocVarName}⌝ (PID: ${pid})."

  if kill "${pid}" &>/dev/null; then
    coproc_removePidFromBackgroundPids "${pid}"
    unset -v "${coprocVarName}" "${coprocVarName}_PID"
  fi
}

# Remove the coproc pid from GLOBAL_BACKGROUND_PIDS
function coproc_removePidFromBackgroundPids() {
  local -i pid="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  local index
  for index in "${!GLOBAL_BACKGROUND_PIDS[@]}"; do
    if [[ ${GLOBAL_BACKGROUND_PIDS[index]} == "${pid}" ]]; then
      unset -v 'GLOBAL_BACKGROUND_PIDS[index]'
      break
    fi
  done
}
