#!/usr/bin/env bash
set -Eeu -o pipefail
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

# we check for this variable to know if this script has already been included
GLOBAL_CORE_INCLUDED=1

# Handle the case where this script was io::invoked outside of valet
if [[ -z "${GLOBAL_VALET_HOME:-}" ]]; then
  GLOBAL_VALET_HOME="${BASH_SOURCE[0]}"
  if [[ "${GLOBAL_VALET_HOME}" != /* ]]; then
    # resolve relative path
    if pushd "${GLOBAL_VALET_HOME%/*}" &>/dev/null; then
      GLOBAL_VALET_HOME="${PWD}"
      popd 1>/dev/null
    else GLOBAL_VALET_HOME="${PWD}"; fi
  else
    GLOBAL_VALET_HOME="${GLOBAL_VALET_HOME%/*}" # strip filename
  fi
  GLOBAL_VALET_HOME="${GLOBAL_VALET_HOME%/*}" # strip libraries.d directory
fi

# First thing we do is to source the valet configuration from the user config dir
# This file can be used to override the default configuration by setting VALET_* env variables.
VALET_CONFIG_FILE="${VALET_CONFIG_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-$HOME/.config}/valet}/config"}"
if [[ -f ${VALET_CONFIG_FILE} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_FILE}"
fi
# Same with the env script
if [[ ${VALET_CONFIG_DOT_ENV_SCRIPT:-} != "false" && -f ${VALET_CONFIG_DOT_ENV_SCRIPT:-.env} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_DOT_ENV_SCRIPT:-.env}"
fi

# Since we use _OPTION_* variables to pass optional options to functions, we want to make sure
# to not create collisions so we unset them here.
unset -v ${!_OPTION_*}

#===============================================================
# >>> Temporary files and folders
#===============================================================

# Setup global variables that will be used for temporary files and folders.
function io::setupTempFileGlobalVariable() {
  # get unique file names for the stdout, stderr and temporary directory
  # to be fast, we do not create anything until we really need it
  # this could lead to issues, although it is very unlikely
  GLOBAL_TEMPORARY_PREFIX="${TMPDIR:-/tmp}/temp-"
  GLOBAL_TEMPORARY_IN_MEM_PREFIX="${VALET_CONFIG_WORK_FILES_DIRECTORY:-${TMPDIR:-/tmp}}/temp-"
  GLOBAL_TEMPORARY_WORK_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-work"
  while [[ -e "${GLOBAL_TEMPORARY_WORK_FILE}" ]]; do GLOBAL_TEMPORARY_WORK_FILE+="x"; done
  GLOBAL_TEMPORARY_STDOUT_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stdout"
  while [[ -e "${GLOBAL_TEMPORARY_STDOUT_FILE}" ]]; do GLOBAL_TEMPORARY_STDOUT_FILE+="x"; done
  GLOBAL_TEMPORARY_STDERR_FILE="${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-stderr"
  while [[ -e "${GLOBAL_TEMPORARY_STDERR_FILE}" ]]; do GLOBAL_TEMPORARY_STDERR_FILE+="x"; done
  GLOBAL_TEMPORARY_DIRECTORY="${GLOBAL_TEMPORARY_PREFIX}${BASHPID}.valet.d"
  while [[ -e "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; do GLOBAL_TEMPORARY_DIRECTORY+="x"; done
}
io::setupTempFileGlobalVariable

# ## io::createTempFile
#
# Creates a temporary file and return its path.
#
# Returns:
#
# - `RETURNED_VALUE`: The created path.
#
# ```bash
# io::createTempFile
# local file="${RETURNED_VALUE}"
# ```
#
# > Files created this way are automatically cleaned up by the io::cleanupTempFiles
# > function when valet ends.
function io::createTempFile() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
  fi
  TEMPORARY_FILE_NUMBER=${TEMPORARY_FILE_NUMBER:-0}
  while true; do
    TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -f "${RETURNED_VALUE}" ]]; then
      : >"${RETURNED_VALUE}"
      return 0
    fi
  done
}

# ## io::createTempDirectory
#
# Creates a temporary directory.
#
# Returns:
#
# - `RETURNED_VALUE`: The created path.
#
# ```bash
# io::createTempDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
# > Directories created this way are automatically cleaned up by the io::cleanupTempFiles
# > function when valet ends.
function io::createTempDirectory() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
  fi
  TEMPORARY_DIRECTORY_NUMBER=${TEMPORARY_DIRECTORY_NUMBER:-0}
  while true; do
    TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -d "${RETURNED_VALUE}" ]]; then
      mkdir -p "${RETURNED_VALUE}" 1>/dev/null
      return 0
    fi
  done
}

# ## io::cleanupTempFiles
#
# Removes all the temporary files and directories that were created by the
# io::createTempFile and io::createTempDirectory functions.
#
# ```bash
# io::cleanupTempFiles
# ```
# shellcheck disable=SC2016
function io::cleanupTempFiles() {
  if [[ -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    unset TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
  fi
  local _file
  for _file in "${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet"*; do
    rm -f "${GLOBAL_TEMPORARY_IN_MEM_PREFIX}${BASHPID}.valet-"* 1>/dev/null
    break
  done
  # for files created in  io::windowsCreateTempFile
  if [[ -n ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY:-} && -d ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting windows temporary directory."
    rm -Rf "${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY}" 1>/dev/null
  fi
}

#===============================================================
# >>> Logging
#===============================================================

# determine if we support colors (can be overridden by the user with VALET_CONFIG_ENABLE_COLORS)
case "${TERM:-}" in
xterm-color | xterm-256color | linux) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}" ;;
xterm) if [[ -n "${COLORTERM:-}" ]]; then VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}"; fi ;;
*) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-false}" ;;
esac

# ## interactive::getTerminalSize
#
# This function exports the terminal size.
#
# Returns:
#
# - `GLOBAL_COLUMNS`: The number of columns in the terminal.
# - `GLOBAL_LINES`: The number of lines in the terminal.
#
# ```bash
# interactive::getTerminalSize
# printf '%s\n' "The terminal has ⌜${GLOBAL_COLUMNS}⌝ columns and ⌜${GLOBAL_LINES}⌝ lines."
# ```
function interactive::getTerminalSize() {
  shopt -s checkwinsize
  # the following subshell is required to correctly compute the columns and lines
  # the bash manual says it these are computed after the execution of an external command
  (
    :
    :
  )
  GLOBAL_COLUMNS="${COLUMNS:-120}"
  GLOBAL_LINES="${LINES:-30}"
  shopt -u checkwinsize
}

# Export terminal size on window resize if we are in interactive mode.
if [[ -t 2 ]]; then
  interactive::getTerminalSize
  GLOBAL_SCREEN_REDRAW_REQUIRED=false
  trap 'interactive::getTerminalSize; GLOBAL_SCREEN_REDRAW_REQUIRED=true;' SIGWINCH
else
  GLOBAL_COLUMNS="${VALET_DEFAULT_COLUMNS:-120}"
  GLOBAL_LINES="${VALET_DEFAULT_LINES:-30}"
fi

# ## log::setLevel
#
# Set the log level.
#
# - $1: **log level** _as string_:
#       the log level to set (or defaults to info), acceptable values are:
#   - trace
#   - debug
#   - info
#   - success
#   - warning
#   - error
# - $2: silent _as bool_:
#       (optional) true to silently switch log level, i.e. does not print a message
#       (defaults to false)
#
# ```bash
# log::setLevel debug
# log::setLevel debug true
# ```
function log::setLevel() {
  # log level, defaults to info
  GLOBAL_LOG_LEVEL="${1:-${VALET_LOG_LEVEL:-info}}"
  case "${GLOBAL_LOG_LEVEL}" in
  error) GLOBAL_LOG_LEVEL_INT=4 ;;
  warning) GLOBAL_LOG_LEVEL_INT=3 ;;
  success) GLOBAL_LOG_LEVEL_INT=2 ;;
  debug) GLOBAL_LOG_LEVEL_INT=0 ;;
  trace) GLOBAL_LOG_LEVEL_INT=-1 ;;
  *) GLOBAL_LOG_LEVEL_INT=1 ;;
  esac

  if [[ ${2:-false} != "true" ]]; then
    if [[ ${GLOBAL_LOG_LEVEL_INT} -ne 1 ]]; then
      log::debug "Log level set to ${GLOBAL_LOG_LEVEL}."
    fi
    if [[ ${GLOBAL_LOG_LEVEL_INT} -eq 0 ]]; then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# ## log::getLevel
#
# Get the current log level.
#
# Returns:
#
# - `RETURNED_VALUE`: The current log level.
#
# ```bash
# log::getLevel
# printf '%s\n' "The log level is ⌜${RETURNED_VALUE}⌝."
# ```
function log::getLevel() {
  RETURNED_VALUE="${GLOBAL_LOG_LEVEL:-info}"
}

# Display log messages in the terminal.
#
# - $1: the color level of the log message (TRACE, DEBUG...)
# - $2: the icon to display in the log message (utf8 character from nerdicons)
# - $3: the severity (max 7 chars)
# - $@: the content of the log message (each arg will be separated by a new line)
#
# ```bash
# log::print "GREEN" $'\uf14a' "SUCCESS" "This is a success message."
# ```
# shellcheck disable=SC2317
function log::print() { return 0; }

# ## log::printFile
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **path** _as string_:
#       the file path to display.
# - $2: max lines _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFile "/my/file/path"
# ```
# shellcheck disable=SC2317
function log::printFile() { return 0; }

# ## log::printFileString
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **content** _as string_:
#       the file content.
# - $2: **max lines** _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFileString "myfilecontent"
# ```
# shellcheck disable=SC2317
function log::printFileString() { return 0; }

# ## log::printString
#
# Display a string in the log.
# The string will be aligned with the current log output and hard wrapped if necessary.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to log (can contain new lines)
# - $2: new line pad string _as string_:
#       (optional) the string with which to prepend each wrapped line
#       (empty by default)
#
# ```bash
# log::printString "my line"
# ```
# shellcheck disable=SC2317
function log::printString() { return 0; }

# ## log::printRaw
#
# Display something in the log stream.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to print (can contain new lines)
#
# ```bash
# log::printRaw "my line"
# ```
# shellcheck disable=SC2317
function log::printRaw() { return 0; }

# We build the log line function dynamically to adapt to the user options.
# This avoid to have to check the options at each log message.
#
# Returns:
#
# - `GLOBAL_LOG_PRINT_FUNCTION`: Contains the functions definitions to print logs.
# shellcheck disable=SC2016
function log::createPrintFunction() {
  local cDefault=""
  local cTimestamp=""
  local colorStatement
  if [[ "${VALET_CONFIG_ENABLE_COLORS:-}" == "true" ]]; then
    cTimestamp=${VALET_CONFIG_COLOR_TIMESTAMP:-$'\e'"[90m"} # Bright Black (Gray)
    cDefault=${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}
    local cDebug=${VALET_CONFIG_COLOR_DEBUG:-$'\e'"[90m"}         # Bright Black (Gray)
    local cInfo=${VALET_CONFIG_COLOR_INFO:-$'\e'"[36m"}           # Cyan
    local cWarning=${VALET_CONFIG_COLOR_WARNING:-$'\e'"[33m"}     # Yellow
    local cSuccess=${VALET_CONFIG_COLOR_SUCCESS:-$'\e'"[32m"}     # Green
    local cError=${VALET_CONFIG_COLOR_ERROR:-$'\e'"[31m"}         # Red
    local cHighlight=${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"} # Bright Magenta (Pink)

    colorStatement="
    local color
    case \"\${colorCode}\" in
    DEBUG) color=${cDebug@Q} ;;
    TRACE) color=${cDebug@Q} ;;
    INFO) color=${cInfo@Q} ;;
    WARNING) color=${cWarning@Q} ;;
    SUCCESS) color=${cSuccess@Q} ;;
    ERROR) color=${cError@Q} ;;
    *) color=${cDefault@Q} ;;
    esac"
    # shellcheck disable=SC2016
    colorStatement+='
    RETURNED_VALUE="${RETURNED_VALUE//⌜/'"${cHighlight@Q}"'⌜}"
    RETURNED_VALUE="${RETURNED_VALUE//⌝/⌝'"${cDefault@Q}"'}"'
  else
    colorStatement='
    local color=""'
  fi

  local wrapStatement
  local wrapTextColumns="${VALET_CONFIG_LOG_COLUMNS:-${GLOBAL_COLUMNS}}"
  local wrapPaddingLength=20
  if [[ "${VALET_CONFIG_DISABLE_LOG_WRAP:-}" != "true" ]]; then

    if [[ ${VALET_CONFIG_DISABLE_LOG_TIME:-} == "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 9))
    fi

    if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} != "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 2))
    fi

    wrapStatement='
    string::wrapText "${RETURNED_VALUE}" '"${wrapTextColumns}"' '"${wrapPaddingLength}"''
  else
    wrapPaddingLength=0
  fi

  local printStatement
  local standardPrintStatement
  local printfFormat
  local printfArguments

  # timestamp
  if [[ ${VALET_CONFIG_DISABLE_LOG_TIME:-} == "true" ]]; then
    printfFormat+=""
  elif [[ ${VALET_CONFIG_ENABLE_LOG_TIMESTAMP:-} == "true" ]]; then
    printfFormat+="%(%F_%H:%M:%S)T "
    printfArguments+='"${EPOCHSECONDS}" '
  else
    printfFormat+="%s%(%H:%M:%S)T "
    printfArguments+="${cTimestamp@Q}"' "${EPOCHSECONDS}" '
  fi

  # severity
  if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} == "true" ]]; then
    printfFormat+="%s%-8s%-4s%s "
    printfArguments+='"${color:-}" "${severity}" "${icon:-}" '"${cDefault@Q}"' '
  else
    printfFormat+="%s%-8s%s "
    printfArguments+='"${color:-}" "${severity}" '"${cDefault@Q}"' '
  fi

  # message
  printfFormat+="%s\n"
  printfArguments+='"${RETURNED_VALUE}"'

  if [[ -z ${VALET_CONFIG_LOG_FD:-} || ${#VALET_CONFIG_LOG_FD} == 1 ]]; then
    # it is a numbered file descriptor

    # clear the line before printing if we are display a progress bar/spinner
    local cleanStatements='
    local eraseLine
    if [[ ${_PROGRESS_BAR_RUNNING:-} == "true" ]]; then
      eraseLine=$'"'"'\e[2K'"'"'
    fi
    '
    printStatement="${cleanStatements}"'
    printf "${eraseLine:-}'"${printfFormat}"'" '"${printfArguments}"' 1>&'"${VALET_CONFIG_LOG_FD:-2}"
    standardPrintStatement="${cleanStatements}"'
    printf "${eraseLine:-}%s" "${toPrint:-}" 1>&'"${VALET_CONFIG_LOG_FD:-2}"
  else
    # it is a file
    printStatement='
    printf "'"${printfFormat}"'" '"${printfArguments}"' 1>>'"${VALET_CONFIG_LOG_FD}"
    standardPrintStatement='
    printf "%s" "${toPrint:-}" 1>>'"${VALET_CONFIG_LOG_FD}"
  fi

  # check if we need to additionally output the logs to a file
  if [[ -n ${VALET_CONFIG_LOG_TO_DIRECTORY:-} ]]; then
    # compute the name of the output file
    local logFile
    if [[ -z ${VALET_CONFIG_LOG_FILENAME_PATTERN:-} ]]; then
      printf -v logFile "%s%(%F_%Hh%Mm%Ss)T%s" "valet-" "${EPOCHSECONDS}" ".log"
    else
      eval "${VALET_CONFIG_LOG_FILENAME_PATTERN}"
    fi
    if [[ -n ${logFile:-} ]]; then
      if [[ ! -d "${VALET_CONFIG_LOG_TO_DIRECTORY}" ]]; then
        mkdir -p "${VALET_CONFIG_LOG_TO_DIRECTORY}" 1>/dev/null
      fi
      # append the log to the file
      printStatement+='
      printf "'"${printfFormat}"'" '"${printfArguments}"' 1>>'"${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}"
      standardPrintStatement+='
      printf "%s" "${toPrint:-}" 1>>'"${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}"
    fi
  fi

  # string with the number of spaces necessary to align with other log messages
  local messageLeftPadding
  messageLeftPadding=""
  for ((i = 0; i < wrapPaddingLength; i++)); do
    messageLeftPadding+=" "
  done

  # log::print function
  GLOBAL_LOG_PRINT_FUNCTION='
  function log::print() {
    local icon severity
    local colorCode="${1}"
    icon="${2}"
    severity="${3}"
    shift 3
    local IFS='"$'\n'"'
    RETURNED_VALUE="$*"
    IFS=" "

    '"${colorStatement}"'

    '"${wrapStatement:-}"'

    '"${printStatement}"'
  }'

  # log::printFile function
  local insideTheLoop='
        string::wrapCharacters "${line}" "${wrapTextColumns}" "${messageLeftPadding}     ░ "
        toPrint+="${messageLeftPadding}${lineNumberPadding}${lineNumber} ░ ${RETURNED_VALUE}"'"$'\n'"'
        lineNumber+=1
        if (( ${#lineNumber} > currentLineNumberLength )); then
          lineNumberPadding="${lineNumberPadding%?}"
          currentLineNumberLength+=1
        fi
        if (( maxLines != 0 && lineNumber > maxLines )); then
          toPrint+="${messageLeftPadding}   … ░ (truncated)"'"$'\n'"'
          break;
        fi
  '

  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printFile() {
    local filePath="${1}"
    local maxLines="${2:-0}"
    local wrapTextColumns='"$((wrapTextColumns - wrapPaddingLength - 7))"'
    local messageLeftPadding="'"${messageLeftPadding}"'"
    local line toPrint
    local lineNumberPadding="   "
    local -i lineNumber=1 currentLineNumberLength=1
    if [[ ! -f "${filePath}" ]]; then
      log::error "Can not print the file ⌜${filePath}⌝ because does not exist."
      return 1
    fi
    local IFS=
    while IFS= read -r line || [[ -n ${line:-} ]]; do
      '"${insideTheLoop}"'
    done <"${filePath}"
    '"${standardPrintStatement}"'
  }'

  # log::printFileString function
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printFileString() {
    local content="${1}"
    local maxLines="${2:-0}"
    local wrapTextColumns='"$((wrapTextColumns - wrapPaddingLength - 7))"'
    local messageLeftPadding="'"${messageLeftPadding}"'"
    local line toPrint
    local lineNumberPadding="   "
    local -i lineNumber=1 currentLineNumberLength=1
    local IFS=
    while IFS= read -r line; do
      '"${insideTheLoop}"'
    done <<<"${content}"
    '"${standardPrintStatement}"'
  }'

  # log::printString function
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printString() {
    local content="${1}"
    local wrappedLineLeftPaddingString="${2:-}"
    local wrapTextColumns='"$((wrapTextColumns - wrapPaddingLength))"'
    local messageLeftPadding="'"${messageLeftPadding}"'"
    local line toPrint
    local IFS=
    while IFS= read -r line; do
        string::wrapCharacters "${line}" "${wrapTextColumns}" "${messageLeftPadding}${wrappedLineLeftPaddingString}" "$((wrapTextColumns - ${#wrappedLineLeftPaddingString}))"
        toPrint+="${messageLeftPadding}${RETURNED_VALUE}"'"$'\n'"'
    done <<<"${content}"
    '"${standardPrintStatement}"'
  }'

  # log::printRaw function
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printRaw() {
    local toPrint="${1}"
    '"${standardPrintStatement}"'
  }'
}
log::createPrintFunction
eval "${GLOBAL_LOG_PRINT_FUNCTION}"

# ## core::fail
#
# Displays an error message and then exit the program with error.
#
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::fail "This is an error message."
# ```
function core::fail() {
  log::error "$@"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_DISPLAYED=1
  exit 1
}

# ## core::failWithCode
#
# Displays an error message and then exit the program with error.
#
# - $1: **exit code** _as int_:
#       the exit code to use, should be between 1 and 255
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::failWithCode 255 "This is an error message."
# ```
function core::failWithCode() {
  local exitCode="${1}"
  shift
  log::error "$@"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_DISPLAYED=1
  exit "${exitCode}"
}

# ## log::error
#
# Displays an error message.
#
# - $@: **message** _as string_:
#       the error messages to display
#
# ```bash
# log::error "This is an error message."
# ```
#
# > You probably want to exit immediately after an error and should consider using core::fail function instead.
function log::error() {
  log::print "ERROR" "${VALET_CONFIG_ICON_ERROR:-$'\uf2d3'}" "ERROR" "$@"
  if log::isDebugEnabled; then
    log::printCallStack 2
  fi
}

# ## log::warning
#
# Displays a warning.
#
# - $@: **message** _as string_:
#       the warning messages to display
#
# ```bash
# log::warning "This is a warning message."
# ```
function log::warning() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 3)); then
    return 0
  fi
  log::print "WARNING" "${VALET_CONFIG_ICON_WARNING:-$'\uf071'}" "WARNING" "$@"
  return 0
}

# ## log::success
#
# Displays a success message.
#
# - $@: **message** _as string_:
#       the success messages to display
#
# ```bash
# log::success "This is a success message."
# ```
function log::success() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 2)); then
    return 0
  fi
  log::print "SUCCESS" "${VALET_CONFIG_ICON_SUCCESS:-$'\uf14a'}" "SUCCESS" "$@"
  return 0
}

# ## log::info
#
# Displays an info message.
#
# - $@: **message** _as string_:
#       the info messages to display
#
# ```bash
# log::info "This is an info message."
# ```
function log::info() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 1)); then
    return 0
  fi
  log::print "INFO" "${VALET_CONFIG_ICON_INFO:-$'\uf05a'}" "INFO" "$@"
  return 0
}

# ## log::debug
#
# Displays a debug message.
#
# - $@: **message** _as string_:
#       the debug messages to display
#
# ```bash
# log::debug "This is a debug message."
# ```
function log::debug() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 0)); then
    return 0
  fi
  log::print "DEBUG" "${VALET_CONFIG_ICON_DEBUG:-$'\uf188'}" "DEBUG" "$@"
  return 0
}

# ## log::trace
#
# Displays a trace message.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::trace "This is a trace message."
# ```
function log::trace() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > -1)); then
    return 0
  fi
  log::print "TRACE" "${VALET_CONFIG_ICON_TRACE:-$'\ue241'}" "TRACE" "$@"
  return 0
}

# ## log::errorTrace
#
# Displays an error trace message.
# This is a trace message that is always displayed, independently of the log level.
# It can be used before a fatal error to display useful information.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::errorTrace "This is a debug message."
# ```
function log::errorTrace() {
  log::print "TRACE" "${VALET_CONFIG_ICON_ERROR_TRACE:-$'\uf06e'}" "TRACE" "$@"
  return 0
}

# ## log::isDebugEnabled
#
# Check if the debug mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if debug mode is enabled (log level is debug)
#   - 1 if disabled
#
# ```bash
# if log::isDebugEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isDebugEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= 0)); then
    return 0
  fi
  return 1
}

# ## log::isTraceEnabled
#
# Check if the trace mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if trace mode is enabled (log level is trace)
#   - 1 if disabled
#
# ```bash
# if log::isTraceEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isTraceEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= -1)); then
    return 0
  fi
  return 1
}

# ## log::printCallStack
#
# This function prints the current function stack in the logs.
#
# - $1: **stack to skip** _as int_:
#       the number of stack to skip (defaults to 2 which skips this function
#       and the first calling function which is usually the onError function)
#
# ```bash
# log::printCallStack 2
# ```
function log::printCallStack() {
  local -i levelToSkip="${1:-2}"
  local i stackSize func linen="${LINENO}" src
  stackSize=${#FUNCNAME[@]}
  treeString="├─"
  for ((i = levelToSkip; i < stackSize; i++)); do
    func="${FUNCNAME[${i}]}"
    if [[ -z ${func} ]]; then
      func=ROOT
    else
      func="${func}()"
    fi
    if ((i > 0)); then
      linen="${BASH_LINENO[$((i - 1))]}"
    fi
    src="${BASH_SOURCE[${i}]}"
    if [[ -z "${src}" ]]; then
      src=non_file_source
    elif [[ -f "${src/#.\//"${PWD}"\/}" ]]; then
      src="${src/#.\//"${PWD}"\/}"
    elif [[ -f "${src/#.\//"${GLOBAL_VALET_HOME}"\/}" ]]; then
      src="${src/#.\//"${GLOBAL_VALET_HOME}"\/}"
    fi
    if ((i == stackSize - 1)); then
      treeString="└─"
    fi
    log::printString "${treeString} in ${func} at ${src}:${linen}" "│  "
  done
}

#===============================================================
# >>> Core utilities
#===============================================================

# ## source
#
# Allows to include a library file or sources a file.
#
# It replaces the builtin source command to make sure that we do not include the same file twice.
# We replace source instead of creating a new function to allow us to
# specify the included file for spellcheck.
#
# - $1: **library name** _as string_:
#       the name of the library (array, interactive, string...) or the file path to include.
# - $@: arguments _as any_:
#       (optional) the arguments to pass to the included file (mimics the builtin source command).
#
# ```bash
#   source string array system
#   source ./my/path my/other/path
# ```
#
# > - The file can be relative to the current script (script that calls this function).
# > - This function makes sure that we do not include the same file twice.
# > - Use `builtin source` if you want to include the file even if it was already included.
function source() {
  local filePathToInclude
  if [[ -f "${GLOBAL_VALET_HOME}/libraries.d/lib-${1}" ]]; then
    # source the lib from the valet core libs
    filePathToInclude="${GLOBAL_VALET_HOME}/libraries.d/lib-${1}"
  else
    # source the lib from user libs
    if [[ -v CMD_LIBRARY_DIRECTORIES ]]; then
      local libraryDirectory
      for libraryDirectory in "${CMD_LIBRARY_DIRECTORIES[@]}"; do
        if [[ -f "${libraryDirectory}/lib-${1}" ]]; then
          filePathToInclude="${libraryDirectory}/lib-${1}"
        fi
      done
    fi
    if [[ -z "${filePathToInclude:-}" ]]; then
      if [[ -f "${BASH_SOURCE[1]%/*}/${1}" ]]; then
        # source a file next to the file that calls this function
        filePathToInclude="${BASH_SOURCE[1]%/*}/${1}"
      elif [[ -f "${1}" ]]; then
        # source a file with an absolute path or in the current directory
        filePathToInclude="${1}"
      else
        core::fail "Cannot source the file ⌜${1}⌝ because it does not exist."$'\n'"If you meant to source a library, make sure it is either in the valet core or user libraries and do not include the ⌜lib-⌝ prefix."
      fi
    fi
  fi

  local includeFile
  for includedFile in "${_LIST_OF_INCLUDED_FILES[@]}"; do
    if [[ ${includedFile} == "${filePathToInclude}" ]]; then
      return 0
    fi
  done
  shift
  # shellcheck source=/dev/null
  builtin source "${filePathToInclude}" "$@"
  _LIST_OF_INCLUDED_FILES+=("${filePathToInclude}")
}
_LIST_OF_INCLUDED_FILES=()

# ## core::resetIncludedFiles
#
# Allows to reset the included files.
# When calling the source function, it will source all the files again.
# This is useful when we want to reload the libraries.
#
# ```bash
# core::resetIncludedFiles
# ```
function core::resetIncludedFiles() {
  _LIST_OF_INCLUDED_FILES=()
}

# ## core::sourceFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# core::sourceFunction "functionName"
# ```
function core::sourceFunction() {
  local functionName="${1}"

  local fileToSource
  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -f "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -f "${GLOBAL_VALET_HOME:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${GLOBAL_VALET_HOME:-}/${fileToSource}"
      log::debug "Loaded file ⌜${GLOBAL_VALET_HOME:-}/${fileToSource}⌝."
    else
      log::warning "The source file ⌜${GLOBAL_VALET_HOME:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# ## core::sourceUserCommands
#
# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we build it on the fly.
#
# ```bash
# core::sourceUserCommands
# ```
function core::sourceUserCommands() {
  if [[ -n "${_CMD_INCLUDED:-}" ]]; then
    return 0
  fi

  # source the user commands
  local userDirectory
  core::getUserDirectory
  userDirectory="${RETURNED_VALUE}"

  local commandsFile
  commandsFile="${userDirectory}/commands"

  # if the commands file does not exist, we build it.
  if [[ ! -f "${commandsFile}" ]]; then
    log::info "The valet user directory ⌜${userDirectory}⌝ does not contain a built ⌜commands⌝ file."$'\n'"Now building it using ⌜valet self build⌝ command."

    # shellcheck disable=SC1091
    unset _CMD_INCLUDED
    # shellcheck source=../commands.d/self-build.sh
    source "${GLOBAL_VALET_HOME}/commands.d/self-build.sh"
    selfBuild --silent

    if [[ ! -f "${commandsFile}" ]]; then
      core::fail "Could not build the commands file, please check the error above."
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  builtin source "${commandsFile}"
}

# ## core::reloadUserCommands
#
# Forcibly source again the user 'commands' file from the valet user directory.
#
# ```bash
# core::reloadUserCommands
# ```
function core::reloadUserCommands() {
  # delete previous variables
  # shellcheck disable=SC2086
  unset -v ${!CMD_*} _CMD_INCLUDED
  core::sourceUserCommands
}

# ## core::deleteUserCommands
#
# Delete the user 'commands' file from the valet user directory.
#
# You probably want to reload the user commands afterward using `core::reloadUserCommands`.
#
# ```bash
# core::deleteUserCommands
# ```
function core::deleteUserCommands() {
  core::getUserDirectory
  rm -f "${RETURNED_VALUE}/commands"
}

# ## core::getVersion
#
# Returns the version of Valet.
#
# Returns:
#
# - `RETURNED_VALUE`: The version of Valet.
#
# ```bash
# core::getVersion
# printf '%s\n' "The version of Valet is ⌜${RETURNED_VALUE}⌝."
# ```
function core::getVersion() {
  # shellcheck source=lib-io
  source io
  io::readFile "${GLOBAL_VALET_HOME}/version"
}

# ## core::reExportFuncToUseGlobalVars (private)
#
# This function can be used to re-export an existing function
# and replace the use of positional parameters by global variables.
#
# This can be useful for performance reasons when a function is called many times,
# to avoid copying the positional parameters each time.
#
# - $1: **function name** _as string_:
#       the name of the function to re-export
# - $2: **new function name** _as string_:
#       the name of the new function to create
# - $@: **global variable name** _as string_:
#       the name of the global variable to use instead of the positional parameters
#       (can be repeated multiple times, for each parameter)
#
# ```bash
# core::reExportFuncToUseGlobalVars "myFunction" "myFunctionWithGlobalVars" "GLOBAL_VAR1" "GLOBAL_VAR2"
# ```
function core::reExportFuncToUseGlobalVars() {
  local functionName="${1}"
  local newFunctionName="${2}"
  shift 2

  io::invoke declare -f "${functionName}"
  local functionDefinition="${RETURNED_VALUE/"${functionName}"/"${newFunctionName}"}"

  # find the mapping between the positional parameters and the new global variable names
  local -A globalVars=()
  local -a positionalParameters=("$@")
  local IFS=$'\n'
  local line varName varPosition
  local modifiedFunctionDefinition=""
  for line in ${functionDefinition}; do
    if (( ${#positionalParameters[@]} != ${#globalVars[@]} )); then
      if [[ "${line}" =~ ^\ *local\ +(-[[:alpha:]]+\ )?([[:alpha:]]+)=[^$]*\$\{?([[:digit:]]+) ]]; then
        varName="${BASH_REMATCH[2]}"
        varPosition="${BASH_REMATCH[3]}"
        globalVars["${varName}"]="${positionalParameters[$((varPosition - 1))]}"
        log::debug "found local ${varName}=\${${varPosition}} -> remapped to ${globalVars[${varName}]}"
        continue
      fi
    fi
    modifiedFunctionDefinition+="${line}"$'\n'
  done

  # modify the function to use the global variables instead of the positional parameters
  for varName in "${!globalVars[@]}"; do
    modifiedFunctionDefinition="${modifiedFunctionDefinition//${varName}/"${globalVars[${varName}]}"}"
  done

  eval "${modifiedFunctionDefinition}"
}

#===============================================================
# >>> String utilities
#===============================================================

# ## string::wrapCharacters
#
# Allows to soft wrap the given text at the given width.
# Wrapping is done at word boundaries.
# Optionally applies left padding to each new line.
#
# - $1: **text** _as string_:
#       the text to wrap
# - $2: wrap width _as int_:
#       (optional) the width to wrap the text at
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding _as int_:
#       (optional) the padding to apply to each new line
#       (defaults to 0)
# - $4: apply padding on first line _as bool_:
#       (optional) true/false if the padding should be applied to the first line
#       (defaults to false)
#
# Returns:
#
# - `RETURNED_VALUE`: the wrapped text
#
# ```bash
# string::wrapText "This is a long text that should be wrapped at 20 characters." 20 2 false
# local wrappedText="${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
function string::wrapText() {
  local text="${1}"
  local width="${2:-${GLOBAL_COLUMNS}}"
  local leftPadding="${3:-0}"
  local appendPaddingToFirstLine="${4:-false}"

  if (( width < 10 )); then
    width=10
  fi

  # compute padding in number of spaces
  local messageLeftPadding
  messageLeftPadding=""
  for ((i = 0; i < leftPadding; i++)); do
    messageLeftPadding+=" "
  done

  local sentenceWidth=$((width - leftPadding))

  local wrappedText

  if [[ "${text}" == *$'\n'* ]]; then
    # we call string::wrapSentence for each line of the text
    local firstLine="1"
    local line
    while read -r line; do
      wrappedText+=$'\n'
      string::wrapSentence "${line}" "${sentenceWidth}" "${messageLeftPadding}"
      if [[ ${firstLine} == "1" ]]; then
        firstLine="0"
      else
        wrappedText+="${messageLeftPadding}"
      fi
      wrappedText+="${RETURNED_VALUE}"
    done <<<"${text}"
  else
    string::wrapSentence "${text}" "${sentenceWidth}" "${messageLeftPadding}"
    wrappedText="${RETURNED_VALUE}"
  fi

  # add left padding on the first line (or not)
  if [[ ${appendPaddingToFirstLine} == "true" ]]; then
    RETURNED_VALUE="${messageLeftPadding}${wrappedText#$'\n'}"
  else
    RETURNED_VALUE="${wrappedText#$'\n'}"
  fi
}

# ## string::wrapSentence
#
# Allows to soft wrap the given sentence (without new lines) at the given width.
# Optionally applies a prefix on each new line.
#
# - $1: **text** _as string_:
#       the text to wrap
# - $2: wrap width _as int_:
#       (optional) the width to wrap the text at
#       (defaults to GLOBAL_COLUMNS)
# - $3:*new line pad string _as string_:
#       (optional) the prefix to apply to each new line
#       (defaults to "")
#
# Returns:
#
# - `RETURNED_VALUE`: the wrapped text
#
# ```bash
# string::wrapSentence "This is a long text that should be wrapped at 20 characters." 20
# local wrappedText="${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
function string::wrapSentence() {
  local text="${1}"
  local -i width="${2}"
  local newLinePrefix="${3:-}"

  # short cut in case the text is already shorter than the width
  if [[ "${#text}" -le width ]]; then
    RETURNED_VALUE="${text}"
    return 0
  fi

  # new line to append
  local newLine
  newLine=$'\n'"${newLinePrefix}"

  local wrappedText word
  local -i spaceLeft wordLength partialWordLength
  wrappedText=""
  spaceLeft=${width}
  local firstWord="1"
  local IFS=' '
  for word in ${text}; do

    if [[ ${firstWord} == "1" ]]; then
      firstWord="0"
    else
      # we just added a word
      if [[ spaceLeft -gt 0 ]]; then
        # if we have space left, we add a space
        wrappedText+=" "
        spaceLeft=$((spaceLeft - 1))
      else
        # otherwise we add a new line
        wrappedText+="${newLine}"
        spaceLeft=${width}
      fi
    fi

    wordLength=${#word}

    if [[ wordLength -le spaceLeft ]]; then
      # we have the space to add the word
      wrappedText+="${word}"
      spaceLeft=$((spaceLeft - wordLength))
    else
      # we don't have the space to add the word

      # will the word fit in the width of the next line?
      if [[ wordLength -le width ]]; then
        # then we add the word to the next line
        wrappedText+="${newLine}${word}"
        spaceLeft=$((width - wordLength))
      else
        # the word doesn't fit in the width of the next line
        # we can add the partial word to the current line
        # and the rest on the next lines until we have the full word
        while [[ wordLength -gt 0 ]]; do
          partialWordLength="${wordLength}"
          if [[ partialWordLength -gt spaceLeft ]]; then
            partialWordLength="${spaceLeft}"
          fi
          wrappedText+="${word:0:${partialWordLength}}"
          word="${word:${partialWordLength}}"
          wordLength=$((wordLength - partialWordLength))
          spaceLeft=$((spaceLeft - partialWordLength))
          if [[ spaceLeft -eq 0 && wordLength -gt 0 ]]; then
            wrappedText+="${newLine}"
            spaceLeft="${width}"
          fi
        done
      fi
    fi
  done

  RETURNED_VALUE="${wrappedText}"
}

# ## string::wrapCharacters
#
# Allows to hard wrap the given string (without new lines) at the given width.
# Wrapping is done at character boundaries without taking spaces into consideration.
# Optionally applies a prefix on each new line.
#
# - $1: **text** _as string_:
#       the text to wrap
# - $2: wrap width _as string_:
#       (optional) the width to wrap the text at
#       (defaults to GLOBAL_COLUMNS)
# - $3: new line pad string _as string_:
#       (optional) the prefix to apply to each new line
#       (defaults to "")
# - $4: new line wrap width _as string_:
#       (optional) the width to wrap the text for each new line
#       (defaults to the width)
#
# Returns:
#
# - `RETURNED_VALUE`: the wrapped string
#
# ```bash
# string::wrapCharacters "This is a long text that should be wrapped at 20 characters." 20 ---
# local wrappedString="${RETURNED_VALUE}"
# ```
#
# > This function is written in pure bash and is faster than calling the fold command.
function string::wrapCharacters() {
  local text="${1}"
  local -i width="${2:-${GLOBAL_COLUMNS}}"
  local newLinePrefix="${3:-}"
  local -i newLineWidth="${4:-"${width}"}"

  # short cut in case the text is already shorter than the width
  if [[ "${#text}" -le width ]]; then
    RETURNED_VALUE="${text}"
    return 0
  fi

  RETURNED_VALUE=""
  local -i textLength="${#text}" i nbLines=-1
  local first=true
  for ((i = 0; i < textLength; i += width)); do
    if ((nbLines == 0)); then
      width=${newLineWidth}
    fi
    if ((nbLines >= 0)); then
      RETURNED_VALUE+=$'\n'"${newLinePrefix}"
    fi
    RETURNED_VALUE+="${text:i:width}"
    nbLines+=1
  done
}

# ## array::fuzzyFilter
#
# Allows to fuzzy match an array against a given pattern.
# Returns an array containing only the lines matching the pattern.
#
# - $1: **pattern** _as string_:
#       the pattern to match
# - $2: **array name** _as string_:
#       the initial array name
#
# Returns:
#
# - `RETURNED_ARRAY`: an array containing only the lines matching the pattern
# - `RETURNED_ARRAY2`: an array of the same size that contains the start index of the match
# - `RETURNED_ARRAY3`: an array of the same size that contains the distance of the match
#
# ```bash
# array::fuzzyFilter "pattern" "myarray"
# if (( ${#RETURNED_ARRAY[@]} == 1 )); then
#   singleMatch="${RETURNED_ARRAY[0]}"
# fi
# ```
#
# > - All characters in the pattern must be found in the same order in the matched line.
# > - The function is case insensitive.
# > - This function does not sort the results, it only filters them.
function array::fuzzyFilter() {
  local pattern="${1}"
  local -n array="${2}"

  local -a matches=()
  local -a indexes=()
  local -a distances=()

  local -i patternLength lineLength
  patternLength="${#pattern}"

  # make all match case insensitive
  shopt -s nocasematch

  local line patternChar lineChar
  local -i lineCharIndex patternCharIndex lastLineCharIndex distance patternFirstCharIndex

  for line in "${array[@]}"; do
    lineLength="${#line}"

    # for each character in the pattern
    patternCharIndex=0
    lineCharIndex=0
    lastLineCharIndex=0
    while [[ patternCharIndex -lt patternLength ]]; do
      patternChar="${pattern:${patternCharIndex}:1}"

      # find the character in the line
      while [[ lineCharIndex -lt lineLength ]]; do
        lineChar="${line:${lineCharIndex}:1}"

        if [[ ${lineChar} == "${patternChar}" ]]; then
          # if we find the character, mark the distance
          distance=$((lineCharIndex - lastLineCharIndex))
          lastLineCharIndex=$((lineCharIndex + 1))

          # if it is the first char of the pattern, remmember the index
          if [[ patternCharIndex -eq 0 ]]; then
            patternFirstCharIndex=${lineCharIndex}
          fi

          # loop on the next pattern character
          break
        fi

        lineCharIndex+=1
      done

      # if we don't find the character in the line, the line is not a match
      if [[ lineCharIndex -ge lineLength ]]; then
        break
      else
        lineCharIndex+=1
      fi

      patternCharIndex+=1
    done

    # if we found all the characters in the pattern
    if [[ patternCharIndex -ge patternLength ]]; then
      matches+=("${line}")
      indexes+=("${patternFirstCharIndex}")
      distances+=("${distance}")
    fi

  done

  shopt -u nocasematch

  RETURNED_ARRAY=("${matches[@]}")
  RETURNED_ARRAY2=("${indexes[@]}")
  RETURNED_ARRAY3=("${distances[@]}")
}

#===============================================================
# >>> Valet files and directories
#===============================================================

# ## core::getConfigurationDirectory
#
# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Returns:
#
# - `RETURNED_VALUE`: the path to the valet configuration directory
#
# ```bash
# core::getConfigurationDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getConfigurationDirectory() {
  local directory
  directory="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getLocalStateDirectory
#
# Returns the path to the valet locla state directory.
# The base directory relative to which user-specific state files should be stored.
# Creates it if missing.
#
# Returns:
#
# - `RETURNED_VALUE`: the path to the valet local state directory
#
# ```bash
# core::getLocalStateDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getLocalStateDirectory() {
  local directory
  directory="${VALET_CONFIG_LOCAL_STATE_DIRECTORY:-${XDG_STATE_HOME:-${HOME}/.local/share}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getUserDirectory
#
# Returns the path to the valet user directory.
# Does not create it if missing.
#
# Returns:
#
# - `RETURNED_VALUE`: the path to the valet user directory
#
# ```bash
# core::getUserDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getUserDirectory() {
  RETURNED_VALUE="${VALET_USER_DIRECTORY:-${HOME}/.valet.d}"
}

#===============================================================
# >>> Parser and interactive mode
#===============================================================

# ## core::showHelp
#
# Show the help for the current function.
# This should be called directly from a command function for which you want to display the help text.
#
# ```bash
# core::showHelp
# ```
function core::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::printHelp funtion "${functionName}"
}

# ## core::parseArguments
#
# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.
#
#
# - $@: **arguments** _as any_:
#       the arguments to parse
#
# Returns:
#
# - `RETURNED_VALUE`: a string that can be evaluated to set the parsed variables
#
# Output example:
#
# ```
# local arg1 option1
# arg1="xxx"
# option1="xxx"
# ```
#
# ```bash
# core::parseArguments "$@" && eval "${RETURNED_VALUE}"
# ```
function core::parseArguments() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]}"

  main::parseFunctionArgumentsOrGoInteractive "${functionName}" "$@"
}

# ## core::checkParseResults
#
# A convenience function to check the parsing results and fails with an error message if there are
# parsing errors.
# Will also display the help if the help option is true.
#
# This should be called from a command function for which you want to check the parsing results.
#
# - $1: **display help** _as bool_:
#       the help option
# - $2: **parsing errors** _as string_:
#       the parsing errors
# - $3: function name _as string_:
#       (optional) the function name
#       (defaults to the calling function)
#
# ```bash
# core::checkParseResults "${help:-}" "${parsingErrors:-}"
# core::checkParseResults "${help:-}" "${parsingErrors:-}" "myFunctionName"
# ```
function core::checkParseResults() {
  local help="${1:-}"
  local parsingErrors="${2:-}"
  local functionName="${3:-${FUNCNAME[1]}}"

  if [[ ${help} == "true" ]]; then
    main::printHelp function "${functionName}"
    exit 0
  fi

  if [[ -n "${parsingErrors:-}" ]]; then
    local -n commandName="CMD_COMMAND_${functionName}"
    core::fail "${parsingErrors}"
  fi
}

#===============================================================
# >>> Main
#===============================================================

# Parsing the options from environment variables
if [[ -n "${VALET_LOG_LEVEL:-}" ]]; then
  log::setLevel "${VALET_LOG_LEVEL}"
fi
if [[ ${VALET_VERBOSE:-} == "true" ]]; then
  log::setLevel debug
fi
if [[ ${VALET_VERY_VERBOSE:-} == "true" ]]; then
  log::setLevel trace
fi
if [[ -n "${VALET_CONFIG_LOG_FD:-}" ]]; then
  _INVALID_FD=false
  # make sure the file descriptor is valid
  if [[ ! "${VALET_CONFIG_LOG_FD}" =~ ^[0-9]+$ ]]; then
    # it is a file
    if ! { : >>"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
      _INVALID_FD=true
    fi
  elif ! { : >&"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
    _INVALID_FD=true
  fi
  if [[ ${_INVALID_FD} == "true" ]]; then
    _ORIGINAL_FD="${VALET_CONFIG_LOG_FD}"
    VALET_CONFIG_LOG_FD=2
    core::fail "The file descriptor VALET_CONFIG_LOG_FD=⌜${_ORIGINAL_FD}⌝ is not valid."
  fi
fi

# Include main if not already included
if [[ -z "${GLOBAL_MAIN_INCLUDED:-}" ]]; then
  # shellcheck source=main
  source "${GLOBAL_VALET_HOME}/libraries.d/main"
fi
