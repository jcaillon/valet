#!/usr/bin/env bash
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

# check the bash version (and that we are running in bash), make it POSIX compliant
# shellcheck disable=SC2292
# shellcheck disable=SC2086
# shellcheck disable=SC2128
if [ ${BASH_VERSINFO:-0} -lt 5 ]; then
  printf '%s\n' "❌ Bash 5 or higher is required to run valet."
  exit 1
fi

if [[ -v GLOBAL_CORE_INCLUDED ]] && command -v log::warning &>/dev/null; then
  log::warning "The core library has already been included but was called again, remove the unnecessary call."
  log::printCallStack
  return 0
fi

# we check for this variable to know if this script has already been included
GLOBAL_CORE_INCLUDED=1

#===============================================================
# >>> Traps
#===============================================================

# This function is called when a command or pipeline returns a non-zero exit status.
# It is executed in the same shell as the command that failed, as if we called this function
# at the line where the command failed.
function trap::onErrorInternal() {
  local -a errorCodes=("$?" "${PIPESTATUS[@]}")
  local IFS=' '
  local errorCodesString="⌜${errorCodes[0]}⌝"
  if (( ${#errorCodes[@]} > 2 )); then
    errorCodesString+=" (pipeline statuses ⌜${errorCodes[*]}⌝)"
  fi

  if [[ ${FUNCNAME[1]:-} == "log::"* ]]; then
    # we are here if the error happened in a log function and thus we couldn't print the error
    printf '%s\n%s\n%s\n' "The command had a return code of ${errorCodesString}." "Error in a log function:" "${BASH_COMMAND:-}" >&2
    log::getCallStack 2
    printf '%s\n' "${RETURNED_VALUE}" >&2
    return 0
  fi

  local symbol="╰"
  if [[ -n ${FUNCNAME[1]:-} ]]; then
    symbol="╭"
  fi
  log::print "ERROR" "${STYLE_ICON_ERROR:-}" "CMDERR" "Error code ${errorCodesString} for the command:"
  log::printString "${symbol} ${BASH_COMMAND:-}" "│ "
  log::printCallStack 2

  # the program will exit
  GLOBAL_EXPECTED_EXIT=1
}

# This function is called when the program exits (on error, on success, on exit, on interrupt).
# It is executed in the same shell that exited, as if we called this function
# at the line where the exit command is called.
function trap::onExitInternal() {
  local exitCode="$?"

  if [[ ${VALET_CONFIG_CORE_DUMP_ON_EXIT:-} == "true" || ( ! -v GLOBAL_EXPECTED_EXIT && ${exitCode} != "0" ) ]]; then
    _OPTION_DUMP_SUFFIX="-${exitCode}" core::dump
  fi

  log::debug "Exiting with code ${exitCode} after ${SECONDS}s."
  if declare -F onExit &>/dev/null; then
    onExit "${exitCode}"
  fi

  if [[ ! -v GLOBAL_EXPECTED_EXIT ]]; then
    local symbol="╰"
    if [[ -n ${FUNCNAME[1]:-} ]]; then
      symbol="╭"
    fi
    if [[ ${BASH_COMMAND:-} != "exit"* ]]; then
      log::print "WARNING" "${STYLE_ICON_EXIT:-}" "EXIT" "Unexpected exit with code ${exitCode}:"
      log::printString "${symbol} ${BASH_COMMAND:-}" "│ "
      log::printCallStack 2
    elif [[ ${exitCode} != "0" ]]; then
      log::print "ERROR" "${STYLE_ICON_EXIT:-}" "EXIT" "Exiting with code ${exitCode}, stack:"
      log::debug "${symbol} ${BASH_COMMAND:-}" "│ "
      log::printCallStack 2
    fi
  fi

  if [[ -n ${GLOBAL_ON_EXIT_MESSAGE:-} ]]; then
    log::error "${GLOBAL_ON_EXIT_MESSAGE}"
  fi

  # always call cleanUp before exiting
  trap::onCleanUpInternal
}

# This function is called when the program is interrupted by the user (CTRL+C).
# It is executed in the same shell that has been interrupted, as if we called this function
# at the line executed at the moment when the interruption took place.
function trap::onInterruptInternal() {
  if ! declare -F tui::restoreTerminalOptions &>/dev/null; then
    printf '\n' # Set cursor to the next line of '^C' (only if stty echo is on)
  fi
  log::print "WARNING" "${STYLE_ICON_STOPPED:-}" "STOPPED" "Program interrupted by the user."

  if log::isDebugEnabled; then
    log::debug "Is your command stuck? Consider using the ⌜-x⌝ option to activate the profiler and identify what's wrong. Here is the current stack:"
    log::printCallStack 2
  fi

  # check if the function exists
  if declare -F onInterrupt &>/dev/null; then
    if onInterrupt; then
      # if onInterrupt returns 0, then we cancel the interrupt
      return 0
    fi
  fi
  # reset the trap to not call this function again
  trap SIGINT SIGQUIT
  GLOBAL_EXPECTED_EXIT=1
  exit 1
}

# This function is called when the program is terminated by the system (SIGHUP, SIGTERM).
function trap::onTerminateInternal() {
  log::print "ERROR" "${STYLE_ICON_KILLED:-}" "KILLED" "Program killed."
  # check if the function exists
  if declare -F onTerminate &>/dev/null; then
    if onTerminate; then
      # if onTerminate returns 0, then we cancel the termination
      return 0
    fi
  fi
  # reset the trap to not call this function again
  trap SIGHUP SIGTERM
  GLOBAL_EXPECTED_EXIT=1
  exit 1
}

# This function is called when terminal changes its size.
function trap::onResizeInternal() {
  tui::getTerminalSize
  # shellcheck disable=SC2034
  GLOBAL_SCREEN_REDRAW_REQUIRED=true
  # need to re init the logs because might depend on the number of columns for wrapping
  log::init
  if declare -F progress::onResize &>/dev/null; then
    progress::onResize
  fi
  if declare -F onResize &>/dev/null; then
    onResize
  fi
}

# This functions is called before the program exits (in all cases, error or not).
function trap::onCleanUpInternal() {
  # disable the profiler if still on
  if [[ ${_ACTIVE_PROFILER:-} == "1" ]]; then profiler::disable; fi

  # kill background job if still running
  if [[ -n ${GLOBAL_BACKGROUND_JOB1_PID:-} ]]; then
    kill "${GLOBAL_BACKGROUND_JOB1_PID}" &>/dev/null || :
  fi

  # if we are in interactive mode, we need to restore the cursor
  if [[ -t 7 && ${VALET_CONFIG_DISABLE_ESC_CODES:-} != "true" ]]; then
    printf '%s' $'\e[?25h' 1>&7 # ESC__CURSOR_SHOW_FORCE
  fi

  # call the clean up functions if they exist
  if declare -F cleanUp &>/dev/null; then
    cleanUp
  fi

  # if we were in interactive mode, we need to restore the logs
  if declare -F tui::restoreLogs &>/dev/null; then
    tui::restoreLogs
  fi

  # restore tty settings if needed
  if declare -F tui::restoreTerminalOptions &>/dev/null; then
    tui::restoreTerminalOptions true
  fi

  fs::cleanTempFiles
}

# Function to handle commands not found, so we can display a better message.
# The name of this function is a bash convention.
# This is called by bash and executed in a subshell (different PID than the main program).
function command_not_found_handle() {
  # check for recursive call
  if [[ -v GLOBAL_COMMAND_NOT_FOUND ]]; then
    # we are here if the error happened in a log function and thus we couldn't print the error
    printf '%s\n%s\n' "Command not found: ⌜${1}⌝." "Error in a log function." >&2
    log::getCallStack 2
    printf '%s\n' "${RETURNED_VALUE}" >&2
    GLOBAL_EXPECTED_EXIT=1
    return 1
  fi
  GLOBAL_COMMAND_NOT_FOUND=1

  local errorMessage
  if [[ ${1:-} == "curl" ]]; then
    errorMessage="This command requires ⌜curl⌝ to make https request to the internet."$'\n'"Please install it in your path and run this command again."
  fi
  # if the command contains :: it is one of our function, we can suggest to source the 'package'
  if [[ ${1} == *::* ]]; then
    errorMessage="Command not found: ⌜${1}⌝."$'\n'"Did you forget to source the package? ⌜source ${1%%::*}⌝"
  fi
  errorMessage="Command not found: ⌜${1}⌝."$'\n'"Please check your ⌜PATH⌝ variable."

  log::print "ERROR" "${STYLE_ICON_ERROR:-}" "CMDMISS" "${errorMessage}"
  log::printCallStack 2

  GLOBAL_EXPECTED_EXIT=1
  return 1
  # since this runs in a subshell, we don't actually exit the main program
  # but we set $? to 1 so ERR trap is called
}

# ## trap::register (private)
#
# Register the traps for the program.
function trap::register() {
  trap trap::onErrorInternal ERR
  trap trap::onExitInternal EXIT
  # Register CTRL+C SIGINT (interrupt) and CTRL+\ QUIT (interrupt with a coredump) event handler
  trap trap::onInterruptInternal SIGINT SIGQUIT
  # Register SIGHUP (hang up, terminal disconnected) and TERM (terminate the program) event handler
  trap trap::onTerminateInternal SIGHUP SIGTERM
  if [[ -t 2 ]]; then
    # shellcheck disable=SC2034
    GLOBAL_SCREEN_REDRAW_REQUIRED=false
    trap trap::onResizeInternal SIGWINCH
  fi
}

# ## trap::unregister (private)
#
# Unregister the traps for the program.
# Can be called in a subshell where we want to reset the traps.
function trap::unregister() {
  trap ERR
  trap EXIT
  trap SIGINT; trap SIGQUIT
  trap SIGHUP; trap SIGTERM
  if [[ -t 2 ]]; then
    trap SIGWINCH
  fi
}

#===============================================================
# >>> Temporary files and folders
#===============================================================

# Setup global variables that will be used for temporary files and folders.
function fs::setupTempFileGlobalVariable() {
  # get unique file names for the stdout, stderr and temporary directory
  # to be fast, we do not create anything until we really need it
  # this could lead to issues, although it is very unlikely
  GLOBAL_TEMPORARY_DIRECTORY_PREFIX="${VALET_CONFIG_TEMP_DIRECTORY:-${TMPDIR:-/tmp}}/vt-${BASHPID}"
  GLOBAL_TEMPORARY_FILE_PREFIX="${VALET_CONFIG_RUNTIME_DIRECTORY:-${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}}/vt-${BASHPID}"

  while [[ -e "${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d" ]]; do
    # just in case we have a collision
    GLOBAL_TEMPORARY_DIRECTORY_PREFIX+="x"
    GLOBAL_TEMPORARY_FILE_PREFIX+="x"
  done

  GLOBAL_TEMPORARY_DIRECTORY="${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_WORK_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-work.f"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_STDOUT_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stdout.f"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_STDERR_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stderr.f"
  unset -v TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
}

# ## fs::createTempFile
#
# Creates a temporary file and return its path.
#
# - ${_OPTION_PATH_ONLY} _as bool_:
#       (optional) If true, does not create the file, only returns the path.
#       (defaults to false)
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempFile
# local file="${RETURNED_VALUE}"
# ```
#
# > Files created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
function fs::createTempFile() {
  if [[ ! -v TEMPORARY_FILE_NUMBER ]]; then
    TEMPORARY_FILE_NUMBER=0
    if [[ ! -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
      mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    fi
  fi
  TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
  RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
  if [[ ${_OPTION_PATH_ONLY:-false} != "true" ]]; then
    : >"${RETURNED_VALUE}"
  fi
}

# ## fs::createTempDirectory
#
# Creates a temporary directory.
#
# - ${_OPTION_PATH_ONLY} _as bool_:
#       (optional) If true, does not create the file, only returns the path.
#       (defaults to false)
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
function fs::createTempDirectory() {
  if [[ ! -v TEMPORARY_DIRECTORY_NUMBER ]]; then
    TEMPORARY_DIRECTORY_NUMBER=0
    if [[ ${_OPTION_PATH_ONLY:-false} == "true" && ! -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
      mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
    fi
  fi
  TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
  RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
  if [[ ${_OPTION_PATH_ONLY:-false} != "true" ]]; then
    mkdir -p "${RETURNED_VALUE}" 1>/dev/null
  fi
}

# ## fs::cleanTempFiles
#
# Removes all the temporary files and directories that were created by the
# fs::createTempFile and fs::createTempDirectory functions.
#
# ```bash
# fs::cleanTempFiles
# ```
# shellcheck disable=SC2016
function fs::cleanTempFiles() {
  if [[ -d ${GLOBAL_TEMPORARY_DIRECTORY:-} ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null || :
  fi
  if [[ -n ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY:-} && -d ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting temporary windows directory."
    rm -Rf "${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY}" 1>/dev/null || :
  fi
  if [[ -n ${GLOBAL_TEMPORARY_FILE_PREFIX:-} ]]; then
    log::debug "Deleting temporary files."
    rm -f "${GLOBAL_TEMPORARY_FILE_PREFIX}"* &>/dev/null || :
  fi
  unset -v TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
}

#===============================================================
# >>> Terminal UI
#===============================================================

# ## tui::getTerminalSize
#
# This function exports the terminal size.
#
# Returns:
#
# - `GLOBAL_COLUMNS`: The number of columns in the terminal.
# - `GLOBAL_LINES`: The number of lines in the terminal.
#
# ```bash
# tui::getTerminalSize
# printf '%s\n' "The terminal has ⌜${GLOBAL_COLUMNS}⌝ columns and ⌜${GLOBAL_LINES}⌝ lines."
# ```
# shellcheck disable=SC2034
function tui::getTerminalSize() {
  shopt -s checkwinsize
  # the following subshell is required to correctly compute the columns and lines
  # the bash manual says these are computed after the execution of an external command
  # but it works with a subshell
  (
    :
    :
  )
  GLOBAL_COLUMNS="${COLUMNS:-120}"
  GLOBAL_LINES="${LINES:-30}"
  shopt -u checkwinsize
}

#===============================================================
# >>> Logging
#===============================================================


# ## log::setLevel
#
# Set the log level.
#
# - $1: **log level** _as string_:
#       The log level to set (or defaults to info), acceptable values are:
#   - trace
#   - debug
#   - info
#   - success
#   - warning
#   - error
# - $2: silent _as bool_:
#       (optional) true to silently switch log level, i.e. does not print a message
#       (defaults to false)
#
# ```bash
# log::setLevel debug
# log::setLevel debug true
# ```
function log::setLevel() {
  # log level, defaults to info
  GLOBAL_LOG_LEVEL="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  case "${GLOBAL_LOG_LEVEL}" in
  error) GLOBAL_LOG_LEVEL_INT=4 ;;
  warning) GLOBAL_LOG_LEVEL_INT=3 ;;
  success) GLOBAL_LOG_LEVEL_INT=2 ;;
  debug) GLOBAL_LOG_LEVEL_INT=0 ;;
  trace) GLOBAL_LOG_LEVEL_INT=-1 ;;
  *) GLOBAL_LOG_LEVEL_INT=1 ;;
  esac

  if [[ ${2:-false} != "true" ]]; then
    if ((GLOBAL_LOG_LEVEL_INT != 1)); then
      log::debug "Log level set to ${GLOBAL_LOG_LEVEL}."
    fi
    if ((GLOBAL_LOG_LEVEL_INT <= 0)); then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# ## log::getLevel
#
# Get the current log level.
#
# Returns:
#
# - ${RETURNED_VALUE}: The current log level.
#
# ```bash
# log::getLevel
# printf '%s\n' "The log level is ⌜${RETURNED_VALUE}⌝."
# ```
function log::getLevel() {
  RETURNED_VALUE="${GLOBAL_LOG_LEVEL:-info}"
}

# ## log::printInternal (private)
#
# Display log message.
#
# - $1: **color name** _as string_:
#       The color name to use for the severity (TRACE, DEBUG...).
# - $2: **icon** _as string_:
#       The icon to display in the log message (utf8 character from nerd icons).
# - $3: **severity** _as string_:
#       The severity to display (max 7 chars for the default log pattern).
# - $@: **message variable name** _as string_:
#       The name of the variable that contains the message to log.
#
# ```bash
# message="This is a success message."
# log::Internal "SUCCESS" $'\uf14a' "OK" message
# ```
# shellcheck disable=SC2034
function log::printInternal() {
  local colorName="${1:-${3}}"
  local icon="${2}"
  local level="${3}"
  local messageVariableName="${4}"
  local -n levelColor="STYLE_COLOR_${colorName^^}"
  # evaluated the print statement built in log::init; it uses the local vars defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}"
}

# ## log::print
#
# Display a log message.
#
# - $1: **color name** _as string_:
#       The color name to use for the severity (TRACE, DEBUG...).
# - $2: **icon** _as string_:
#       The icon to display in the log message (utf8 character from nerd icons).
# - $3: **severity** _as string_:
#       The severity to display (max 7 chars for the default log pattern).
# - $@: **message** _as string_:
#       The message to log.
#
# ```bash
# log::print "SUCCESS" $'\uf14a' "OK" "This is a success message."
# ```
# shellcheck disable=SC2034
function log::print() {
  local IFS=$'\n'
  local message="${*:4}"
  log::printInternal "${1}" "${2}" "${3}" message
}

# ## log::printFile
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **path** _as string_:
#       the file path to display.
# - $2: max lines _as int_:
#       (optional) Can be set using the variable `_OPTION_MAX_LINES`.
#       Max lines to display, can be set to 0 to display all lines.
#       (defaults to 0)
#
# ```bash
# log::printFile "/my/file/path"
# ```
# shellcheck disable=SC2317
function log::printFile() {
  local filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i maxLines="${2:-${_OPTION_MAX_LINES:-0}}"

  local line rawStringToPrintInLog lineNumberPadding="   "
  local -i lineNumber=1 currentLineNumberLength=1
  if [[ ! -f "${filePath}" ]]; then
    log::error "Can not print the file ⌜${filePath}⌝ because does not exist."
    return 1
  fi
  local IFS=""
  while IFS="" read -r line || [[ -n ${line:-} ]]; do
    log::printFileInternalLoop || break;
  done <"${filePath}"
  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::printFileString
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **content variable name** _as string_:
#       The name of the variable containing the file content to print.
# - $2: max lines _as int_:
#       (optional) Can be set using the variable `_OPTION_MAX_LINES`.
#       Max lines to display, can be set to 0 to display all lines.
#       (defaults to 0)
#
# ```bash
# log::printFileString "myvar"
# ```
#
# > This function is not at all suited for large strings, print the content to a file instead.
# shellcheck disable=SC2317
function log::printFileString() {
  local -n contentToPrint="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i maxLines="${2:-${_OPTION_MAX_LINES:-0}}"

  local line rawStringToPrintInLog lineNumberPadding="   "
  local -i lineNumber=1 currentLineNumberLength=1

  local IFS
  while IFS=$'\n' read -rd $'\n' line; do
    log::printFileInternalLoop || break;
  done <<<"${contentToPrint}"

  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::printFileInternalLoop (private)
#
# An internal function used in log::printFile and log::printFileString to display each line
# of a file or string. It uses the local variables set by the calling function.
function log::printFileInternalLoop() {
  if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
    string::wrapCharacters line "${GLOBAL_LOG_COLUMNS}" "${GLOBAL_LOG_WRAP_PADDING}     ${STYLE_COLOR_FADED}░${STYLE_COLOR_DEFAULT} " "$((GLOBAL_LOG_COLUMNS - 7 - ${#GLOBAL_LOG_WRAP_PADDING}))"

    rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}${STYLE_COLOR_FADED}${lineNumberPadding}${lineNumber} ░${STYLE_COLOR_DEFAULT} ${RETURNED_VALUE}"$'\n'
  else
    rawStringToPrintInLog+="${STYLE_COLOR_FADED}${lineNumberPadding}${lineNumber} ░${STYLE_COLOR_DEFAULT} ${line}"$'\n'
  fi

  lineNumber+=1
  if (( ${#lineNumber} > currentLineNumberLength )); then
    lineNumberPadding="${lineNumberPadding%?}"
    currentLineNumberLength+=1
  fi
  if (( maxLines != 0 && lineNumber > maxLines )); then
    if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
      rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}"
    fi
    rawStringToPrintInLog+="${STYLE_COLOR_FADED}     ░ (truncated)${STYLE_COLOR_DEFAULT}"$'\n'
    return 1
  fi
}

# ## log::printString
#
# Display a string in the log.
# The string will be aligned with the current log output and hard wrapped if necessary.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to log (can contain new lines)
# - $2: new line pad string _as string_:
#       (optional) the string with which to prepend each wrapped line
#       (empty by default)
#
# ```bash
# log::printString "my line"
# ```
# shellcheck disable=SC2317
function log::printString() {
  local content="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local wrappedLineLeftPaddingString="${2:-}"

  local line rawStringToPrintInLog
  while [[ -n ${content} ]]; do
    line="${content%%$'\n'*}"
    content="${content:${#line} + 1}"

    if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
      string::wrapCharacters line "${GLOBAL_LOG_COLUMNS}" "${GLOBAL_LOG_WRAP_PADDING}${wrappedLineLeftPaddingString}" "$((GLOBAL_LOG_COLUMNS - ${#GLOBAL_LOG_WRAP_PADDING}))"
      rawStringToPrintInLog+="${GLOBAL_LOG_WRAP_PADDING}${RETURNED_VALUE}"$'\n'
    else
      rawStringToPrintInLog+="${line}"$'\n'
    fi
  done
  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::saveFile
#
# Save the given file by copying it to a new file in the user local state directory
# (using `core::createNewStateFilePath`).
# Useful for debugging purposes, to save the state of a file during execution.
#
# - $1: **path** _as string_:
#       The file path to save.
# - $2: **suffix** _as string_:
#       The suffix to add to the file name.
# - $3: log path _as bool_:
#       (optional) if true, log the path of the saved file using `log::printString`
#       (defaults to true)
#
# Returns:
#
# - ${RETURNED_VALUE}: The path to the saved file.
#
# ```bash
# log::saveFile "/my/file/path" "suffix" "important result file"
# ```
function log::saveFile() {
  local filePath="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local suffix="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local logPath="${3:-"true"}"
  core::createNewStateFilePath "${suffix}"
  local newFilePath="${RETURNED_VALUE}"
  cp "${filePath}" "${newFilePath}"
  if [[ ${logPath} == "true" ]]; then
    log::printString "⌜${newFilePath}⌝"
  fi
  RETURNED_VALUE="${newFilePath}"
}

# ## log::saveFileString
#
# Save the given string to a new file in the user local state directory
# (using `core::createNewStateFilePath`).
# Useful for debugging purposes, to save the state of a string during execution.
#
# - $1: **content variable name** _as string_:
#       The variable name of the content to save.
# - $2: **suffix** _as string_:
#       The suffix to add to the file name.
# - $3: log path _as bool_:
#       (optional) if true, log the path of the saved file using `log::printString`
#       (defaults to true)
#
# Returns:
#
# - ${RETURNED_VALUE}: The path to the saved file.
#
# ```bash
# log::saveFileString "my content" "suffix" "important result file"
# ```
function log::saveFileString() {
  local -n contentToSave="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local suffix="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local logPath="${3:-"true"}"
  core::createNewStateFilePath "${suffix}"
  local newFilePath="${RETURNED_VALUE}"
  printf '%s' "${contentToSave}" >"${newFilePath}"
  if [[ ${logPath} == "true" ]]; then
    log::printString "⌜${newFilePath}⌝"
  fi
  RETURNED_VALUE="${newFilePath}"
}

# ## log::printRaw
#
# Display something in the log stream.
# Does not check the log level.
#
# - $1: **content variable name** _as string_:
#       The variable name containing the content to print (can contain new lines).
#
# ```bash
# log::printRaw "my line"
# ```
# shellcheck disable=SC2317
function log::printRaw() {
  local -n rawStringToPrintInLog="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  # shellcheck disable=SC2034

  # evaluated the print statement built in log::init; it uses the local var rawStringToPrintInLog defined above
  eval "${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}"
}

# ## log::error
#
# Displays an error message.
#
# - $@: **message** _as string_:
#       the error messages to display
#
# ```bash
# log::error "This is an error message."
# ```
#
# > You probably want to exit immediately after an error and should consider using core::fail function instead.
function log::error() {
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "ERROR" "${STYLE_ICON_ERROR:-}" "ERROR" loggedLine
  if log::isDebugEnabled; then
    log::printCallStack 2
  fi
}

# ## log::warning
#
# Displays a warning.
#
# - $@: **message** _as string_:
#       the warning messages to display
#
# ```bash
# log::warning "This is a warning message."
# ```
function log::warning() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 3)); then
    return 0
  fi
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "WARNING" "${STYLE_ICON_WARNING:-}" "WARNING" loggedLine
  return 0
}

# ## log::success
#
# Displays a success message.
#
# - $@: **message** _as string_:
#       the success messages to display
#
# ```bash
# log::success "This is a success message."
# ```
function log::success() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 2)); then
    return 0
  fi
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "SUCCESS" "${STYLE_ICON_SUCCESS:-}" "SUCCESS" loggedLine
  return 0
}

# ## log::info
#
# Displays an info message.
#
# - $@: **message** _as string_:
#       the info messages to display
#
# ```bash
# log::info "This is an info message."
# ```
function log::info() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 1)); then
    return 0
  fi
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "INFO" "${STYLE_ICON_INFO:-}" "INFO" loggedLine
  return 0
}

# ## log::debug
#
# Displays a debug message.
#
# - $@: **message** _as string_:
#       the debug messages to display
#
# ```bash
# log::debug "This is a debug message."
# ```
function log::debug() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 0)); then
    return 0
  fi
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "DEBUG" "${STYLE_ICON_DEBUG:-}" "DEBUG" loggedLine
  return 0
}

# ## log::trace
#
# Displays a trace message.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::trace "This is a trace message."
# ```
function log::trace() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > -1)); then
    return 0
  fi
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "TRACE" "${STYLE_ICON_TRACE:-}" "TRACE" loggedLine
  return 0
}

# ## log::errorTrace
#
# Displays an error trace message.
# This is a trace message that is always displayed, independently of the log level.
# It can be used before a fatal error to display useful information.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::errorTrace "This is a debug message."
# ```
function log::errorTrace() {
  local IFS=$'\n'
  # shellcheck disable=SC2034
  local loggedLine="$*"
  log::printInternal "TRACE" "${STYLE_ICON_ERROR_TRACE:-}" "TRACE" loggedLine
  return 0
}

# ## log::isDebugEnabled
#
# Check if the debug mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if debug mode is enabled (log level is debug)
#   - 1 if disabled
#
# ```bash
# if log::isDebugEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isDebugEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= 0)); then
    return 0
  fi
  return 1
}

# ## log::isTraceEnabled
#
# Check if the trace mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if trace mode is enabled (log level is trace)
#   - 1 if disabled
#
# ```bash
# if log::isTraceEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isTraceEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= -1)); then
    return 0
  fi
  return 1
}

# ## log::printCallStack
#
# This function prints the current function stack in the logs.
#
# - $1: Stack to skip _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP`.
#       The number of stack to skip.
#       (defaults to 2 which skips this function and the first calling function
#       which is usually the onError function)
# - $2: Stack to skip at end _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP_AT_END`.
#       The number of stack to skip at the end.
#       (defaults to 0)
#
# ```bash
# log::printCallStack
# log::printCallStack 0
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
function log::printCallStack() {
  local -i levelToSkip="${1:-${_OPTION_STACK_TO_SKIP:-2}}"
  local -i levelToSkipAtEnd="${2:-${_OPTION_STACK_TO_SKIP_AT_END:-0}}"

  _OPTION_WRAP_WIDTH="$((${GLOBAL_LOG_COLUMNS:-${GLOBAL_COLUMNS}} - ${#GLOBAL_LOG_WRAP_PADDING}))" log::getCallStack "$((levelToSkip + 1))" "${levelToSkipAtEnd}"
  if (( ${#RETURNED_VALUE} > 0 )); then
    log::printString "${RETURNED_VALUE}"
  fi
}

# ## log::getCallStack
#
# This function returns the current function stack.
#
# - $1: Stack to skip _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP`.
#       The number of stack to skip.
#       (defaults to 1 which skips this function)
# - $2: Stack to skip at end _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP_AT_END`.
#       The number of stack to skip at the end.
#       (defaults to 0)
# - ${_OPTION_WRAP_WIDTH} _as int_:
#       (optional) The width to wrap the call stack.
#       (defaults to the terminal width)
#
# Returns:
#
# - ${RETURNED_VALUE}: The call stack as a string.
#
# ```bash
# log::getCallStack
# echo "${RETURNED_VALUE}"
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
function log::getCallStack() {
  local -i levelToSkip="${1:-${_OPTION_STACK_TO_SKIP:-1}}"
  local -i levelToSkipAtEnd="${2:-${_OPTION_STACK_TO_SKIP_AT_END:-0}}"
  local -i wrapWidth=${_OPTION_WRAP_WIDTH:-"${GLOBAL_COLUMNS}"}

  local -a stackFunctionNames stackSourceFiles stackLineNumbers
  if [[ -n ${GLOBAL_STACK_FUNCTION_NAMES:-} ]]; then
    stackFunctionNames=("${GLOBAL_STACK_FUNCTION_NAMES[@]}")
    stackSourceFiles=("${GLOBAL_STACK_SOURCE_FILES[@]}")
    stackLineNumbers=("${GLOBAL_STACK_LINE_NUMBERS[@]}")
  else
    stackFunctionNames=("${FUNCNAME[@]}")
    stackSourceFiles=("${BASH_SOURCE[@]}")
    stackLineNumbers=("${BASH_LINENO[@]}")
  fi

  local -i idx stackSize=$((${#stackFunctionNames[@]} - levelToSkipAtEnd))
  local functionName lineNumber="${LINENO}" sourceFile line returnedString=""
  local treeString="├─" treePadding="│  "
  for ((idx = levelToSkip; idx < stackSize; idx++)); do
    functionName="${stackFunctionNames[${idx}]}"
    if [[ -z ${functionName} ]]; then
      functionName=ROOT
    else
      functionName="${functionName}()"
    fi
    if ((idx > 0)); then
      lineNumber="${stackLineNumbers[$((idx - 1))]}"
    fi
    sourceFile="${stackSourceFiles[${idx}]}"
    if [[ -z ${sourceFile} ]]; then
      sourceFile=non_file_source
    fi
    sourceFile="${sourceFile#"./"}"
    sourceFile="${sourceFile#"${GLOBAL_PROGRAM_STARTED_AT_DIRECTORY}/"}"
    if ((idx == stackSize - 1)); then
      treeString="╰─"
      treePadding="   "
    fi
    line="${treeString} in ${functionName} at ${sourceFile}:${lineNumber}"
    if (( wrapWidth > 0 )); then
      string::wrapCharacters line "${wrapWidth}" "${treePadding}"
      returnedString+="${RETURNED_VALUE}"$'\n'
    else
      returnedString+="${line}"$'\n'
    fi
  done

  RETURNED_VALUE="${returnedString}"
}

# ## log_setPrintfArgumentFromFormat (private)
#
# Set the variable printfArgument from the format specifier.
function log_setPrintfArgumentFromFormat() {
  local format="${printfFormat#'%'}"
  if [[ ${format} != *[0-9]* ]]; then
    printfArgument="\${${1}}"
  else
    format="${format%[sd]}"
    if [[ ${format} == "-"* ]]; then
      format="${format#-}"
      printfArgument="\${${1}:0:${format#-}}"
    else
      printfArgument="\${${1}:\${#${1}} - ${format} > 0 ? \${#${1}} - ${format} : 0}"
    fi
  fi
}

# ## log::parseLogPattern (private)
#
# Parse the log pattern and set variables that will be used to print the logs.
# If the pattern changes during runtime, the function `log::init` should be called again.
#
# - $1: **log pattern** _as string_:
#       The log pattern to parse.
#
# Available placeholders:
#
# - `<colorXXX>`: The value of the color variable `STYLE_COLOR_XXX`.
# - `<time>`: The current time formatted with the `format` string.
# - `<level>`: The log level.
# - `<levelColor>`: The color for the log level.
# - `<icon>`: The log level icon.
# - `<pid>`: The process ID of the bash instance that logged the message.
# - `<subshell>`: The subshell level of the bash instance that logged the message.
# - `<function>`: The name of the function that logged the message.
# - `<line>`: The line number where the message was logged.
# - `<source>`: The source of the function that logged the message.
# - `<varXXX>`: The value of an arbitrary variable `XXX`.
# - `<message>`: The log message (should be the last placeholder).
# - `<sourceFile>`: The file name of the source of the function that logged the message.
# - `<wrapPadding>`: The padding (spaces) used for wrapping the log message.
# - `<elapsedTime>`: The time elapsed since the start of the script.
# - `<elapsedTimeSinceLastLog>`: The time elapsed since the last log.
#
# Each placeholder can be fallowed by `{...}` to add the format specifier (see printf help).
#
# Returns:
#
# - ${RETURNED_VALUE}: The format string to use in a printf statement.
# - ${RETURNED_VALUE2}: The arguments (as a string space separated) to use in the printf statement.
# - ${RETURNED_VALUE3}: The length of the displayed log before the message.
# - ${RETURNED_VALUE4}: Extra code to compute variables that will be used to print the logs.
#
# ```bash
# log::parseLogPattern "<colorFaded><time>{(%H:%M:%S)T}<colorDefault> <levelColor><level> <icon><colorDefault> <message>"
# ```
# shellcheck disable=SC2120
function log::parseLogPattern() {
  local pattern="${1}"

  RETURNED_VALUE="" # format
  RETURNED_VALUE2="" # arguments
  RETURNED_VALUE3=0 # wrap padding length
  RETURNED_VALUE4="" # code
  local -i wrapPaddingLength=0

  local normalString placeHolder formatSpecifier normalStringVisibleCharacters formatLengthTest printfFormat printfArgument
  while [[ -n ${pattern} ]]; do
    # extract the next placeholder
    if [[ ${pattern} =~ \<([^\>]+)\>(\{([^}]+)\})? ]]; then
      placeHolder="${BASH_REMATCH[1]}"
      formatSpecifier="${BASH_REMATCH[3]:-}"
      normalString="${pattern%%"${BASH_REMATCH[0]}"*}"
      pattern="${pattern#*"${BASH_REMATCH[0]}"}"
    else
      placeHolder=""
      normalString="${pattern}"
      pattern=""
    fi

    # handle the normal string
    if [[ -n ${normalString} ]]; then
      normalStringVisibleCharacters="${normalString//$'\e['[0-9][0-9]m/}"
      normalStringVisibleCharacters="${normalStringVisibleCharacters//$'\e['[0-9]m/}"
      RETURNED_VALUE+="%s"
      RETURNED_VALUE2+="\"${normalString//\"/\\\"}\" "
      wrapPaddingLength+=${#normalStringVisibleCharacters}

      if [[ ${normalString} == *$'\n'* ]]; then
        local stringAfterNewline="${normalString##*$'\n'}"
        wrapPaddingLength=${#stringAfterNewline}
      fi
    fi

    printfFormat=""

    # handle a placeholder
    case "${placeHolder}" in
      color*)
        placeHolder="${placeHolder#color}"
        local -n color="STYLE_COLOR_${placeHolder^^}"
        if [[ -n ${color:-} ]]; then
          printfFormat="%s"
          printfArgument="${color}"
        fi
        ;;
      time)
        printfFormat="%${formatSpecifier:-"(%H:%M:%S)T"}"
        printfArgument="\${EPOCHSECONDS}"
        ;;
      levelColor)
        printfFormat="%s"
        printfArgument="\${levelColor:-}"
        ;;
      level)
        printfFormat="%${formatSpecifier:-"-8s"}"
        log_setPrintfArgumentFromFormat "level"
        ;;
      icon)
        if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} == "true" ]]; then
          printfFormat="%${formatSpecifier:-"-4s"}"
          printfArgument="\${icon:-}"
          # nerd font icons are 2 characters long
          wrapPaddingLength=$((wrapPaddingLength - 2))
        fi
        ;;
      var*)
        printfFormat="%${formatSpecifier:-"s"}"
        printfArgument="\${${placeHolder#var}:-}"
        RETURNED_VALUE4+=$'\n'"local variableToPrintInLog=\"\${${placeHolder#var}:-}\""
        log_setPrintfArgumentFromFormat "variableToPrintInLog"
        ;;
      pid)
        printfFormat="%${formatSpecifier:-"-5d"}"
        log_setPrintfArgumentFromFormat "BASHPID"
        ;;
      subshell)
        printfFormat="%${formatSpecifier:-"-2d"}"
        log_setPrintfArgumentFromFormat "BASH_SUBSHELL"
        ;;
      function)
        printfFormat="%${formatSpecifier:-"-10s"}"
        log_setPrintfArgumentFromFormat "FUNCNAME[2]"
        ;;
      line)
        printfFormat="%${formatSpecifier:-"-4s"}"
        log_setPrintfArgumentFromFormat "BASH_LINENO[1]"
        ;;
      source)
        printfFormat="%${formatSpecifier:-"-10s"}"
        log_setPrintfArgumentFromFormat "BASH_SOURCE[2]"
        ;;
      sourceFile)
        printfFormat="%${formatSpecifier:-"-10s"}"
        RETURNED_VALUE4+=$'\n'"local sourceFile=\"\${BASH_SOURCE[2]##*/}\""
        log_setPrintfArgumentFromFormat "sourceFile"
        ;;
      elapsedTime)
        printfFormat="%${formatSpecifier:-"-7s"}"
        log_setPrintfArgumentFromFormat "loggedElapsedTime"
        # shellcheck source=lib-time
        source time
        RETURNED_VALUE4+=$'\n'"time::getProgramElapsedMicroseconds; time::convertMicrosecondsToHuman \"\${RETURNED_VALUE}\" \"%S.%LLs\"; local loggedElapsedTime=\"\${RETURNED_VALUE}\""
        ;;
      elapsedTimeSinceLastLog)
        printfFormat="%${formatSpecifier:-"-7s"}"
        log_setPrintfArgumentFromFormat "loggedElapsedTimeSinceLastLog"
        # shellcheck source=lib-time
        source time
        RETURNED_VALUE4+=$'\n'"time::getProgramElapsedMicroseconds; local -i currentTime=\${RETURNED_VALUE}; _LOG_ELAPSED_TIME=\$(( currentTime - \${_LOG_ELAPSED_TIME:-0} )); time::convertMicrosecondsToHuman \"\${_LOG_ELAPSED_TIME}\" \"%S.%LLs\"; local loggedElapsedTimeSinceLastLog=\"\${RETURNED_VALUE}\"; _LOG_ELAPSED_TIME=\${currentTime}"
        ;;
      wrapPadding)
        printfFormat="%s"
        printfArgument="\${GLOBAL_LOG_WRAP_PADDING}"
        ;;
      message)
        printfFormat="%s"
        printfArgument="\${messageToPrintInLog:-}"

        # shellcheck disable=SC2034
        RETURNED_VALUE3="${wrapPaddingLength}"
        ;;
    esac
    if [[ -z ${printfFormat} ]]; then
      continue
    fi
    RETURNED_VALUE+="${printfFormat}"
    RETURNED_VALUE2+="\"${printfArgument}\" "

    if [[ ${printfFormat} != "%s" ]]; then
      # shellcheck disable=SC2059
      printf -v formatLengthTest "${printfFormat}" "1"
      wrapPaddingLength+=${#formatLengthTest}
    fi
  done

  RETURNED_VALUE+="\n"
}

# ## log::init (private)
#
# In charge of setting up global variables that will be used to print the logs.
# We compute them once to avoid recomputing them at each log call.
# Indeed, each log function might have to output the same log to different file descriptors or files,
# we don't want to repeat code and we don't want to recompute the same output logic on each function.
#
# - ${_OPTION_LOG_PATTERN} _as string_:
#       (optional) If defined, the log pattern to use.
#       (defaults to "")
#
# It uses the following config
#
# - ${VALET_CONFIG_LOG_PATTERN}: The pattern used to display a formatted log line.
# - ${VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL}: Contains a bash code executed before the print statement, to further process the variable messageToPrintInLog or define new variables to use in the log pattern.
#   to compute extra variables that can be used in the log pattern.
# - ${VALET_CONFIG_LOG_COLUMNS}: The number of columns to use for the log.
# - ${VALET_CONFIG_LOG_DISABLE_HIGHLIGHT}: true to disable highlight for ⌜⌝.
# - ${VALET_CONFIG_LOG_DISABLE_WRAP}: true if the log should not be wrapped.
# - ${VALET_CONFIG_LOG_FD}: The file descriptor to use for the log.
# - ${VALET_CONFIG_LOG_TO_DIRECTORY}: The directory in which to create an additional log file.
# - ${VALET_CONFIG_LOG_FILENAME_PATTERN}: pattern for the new log file name
# - ${VALET_CONFIG_ENABLE_NERDFONT_ICONS}: To know if we display a nerd icon for the log level.
#
# Returns:
#
# - ${GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG}: The statement to print the formatted log.
# - ${GLOBAL_LOG_PRINT_STATEMENT_STANDARD}: The statement to print the standard log.
# - ${GLOBAL_LOG_WRAP_PADDING}: The string with the number of spaces necessary to align with other log messages.
# - $[GLOBAL_LOG_COLUMNS}: The number of columns to use for the log.
# - $[GLOBAL_LOG_DISABLE_WRAP}: true if the log should not be wrapped.
function log::init() {
    GLOBAL_LOG_COLUMNS="${VALET_CONFIG_LOG_COLUMNS:-${GLOBAL_COLUMNS}}"
    GLOBAL_LOG_DISABLE_WRAP="${VALET_CONFIG_LOG_DISABLE_WRAP:-false}"
    GLOBAL_LOG_PATTERN="${_OPTION_LOG_PATTERN:-${VALET_CONFIG_LOG_PATTERN:-"<colorFaded><time>{(%H:%M:%S)T}<colorDefault> <levelColor><level>  <icon><colorDefault> <message>"}}"

    local logFileDescriptor="${VALET_CONFIG_LOG_FD:-2}"

    # we prepare the variables that will be used to print the formatted logs
    local -n printfFormat=RETURNED_VALUE
    local -n printfArguments=RETURNED_VALUE2
    local -n wrapPaddingLength=RETURNED_VALUE3
    local -n beforePrintStatementCode=RETURNED_VALUE4
    log::parseLogPattern "${GLOBAL_LOG_PATTERN}"

    # string with the number of spaces necessary to align with other log messages
    if (( wrapPaddingLength > 0 )); then
      printf -v GLOBAL_LOG_WRAP_PADDING "%${wrapPaddingLength}s" ""
    else
      GLOBAL_LOG_WRAP_PADDING=""
    fi

    # now we build the two statements that can be evaluated to print the logs
    # in the correct file descriptor or file (and to additional log file if needed)
    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG=""
    GLOBAL_LOG_PRINT_STATEMENT_STANDARD=""

    if (( ${#beforePrintStatementCode} > 0 )); then
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="${beforePrintStatementCode}"$'\n'
    fi
    if [[ ${GLOBAL_LOG_DISABLE_WRAP} != "true" ]]; then
      # define RETURNED_VALUE/RETURNED_VALUE2 as local so we don't impact the parent scope (they are used during parsing)
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="local RETURNED_VALUE RETURNED_VALUE2"$'\n'"local -n messageToPrintInLog=RETURNED_VALUE"$'\n'"string::wrapWords \"\${messageVariableName}\" ${GLOBAL_LOG_COLUMNS} \"${GLOBAL_LOG_WRAP_PADDING}\" $((GLOBAL_LOG_COLUMNS - wrapPaddingLength))"$'\n'
    else
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="local -n messageToPrintInLog=\"\${messageVariableName}\""$'\n'
    fi
    if [[ ${VALET_CONFIG_LOG_DISABLE_HIGHLIGHT:-false} != "true" ]]; then
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="messageToPrintInLog=\"\${messageToPrintInLog//⌜/${STYLE_COLOR_ACCENT}⌜}\""$'\n'"messageToPrintInLog=\"\${messageToPrintInLog//⌝/⌝${STYLE_COLOR_DEFAULT}}\""$'\n'
    fi
    if [[ -v VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL ]]; then
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+=$'\n'"${VALET_CONFIG_LOG_FORMATTED_EXTRA_EVAL}"$'\n'
    fi

    local progressBarCode progressBarCode2 progressBarCode3 outputCode
    if [[ ${logFileDescriptor} =~ ^[0-9]+$ ]]; then
      # it is a numbered file descriptor
      outputCode="1>&${logFileDescriptor}"

      # clear the line before printing if we are display a progress bar/spinner
      if [[ -t ${logFileDescriptor} || ${GLOBAL_TEST_FORCE_FD_OPEN:-} == "true" ]]; then
        progressBarCode="local eraseLine; if [[ -v _PROGRESS_BAR_RUNNING ]]; then eraseLine=$'\e[2K'; fi"$'\n'
        progressBarCode2="\${eraseLine:-}"
        progressBarCode3=$'\n'"if [[ -v _PROGRESS_BAR_RUNNING ]]; then progress:redraw; fi"$'\n'
      fi
    else
      # it is a file
      outputCode="1>>\"${logFileDescriptor}\""
    fi

    # define the formatted log statement
    local formattedLogStatement="printf \"${progressBarCode2:-}${printfFormat}\" ${printfArguments}"
    local standardStatement="printf \"${progressBarCode2:-}%s\" \"\${rawStringToPrintInLog:-}\""

    GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+="${progressBarCode:-}${formattedLogStatement} ${outputCode}${progressBarCode3:-}"
    GLOBAL_LOG_PRINT_STATEMENT_STANDARD+="${progressBarCode:-}${standardStatement} ${outputCode}${progressBarCode3:-}"

    # check if we need to additionally output the logs to a file
    if [[ -n ${VALET_CONFIG_LOG_TO_DIRECTORY:-} ]]; then
      # compute the name of the output file
      local logFile
      if [[ -n ${VALET_CONFIG_LOG_FILENAME_PATTERN:-} ]]; then
        eval "${VALET_CONFIG_LOG_FILENAME_PATTERN}"
        if [[ ! -v logFile ]]; then
          core::fail "The filename pattern for the log files VALET_CONFIG_LOG_FILENAME_PATTERN is not valid (does not create the variable logFile): ⌜${VALET_CONFIG_LOG_FILENAME_PATTERN}⌝."
        fi
      else
        printf -v logFile "%s%(%FT%H-%M-%S%z)T%s" "valet-" "${EPOCHSECONDS}" ".log"
      fi
      if [[ ! -d "${VALET_CONFIG_LOG_TO_DIRECTORY}" ]]; then
        mkdir -p "${VALET_CONFIG_LOG_TO_DIRECTORY}" 1>/dev/null
      fi
      # append the log to the file
      outputCode="1>>\"${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}\""
      GLOBAL_LOG_PRINT_STATEMENT_FORMATTED_LOG+=$'\n'"${formattedLogStatement} ${outputCode}"
      GLOBAL_LOG_PRINT_STATEMENT_STANDARD+=$'\n'"${standardStatement} ${outputCode}"
    fi
}


#===============================================================
# >>> String utilities
#===============================================================

# ## string::wrapWords
#
# Allows to soft wrap the given text at the given width.
# Wrapping is done at word boundaries.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped text
#
# ```bash
# string::wrapWords "This is a long text that should be wrapped at 20 characters." 20 '  ' 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
# > - It considers escape sequence for text formatting and does not count them as visible characters.
function string::wrapWords() {
  local -n textToWrapAtWords="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i width="${2:-${_OPTION_WRAP_WIDTH:-${GLOBAL_COLUMNS}}}"
  local leftPaddingChars="${3:-${_OPTION_PADDING_CHARS:-}}"
  local -i firstLineWidth="${4:-${_OPTION_FIRST_LINE_WIDTH:-${width}}}"

  # short cut in case the text is already shorter than the width
  if [[ ${#textToWrapAtWords} -le ${firstLineWidth} && ${textToWrapAtWords} != *$'\n'* ]]; then
    RETURNED_VALUE="${textToWrapAtWords}"
    return 0
  fi

  local text="${textToWrapAtWords}"
  local IFS=$' \t' output="" line word realWord RETURNED_VALUE2
  local leftPaddingVisibleChars="${leftPaddingChars//$'\e['[0-9][0-9]m/}"
  leftPaddingVisibleChars="${leftPaddingVisibleChars//$'\e['[0-9]m/}"
  local -i sentenceWidth=$((width - ${#leftPaddingVisibleChars})) realWordLength=0 firstWord=1
  local -i lineLength=$((sentenceWidth - firstLineWidth))

  while ((${#text} > 0)); do
    line="${text%%$'\n'*}"
    text="${text:${#line}+1}"

    output+=$'\n'"${leftPaddingChars}"

    # short cut in case the text is already shorter than the width
    if ((lineLength + ${#line} <= sentenceWidth)); then
      output+="${line}"
      continue
    fi

    firstWord=1

    for word in ${line}; do
      if [[ ${word} == *$'\e'* ]]; then
        realWord="${word//$'\e['[0-9][0-9]m/}"
        realWord="${realWord//$'\e['[0-9]m/}"
        realWordLength="${#realWord}"
      else
        realWordLength="${#word}"
      fi

      if ((lineLength < sentenceWidth && firstWord == 0)); then
        output+=" "
        lineLength+=1
      else
        firstWord=0
      fi

      if ((lineLength + realWordLength <= sentenceWidth)); then
        # add the word to the current line
        output+="${word}"
        lineLength+=realWordLength
      else
        # not enough space left, check if the word fits on the next line
        if ((realWordLength <= sentenceWidth)); then
          output+=$'\n'"${leftPaddingChars}${word}"
          lineLength=realWordLength
        else
          # the word is too long to fit on a line, split it in multiple lines
          string::wrapCharacters word "${width}" "${leftPaddingChars}" "$((sentenceWidth - lineLength))"
          output+="${RETURNED_VALUE}"
          lineLength=${RETURNED_VALUE2}
        fi
      fi

    done

    lineLength=0
  done

  RETURNED_VALUE="${output#$'\n'"${leftPaddingChars}"}"
}

# ## string::wrapCharacters
#
# Allows to hard wrap the given string at the given width.
# Wrapping is done at character boundaries, see string::warpText for word wrapping.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to "")
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped string
# - ${RETURNED_VALUE2}: the length taken on the last line
#
# ```bash
# string::wrapCharacters "This is a long text that should be wrapped at 20 characters." 20 --- 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - It considers escape sequence for text formatting and does not count them as visible characters.
# > - Leading spaces after a newly wrapped line are removed.
function string::wrapCharacters() {
  local -n textToWrapAtCharacters="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i width="${2:-${_OPTION_WRAP_WIDTH:-${GLOBAL_COLUMNS}}}"
  local leftPaddingChars="${3:-${_OPTION_PADDING_CHARS:-}}"
  local -i firstLineWidth="${4:-${_OPTION_FIRST_LINE_WIDTH:-${width}}}"

  local itemChunk spaces text="${textToWrapAtCharacters}"
  local leftPaddingVisibleChars="${leftPaddingChars//$'\e['[0-9][0-9]m/}"
  leftPaddingVisibleChars="${leftPaddingVisibleChars//$'\e['[0-9]m/}"
  width=$((width - ${#leftPaddingVisibleChars}))
  local -i lineLength=$((width - firstLineWidth)) isWrapping=0

  if ((width <= 0)); then
    RETURNED_VALUE=""
    RETURNED_VALUE2=0
    return
  fi

  RETURNED_VALUE=""
  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    itemChunk="${itemChunk%%$'\n'*}"

    spaces="${itemChunk%%[^ ]*}"
    if [[ -n ${spaces} && lineLength -eq 0 && isWrapping -eq 1 ]]; then
      # if the chunk contains heading spaces, we can remove them
      itemChunk="${itemChunk:${#spaces}}"
      text="${text:${#spaces}}"
    fi

    if ((lineLength < width)); then
      itemChunk="${itemChunk:0:$((width - lineLength))}"
      text="${text:${#itemChunk}}"
      lineLength+=${#itemChunk}
      RETURNED_VALUE+="${itemChunk}"
      isWrapping=1

      while [[ ${text} == $'\e'* ]]; do
        # case where we have an escape sequence at the beginning of the string
        # we only consider escape sequences for text formatting, they end with 'm'
        itemChunk="${text%%"m"*}m"
        RETURNED_VALUE+="${itemChunk}"
        text="${text:${#itemChunk}}"
      done

      while [[ ${text} == $'\n'* ]]; do
        RETURNED_VALUE+=$'\n'"${leftPaddingChars}"
        text="${text:1}"
        lineLength=0
        isWrapping=0
      done
    fi

    if ((lineLength >= width)); then
      # we reached the desired size
      lineLength=0
      RETURNED_VALUE+=$'\n'"${leftPaddingChars}"
    fi
  done

  RETURNED_VALUE="${RETURNED_VALUE%$'\n'"${leftPaddingChars}"}"
  RETURNED_VALUE2=${lineLength}
}

# ## string::highlight
#
# Highlight characters in a string.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to highlight.
# - $2: **characters variable name** _as string_:
#       The variable name that contains characters to highlight.
# - $3: highlight ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_HIGHLIGHT_ANSI`.
#       The ANSI code to use for highlighting.
#       (defaults to STYLE_COLOR_ACCENT)
# - $4: reset ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_RESET_ANSI`.
#       The ANSI code to use for resetting the highlighting.
#       (defaults to STYLE_COLOR_DEFAULT)
#
# Returns:
#
# - ${RETURNED_VALUE}: the highlighted text
#
# ```bash
# string::highlight "This is a text to highlight." "ttttt"
# echo "${RETURNED_VALUE}"
# ```
#
# > - All characters to highlight must be found in the same order in the matched line.
# > - This functions is case insensitive.
function string::highlight() {
  local -n textToHighlight="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -n charactersToHighlight="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local highlightCode="${3:-${_OPTION_HIGHLIGHT_ANSI:-${STYLE_COLOR_ACCENT:-$'\e'"[95m"}}}"
  local resetCode="${4:-${_OPTION_RESET_ANSI:-${STYLE_COLOR_DEFAULT:-$'\e'"[0m"}}}"

  local itemChunk itemChunkPiece
  local -i searchStringIndex=0
  local searchStringCharacter="${charactersToHighlight:0:1}"
  local searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
  local text="${textToHighlight}"

  RETURNED_VALUE=""

  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    text="${text:${#itemChunk}}"

    if [[ -n ${itemChunk} ]]; then
      # colorize the search string in this chunk
      while [[ -n ${searchStringCharacter} && ${itemChunk} == *["${searchStringCharacters}"]* ]]; do
        itemChunkPiece="${itemChunk%%["${searchStringCharacters}"]*}"
        RETURNED_VALUE+="${itemChunkPiece}${highlightCode}${itemChunk:${#itemChunkPiece}:1}${resetCode}"
        itemChunk="${itemChunk:${#itemChunkPiece}+1}"
        searchStringIndex+=1
        searchStringCharacter="${charactersToHighlight:searchStringIndex:1}"
        searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
      done

      RETURNED_VALUE+="${itemChunk}"
    fi

    while [[ ${text} == $'\e'* ]]; do
      # case where we have an escape sequence at the beginning of the string
      # we only consider escape sequences for text formatting, they end with m
      itemChunk="${text%%"m"*}m"
      RETURNED_VALUE+="${itemChunk}"
      text="${text:${#itemChunk}}"
    done
  done
}

# ## string::getFuzzySearchRegexFromSearchString
#
# Allows to get a regex that can be used to fuzzy search a string.
# the -> '([^t]*)(t[^h]*h[^e]*e)'
#
# - $1: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${_STRING_FUZZY_FILTER_REGEX}: the regex
#
# ```bash
# string::getFuzzySearchRegexFromSearchString SEARCH_STRING
# echo "${_STRING_FUZZY_FILTER_REGEX}"
# ```
function regex::getFuzzySearchRegexFromSearchString() {
  local -n filterSearchString="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # nothing to filter
  if [[ -z ${filterSearchString} ]]; then
    _STRING_FUZZY_FILTER_REGEX=""
    return 0
  fi

  # \^$.|?*+[]{}()
  local escapedCharacter

  # prepare the regex for the searched string
  _STRING_FUZZY_FILTER_REGEX=""
  local -i index
  for ((index = 0; index < ${#filterSearchString}; index++)); do
    escapedCharacter=${filterSearchString:index:1}
    if [[ '\^$.|?*+[]{}()' == *"${escapedCharacter}"* ]]; then
      escapedCharacter="\\"${escapedCharacter}
    fi
    if ((index == 0)); then
      _STRING_FUZZY_FILTER_REGEX+="^([^${filterSearchString:index:1}]"'*'")(${escapedCharacter}"
    else
      _STRING_FUZZY_FILTER_REGEX+="[^${filterSearchString:index:1}]"'*'"${escapedCharacter}"
    fi
  done

  _STRING_FUZZY_FILTER_REGEX+=")(.?)"
}

#===============================================================
# >>> Array utilities
#===============================================================

# ## array::fuzzyFilterSort
#
# Allows to fuzzy sort an array against a given searched string.
# Returns an array containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
# - the original order in the list
#
# Also returns an array containing the indexes of the matched items in the original array.
#
# - $1: **array name** _as string_:
#       The array name to fuzzy filter and sort.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${RETURNED_ARRAY[@]}: An array containing the items sorted and filtered
# - ${RETURNED_ARRAY2[@]}: An array containing the indexes of the matched items in the original array
#
# ```bash
# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING
# echo "${RETURNED_ARRAY[*]}"
# ```
#
# > - All characters in the searched string must be found in the same order in the matched line.
# > - Use `shopt -s nocasematch` to make this function is case insensitive.
# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.
function array::fuzzyFilterSort() {
  local -n arrayToFilter="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -n filterSearchString="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # nothing to filter
  if (( ${#filterSearchString} == 0 || ${#arrayToFilter[@]} == 0 )); then
    RETURNED_ARRAY=("${arrayToFilter[@]}")
    eval "RETURNED_ARRAY2=( {0..$((${#arrayToFilter[@]} - 1))} )"
    return 0
  fi

  regex::getFuzzySearchRegexFromSearchString "${2}"

  local -i patternLength=${#filterSearchString}

  # will contain a key that allows to sort the items, it is a combination of the length before the pattern,
  # the length of the matched pattern and the initial position of the item
  _ARRAY_FUZZY_FILTER_KEYS=()
  # will contain the original indexes corresponding to the sorted array
  RETURNED_ARRAY2=()

  for ((index = 0; index < ${#arrayToFilter[@]}; index++)); do
    if [[ ${arrayToFilter[index]} =~ ${_STRING_FUZZY_FILTER_REGEX} ]]; then
      if ((${#BASH_REMATCH[3]} == 0 && ${#BASH_REMATCH[1]} == 0)); then
        _ARRAY_FUZZY_FILTER_KEYS+=($((index)))
      else
        _ARRAY_FUZZY_FILTER_KEYS+=($((${#BASH_REMATCH[1]} * 10000000 + ${#BASH_REMATCH[2]} * 10000 + index)))
      fi
      RETURNED_ARRAY2+=($((index)))
    fi
  done

  if (( ${#_ARRAY_FUZZY_FILTER_KEYS[@]} > 1 )); then
    array::fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))
  fi

  # will contain the matched lines, sorted
  RETURNED_ARRAY=()
  for ((index = 0; index < ${#RETURNED_ARRAY2[@]}; index++)); do
    RETURNED_ARRAY+=("${arrayToFilter[RETURNED_ARRAY2[index]]}")
  done
  unset -v _ARRAY_FUZZY_FILTER_KEYS
}

# ## array::fuzzyFilterSortQuicksort (private)
#
# A special quicksort implementation dedicated to `array::fuzzyFilterSort`
# that only compare numbers and that uses _ARRAY_FUZZY_FILTER_KEYS as
# a global arrays to go faster. Check `array::quicksort` for an equivalent
# but clearer implementation.
#
# - $1: **low** _as int_:
#       The low index of the _ARRAY_FUZZY_FILTER_KEYS array.
# - $2: **high** _as int_:
#       The high index of the _ARRAY_FUZZY_FILTER_KEYS array.
#
# ```bash

# array::fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))
# ```
function array::fuzzyFilterSortQuicksort() {
  local -i left=${1} right=${2} tempValue pivotValue=${_ARRAY_FUZZY_FILTER_KEYS[${1} + (${2} - ${1}) / 2]}
  while :; do
    while ((_ARRAY_FUZZY_FILTER_KEYS[left] < pivotValue)); do
      left+=1
    done
    while ((pivotValue < _ARRAY_FUZZY_FILTER_KEYS[right])); do
      right=$((right - 1))
    done
    if ((left >= right)); then
      break;
    fi
    tempKey=${_ARRAY_FUZZY_FILTER_KEYS[left]}
    _ARRAY_FUZZY_FILTER_KEYS[left]=${_ARRAY_FUZZY_FILTER_KEYS[right]}
    _ARRAY_FUZZY_FILTER_KEYS[right]=${tempKey}
    tempValue=${RETURNED_ARRAY2[left]}
    RETURNED_ARRAY2[left]=${RETURNED_ARRAY2[right]}
    RETURNED_ARRAY2[right]=${tempValue}
    left+=1
    right=$((right - 1))
  done
  if ((${1} < right)); then
    array::fuzzyFilterSortQuicksort ${1} ${right}
  fi
  if ((right + 1 < ${2})); then
    array::fuzzyFilterSortQuicksort $((right + 1)) ${2}
  fi
}

#===============================================================
# >>> Time utilities
#===============================================================

# ## time::getProgramElapsedMicroseconds
#
# Get the elapsed time in µs since the program started.
#
# Returns:
#
# - ${RETURNED_VALUE}: the elapsed time in µs since the program started.
#
# ```bash
# core::getElapsedProgramTime
# echo "${RETURNED_VALUE}"
# time::convertMicrosecondsToHuman "${RETURNED_VALUE}"
# echo "Human time: ${RETURNED_VALUE}"
# ```
#
# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.
# > The 10# forces the base 10 conversion to avoid issues with leading zeros.
# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.
function time::getProgramElapsedMicroseconds() {
  RETURNED_VALUE=$(((${EPOCHREALTIME%%[.,]*} - GLOBAL_PROGRAM_STARTED_AT_SECOND) * 1000000 + (10#${EPOCHREALTIME##*[.,]} - 10#${GLOBAL_PROGRAM_STARTED_AT_MICROSECOND})))
}

#===============================================================
# >>> Core utilities
#===============================================================

# ## core::fail
#
# Displays an error message and then exit the program with error.
#
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::fail "This is an error message."
# ```
function core::fail() {
  log::print "ERROR" "${STYLE_ICON_ERROR:-}" "FAIL" "$@"
  if log::isDebugEnabled; then
    log::printCallStack 2
  fi
  # shellcheck disable=SC2034
  GLOBAL_EXPECTED_EXIT=1
  exit 1
}

# ## core::failWithCode
#
# Displays an error message and then exit the program with error.
#
# - $1: **exit code** _as int_:
#       the exit code to use, should be between 1 and 255
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::failWithCode 255 "This is an error message."
# ```
function core::failWithCode() {
  local exitCode="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  shift
  log::print "ERROR" "${STYLE_ICON_ERROR:-}" "FAIL" "$@"
  if log::isDebugEnabled; then
    log::printCallStack 2
  fi
  # shellcheck disable=SC2034
  GLOBAL_EXPECTED_EXIT=1
  exit "${exitCode}"
}

# ## source
#
# Allows to source/include a library file or sources a file.
#
# It replaces the builtin source command to make sure that we do not source the same library twice.
# We replace source instead of creating a new function to allow us to
# specify the included file for spellcheck.
#
# - $1: **library name or path** _as string_:
#       the name of the library (array, interactive, string...) or the file path to include.
# - $@: arguments _as any_:
#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).
#
# ```bash
#   source string
#   source ./my/path
# ```
#
# > - The file can be relative to the current script (script that calls this function).
# > - Use `builtin source` if you want to include the file even if it was already included.
function source() {
  local pathOrName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  shift

  # if the name does not start with . or /, we assume it is a library name
  if [[ ${pathOrName:0:1} != [./] ]]; then
    # quick check if it is already included
    if [[ ${_CORE_INCLUDED_LIBRARIES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
      return 0
    fi

    local -i sourcedFiles=0
    # source the lib from the valet core libs
    if [[ -f "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" ]]; then
      builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" "$@"
      sourcedFiles+=1
    fi

    # source the lib from user libs
    if [[ -v CMD_LIBRARY_DIRECTORIES ]]; then
      local libraryDirectory
      for libraryDirectory in "${CMD_LIBRARY_DIRECTORIES[@]}"; do
        if [[ -f "${libraryDirectory}/lib-${pathOrName}" ]]; then
          builtin source "${libraryDirectory}/lib-${pathOrName}" "$@"
          sourcedFiles+=1
        fi
      done
    fi

    # we included at least one file? then we are done
    if ((sourcedFiles > 0)); then
      _CORE_INCLUDED_LIBRARIES="${_CORE_INCLUDED_LIBRARIES:-}"$'\n'"${pathOrName}"$'\n'
      return 0
    fi
  fi

  # quick check if the file is already included
  if [[ ${_CORE_INCLUDED_FILES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
    return 0
  fi

  # source a file next to the file that calls this function
  if [[ -n ${BASH_SOURCE[1]:-} && -f "${BASH_SOURCE[1]%/*}/${pathOrName}" ]]; then
    pathOrName="${BASH_SOURCE[1]%/*}/${pathOrName}"
    builtin source "${pathOrName}" "$@"
    _CORE_INCLUDED_FILES="${_CORE_INCLUDED_FILES:-}"$'\n'"${pathOrName}"$'\n'
    return 0
  fi

  # source a file with an absolute path or in the current directory
  if [[ -f "${pathOrName}" ]]; then
    builtin source "${pathOrName}" "$@"
    _CORE_INCLUDED_FILES="${_CORE_INCLUDED_FILES:-}"$'\n'"${pathOrName}"$'\n'
    return 0
  fi

  local failMessage="Cannot source the file ⌜${pathOrName}⌝ because it does not exist."
  if [[ ${pathOrName} =~ ^(esc-codes|core)$ ]]; then
    failMessage+="The ⌜${pathOrName}⌝ library is included by default in Valet, please remove ⌜source ${pathOrName}⌝."
  elif [[ ${pathOrName} == "lib-"* ]]; then
    failMessage+=$'\n'"If you meant to source a library, make sure it is either in the valet core or user libraries and do not include the ⌜lib-⌝ prefix."
  fi
  core::fail "${failMessage}"
}

# ## include
#
# Allows to include multiple library files.
#
# It calls `source` for each argument.
# Useful if you don't have arguments to pass to the sourced files.
#
# - $@: **libraries** _as string_:
#       The names of the libraries (array, interactive, string...) or the file paths to include.
#
# ```bash
# include string array ./my/path
# ```
function include() {
  local name
  for name in "$@"; do
    # shellcheck disable=SC1090
    source "${name}"
  done
}

# ## core::resetIncludedFiles (private)
#
# Allows to reset the included libraries.
# When calling the source function, it will source all the libraries again.
# This is useful when we want to reload the libraries.
#
# ```bash
# core::resetIncludedFiles
# ```
function core::resetIncludedFiles() {
  _CORE_INCLUDED_LIBRARIES=""
  _CORE_INCLUDED_FILES=""
}

# ## core::resetIncludedFile (private)
#
# Allows to source again a given file at the next source call.
#
# ```bash
# core::resetIncludedFile
# ```
function core::resetIncludedFile() {
  if [[ -v _CORE_INCLUDED_LIBRARIES ]]; then
    _CORE_INCLUDED_LIBRARIES="${_CORE_INCLUDED_LIBRARIES//$'\n'${1}$'\n'/$'\n'}"
  fi
  if [[ -v _CORE_INCLUDED_FILES ]]; then
    _CORE_INCLUDED_FILES="${_CORE_INCLUDED_FILES//$'\n'${1}$'\n'/$'\n'}"
  fi
}

# ## core::sourceUserCommands (private)
#
# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we build it on the fly.
#
# ```bash
# core::sourceUserCommands
# ```
function core::sourceUserCommands() {
  if [[ -n ${GLOBAL_CMD_INCLUDED:-} ]]; then
    return 0
  fi

  # source the user commands
  local stateDirectory
  core::getUserDataDirectory
  stateDirectory="${RETURNED_VALUE}"

  local commandsFile
  commandsFile="${stateDirectory}/commands"

  # if the commands file does not exist, we build it.
  if [[ ! -f "${commandsFile}" ]]; then
    log::info "The commands index does not exist ⌜${stateDirectory}/commands⌝."$'\n'"Now silently building it using ⌜valet self build⌝ command."

    # shellcheck disable=SC1091
    unset GLOBAL_CMD_INCLUDED
    # shellcheck source=/dev/null
    source "${GLOBAL_INSTALLATION_DIRECTORY}/commands.d/self-build.sh"
    selfBuild --silent

    if [[ ! -f "${commandsFile}" ]]; then
      core::fail "Could not build the commands file, please check the error above."
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  GLOBAL_ON_EXIT_MESSAGE="Error sourcing the commands file ⌜${commandsFile}⌝."$'\n'"Please rebuild it using the ⌜valet self build⌝ command."
  builtin source "${commandsFile}"
  unset -v GLOBAL_ON_EXIT_MESSAGE
}

# ## core::reloadUserCommands (private)
#
# Forcibly source again the user 'commands' file from the valet user directory.
#
# ```bash
# core::reloadUserCommands
# ```
function core::reloadUserCommands() {
  # delete previous variables
  # shellcheck disable=SC2086
  unset -v ${!CMD_*} GLOBAL_CMD_INCLUDED
  core::sourceUserCommands
}

# ## core::deleteUserCommands (private)
#
# Delete the user 'commands' file from the valet user directory.
#
# You probably want to reload the user commands afterward using `core::reloadUserCommands`.
#
# ```bash
# core::deleteUserCommands
# ```
function core::deleteUserCommands() {
  core::getUserDataDirectory
  rm -f "${RETURNED_VALUE}/commands" 1>/dev/null || :
}

# ## core::getVersion
#
# Returns the version of Valet.
#
# Returns:
#
# - ${RETURNED_VALUE}: The version of Valet.
#
# ```bash
# core::getVersion
# printf '%s\n' "The version of Valet is ⌜${RETURNED_VALUE}⌝."
# ```
function core::getVersion() {
  # shellcheck source=lib-fs
  source fs
  fs::readFile "${GLOBAL_INSTALLATION_DIRECTORY}/version"
}

# ## core::getConfigurationDirectory
#
# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet configuration directory
#
# ```bash
# core::getConfigurationDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getConfigurationDirectory() {
  local directory
  directory="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getUserDataDirectory
#
# Returns the path to the valet local data directory.
# Where user-specific data files should be written (analogous to /usr/share).
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet local state directory
#
# ```bash
# core::getUserDataDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getUserDataDirectory() {
  local directory
  directory="${VALET_CONFIG_USER_DATA_DIRECTORY:-${XDG_DATA_HOME:-${HOME}/.local/share}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getUserCacheDirectory
#
# Returns the path to the valet local cache directory.
# Where user-specific non-essential (cached) data should be written (analogous to /var/cache).
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet local state directory
#
# ```bash
# core::getUserCacheDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getUserCacheDirectory() {
  local directory
  directory="${VALET_CONFIG_USER_CACHE_DIRECTORY:-${XDG_CACHE_HOME:-${HOME}/.cache}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getUserStateDirectory
#
# Returns the path to the valet local cache directory.
# Where user-specific state files should be written (analogous to /var/lib).
# Ideal location for storing runtime information, logs, etc...
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet local state directory
#
# ```bash
# core::getUserStateDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getUserStateDirectory() {
  local directory
  directory="${VALET_CONFIG_USER_STATE_DIRECTORY:-${XDG_STATE_HOME:-${HOME}/.local/state}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getExtensionsDirectory
#
# Returns the path to the user extensions directory.
# Does not create it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet user directory
#
# ```bash
# core::getExtensionsDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getExtensionsDirectory() {
  RETURNED_VALUE="${VALET_CONFIG_USER_VALET_DIRECTORY:-${HOME}/.valet.d}"
}

# ## core::createNewStateFilePath
#
# Returns the path to a new file stored in the user state directory.
# Can be used to save the state of important temporary files generated during a program
# execution.
#
# - $1: **file suffix** _as string_:
#       The suffix for the file to create.
#
# Returns:
#
# - ${RETURNED_VALUE}: The path to the created file.
#
# ```bash
# core::createNewStateFilePath "my-file"
# printf '%s\n' "The file is ⌜${RETURNED_VALUE}⌝."
# ```
function core::createNewStateFilePath() {
  local filePath
  printf -v filePath "%(%FT%H-%M-%S%z)T--PID_%06d--%s" "${EPOCHSECONDS}" "${BASHPID}" "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  core::getUserStateDirectory
  if [[ ! -d "${RETURNED_VALUE}/saved-files" ]]; then
    mkdir -p "${RETURNED_VALUE}/saved-files"
  fi
  RETURNED_VALUE="${RETURNED_VALUE}/saved-files/${filePath}"
}

# ## core::dump
#
# Dumps information about the current environment into a new state file.
#
# - ${_OPTION_DUMP_SUFFIX} _as string_:
#       (optional) The suffix for the file to create.
#       (defaults to an empty string)
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the created file.
#
# ```bash
# core::dump
# ```
function core::dump() {
  local filePath
  printf -v filePath "%(%FT%H-%M-%S%z)T--PID_%06d" "${EPOCHSECONDS}" "${BASHPID}"
  core::getUserStateDirectory
  if [[ ! -d "${RETURNED_VALUE}/core-dumps" ]]; then
    mkdir -p "${RETURNED_VALUE}/core-dumps"
  fi
  filePath="${RETURNED_VALUE}/core-dumps/${filePath}${_OPTION_DUMP_SUFFIX:-}"

  {
    echo "================="$'\n'"BASHPID: ${BASHPID:-}"
    echo "================="$'\n'"PPID: ${PPID:-}"
    echo "================="$'\n'"Stack:"
    log::getCallStack
    echo "${RETURNED_VALUE}"
    echo "================="$'\n'"Processes:"
    ps -l || :
    echo "================="$'\n'"File descriptors:"
  } >"${filePath}"
    ls -l /proc/"${BASHPID}"/fd >>"${filePath}" || :
  {
    if command -v lsof &>/dev/null; then
      echo "================="$'\n'"Open files:"
      lsof -p "${BASHPID}" || :
    fi
    echo "================="$'\n'"Options:"
    shopt
    shopt -p
    echo "================="$'\n'"Signals:"
    trap -p
    echo "================="$'\n'"Jobs:"
    jobs || :
    echo "================="$'\n'"Variables:"
    declare -p
    echo "================="$'\n'"Functions:"
    declare -f
    echo "================="$'\n'"Aliases:"
    alias
  } >>"${filePath}"

  log::debug "Core dump saved to ⌜${filePath}⌝"
  RETURNED_VALUE="${filePath}"
}

# ## core::setShellOptions (private)
#
# Set the important shell attributes to ensure consistency in execution (-enable, +disable).
#
# ```bash
# core::setShellOptions
# ```
function core::setShellOptions() {
  # -pipefail: the $? of a pipeline is the status of the last command to exit with a non-zero status
  # -braceexpand: {1..3} will be expanded to 1 2 3
  # -errexit: exit immediately if a command exits with a non-zero status
  # -errtrace: ERR trap is inherited in subshell
  # -functrace: DEBUG and RETURN traps are inherited in subshell
  # -nounset: exit when script tries to use undeclared variables
  # -hashall: enable hashing of all commands (for performance)
  # +histexpand: disable history expansion
  # +monitor: disable job control monitor (will not report status of background jobs)
  # +noclobber: enable overwriting files during redirection
  # +noglob: enable filename expansion (globbing)
  # +notify: disable immediate report status of background jobs
  set -o pipefail -o braceexpand -o errexit -o errtrace -o functrace -o nounset -o hashall +o histexpand +o monitor +o noclobber +o noglob +o notify
  # -globasciiranges: use C locale for [] character ranges in match patterns
  # +checkwinsize: do not check the window size after each external command
  # +dotglob: disable inclusion of hidden files in filename expansion
  # +expand_aliases: disable alias expansion
  # +nocasematch: disable case-insensitive matching
  shopt -s extquote globasciiranges huponexit interactive_comments progcomp
  shopt -u assoc_expand_once cdable_vars checkhash checkjobs checkwinsize compat31 compat32 compat40 compat41 compat42 compat43 compat44 globstar localvar_inherit localvar_unset nocaseglob nocasematch progcomp_alias shift_verbose xpg_echo nullglob direxpand dirspell dotglob extglob failglob execfail expand_aliases inherit_errexit
  if (( BASH_VERSINFO[1] >= 2)); then
    shopt -s globskipdots
    # we disable newer options for compatibility with older versions
    shopt -u varredir_close patsub_replacement
  fi

  # remove all aliases
  # unalias -a

  # unset important variables
  unset -v CDPATH TMOUT

  # default IFS
  IFS=' '$'\t'$'\n'

  # Set a locale otherwise we will face inconsistencies in the output of commands:
  # - file listing will not sort the same way
  # - string comparison < and > will not have the same behavior
  # - `EPOCHREALTIME` can output with a comma as decimal separator instead of a dot
  # - ...
  # If the user does not have the locale, they will get a warning here.
  # In which case they must either generate the locale C.utf8 or set an existing locale
  # listed in `locale -a` via the VALET_CONFIG_LOCALE environment variable.
  LC_ALL="${VALET_CONFIG_LOCALE:-C.UTF-8}"
  LANG="${LC_ALL}"
}

# ## styles::init (private)
#
# Initialize the valet styles variables.
# Also includes the esc-codes library (required for styles).
function styles::init() {
  builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/esc-codes"
  builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/styles"
}


#===============================================================
# >>> Command functions
#===============================================================

# ## command::sourceFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# command::sourceFunction "functionName"
# ```
function command::sourceFunction() {
  local functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  local fileToSource
  if ! declare -F "${functionName}" &>/dev/null; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -z "${fileToSource:-}" ]]; then
      core::fail "Could not find a command function named ⌜${functionName}⌝."
    elif [[ -f "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -f "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}"
      log::debug "Loaded file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝."
    else
      core::fail "The source file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# ## command::showHelp
#
# Show the help for the current function.
# This should be called directly from a command function for which you want to display the help text.
#
# ```bash
# command::showHelp
# ```
function command::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  main::printHelp function "${functionName}"
}

# ## command::parseArguments
#
# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.
#
#
# - $@: **arguments** _as any_:
#       the arguments to parse
#
# Returns:
#
# - ${RETURNED_VALUE}: a string that can be evaluated to set the parsed variables
#
# Output example:
#
# ```
# local arg1 option1
# arg1="xxx"
# option1="xxx"
# ```
#
# ```bash
# command::parseArguments "$@" && eval "${RETURNED_VALUE}"
# ```
function command::parseArguments() {
  # get the function name of the calling function
  local functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  main::parseCmdFunctionArgumentsOrGoInteractive "${functionName}" "$@"
}

# ## command::checkParsedResults
#
# A convenience function to check the parsing results and fails with an error message if there are
# parsing errors.
# Will also display the help if the help option is true.
#
# This should be called from a command function for which you want to check the parsing results.
#
# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed
# and if there are parsing errors.
#
# ```bash
# command::checkParsedResults
# ```
function command::checkParsedResults() {
  if [[ ${help:-false} == "true" ]]; then
    main::printHelp function "${FUNCNAME[1]?"This function must be called from a command function."}"
    exit 0
  fi
  if [[ -n ${commandArgumentsErrors:-} ]]; then
    core::fail "${commandArgumentsErrors}"
  fi
}

#===============================================================
# >>> Main
#===============================================================

# Set GLOBAL_INSTALLATION_DIRECTORY if not already set (case where core was included outside valet)
if [[ ! -v GLOBAL_INSTALLATION_DIRECTORY ]]; then
  GLOBAL_INSTALLATION_DIRECTORY="${BASH_SOURCE[0]}"
  if [[ "${GLOBAL_INSTALLATION_DIRECTORY}" != /* ]]; then
    # resolve relative path
    if pushd "${GLOBAL_INSTALLATION_DIRECTORY%/*}" &>/dev/null; then
      GLOBAL_INSTALLATION_DIRECTORY="${PWD}"
      popd 1>/dev/null
    else GLOBAL_INSTALLATION_DIRECTORY="${PWD}"; fi
  else
    GLOBAL_INSTALLATION_DIRECTORY="${GLOBAL_INSTALLATION_DIRECTORY%/*}" # strip filename
  fi
  GLOBAL_INSTALLATION_DIRECTORY="${GLOBAL_INSTALLATION_DIRECTORY%/*}" # strip libraries.d directory
fi

# Include main if not already included
if [[ ! -v GLOBAL_MAIN_INCLUDED ]]; then
  # do not specify shellcheck source to avoid circular dependency!
  # shellcheck source=/dev/null
  source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/main"
fi

