#!/usr/bin/env bash
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

# check the bash version (and that we are running in bash), make it POSIX compliant
# shellcheck disable=SC2292
# shellcheck disable=SC2086
# shellcheck disable=SC2128
if [ ${BASH_VERSINFO:-0} -lt 5 ]; then
  printf '%s\n' "❌ Bash 5 or higher is required to run valet."
  exit 1
fi

# ## core::setShellOptions (private)
#
# Set the important shell attributes to ensure consistency in execution (-enable, +disable).
#
# ```bash
# core::setShellOptions
# ```
function core::setShellOptions() {
  # -pipefail: the $? of a pipeline is the status of the last command to exit with a non-zero status
  # -braceexpand: {1..3} will be expanded to 1 2 3
  # -errexit: exit immediately if a command exits with a non-zero status
  # -errtrace: ERR trap is inherited in subshell
  # -functrace: DEBUG and RETURN traps are inherited in subshell
  # -nounset: exit when script tries to use undeclared variables
  # -hashall: enable hashing of all commands (for performance)
  # +histexpand: disable history expansion
  # +monitor: disable job control monitor (will not report status of background jobs)
  # +noclobber: enable overwriting files during redirection
  # +noglob: enable filename expansion (globbing)
  # +notify: disable immediate report status of background jobs
  set -o pipefail -o braceexpand -o errexit -o errtrace -o functrace -o nounset -o hashall +o histexpand +o monitor +o noclobber +o noglob +o notify
  # -globasciiranges: use C locale for [] character ranges in match patterns
  # +checkwinsize: do not check the window size after each external command
  # +dotglob: disable inclusion of hidden files in filename expansion
  # +expand_aliases: disable alias expansion
  # +nocasematch: disable case-insensitive matching
  shopt -s extquote globasciiranges huponexit interactive_comments progcomp
  shopt -u assoc_expand_once cdable_vars checkhash checkjobs checkwinsize compat31 compat32 compat40 compat41 compat42 compat43 compat44 globstar localvar_inherit localvar_unset nocaseglob nocasematch progcomp_alias shift_verbose xpg_echo nullglob direxpand dirspell dotglob extglob failglob execfail expand_aliases inherit_errexit
  if (( BASH_VERSINFO[1] >= 2)); then
    shopt -s globskipdots
    # we disable newer options for compatibility with older versions
    shopt -u varredir_close patsub_replacement
  fi

  # remove all aliases
  # unalias -a

  # default IFS
  IFS=' '$'\t'$'\n'

  # Set a locale otherwise we will face inconsistencies in the output of commands:
  # - file listing will not sort the same way
  # - string comparison < and > will not have the same behavior
  # - `EPOCHREALTIME` can output with a comma as decimal separator instead of a dot
  # - ...
  # If the user does not have the locale, they will get a warning here.
  # In which case they must either generate the locale C.utf8 or set an existing locale
  # listed in `locale -a` via the VALET_CONFIG_LOCALE environment variable.
  LC_ALL=C.UTF-8
  LANG=C.UTF-8
}

# set different options for the shell, to have consistent behavior on all machines
core::setShellOptions

if [[ -n ${GLOBAL_CORE_INCLUDED:-} ]] && command -v log::warning &>/dev/null; then
  log::warning "The core library has already been included but was called again, remove the unnecessary call."
  log::printCallStack
  return 0
fi

# we check for this variable to know if this script has already been included
GLOBAL_CORE_INCLUDED=1
# Remember the time the program started (nb of seconds since epoch)
GLOBAL_PROGRAM_STARTED_AT_SECOND="${EPOCHREALTIME%%\.*}"
GLOBAL_PROGRAM_STARTED_AT_MICROSECOND="${EPOCHREALTIME##*\.}"

# Remember the original working directory
GLOBAL_PROGRAM_STARTED_AT_DIRECTORY="${PWD}"

# Handle the case where this script was exe::invoked outside of valet
if [[ -z "${GLOBAL_INSTALLATION_DIRECTORY:-}" ]]; then
  GLOBAL_INSTALLATION_DIRECTORY="${BASH_SOURCE[0]}"
  if [[ "${GLOBAL_INSTALLATION_DIRECTORY}" != /* ]]; then
    # resolve relative path
    if pushd "${GLOBAL_INSTALLATION_DIRECTORY%/*}" &>/dev/null; then
      GLOBAL_INSTALLATION_DIRECTORY="${PWD}"
      popd 1>/dev/null
    else GLOBAL_INSTALLATION_DIRECTORY="${PWD}"; fi
  else
    GLOBAL_INSTALLATION_DIRECTORY="${GLOBAL_INSTALLATION_DIRECTORY%/*}" # strip filename
  fi
  GLOBAL_INSTALLATION_DIRECTORY="${GLOBAL_INSTALLATION_DIRECTORY%/*}" # strip libraries.d directory
fi

# First thing we do is to source the valet configuration from the user config dir
# This file can be used to override the default configuration by setting VALET_* env variables.
VALET_CONFIG_FILE="${VALET_CONFIG_FILE:-"${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}/config"}"
if [[ -f ${VALET_CONFIG_FILE} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_FILE}"
fi
# Same with the env script
if [[ ${VALET_CONFIG_DOT_ENV_SCRIPT:-} != "false" && -f ${VALET_CONFIG_DOT_ENV_SCRIPT:-.env} ]]; then
  # shellcheck source=/dev/null
  source "${VALET_CONFIG_DOT_ENV_SCRIPT:-.env}"
fi

#===============================================================
# >>> Temporary files and folders
#===============================================================

# Setup global variables that will be used for temporary files and folders.
function fs::setupTempFileGlobalVariable() {
  # get unique file names for the stdout, stderr and temporary directory
  # to be fast, we do not create anything until we really need it
  # this could lead to issues, although it is very unlikely
  GLOBAL_TEMPORARY_DIRECTORY_PREFIX="${TMPDIR:-/tmp}/vt-${BASHPID}"
  GLOBAL_TEMPORARY_FILE_PREFIX="${VALET_CONFIG_WORK_FILES_DIRECTORY:-${TMPDIR:-/tmp}}/vt-${BASHPID}"

  while [[ -e "${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d" ]]; do
    # just in case we have a collision
    GLOBAL_TEMPORARY_DIRECTORY_PREFIX+="x"
    GLOBAL_TEMPORARY_FILE_PREFIX+="x"
  done

  GLOBAL_TEMPORARY_DIRECTORY="${GLOBAL_TEMPORARY_DIRECTORY_PREFIX}.d"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_WORK_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-work.f"
  GLOBAL_TEMPORARY_STDOUT_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stdout.f"
  # shellcheck disable=SC2034
  GLOBAL_TEMPORARY_STDERR_FILE="${GLOBAL_TEMPORARY_FILE_PREFIX}-stderr.f"
}

# ## fs::createTempFile
#
# Creates a temporary file and return its path.
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempFile
# local file="${RETURNED_VALUE}"
# ```
#
# > Files created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
#
# TODO: add an _OPTION to not create the file immediately
function fs::createTempFile() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
  fi
  TEMPORARY_FILE_NUMBER=${TEMPORARY_FILE_NUMBER:-0}
  while true; do
    TEMPORARY_FILE_NUMBER=$((TEMPORARY_FILE_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/f${TEMPORARY_FILE_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -f "${RETURNED_VALUE}" ]]; then
      : >"${RETURNED_VALUE}"
      return 0
    fi
  done
}

# ## fs::createTempDirectory
#
# Creates a temporary directory.
#
# Returns:
#
# - ${RETURNED_VALUE}: The created path.
#
# ```bash
# fs::createTempDirectory
# local directory="${RETURNED_VALUE}"
# ```
#
# > Directories created this way are automatically cleaned up by the fs::cleanTempFiles
# > function when valet ends.
function fs::createTempDirectory() {
  if [[ ! -d "${GLOBAL_TEMPORARY_DIRECTORY}" ]]; then
    mkdir -p "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null
  fi
  TEMPORARY_DIRECTORY_NUMBER=${TEMPORARY_DIRECTORY_NUMBER:-0}
  while true; do
    TEMPORARY_DIRECTORY_NUMBER=$((TEMPORARY_DIRECTORY_NUMBER + 1))
    RETURNED_VALUE="${GLOBAL_TEMPORARY_DIRECTORY}/d${TEMPORARY_DIRECTORY_NUMBER}-${BASH_SUBSHELL}"
    if [[ ! -d "${RETURNED_VALUE}" ]]; then
      mkdir -p "${RETURNED_VALUE}" 1>/dev/null
      return 0
    fi
  done
}

# ## fs::cleanTempFiles
#
# Removes all the temporary files and directories that were created by the
# fs::createTempFile and fs::createTempDirectory functions.
#
# ```bash
# fs::cleanTempFiles
# ```
# shellcheck disable=SC2016
function fs::cleanTempFiles() {
  if [[ -d ${GLOBAL_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting temporary directory."
    rm -Rf "${GLOBAL_TEMPORARY_DIRECTORY}" 1>/dev/null || :
  fi
  if [[ -n ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY:-} && -d ${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY} ]]; then
    log::debug "Deleting temporary windows directory."
    rm -Rf "${GLOBAL_WINDOWS_TEMPORARY_DIRECTORY}" 1>/dev/null || :
  fi
  rm -f "${GLOBAL_TEMPORARY_FILE_PREFIX}"* &>/dev/null || :
  unset TEMPORARY_FILE_NUMBER TEMPORARY_DIRECTORY_NUMBER
}

#===============================================================
# >>> Terminal UI
#===============================================================

# ## tui::getTerminalSize
#
# This function exports the terminal size.
#
# Returns:
#
# - `GLOBAL_COLUMNS`: The number of columns in the terminal.
# - `GLOBAL_LINES`: The number of lines in the terminal.
#
# ```bash
# tui::getTerminalSize
# printf '%s\n' "The terminal has ⌜${GLOBAL_COLUMNS}⌝ columns and ⌜${GLOBAL_LINES}⌝ lines."
# ```
function tui::getTerminalSize() {
  shopt -s checkwinsize
  # the following subshell is required to correctly compute the columns and lines
  # the bash manual says these are computed after the execution of an external command
  # but it works with a subshell
  (
    :
    :
  )
  GLOBAL_COLUMNS="${COLUMNS:-120}"
  GLOBAL_LINES="${LINES:-30}"
  shopt -u checkwinsize
}

#===============================================================
# >>> Logging
#===============================================================


# ## log::setLevel
#
# Set the log level.
#
# - $1: **log level** _as string_:
#       The log level to set (or defaults to info), acceptable values are:
#   - trace
#   - debug
#   - info
#   - success
#   - warning
#   - error
# - $2: silent _as bool_:
#       (optional) true to silently switch log level, i.e. does not print a message
#       (defaults to false)
#
# ```bash
# log::setLevel debug
# log::setLevel debug true
# ```
function log::setLevel() {
  # log level, defaults to info
  GLOBAL_LOG_LEVEL="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  case "${GLOBAL_LOG_LEVEL}" in
  error) GLOBAL_LOG_LEVEL_INT=4 ;;
  warning) GLOBAL_LOG_LEVEL_INT=3 ;;
  success) GLOBAL_LOG_LEVEL_INT=2 ;;
  debug) GLOBAL_LOG_LEVEL_INT=0 ;;
  trace) GLOBAL_LOG_LEVEL_INT=-1 ;;
  *) GLOBAL_LOG_LEVEL_INT=1 ;;
  esac

  if [[ ${2:-false} != "true" ]]; then
    if ((GLOBAL_LOG_LEVEL_INT != 1)); then
      log::debug "Log level set to ${GLOBAL_LOG_LEVEL}."
    fi
    if ((GLOBAL_LOG_LEVEL_INT <= 0)); then
      log::warning "Beware that debug log level might lead to secret leak, use it only if necessary."
    fi
  fi
}

# ## log::getLevel
#
# Get the current log level.
#
# Returns:
#
# - ${RETURNED_VALUE}: The current log level.
#
# ```bash
# log::getLevel
# printf '%s\n' "The log level is ⌜${RETURNED_VALUE}⌝."
# ```
function log::getLevel() {
  RETURNED_VALUE="${GLOBAL_LOG_LEVEL:-info}"
}

# ## log::print (private)
#
# Display log messages in the terminal.
#
# - $1: **log level** _as string_:
#       The level of the log message, which gives the color to use (TRACE, DEBUG...).
# - $2: **icon** _as string_:
#       The icon to display in the log message (utf8 character from nerdicons).
# - $3: **severity** _as string_:
#       The severity to display (max 7 chars).
# - $@: **message** _as string_:
#       The content of the log message (each arg will be separated by a new line).
#
# ```bash
# log::print "SUCCESS" $'\uf14a' "OK" "This is a success message."
# ```
# shellcheck disable=SC2317
function log::print() { return 0; }

# ## log::printFile
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **path** _as string_:
#       the file path to display.
# - $2: max lines _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFile "/my/file/path"
# ```
# shellcheck disable=SC2317
function log::printFile() { return 0; }

# ## log::printFileString
#
# Display a file content with line numbers in the logs.
# The file content will be aligned with the current log output and hard wrapped if necessary.
#
# - $1: **content** _as string_:
#       the file content.
# - $2: **max lines** _as int_:
#       (optional) max lines to display (defaults to 0 which prints all lines).
#
# ```bash
# log::printFileString "myfilecontent"
# ```
# shellcheck disable=SC2317
function log::printFileString() { return 0; }

# ## log::printString
#
# Display a string in the log.
# The string will be aligned with the current log output and hard wrapped if necessary.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to log (can contain new lines)
# - $2: new line pad string _as string_:
#       (optional) the string with which to prepend each wrapped line
#       (empty by default)
#
# ```bash
# log::printString "my line"
# ```
# shellcheck disable=SC2317
function log::printString() { return 0; }

# ## log::printRaw
#
# Display something in the log stream.
# Does not check the log level.
#
# - $1: **content** _as string_:
#       the content to print (can contain new lines)
#
# ```bash
# log::printRaw "my line"
# ```
# shellcheck disable=SC2317
function log::printRaw() { return 0; }

# ## log::createPrintFunction (private)
#
# We build the log line function dynamically to adapt to the user options.
# This avoid to have to check the options at each log message.
#
# Returns:
#
# - `GLOBAL_LOG_PRINT_FUNCTION`: Contains the functions definitions to print logs.
# shellcheck disable=SC2016
function log::createPrintFunction() {
  local cDefault=""
  local cTimestamp=""
  local colorStatement
  if [[ "${VALET_CONFIG_ENABLE_COLORS:-}" == "true" ]]; then
    cTimestamp=${VALET_CONFIG_COLOR_TIMESTAMP:-$'\e'"[90m"}       # Bright Black (Gray)
    cDefault=${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}            # Text reset
    local cDebug=${VALET_CONFIG_COLOR_DEBUG:-$'\e'"[90m"}         # Bright Black (Gray)
    local cInfo=${VALET_CONFIG_COLOR_INFO:-$'\e'"[36m"}           # Cyan
    local cWarning=${VALET_CONFIG_COLOR_WARNING:-$'\e'"[33m"}     # Yellow
    local cSuccess=${VALET_CONFIG_COLOR_SUCCESS:-$'\e'"[32m"}     # Green
    local cError=${VALET_CONFIG_COLOR_ERROR:-$'\e'"[31m"}         # Red
    local cHighlight=${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"} # Bright Magenta (Pink)

    colorStatement="
    local color
    case \"\${colorCode}\" in
    DEBUG) color=${cDebug@Q} ;;
    TRACE) color=${cDebug@Q} ;;
    INFO) color=${cInfo@Q} ;;
    WARNING) color=${cWarning@Q} ;;
    SUCCESS) color=${cSuccess@Q} ;;
    ERROR) color=${cError@Q} ;;
    *) color=${cDefault@Q} ;;
    esac"
    # shellcheck disable=SC2016
    colorStatement+='
    RETURNED_VALUE="${RETURNED_VALUE//⌜/'"${cHighlight@Q}"'⌜}"
    RETURNED_VALUE="${RETURNED_VALUE//⌝/⌝'"${cDefault@Q}"'}"'
  else
    colorStatement='
    local color=""'
  fi

  local wrapStatement
  local wrapTextColumns="${VALET_CONFIG_LOG_COLUMNS:-${GLOBAL_COLUMNS}}"
  local wrapPaddingCharacters=""
  local wrapPaddingLength=20
  if [[ "${VALET_CONFIG_LOG_DISABLE_WRAP:-}" != "true" ]]; then
    if [[ ${VALET_CONFIG_LOG_DISABLE_TIME:-} == "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 9))
    fi
    if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} != "true" ]]; then
      wrapPaddingLength=$((wrapPaddingLength - 2))
    fi
    # string with the number of spaces necessary to align with other log messages
    for ((i = 0; i < wrapPaddingLength; i++)); do
      wrapPaddingCharacters+=" "
    done

    wrapStatement='
    string::wrapWords RETURNED_VALUE '"${wrapTextColumns}"' '"'${wrapPaddingCharacters}'"' '"$((wrapTextColumns - wrapPaddingLength))"''
  else
    wrapPaddingLength=0
  fi

  local printStatement
  local standardPrintStatement
  local printfFormat
  local printfArguments

  # timestamp
  if [[ ${VALET_CONFIG_LOG_DISABLE_TIME:-} == "true" ]]; then
    printfFormat+=""
  elif [[ ${VALET_CONFIG_LOG_ENABLE_TIMESTAMP:-} == "true" ]]; then
    printfFormat+="%(%F_%H:%M:%S)T "
    printfArguments+='"${EPOCHSECONDS}" '
  else
    printfFormat+="%s%(%H:%M:%S)T "
    printfArguments+="${cTimestamp@Q}"' "${EPOCHSECONDS}" '
  fi

  # severity
  if [[ ${VALET_CONFIG_ENABLE_NERDFONT_ICONS:-} == "true" ]]; then
    printfFormat+="%s%-8s%-4s%s "
    printfArguments+='"${color:-}" "${severity}" "${icon:-}" '"${cDefault@Q}"' '
  else
    printfFormat+="%s%-8s%s "
    printfArguments+='"${color:-}" "${severity}" '"${cDefault@Q}"' '
  fi

  # message
  printfFormat+="%s\n"
  printfArguments+='"${RETURNED_VALUE}"'

  if [[ -z ${VALET_CONFIG_LOG_FD:-} || ${#VALET_CONFIG_LOG_FD} == 1 ]]; then
    # it is a numbered file descriptor

    # clear the line before printing if we are display a progress bar/spinner
    local cleanStatements='
    local eraseLine
    if [[ ${_PROGRESS_BAR_RUNNING:-} == "true" ]]; then
      eraseLine=$'"'"'\e[2K'"'"'
    fi
    '
    printStatement="${cleanStatements}"'
    printf "${eraseLine:-}'"${printfFormat}"'" '"${printfArguments}"' 1>&'"${VALET_CONFIG_LOG_FD:-2}"
    standardPrintStatement="${cleanStatements}"'
    printf "${eraseLine:-}%s" "${toPrint:-}" 1>&'"${VALET_CONFIG_LOG_FD:-2}"
  else
    # it is a file
    printStatement='
    printf "'"${printfFormat}"'" '"${printfArguments}"' 1>>'"${VALET_CONFIG_LOG_FD}"
    standardPrintStatement='
    printf "%s" "${toPrint:-}" 1>>'"${VALET_CONFIG_LOG_FD}"
  fi

  # check if we need to additionally output the logs to a file
  if [[ -n ${VALET_CONFIG_LOG_TO_DIRECTORY:-} ]]; then
    # compute the name of the output file
    local logFile
    if [[ -z ${VALET_CONFIG_LOG_FILENAME_PATTERN:-} ]]; then
      printf -v logFile "%s%(%F_%Hh%Mm%Ss)T%s" "valet-" "${EPOCHSECONDS}" ".log"
    else
      eval "${VALET_CONFIG_LOG_FILENAME_PATTERN}"
    fi
    if [[ -n ${logFile:-} ]]; then
      if [[ ! -d "${VALET_CONFIG_LOG_TO_DIRECTORY}" ]]; then
        mkdir -p "${VALET_CONFIG_LOG_TO_DIRECTORY}" 1>/dev/null
      fi
      # append the log to the file
      printStatement+='
      printf "'"${printfFormat}"'" '"${printfArguments}"' 1>>'"${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}"
      standardPrintStatement+='
      printf "%s" "${toPrint:-}" 1>>'"${VALET_CONFIG_LOG_TO_DIRECTORY%/}/${logFile}"
    fi
  fi

  # log::printFile function
  local insideTheLoop='
        string::wrapCharacters line "${wrapTextColumns}" "${wrapPaddingCharacters}     '"${cDebug:-}"'░'"${cDefault:-}"' " "$((wrapTextColumns - 7 - ${#wrapPaddingCharacters}))"
        toPrint+="${wrapPaddingCharacters}${lineNumberPadding}'"${cDebug:-}"'${lineNumber} ░'"${cDefault:-}"' ${RETURNED_VALUE}"'"$'\n'"'
        lineNumber+=1
        if (( ${#lineNumber} > currentLineNumberLength )); then
          lineNumberPadding="${lineNumberPadding%?}"
          currentLineNumberLength+=1
        fi
        if (( maxLines != 0 && lineNumber > maxLines )); then
          toPrint+="${wrapPaddingCharacters}   '"${cDebug:-}"'… ░ (truncated)'"${cDefault:-}"'"'"$'\n'"'
          break;
        fi
  '

  # log::print function
  GLOBAL_LOG_PRINT_FUNCTION='
  function log::print() {
    local colorCode="${1}"
    local icon="${2}"
    local severity="${3}"
    shift 3
    local IFS='"$'\n'"'
    RETURNED_VALUE="$*"
    IFS=" "

    '"${colorStatement}"'

    '"${wrapStatement:-}"'

    '"${printStatement}"'
  }'

  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printFile() {
    local filePath="${1}"
    local maxLines="${2:-0}"
    local wrapTextColumns='"${wrapTextColumns}"'
    local wrapPaddingCharacters="'"${wrapPaddingCharacters}"'"
    local line toPrint
    local lineNumberPadding="   "
    local -i lineNumber=1 currentLineNumberLength=1
    if [[ ! -f "${filePath}" ]]; then
      log::error "Can not print the file ⌜${filePath}⌝ because does not exist."
      return 1
    fi
    local IFS=
    while IFS= read -r line || [[ -n ${line:-} ]]; do
      '"${insideTheLoop}"'
    done <"${filePath}"
    '"${standardPrintStatement}"'
  }'

  # log::printFileString function
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printFileString() {
    local content="${1}"
    local maxLines="${2:-0}"
    local wrapTextColumns='"${wrapTextColumns}"'
    local wrapPaddingCharacters="'"${wrapPaddingCharacters}"'"
    local line toPrint
    local lineNumberPadding="   "
    local -i lineNumber=1 currentLineNumberLength=1
    local IFS=
    while IFS= read -r line; do
      '"${insideTheLoop}"'
    done <<<"${content}"
    '"${standardPrintStatement}"'
  }'

  # log::printString function
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printString() {
    local content="${1}"
    local wrappedLineLeftPaddingString="${2:-}"
    local wrapTextColumns='"${wrapTextColumns}"'
    local wrapPaddingCharacters="'"${wrapPaddingCharacters}"'"
    local line toPrint
    local IFS=
    while IFS= read -r line; do
        string::wrapCharacters line "${wrapTextColumns}" "${wrapPaddingCharacters}${wrappedLineLeftPaddingString}" "$((wrapTextColumns - ${#wrapPaddingCharacters}))"
        toPrint+="${wrapPaddingCharacters}${RETURNED_VALUE}"'"$'\n'"'
    done <<<"${content}"
    '"${standardPrintStatement}"'
  }'

  # log::printRaw function
  # shellcheck disable=SC2089
  GLOBAL_LOG_PRINT_FUNCTION+='
  function log::printRaw() {
    local toPrint="${1}"
    '"${standardPrintStatement}"'
  }'

}

# ## log::error
#
# Displays an error message.
#
# - $@: **message** _as string_:
#       the error messages to display
#
# ```bash
# log::error "This is an error message."
# ```
#
# > You probably want to exit immediately after an error and should consider using core::fail function instead.
function log::error() {
  log::print "ERROR" "${VALET_CONFIG_ICON_ERROR:-$'\uf2d3'}" "ERROR" "$@"
  if log::isDebugEnabled; then
    log::printCallStack 2
  fi
}

# ## log::warning
#
# Displays a warning.
#
# - $@: **message** _as string_:
#       the warning messages to display
#
# ```bash
# log::warning "This is a warning message."
# ```
function log::warning() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 3)); then
    return 0
  fi
  log::print "WARNING" "${VALET_CONFIG_ICON_WARNING:-$'\uf071'}" "WARNING" "$@"
  return 0
}

# ## log::success
#
# Displays a success message.
#
# - $@: **message** _as string_:
#       the success messages to display
#
# ```bash
# log::success "This is a success message."
# ```
function log::success() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 2)); then
    return 0
  fi
  log::print "SUCCESS" "${VALET_CONFIG_ICON_SUCCESS:-$'\uf14a'}" "SUCCESS" "$@"
  return 0
}

# ## log::info
#
# Displays an info message.
#
# - $@: **message** _as string_:
#       the info messages to display
#
# ```bash
# log::info "This is an info message."
# ```
function log::info() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 1)); then
    return 0
  fi
  log::print "INFO" "${VALET_CONFIG_ICON_INFO:-$'\uf05a'}" "INFO" "$@"
  return 0
}

# ## log::debug
#
# Displays a debug message.
#
# - $@: **message** _as string_:
#       the debug messages to display
#
# ```bash
# log::debug "This is a debug message."
# ```
function log::debug() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > 0)); then
    return 0
  fi
  log::print "DEBUG" "${VALET_CONFIG_ICON_DEBUG:-$'\uf188'}" "DEBUG" "$@"
  return 0
}

# ## log::trace
#
# Displays a trace message.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::trace "This is a trace message."
# ```
function log::trace() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} > -1)); then
    return 0
  fi
  log::print "TRACE" "${VALET_CONFIG_ICON_TRACE:-$'\ue241'}" "TRACE" "$@"
  return 0
}

# ## log::errorTrace
#
# Displays an error trace message.
# This is a trace message that is always displayed, independently of the log level.
# It can be used before a fatal error to display useful information.
#
# - $@: **message** _as string_:
#       the trace messages to display
#
# ```bash
# log::errorTrace "This is a debug message."
# ```
function log::errorTrace() {
  log::print "TRACE" "${VALET_CONFIG_ICON_ERROR_TRACE:-$'\uf06e'}" "TRACE" "$@"
  return 0
}

# ## log::isDebugEnabled
#
# Check if the debug mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if debug mode is enabled (log level is debug)
#   - 1 if disabled
#
# ```bash
# if log::isDebugEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isDebugEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= 0)); then
    return 0
  fi
  return 1
}

# ## log::isTraceEnabled
#
# Check if the trace mode is enabled.
#
# Returns:
#
# - $?:
#   - 0 if trace mode is enabled (log level is trace)
#   - 1 if disabled
#
# ```bash
# if log::isTraceEnabled; then printf '%s\n' "Debug mode is active."; fi
# ```
function log::isTraceEnabled() {
  if ((${GLOBAL_LOG_LEVEL_INT:-1} <= -1)); then
    return 0
  fi
  return 1
}

# ## log::printCallStack
#
# This function prints the current function stack in the logs.
#
# - $1: Stack to skip _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP`.
#       The number of stack to skip.
#       (defaults to 2 which skips this function and the first calling function
#       which is usually the onError function)
# - $2: Stack to skip at end _as int_:
#       (optional) Can be set using the variable `_OPTION_STACK_TO_SKIP_AT_END`.
#       The number of stack to skip at the end.
#       (defaults to 0)
#
# ```bash
# log::printCallStack
# log::printCallStack 0
# ```
#
# > For test purposes, you can set the `GLOBAL_STACK_FUNCTION_NAMES`, `GLOBAL_STACK_SOURCE_FILES` and `GLOBAL_STACK_LINE_NUMBERS`
# > variables to simulate a call stack.
function log::printCallStack() {
  local -i levelToSkip="${1:-${_OPTION_STACK_TO_SKIP:-2}}"
  local -i levelToSkipAtEnd="${2:-${_OPTION_STACK_TO_SKIP_AT_END:-0}}"
  local -i idx stackSize

  local -a stackFunctionNames stackSourceFiles stackLineNumbers
  if [[ -n ${GLOBAL_STACK_FUNCTION_NAMES:-} ]]; then
    stackFunctionNames=("${GLOBAL_STACK_FUNCTION_NAMES[@]}")
    stackSourceFiles=("${GLOBAL_STACK_SOURCE_FILES[@]}")
    stackLineNumbers=("${GLOBAL_STACK_LINE_NUMBERS[@]}")
  else
    stackFunctionNames=("${FUNCNAME[@]}")
    stackSourceFiles=("${BASH_SOURCE[@]}")
    stackLineNumbers=("${BASH_LINENO[@]}")
  fi

  stackSize=$((${#stackFunctionNames[@]} - levelToSkipAtEnd))
  local functionName lineNumber="${LINENO}" sourceFile
  local treeString="├─" treePadding="│  "
  for ((idx = levelToSkip; idx < stackSize; idx++)); do
    functionName="${stackFunctionNames[${idx}]}"
    if [[ -z ${functionName} ]]; then
      functionName=ROOT
    else
      functionName="${functionName}()"
    fi
    if ((idx > 0)); then
      lineNumber="${stackLineNumbers[$((idx - 1))]}"
    fi
    sourceFile="${stackSourceFiles[${idx}]}"
    if [[ -z "${sourceFile}" ]]; then
      sourceFile=non_file_source
    fi
    sourceFile="${sourceFile#"./"}"
    sourceFile="${sourceFile#"${GLOBAL_PROGRAM_STARTED_AT_DIRECTORY}/"}"
    if ((idx == stackSize - 1)); then
      treeString="└─"
      treePadding="   "
    fi
    log::printString "${treeString} in ${functionName} at ${sourceFile}:${lineNumber}" "${treePadding}"
  done
}

#===============================================================
# >>> String utilities
#===============================================================

# ## string::wrapWords
#
# Allows to soft wrap the given text at the given width.
# Wrapping is done at word boundaries.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped text
#
# ```bash
# string::wrapWords "This is a long text that should be wrapped at 20 characters." 20 '  ' 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - This function effectively trims all the extra spaces in the text (leading, trailing but also in the middle).
# > - It considers escape sequence for text formatting and does not count them as visible characters.
function string::wrapWords() {
  local -n textToWrapAtWords="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i width="${2:-${_OPTION_WRAP_WIDTH:-${GLOBAL_COLUMNS}}}"
  local leftPaddingChars="${3:-${_OPTION_PADDING_CHARS:-}}"
  local -i firstLineWidth="${4:-${_OPTION_FIRST_LINE_WIDTH:-${width}}}"

  # short cut in case the text is already shorter than the width
  if [[ ${#textToWrapAtWords} -le ${firstLineWidth} && ${textToWrapAtWords} != *$'\n'* ]]; then
    RETURNED_VALUE="${textToWrapAtWords}"
    return 0
  fi

  local text="${textToWrapAtWords}"
  local IFS=$' \t' output="" line word realWord RETURNED_VALUE2
  local leftPaddingVisibleChars="${leftPaddingChars//$'\e['[0-9][0-9]m/}"
  leftPaddingVisibleChars="${leftPaddingVisibleChars//$'\e['[0-9]m/}"
  local -i sentenceWidth=$((width - ${#leftPaddingVisibleChars})) realWordLength=0 firstWord=1
  local -i lineLength=$((sentenceWidth - firstLineWidth))

  while ((${#text} > 0)); do
    line="${text%%$'\n'*}"
    text="${text:${#line}+1}"

    output+=$'\n'"${leftPaddingChars}"

    # short cut in case the text is already shorter than the width
    if ((lineLength + ${#line} <= sentenceWidth)); then
      output+="${line}"
      continue
    fi

    firstWord=1

    for word in ${line}; do
      if [[ ${word} == *$'\e'* ]]; then
        realWord="${word//$'\e['[0-9][0-9]m/}"
        realWord="${realWord//$'\e['[0-9]m/}"
        realWordLength="${#realWord}"
      else
        realWordLength="${#word}"
      fi

      if ((lineLength < sentenceWidth && firstWord == 0)); then
        output+=" "
        lineLength+=1
      else
        firstWord=0
      fi

      if ((lineLength + realWordLength <= sentenceWidth)); then
        # add the word to the current line
        output+="${word}"
        lineLength+=realWordLength
      else
        # not enough space left, check if the word fits on the next line
        if ((realWordLength <= sentenceWidth)); then
          output+=$'\n'"${leftPaddingChars}${word}"
          lineLength=realWordLength
        else
          # the word is too long to fit on a line, split it in multiple lines
          string::wrapCharacters word "${width}" "${leftPaddingChars}" "$((sentenceWidth - lineLength))"
          output+="${RETURNED_VALUE}"
          lineLength=${RETURNED_VALUE2}
        fi
      fi

    done

    lineLength=0
  done

  RETURNED_VALUE="${output#$'\n'"${leftPaddingChars}"}"
}

# ## string::wrapCharacters
#
# Allows to hard wrap the given string at the given width.
# Wrapping is done at character boundaries, see string::warpText for word wrapping.
# Optionally appends padding characters on each new line.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to wrap.
# - $2: wrap width _as string_:
#       (optional) Can be set using the variable `_OPTION_WRAP_WIDTH`.
#       The width to wrap the text at.
#       Note that length of the optional padding characters are subtracted from the
#       width to make sure the text fits in the given width.
#       (defaults to GLOBAL_COLUMNS)
# - $3: padding characters _as string_:
#       (optional) Can be set using the variable `_OPTION_PADDING_CHARS`.
#       The characters to apply as padding on the left of each new line.
#       E.g. '  ' will add 2 spaces on the left of each new line.
#       (defaults to 0)
# - $4: first line width _as int_:
#       (optional) Can be set using the variable `_OPTION_FIRST_LINE_WIDTH`.
#       The width to use for the first line.
#       (defaults to the width)
#
# Returns:
#
# - ${RETURNED_VALUE}: the wrapped string
# - ${RETURNED_VALUE2}: the length taken on the last line
#
# ```bash
# string::wrapCharacters "This is a long text that should be wrapped at 20 characters." 20 --- 5
# echo "${RETURNED_VALUE}"
# ```
#
# > - This function is written in pure bash and is faster than calling the fold command.
# > - It considers escape sequence for text formatting and does not count them as visible characters.
# > - Leading spaces after a newly wrapped line are removed.
function string::wrapCharacters() {
  local -n textToWrapAtCharacters="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -i width="${2:-${_OPTION_WRAP_WIDTH:-${GLOBAL_COLUMNS}}}"
  local leftPaddingChars="${3:-${_OPTION_PADDING_CHARS:-}}"
  local -i firstLineWidth="${4:-${_OPTION_FIRST_LINE_WIDTH:-${width}}}"

  local itemChunk spaces text="${textToWrapAtCharacters}"
  local leftPaddingVisibleChars="${leftPaddingChars//$'\e['[0-9][0-9]m/}"
  leftPaddingVisibleChars="${leftPaddingVisibleChars//$'\e['[0-9]m/}"
  width=$((width - ${#leftPaddingVisibleChars}))
  local -i lineLength=$((width - firstLineWidth)) isWrapping=0

  if ((width <= 0)); then
    RETURNED_VALUE=""
    RETURNED_VALUE2=0
    return
  fi

  RETURNED_VALUE=""
  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    itemChunk="${itemChunk%%$'\n'*}"

    spaces="${itemChunk%%[^ ]*}"
    if [[ -n ${spaces} && lineLength -eq 0 && isWrapping -eq 1 ]]; then
      # if the chunk contains heading spaces, we can remove them
      itemChunk="${itemChunk:${#spaces}}"
      text="${text:${#spaces}}"
    fi

    if ((lineLength < width)); then
      itemChunk="${itemChunk:0:$((width - lineLength))}"
      text="${text:${#itemChunk}}"
      lineLength+=${#itemChunk}
      RETURNED_VALUE+="${itemChunk}"
      isWrapping=1

      while [[ ${text} == $'\e'* ]]; do
        # case where we have an escape sequence at the beginning of the string
        # we only consider escape sequences for text formatting, they end with 'm'
        itemChunk="${text%%"m"*}m"
        RETURNED_VALUE+="${itemChunk}"
        text="${text:${#itemChunk}}"
      done

      while [[ ${text} == $'\n'* ]]; do
        RETURNED_VALUE+=$'\n'"${leftPaddingChars}"
        text="${text:1}"
        lineLength=0
        isWrapping=0
      done
    fi

    if ((lineLength >= width)); then
      # we reached the desired size
      lineLength=0
      RETURNED_VALUE+=$'\n'"${leftPaddingChars}"
    fi
  done

  RETURNED_VALUE="${RETURNED_VALUE%$'\n'"${leftPaddingChars}"}"
  RETURNED_VALUE2=${lineLength}
}

# ## string::highlight
#
# Highlight characters in a string.
#
# - $1: **text variable name** _as string_:
#       The variable name that contains the text to highlight.
# - $2: **characters variable name** _as string_:
#       The variable name that contains characters to highlight.
# - $3: highlight ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_HIGHLIGHT_ANSI`.
#       The ANSI code to use for highlighting.
#       (defaults to VALET_CONFIG_COLOR_HIGHLIGHT)
# - $4: reset ansi code _as string_:
#       (optional) Can be set using the variable `_OPTION_RESET_ANSI`.
#       The ANSI code to use for resetting the highlighting.
#       (defaults to VALET_CONFIG_COLOR_DEFAULT)
#
# Returns:
#
# - ${RETURNED_VALUE}: the highlighted text
#
# ```bash
# string::highlight "This is a text to highlight." "ttttt"
# echo "${RETURNED_VALUE}"
# ```
#
# > - All characters to highlight must be found in the same order in the matched line.
# > - This functions is case insensitive.
function string::highlight() {
  local -n textToHighlight="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -n charactersToHighlight="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local highlightCode="${3:-${_OPTION_HIGHLIGHT_ANSI:-${VALET_CONFIG_COLOR_HIGHLIGHT:-$'\e'"[95m"}}}"
  local resetCode="${4:-${_OPTION_RESET_ANSI:-${VALET_CONFIG_COLOR_DEFAULT:-$'\e'"[0m"}}}"

  local itemChunk itemChunkPiece
  local -i searchStringIndex=0
  local searchStringCharacter="${charactersToHighlight:0:1}"
  local searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
  local text="${textToHighlight}"

  RETURNED_VALUE=""

  while ((${#text} > 0)); do
    # take the first chunk that does not contain an escape character
    itemChunk="${text%%$'\e'*}"
    text="${text:${#itemChunk}}"

    if [[ -n ${itemChunk} ]]; then
      # colorize the search string in this chunk
      while [[ -n ${searchStringCharacter} && ${itemChunk} == *["${searchStringCharacters}"]* ]]; do
        itemChunkPiece="${itemChunk%%["${searchStringCharacters}"]*}"
        RETURNED_VALUE+="${itemChunkPiece}${highlightCode}${itemChunk:${#itemChunkPiece}:1}${resetCode}"
        itemChunk="${itemChunk:${#itemChunkPiece}+1}"
        searchStringIndex+=1
        searchStringCharacter="${charactersToHighlight:searchStringIndex:1}"
        searchStringCharacters="${searchStringCharacter,}${searchStringCharacter^}"
      done

      RETURNED_VALUE+="${itemChunk}"
    fi

    while [[ ${text} == $'\e'* ]]; do
      # case where we have an escape sequence at the beginning of the string
      # we only consider escape sequences for text formatting, they end with m
      itemChunk="${text%%"m"*}m"
      RETURNED_VALUE+="${itemChunk}"
      text="${text:${#itemChunk}}"
    done
  done
}

#===============================================================
# >>> Array utilities
#===============================================================

# ## array::fuzzyFilterSort
#
# Allows to fuzzy sort an array against a given searched string.
# Returns an array containing only the lines matching the searched string.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
# - the original order in the list
#
# Also returns an array containing the indexes of the matched items in the original array.
#
# - $1: **array name** _as string_:
#       The array name to fuzzy filter and sort.
# - $2: **search string** _as string_:
#       The variable name containing the search string to match.
#
# Returns:
#
# - ${RETURNED_ARRAY}: An array containing the items sorted and filtered
# - ${RETURNED_ARRAY2}: An array containing the indexes of the matched items in the original array
#
# ```bash
# array::fuzzyFilterSort MY_ARRAY SEARCH_STRING
# echo "${RETURNED_ARRAY[*]}"
# ```
#
# > - All characters in the searched string must be found in the same order in the matched line.
# > - Use `shopt -s nocasematch` to make this function is case insensitive.
# > - This function is not appropriate for large arrays (>10k elements), see `array::fuzzyFilterSortFileWithGrepAndGawk` for large arrays.
function array::fuzzyFilterSort() {
  local -n arrayToFilter="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  local -n filterSearchString="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  # nothing to filter
  if [[ -z ${filterSearchString} || ${#arrayToFilter[@]} -eq 0 ]]; then
    RETURNED_ARRAY=("${arrayToFilter[@]}")
    eval "RETURNED_ARRAY2=( {0..$((${#arrayToFilter[@]} - 1))} )"
    return 0
  fi

  # prepare the regex for the searched string
  # the -> '([^t]*)(t[^h]*h[^e]*e)'
  local patternRegex="^([^${filterSearchString:0:1}]*)(${filterSearchString:0:1}"
  local -i index
  for ((index = 1; index < ${#filterSearchString}; index++)); do
    patternRegex+="[^${filterSearchString:index:1}]*${filterSearchString:index:1}"
  done
  patternRegex+=")(.?)"
  local -i patternLength=${#filterSearchString}

  # will contain a key that allows to sort the items, it is a combination of the length before the pattern,
  # the length of the matched pattern and the initial position of the item
  _ARRAY_FUZZY_FILTER_KEYS=()
  # will contain the original indexes corresponding to the sorted array
  RETURNED_ARRAY2=()

  for ((index = 0; index < ${#arrayToFilter[@]}; index++)); do
    if [[ ${arrayToFilter[index]} =~ ${patternRegex} ]]; then
      if ((${#BASH_REMATCH[3]} == 0 && patternLength == ${#BASH_REMATCH[0]})); then
        _ARRAY_FUZZY_FILTER_KEYS+=($((index)))
      else
        _ARRAY_FUZZY_FILTER_KEYS+=($((${#BASH_REMATCH[1]} * 10000000 + ${#BASH_REMATCH[2]} * 10000 + index)))
      fi
      RETURNED_ARRAY2+=($((index)))
    fi
  done

  array::fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))

  # will contain the matched lines, sorted
  RETURNED_ARRAY=()
  for ((index = 0; index < ${#RETURNED_ARRAY2[@]}; index++)); do
    RETURNED_ARRAY+=("${arrayToFilter[RETURNED_ARRAY2[index]]}")
  done
  unset -v _ARRAY_FUZZY_FILTER_KEYS
}

# ## array::fuzzyFilterSortQuicksort (private)
#
# A special quicksort implementation dedicated to `array::fuzzyFilterSort`
# that only compare numbers and that uses _ARRAY_FUZZY_FILTER_KEYS as
# a global arrays to go faster.
#
# - $1: **low** _as int_:
#       The low index of the _ARRAY_FUZZY_FILTER_KEYS array.
# - $2: **high** _as int_:
#       The high index of the _ARRAY_FUZZY_FILTER_KEYS array.
#
# ```bash
# array::fuzzyFilterSortQuicksort 0 $((${#_ARRAY_FUZZY_FILTER_KEYS[@]} - 1))
# ```
function array::fuzzyFilterSortQuicksort() {
  local -i low=${1}
  local -i high=${2}
  if ((low >= high)); then
    return 0
  fi
  local pivot=${_ARRAY_FUZZY_FILTER_KEYS[low]}
  local -i ii=${low}
  local -i jj=${high}
  local tmpKey tempValue
  while ((ii <= jj)); do
    while ((_ARRAY_FUZZY_FILTER_KEYS[ii] < pivot)); do
      ii+=1
    done
    while ((pivot < _ARRAY_FUZZY_FILTER_KEYS[jj])); do
      jj=$((jj - 1))
    done
    if ((ii <= jj)); then
      tmpKey=${_ARRAY_FUZZY_FILTER_KEYS[ii]}
      tempValue=${RETURNED_ARRAY2[ii]}
      _ARRAY_FUZZY_FILTER_KEYS[ii]=${_ARRAY_FUZZY_FILTER_KEYS[jj]}
      RETURNED_ARRAY2[ii]=${RETURNED_ARRAY2[jj]}
      _ARRAY_FUZZY_FILTER_KEYS[jj]=${tmpKey}
      RETURNED_ARRAY2[jj]=${tempValue}
      ii+=1
      jj=$((jj - 1))
    fi
  done
  if ((low < jj)); then
    array::fuzzyFilterSortQuicksort ${low} ${jj}
  fi
  if ((ii < high)); then
    array::fuzzyFilterSortQuicksort ${ii} ${high}
  fi
}

#===============================================================
# >>> Time utilities
#===============================================================

# ## time::getProgramElapsedMicroseconds
#
# Get the elapsed time in µs since the program started.
#
# Returns:
#
# - ${RETURNED_VALUE}: the elapsed time in µs since the program started.
#
# ```bash
# core::getElapsedProgramTime
# echo "${RETURNED_VALUE}"
# time::convertMicrosecondsToHuman "${RETURNED_VALUE}"
# echo "Human time: ${RETURNED_VALUE}"
# ```
#
# > We split the computation in seconds and milliseconds to avoid overflow on 32-bit systems.
# > The 10# forces the base 10 conversion to avoid issues with leading zeros.
# > Fun fact: this function will fail in 2038 on 32-bit systems because the number of seconds will overflow.
function time::getProgramElapsedMicroseconds() {
  RETURNED_VALUE=$(((${EPOCHREALTIME%%\.*} - GLOBAL_PROGRAM_STARTED_AT_SECOND) * 1000000 + (10#${EPOCHREALTIME##*\.} - 10#${GLOBAL_PROGRAM_STARTED_AT_MICROSECOND})))
}

#===============================================================
# >>> Core utilities
#===============================================================

# ## core::fail
#
# Displays an error message and then exit the program with error.
#
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::fail "This is an error message."
# ```
function core::fail() {
  log::error "$@"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_DISPLAYED=1
  exit 1
}

# ## core::failWithCode
#
# Displays an error message and then exit the program with error.
#
# - $1: **exit code** _as int_:
#       the exit code to use, should be between 1 and 255
# - $@: **message** _as string_:
#       the error message to display
#
# ```bash
# core::failWithCode 255 "This is an error message."
# ```
function core::failWithCode() {
  local exitCode="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  shift
  log::error "$@"
  # shellcheck disable=SC2034
  GLOBAL_ERROR_DISPLAYED=1
  exit "${exitCode}"
}

# ## source
#
# Allows to source/include a library file or sources a file.
#
# It replaces the builtin source command to make sure that we do not source the same library twice.
# We replace source instead of creating a new function to allow us to
# specify the included file for spellcheck.
#
# - $1: **library name or path** _as string_:
#       the name of the library (array, interactive, string...) or the file path to include.
# - $@: arguments _as any_:
#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).
#
# ```bash
#   source string
#   source ./my/path
# ```
#
# > - The file can be relative to the current script (script that calls this function).
# > - Use `builtin source` if you want to include the file even if it was already included.
function source() {
  local pathOrName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  shift

  # if the name does not start with . or /, we assume it is a library name
  if [[ ${pathOrName:0:1} != [./] ]]; then
    # quick check if it is already included
    if [[ ${_CORE_INCLUDED_LIBRARIES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
      return 0
    fi

    local -i sourcedFiles=0

    # source the lib from the valet core libs
    if [[ -f "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" ]]; then
      builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" "$@"
      sourcedFiles+=1
    fi

    # source the lib from user libs
    if [[ -v CMD_LIBRARY_DIRECTORIES ]]; then
      local libraryDirectory
      for libraryDirectory in "${CMD_LIBRARY_DIRECTORIES[@]}"; do
        if [[ -f "${libraryDirectory}/lib-${pathOrName}" ]]; then
          builtin source "${libraryDirectory}/lib-${pathOrName}" "$@"
          sourcedFiles+=1
        fi
      done
    fi

    # we included at least one file? then we are done
    if ((sourcedFiles > 0)); then
      _CORE_INCLUDED_LIBRARIES="${_CORE_INCLUDED_LIBRARIES:-}"$'\n'"${pathOrName}"$'\n'
      return 0
    fi
  fi

  # quick check if the file is already included
  if [[ ${_CORE_INCLUDED_FILES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
    return 0
  fi

  # source a file next to the file that calls this function
  if [[ -n ${BASH_SOURCE[1]:-} && -f "${BASH_SOURCE[1]%/*}/${pathOrName}" ]]; then
    builtin source "${BASH_SOURCE[1]%/*}/${pathOrName}" "$@"
    return 0
  fi

  # source a file with an absolute path or in the current directory
  if [[ -f "${pathOrName}" ]]; then
    builtin source "${pathOrName}" "$@"
    return 0
  fi

  local failMessage="Cannot source the file ⌜${pathOrName}⌝ because it does not exist."
  if [[ ${pathOrName} == "lib-"* ]]; then
    failMessage+=$'\n'"If you meant to source a library, make sure it is either in the valet core or user libraries and do not include the ⌜lib-⌝ prefix."
  fi
  core::fail "${failMessage}"
}

# ## core::resetIncludedLibraries (private)
#
# Allows to reset the included libraries.
# When calling the source function, it will source all the libraries again.
# This is useful when we want to reload the libraries.
#
# ```bash
# core::resetIncludedLibraries
# ```
function core::resetIncludedLibraries() {
  _CORE_INCLUDED_LIBRARIES=""
}

# ## core::sourceUserCommands (private)
#
# Source the user 'commands' file from the valet user directory.
# If the file does not exist, we build it on the fly.
#
# ```bash
# core::sourceUserCommands
# ```
function core::sourceUserCommands() {
  if [[ -n "${GLOBAL_CMD_INCLUDED:-}" ]]; then
    return 0
  fi

  # source the user commands
  local userDirectory
  core::getUserDirectory
  userDirectory="${RETURNED_VALUE}"

  local commandsFile
  commandsFile="${userDirectory}/commands"

  # if the commands file does not exist, we build it.
  if [[ ! -f "${commandsFile}" ]]; then
    log::info "The valet user directory ⌜${userDirectory}⌝ does not contain a built ⌜commands⌝ file."$'\n'"Now building it using ⌜valet self build⌝ command."

    # shellcheck disable=SC1091
    unset GLOBAL_CMD_INCLUDED
    # shellcheck source=/dev/null
    source "${GLOBAL_INSTALLATION_DIRECTORY}/commands.d/self-build.sh"
    selfBuild --silent

    if [[ ! -f "${commandsFile}" ]]; then
      core::fail "Could not build the commands file, please check the error above."
    fi
  fi

  log::debug "Sourcing the user commands from ⌜${commandsFile}⌝."

  # source commands (use builtin to not use our custom source function)
  builtin source "${commandsFile}"
}

# ## core::reloadUserCommands (private)
#
# Forcibly source again the user 'commands' file from the valet user directory.
#
# ```bash
# core::reloadUserCommands
# ```
function core::reloadUserCommands() {
  # delete previous variables
  # shellcheck disable=SC2086
  unset -v ${!CMD_*} GLOBAL_CMD_INCLUDED
  core::sourceUserCommands
}

# ## core::deleteUserCommands (private)
#
# Delete the user 'commands' file from the valet user directory.
#
# You probably want to reload the user commands afterward using `core::reloadUserCommands`.
#
# ```bash
# core::deleteUserCommands
# ```
function core::deleteUserCommands() {
  core::getUserDirectory
  rm -f "${RETURNED_VALUE}/commands"
}

# ## core::getVersion
#
# Returns the version of Valet.
#
# Returns:
#
# - ${RETURNED_VALUE}: The version of Valet.
#
# ```bash
# core::getVersion
# printf '%s\n' "The version of Valet is ⌜${RETURNED_VALUE}⌝."
# ```
function core::getVersion() {
  # shellcheck source=lib-fs
  source fs
  fs::readFile "${GLOBAL_INSTALLATION_DIRECTORY}/version"
}

#===============================================================
# >>> Valet files and directories
#===============================================================

# ## core::getConfigurationDirectory
#
# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet configuration directory
#
# ```bash
# core::getConfigurationDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getConfigurationDirectory() {
  local directory
  directory="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getLocalStateDirectory
#
# Returns the path to the valet local state directory.
# The base directory relative to which user-specific state files should be stored.
# Creates it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet local state directory
#
# ```bash
# core::getLocalStateDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getLocalStateDirectory() {
  local directory
  directory="${VALET_CONFIG_LOCAL_STATE_DIRECTORY:-${XDG_STATE_HOME:-${HOME}/.local/share}/valet}"
  if [[ ! -d "${directory}" ]]; then
    mkdir -p "${directory}"
  fi
  RETURNED_VALUE="${directory}"
}

# ## core::getUserDirectory
#
# Returns the path to the valet user directory.
# Does not create it if missing.
#
# Returns:
#
# - ${RETURNED_VALUE}: the path to the valet user directory
#
# ```bash
# core::getUserDirectory
# local directory="${RETURNED_VALUE}"
# ```
function core::getUserDirectory() {
  RETURNED_VALUE="${VALET_USER_DIRECTORY:-${HOME}/.valet.d}"
}

#===============================================================
# >>> Command functions
#===============================================================

# ## command::sourceFunction
#
# Source the file associated with a command function.
# This allows you to call a command function without having to source the file manually.
#
# - $1: **function name** _as string_:
#       the function name
#
# ```bash
# command::sourceFunction "functionName"
# ```
function command::sourceFunction() {
  local functionName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  local fileToSource
  if ! command -v "${functionName}" 1>/dev/null 2>&1; then
    local -n fileToSource="CMD_FILETOSOURCE_${functionName}"
    if [[ -f "${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${fileToSource}"
      log::debug "Loaded file ⌜${fileToSource}⌝."
    elif [[ -f "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}" ]]; then
      # shellcheck disable=SC1090
      source "${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}"
      log::debug "Loaded file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝."
    else
      log::warning "The source file ⌜${GLOBAL_INSTALLATION_DIRECTORY:-}/${fileToSource}⌝ referenced by the function ⌜${functionName}⌝ does not exist!"
    fi
  fi
}

# ## command::showHelp
#
# Show the help for the current function.
# This should be called directly from a command function for which you want to display the help text.
#
# ```bash
# command::showHelp
# ```
function command::showHelp() {
  local functionName
  # get the function name of the calling function
  functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  main::printHelp function "${functionName}"
}

# ## command::parseArguments
#
# Parse the arguments and options of a function and return a string that can be evaluated to set the variables.
# This should be called from a command function for which you want to parse the arguments.
#
# See the documentation for more details on the parser: <https://jcaillon.github.io/valet/docs/new-commands/#-implement-your-command>.
#
#
# - $@: **arguments** _as any_:
#       the arguments to parse
#
# Returns:
#
# - ${RETURNED_VALUE}: a string that can be evaluated to set the parsed variables
#
# Output example:
#
# ```
# local arg1 option1
# arg1="xxx"
# option1="xxx"
# ```
#
# ```bash
# command::parseArguments "$@" && eval "${RETURNED_VALUE}"
# ```
function command::parseArguments() {
  # get the function name of the calling function
  local functionName="${FUNCNAME[1]?"This function must be called from a command function."}"

  main::parseCmdFunctionArgumentsOrGoInteractive "${functionName}" "$@"
}

# ## command::checkParsedResults
#
# A convenience function to check the parsing results and fails with an error message if there are
# parsing errors.
# Will also display the help if the help option is true.
#
# This should be called from a command function for which you want to check the parsing results.
#
# It uses the variables `help` and `commandArgumentsErrors` to determine if the help should be displayed
# and if there are parsing errors.
#
# ```bash
# command::checkParsedResults
# ```
function command::checkParsedResults() {
  if [[ ${help:-false} == "true" ]]; then
    main::printHelp function "${FUNCNAME[1]?"This function must be called from a command function."}"
    exit 0
  fi
  if [[ -n "${commandArgumentsErrors:-}" ]]; then
    core::fail "${commandArgumentsErrors}"
  fi
}

#===============================================================
# >>> Main
#===============================================================

# Setup global variables that will be used for temporary files and folders.
fs::setupTempFileGlobalVariable

core::resetIncludedLibraries

# Since we use _OPTION_* variables to pass optional options to functions, we want to make sure
# to not create collisions so we unset them here.
unset -v ${!_OPTION_*}

# determine if we support colors (can be overridden by the user with VALET_CONFIG_ENABLE_COLORS)
case "${TERM:-}" in
xterm-color | xterm-256color | linux) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}" ;;
xterm) if [[ -n "${COLORTERM:-}" ]]; then VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-true}"; fi ;;
*) VALET_CONFIG_ENABLE_COLORS="${VALET_CONFIG_ENABLE_COLORS:-false}" ;;
esac

# Export terminal size on window resize if we are in interactive mode.
if [[ -t 2 ]]; then
  tui::getTerminalSize
  # shellcheck disable=SC2034
  GLOBAL_SCREEN_REDRAW_REQUIRED=false
  # shellcheck disable=SC2090
  trap 'tui::getTerminalSize; GLOBAL_SCREEN_REDRAW_REQUIRED=true; log::createPrintFunction; eval "${GLOBAL_LOG_PRINT_FUNCTION}"' SIGWINCH
else
  GLOBAL_COLUMNS="${VALET_DEFAULT_COLUMNS:-120}"
  # shellcheck disable=SC2034
  GLOBAL_LINES="${VALET_DEFAULT_LINES:-30}"
fi

# Declare the print functions
log::createPrintFunction
eval "${GLOBAL_LOG_PRINT_FUNCTION}"

# Parsing the options from environment variables
if [[ -n "${VALET_LOG_LEVEL:-}" ]]; then
  log::setLevel "${VALET_LOG_LEVEL}"
fi
if [[ ${VALET_VERBOSE:-} == "true" ]]; then
  log::setLevel debug
fi
if [[ ${VALET_VERY_VERBOSE:-} == "true" ]]; then
  log::setLevel trace
fi
if [[ -n "${VALET_CONFIG_LOG_FD:-}" ]]; then
  _INVALID_FD=false
  # make sure the file descriptor is valid
  if [[ ! "${VALET_CONFIG_LOG_FD}" =~ ^[0-9]+$ ]]; then
    # it is a file
    if ! { : >>"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
      _INVALID_FD=true
    fi
  elif ! { : >&"${VALET_CONFIG_LOG_FD}"; } 2>/dev/null; then
    _INVALID_FD=true
  fi
  if [[ ${_INVALID_FD} == "true" ]]; then
    _ORIGINAL_FD="${VALET_CONFIG_LOG_FD}"
    VALET_CONFIG_LOG_FD=2
    core::fail "The file descriptor VALET_CONFIG_LOG_FD=⌜${_ORIGINAL_FD}⌝ is not valid."
  fi
fi

# Include main if not already included
if [[ -z "${GLOBAL_MAIN_INCLUDED:-}" ]]; then
  # do not specify shellcheck source to avoid circular dependency!
  # shellcheck source=/dev/null
  source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/main"
fi

