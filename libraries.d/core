#!/usr/bin/env bash
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

#===============================================================
# >>> Core utilities
#===============================================================

# ## core::parseFunctionOptions
#
# Parses the shell parameters passed as arguments and sets the REPLY variable to a string that can be
# evaluated to set the local variables required in the calling function.
#
# This should be called when you need to parse the arguments of a function that has a finite number of arguments
# (i.e. that uses $@ or $*) in which case we expect the shell parameters to be passed after a separator `---`.
#
# - $@: arguments _as any_:
#       The arguments to parse.
#
# Returns:
#
# - ${REPLY}: The string to evaluate to set the local variables.
#
# ```bash
# core::parseFunctionOptions 1 2 3 --- myOption=one
# eval "${REPLY}"
# # REPLY will be: local myOption="one"; set -- "${@:1:3}"
# ```
function core::parseFunctionOptions() {
  local param
  local -i nb=0
  for param; do
    if [[ ${param} == "---" ]]; then
      break
    fi
    nb+=1
  done
  if (($# == nb)); then
    # no separators, only arguments
    REPLY=":"
    return 0
  elif (($# - 1 == nb)); then
    # a separator but no options after it
    REPLY="set -- \"\${@:1:${nb}}\""
    return 0
  fi
  shift "$((nb + 1))"
  local IFS=$' '
  REPLY="local ${*@Q}; set -- \"\${@:1:${nb}}\""
}

# ## core::exit
#
# Exits the program with the given exit code.
#
# We replace the builtin exit command to make sure that we can correctly capture where
# the exit was called and print the call stack.
#
# - $1: exit code _as int_:
#       (optional) the exit code to use, should be between 0 and 255
#       (defaults to 0)
# - ${silent} _as bool_:
#       (optional) If true, will not print the exit message and call stack for non zero exit codes.
#       (defaults to false)
#
# ```bash
# core::exit 0
# core::exit 0 silent=true
# ```
function core::exit() {
  local \
    exitCode="${1:-0}" \
    silent="false" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  _OPTION_SILENT="${silent}" exit "${exitCode}"
}

# ## exit (private)
#
# Exits the program with the given exit code.
#
# We replace the builtin exit command to make sure that we can correctly capture where
# the exit was called and print the call stack.
#
# See core::exit.
function exit() {
  local -i exitCode="${1:-0}"
  local silent="${_OPTION_SILENT:-false}"

  if log::isTraceEnabled; then
    log::trace "Explicit exit with code ${exitCode}, stack:"
    log::printCallStack
  fi

  if [[ ${exitCode} != "0" && ${GLOBAL_EXPECTED_EXIT:-} != "true" && ${silent} != "true" ]]; then
    log::print "ERROR" "${ICON_EXIT:-}" "EXIT" "Explicit exit with code ${exitCode}, stack:"
    log::printCallStack
  fi

  # shellcheck disable=SC2034
  GLOBAL_EXPECTED_EXIT=true
  builtin exit "${exitCode}"
}

# ## core::fail
#
# Displays an error message and then exit the program with error.
#
# - $1: **message** _as string_:
#       The error message to display
# - ${exitCode} _as int_:
#       (optional) the exit code to use, should be between 1 and 255
#       (defaults to 1)
#
# ```bash
# core::fail "This is an error message."
# core::fail "This is an error message." exitCode=255
# ```
function core::fail() {
  local \
    message="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    exitCode=1
  shift 1
  local IFS=$' '
  eval "local a= ${*@Q}"

  log::print "ERROR" "${ICON_ERROR:-}" "FAIL" "${message}"
  if log::isDebugEnabled; then
    log::printCallStack
  fi
  # shellcheck disable=SC2034
  _OPTION_SILENT=true exit "${exitCode}"
}

# ## source
#
# Allows to source/include a library file or sources a file.
#
# When sourcing a library, omit the `lib-` prefix.
# It will source all user and core libraries with the given name.
#
# It replaces the builtin source command to make sure that we do not source the same library twice.
# We replace source instead of creating a new function to allow us to
# specify the included file for spellcheck.
#
# - $1: **library name or path** _as string_:
#       the name of the library (array, interactive, string...) or the file path to include.
# - $@: arguments _as any_:
#       (optional) the arguments to pass to the sourced file (mimics the builtin source command).
# - $_OPTION_CONTINUE_IF_NOT_FOUND _as bool_:
#       (optional) Do not fail the program if we do not find a file to source, we simply return 1.
#       (defaults to false)
# - $_OPTION_RETURN_CODE_IF_ALREADY_INCLUDED _as int_:
#       (optional) The function return code if the given file or library was already
#       included.
#       (defaults to 0)
#
# ```bash
# source string
# source ./my/path
# _OPTION_CONTINUE_IF_NOT_FOUND=false _OPTION_RETURN_CODE_IF_ALREADY_INCLUDED=2 source ./my/path
# ```
#
# > - The file can be relative to the current script (script that calls this function).
# > - Use `builtin source` if you want to include the file even if it was already included.
function source() {
  local \
    pathOrName="${1}" \
    continueIfNotFound="${_OPTION_CONTINUE_IF_NOT_FOUND:-false}" \
    returnCodeIfAlreadyIncluded="${_OPTION_RETURN_CODE_IF_ALREADY_INCLUDED:-0}"
  shift 1

  # if the name does not start with . or /, we assume it is a library name
  if [[ ${pathOrName:0:1} != [./] ]]; then
    # quick check if it is already included
    if [[ ${_CORE_INCLUDED_LIBRARIES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
      return "${returnCodeIfAlreadyIncluded}"
    fi

    local -i sourcedFiles=0
    # source the lib from the valet core libs
    if [[ -f "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" ]]; then
      builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}" "$@"
      sourcedFiles+=1
    elif [[ -f "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}.sh" ]]; then
      builtin source "${GLOBAL_INSTALLATION_DIRECTORY}/libraries.d/lib-${pathOrName}.sh" "$@"
      sourcedFiles+=1
    fi

    # source the lib from user libs
    if [[ -v CMD_LIBRARY_DIRECTORIES ]]; then
      local libraryDirectory
      for libraryDirectory in "${CMD_LIBRARY_DIRECTORIES[@]}"; do
        if [[ -f "${libraryDirectory}/lib-${pathOrName}" ]]; then
          builtin source "${libraryDirectory}/lib-${pathOrName}" "$@"
          sourcedFiles+=1
        elif [[ -f "${libraryDirectory}/lib-${pathOrName}.sh" ]]; then
          builtin source "${libraryDirectory}/lib-${pathOrName}.sh" "$@"
          sourcedFiles+=1
        fi
      done
    fi

    # we included at least one file? then we are done
    if ((sourcedFiles > 0)); then
      _CORE_INCLUDED_LIBRARIES="${_CORE_INCLUDED_LIBRARIES:-}"$'\n'"${pathOrName}"$'\n'
      return 0
    fi
  fi

  # source a file next to the file that calls this function
  if [[ -n ${BASH_SOURCE[1]:-} && -f "${BASH_SOURCE[1]%/*}/${pathOrName}" ]]; then
    pathOrName="${BASH_SOURCE[1]%/*}/${pathOrName}"

    # check if the file is already included
    if [[ ${_CORE_INCLUDED_FILES:-} == *$'\n'"${pathOrName}"$'\n'* ]]; then
      return "${returnCodeIfAlreadyIncluded}"
    fi

    builtin source "${pathOrName}" "$@"
    _CORE_INCLUDED_FILES="${_CORE_INCLUDED_FILES:-}"$'\n'"${pathOrName}"$'\n'
    return 0
  fi

  # source a file with an absolute path or in the current directory
  if [[ -f "${pathOrName}" ]]; then
    builtin source "${pathOrName}" "$@"
    # in that case we do not add the file to the included files because we are on the
    # default builtin source command behavior
    return 0
  fi

  if [[ ${continueIfNotFound} != "true" ]]; then
    local failMessage="Cannot source the file ⌜${pathOrName}⌝ because it does not exist."
    if [[ ${pathOrName} =~ ^(core|core-esc-codes|core-lib|core-styles|core-traps|main)$ ]]; then
      failMessage+="The ⌜${pathOrName}⌝ library is included by default in Valet, please remove ⌜source ${pathOrName}⌝."
    elif [[ ${pathOrName} == "lib-"* ]]; then
      failMessage+=$'\n'"If you meant to source a library, make sure it is either in the valet or user libraries and do not include the ⌜lib-⌝ prefix."
    fi
    core::fail "${failMessage}"
  else
    return 1
  fi
}

# ## include
#
# Allows to include multiple library files.
#
# It calls `source` for each argument.
# Useful if you don't have arguments to pass to the sourced files.
#
# - $@: **libraries** _as string_:
#       The names of the libraries (array, interactive, string...) or the file paths to include.
#
# ```bash
# include string array ./my/path
# ```
function include() {
  local name
  for name; do
    # shellcheck disable=SC1090
    source "${name}"
  done
}

# ## core::resetIncludedFiles (private)
#
# Allows to reset the included libraries.
# When calling the source function, it will source all the libraries again.
# This is useful when we want to reload the libraries.
#
# ```bash
# core::resetIncludedFiles
# ```
function core::resetIncludedFiles() {
  _CORE_INCLUDED_LIBRARIES=""
  _CORE_INCLUDED_FILES=""
}

# ## core::resetIncludedFile (private)
#
# Allows to source again a given file at the next source call.
#
# ```bash
# core::resetIncludedFile
# ```
function core::resetIncludedFile() {
  if [[ -v _CORE_INCLUDED_LIBRARIES ]]; then
    _CORE_INCLUDED_LIBRARIES="${_CORE_INCLUDED_LIBRARIES//$'\n'${1}$'\n'/$'\n'}"
  fi
  if [[ -v _CORE_INCLUDED_FILES ]]; then
    _CORE_INCLUDED_FILES="${_CORE_INCLUDED_FILES//$'\n'${1}$'\n'/$'\n'}"
  fi
}

# ## core::getVersion
#
# Returns the version of Valet.
#
# Returns:
#
# - ${REPLY}: The version of Valet.
#
# ```bash
# core::getVersion
# printf '%s\n' "The version of Valet is ⌜${REPLY}⌝."
# ```
function core::getVersion() {
  # shellcheck disable=SC1091
  source fs
  fs::readFile "${GLOBAL_INSTALLATION_DIRECTORY}/version"
}

# ## core::getConfigurationDirectory
#
# Returns the path to the valet configuration directory.
# Creates it if missing.
#
# Returns:
#
# - ${REPLY}: the path to the valet configuration directory
#
# ```bash
# core::getConfigurationDirectory
# local directory="${REPLY}"
# ```
#
# > The default configuration directory is `~/.config/valet`.
function core::getConfigurationDirectory() {
  REPLY="${VALET_CONFIG_DIRECTORY:-${XDG_CONFIG_HOME:-${HOME}/.config}/valet}"
  if [[ ! -d "${REPLY}" ]]; then
    mkdir -p "${REPLY}"
  fi
}

# ## core::getUserDataDirectory
#
# Returns the path to the valet local data directory.
# Where user-specific data files should be written (analogous to /usr/share).
# Creates it if missing.
#
# Returns:
#
# - ${REPLY}: the path to the valet local state directory
#
# ```bash
# core::getUserDataDirectory
# local directory="${REPLY}"
# ```
#
# > The default data directory is `~/.local/share/valet`.
function core::getUserDataDirectory() {
  REPLY="${VALET_CONFIG_USER_DATA_DIRECTORY:-${XDG_DATA_HOME:-${HOME}/.local/share}/valet}"
  if [[ ! -d "${REPLY}" ]]; then
    mkdir -p "${REPLY}"
  fi
}

# ## core::getUserCacheDirectory
#
# Returns the path to the valet local cache directory.
# Where user-specific non-essential (cached) data should be written (analogous to /var/cache).
# Creates it if missing.
#
# Returns:
#
# - ${REPLY}: the path to the valet local state directory
#
# ```bash
# core::getUserCacheDirectory
# local directory="${REPLY}"
# ```
#
# > The default cache directory is `~/.cache/valet`.
function core::getUserCacheDirectory() {
  REPLY="${VALET_CONFIG_USER_CACHE_DIRECTORY:-${XDG_CACHE_HOME:-${HOME}/.cache}/valet}"
  if [[ ! -d "${REPLY}" ]]; then
    mkdir -p "${REPLY}"
  fi
}

# ## core::getUserStateDirectory
#
# Returns the path to the valet local cache directory.
# Where user-specific state files should be written (analogous to /var/lib).
# Ideal location for storing runtime information, logs, etc...
# Creates it if missing.
#
# Returns:
#
# - ${REPLY}: the path to the valet local state directory
#
# ```bash
# core::getUserStateDirectory
# local directory="${REPLY}"
# ```
#
# > The default state directory is `~/.local/state/valet`.
function core::getUserStateDirectory() {
  REPLY="${VALET_CONFIG_USER_STATE_DIRECTORY:-${XDG_STATE_HOME:-${HOME}/.local/state}/valet}"
  if [[ ! -d "${REPLY}" ]]; then
    mkdir -p "${REPLY}"
  fi
}

# ## core::getExtensionsDirectory
#
# Returns the path to the user extensions directory.
# Creates it if missing.
#
# Returns:
#
# - ${REPLY}: the path to the valet user directory
#
# ```bash
# core::getExtensionsDirectory
# local directory="${REPLY}"
# ```
#
# > The default extensions directory is `~/.valet.d`.
function core::getExtensionsDirectory() {
  REPLY="${VALET_CONFIG_USER_VALET_DIRECTORY:-${HOME}/.valet.d}"
  if [[ ! -d "${REPLY}" ]]; then
    mkdir -p "${REPLY}"
  fi
}

# ## core::createSavedFilePath
#
# Returns the path to a new file stored in the user state directory under `saved-files`.
# Can be used to save the state of important temporary files generated during a program
# execution.
#
# - ${suffix} _as string_:
#       (optional) The suffix for the file to create.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY}: The path to the created file.
#
# ```bash
# core::createSavedFilePath
# core::createSavedFilePath suffix="my-file"
# printf '%s\n' "The file is ⌜${REPLY}⌝."
# ```
function core::createSavedFilePath() {
  local \
    suffix="" \
    IFS=$' '
  eval "local a= ${*@Q}"

  if [[ -n ${suffix} ]]; then
    suffix="--${suffix}"
  fi

  local filePath
  printf -v filePath "%(%FT%H-%M-%S%z)T--PID_%06d%s" "${GLOBAL_MOCK_EPOCHSECONDS:-${EPOCHSECONDS}}" "${GLOBAL_MOCK_BASHPID:-${BASHPID}}" "${suffix}"
  core::getUserStateDirectory
  if [[ ! -d "${REPLY}/saved-files" ]]; then
    mkdir -p "${REPLY}/saved-files"
  fi
  REPLY="${REPLY}/saved-files/${filePath}"
}

# ## core::initSubshell
#
# Do the necessary initialization for a new subshell, ensuring coherent behavior:
#
# - Set the correct traps.
# - Initialize specific temporary files/directories location.
# - Reset the elapsed time to 0.
# - Reset the background processes.
#
# ```bash
# core::initSubshell
# ```
function core::initSubshell() {
  if ((BASH_SUBSHELL == 0)); then
    core::fail "This function should only be called in a subshell."
  fi

  # in case we are in a subshell called within a bash::catchErrors, we reset errexit and not longer catch errors
  unset -v GLOBAL_ERROR_TRAP_TRY_MODE_ENABLED
  set -o errexit

  # reset the background processes
  # shellcheck disable=SC2034
  declare -g -A \
    GLOBAL_BACKGROUND_PROCESSES=() \
    GLOBAL_BACKGROUND_PROCESSES_LOGS=()

  # shellcheck disable=SC2034
  declare -g \
    GLOBAL_PROGRAM_STARTED_AT_SECOND="${EPOCHREALTIME%%[.,]*}" \
    GLOBAL_PROGRAM_STARTED_AT_MICROSECOND="${EPOCHREALTIME##*[.,]}"

  trap::registerSubshell
  fs::setupSubshellTempFileGlobalVariable
}

# ## core::dump
#
# Dumps information about the current bash session into a new file.
#
# - ${dumpSuffix} _as string_:
#       (optional) The suffix for the file to create.
#       (defaults to "")
#
# Returns:
#
# - ${REPLY}: the path to the created file.
#
# ```bash
# core::dump
# ```
function core::dump() {
  local \
    dumpSuffix="" \
    IFS=$' '
  eval "local a= ${*@Q}"

  # shellcheck disable=SC1091
  if core_dump "${dumpSuffix}"; then
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    :
  fi
}

# Private function to create a core dump file.
function core_dump() {
  local filePath REPLY_CODE
  printf -v filePath "%(%FT%H-%M-%S%z)T--PID_%06d%s" "${GLOBAL_MOCK_EPOCHSECONDS:-${EPOCHSECONDS}}" "${GLOBAL_MOCK_BASHPID:-${BASHPID}}" "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"

  core::getUserStateDirectory
  if [[ ! -d "${REPLY}/core-dumps" ]]; then
    mkdir -p "${REPLY}/core-dumps"
  fi
  filePath="${REPLY}/core-dumps/${filePath}"

  local fd listOfFds=""
  if command -v readlink &>/dev/null && [[ -d /proc/"${BASHPID}"/fd ]]; then
    # shellcheck disable=SC1091
    source bash
    for fd in /proc/"${BASHPID}"/fd/*; do
      bash::getBuiltinOutput readlink -f "${fd}" 2>/dev/null
      if [[ -n ${REPLY} ]]; then
        listOfFds+="${fd} -> ${REPLY%$'\n'*}"$'\n'
      else
        listOfFds+="${fd} -> ?? (readlink failed)"$'\n'
      fi
    done
  fi

  {
    echo "================="$'\n'"BASHPID: ${BASHPID:-}"
    echo "================="$'\n'"PPID: ${PPID:-}"
    echo "================="$'\n'"Stack:"
    log::getCallStack
    echo "${REPLY}"
    if command -v ps &>/dev/null; then
      echo "================="$'\n'"Processes:"
      ps -l || :
    fi
    echo "================="$'\n'"File descriptors:"
    echo "${listOfFds}"
  } >"${filePath}"
  if command -v ls &>/dev/null && [[ -d /proc/"${BASHPID}"/fd ]]; then
    echo "From ls:" >>"${filePath}"
    ls -l /proc/"${BASHPID}"/fd >>"${filePath}" || :
  fi
  {
    if command -v lsof &>/dev/null; then
      echo "================="$'\n'"Open files:"
      lsof -p "${BASHPID}" 2>/dev/null || :
    fi
    echo "================="$'\n'"Options:"
    shopt
    shopt -p
    echo "================="$'\n'"Traps:"
    trap -p
    echo "================="$'\n'"Jobs:"
    jobs || :
    echo "================="$'\n'"Variables:"
    declare -p
    echo "================="$'\n'"Functions:"
    declare -f
    echo "================="$'\n'"Aliases:"
    alias
  } >>"${filePath}"

  log::debug "Core dump saved to ⌜${filePath}⌝"
  REPLY="${filePath}"
}

# ## core::setShellOptions (private)
#
# Set the important shell attributes to ensure consistency in execution (-enable, +disable).
#
# ```bash
# core::setShellOptions
# ```
function core::setShellOptions() {
  # https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin-1
  # -pipefail: the $? of a pipeline is the status of the last command to exit with a non-zero status
  # -braceexpand: {1..3} will be expanded to 1 2 3
  # -errexit: exit immediately if a command exits with a non-zero status
  # -errtrace: ERR trap is inherited in subshell
  # -functrace: DEBUG and RETURN traps are inherited in subshell
  # -nounset: exit when script tries to use undeclared variables
  # -hashall: enable hashing of all commands (for performance)
  # +histexpand: disable history expansion
  # +monitor: disable job control monitor (will not report status of background jobs)
  # +noclobber: enable overwriting files during redirection
  # +noglob: enable filename expansion (globbing)
  # +notify: disable immediate report status of background jobs
  set -o pipefail -o braceexpand -o errexit -o errtrace -o functrace -o nounset -o hashall +o histexpand +o monitor +o noclobber +o noglob +o notify +o allexport +o keyword +o physical +o posix +o privileged

  # https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin-1
  # -globasciiranges: use C locale for [] character ranges in match patterns
  # +checkwinsize: do not check the window size after each external command
  # +dotglob: disable inclusion of hidden files in filename expansion
  # +expand_aliases: disable alias expansion
  # +nocasematch: disable case-insensitive matching
  shopt -s extquote globasciiranges huponexit interactive_comments progcomp
  shopt -u assoc_expand_once cdable_vars checkhash checkjobs checkwinsize compat31 compat32 compat40 compat41 compat42 compat43 compat44 globstar localvar_inherit localvar_unset nocaseglob nocasematch progcomp_alias shift_verbose xpg_echo nullglob direxpand dirspell dotglob extglob failglob execfail expand_aliases inherit_errexit
  if ((BASH_VERSINFO[1] >= 2)); then
    shopt -s globskipdots
    # we disable newer options for compatibility with older versions
    shopt -u varredir_close patsub_replacement
  fi

  # remove all aliases
  # unalias -a

  # unset important variables
  unset -v CDPATH TMOUT

  # default IFS
  IFS=$' \t\n'

  # Set a locale otherwise we will face inconsistencies in the output of commands:
  # - file listing will not sort the same way
  # - string comparison < and > will not have the same behavior
  # - `EPOCHREALTIME` can output with a comma as decimal separator instead of a dot
  # - ...
  # If the user does not have the locale, they will get a warning here.
  # In which case they must either generate the locale C.utf8 or set an existing locale
  # listed in `locale -a` via the VALET_CONFIG_LOCALE environment variable.
  LC_ALL="${VALET_CONFIG_LOCALE:-C.UTF-8}"
  LANG="${LC_ALL}"
}
