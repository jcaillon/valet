#!/usr/bin/env bash
# Title:          libraries.d/core
# Description:    this script contains the core functions and variables and it
#                 should be sourced, not called directly
# Author:         github.com/jcaillon

#===============================================================
# >>> Traps
#===============================================================

# ## trap::register (private)
#
# Register the traps for the program.
function trap::register() {
  trap trap::onErrorInternal ERR
  trap trap::onExitInternal EXIT
  # Register CTRL+C SIGINT (interrupt) and CTRL+\ SIGQUIT (interrupt with a coredump) event handler
  trap trap::onInterruptInternal SIGINT SIGQUIT
  # Register SIGHUP (hang up, terminal disconnected) and SIGTERM (terminate the program) event handler
  trap trap::onTerminateInternal SIGHUP SIGTERM
  # Register CTRL+Z SIGTSTP (stop/suspend from tty)
  trap trap::onSuspendInternal SIGTSTP
  # Register SIGCONT (continue with fg or bg after suspend) event handler
  trap trap::onContinueInternal SIGCONT
  if [[ -t 2 ]]; then
    # shellcheck disable=SC2034
    GLOBAL_SCREEN_REDRAW_REQUIRED=false
    trap trap::onResizeInternal SIGWINCH
  fi
}

# This function is called when a command or pipeline returns a non-zero exit status.
# It is executed in the same shell as the command that failed, as if we called this function
# at the line where the command failed.
function trap::onErrorInternal() {
  local -a errorCodes=("$?" "${PIPESTATUS[@]}")
  local IFS=' ' REPLY
  local errorCodesString="⌜${errorCodes[0]}⌝"
  if ((${#errorCodes[@]} > 2)); then
    errorCodesString+=" (pipeline statuses ⌜${errorCodes[*]}⌝)"
  fi

  if [[ ${FUNCNAME[1]:-} == "log::"* ]]; then
    # we are here if the error happened in a log function and thus we couldn't print the error
    printf '%s\n%s\n%s\n' "The command had a return code of ${errorCodesString}." "Error in a log function:" "${BASH_COMMAND:-}" >&"${GLOBAL_FD_LOG:-2}"
    log::getCallStack stackToSkip=2
    printf '%s\n' "${REPLY}" >&"${GLOBAL_FD_LOG:-2}"
    return 0
  fi

  if [[ ${GLOBAL_ERROR_TRAP_TRY_MODE_ENABLED:-} == "true" ]]; then
    # if we are in try/catch mode, we do not want to exit the program on error, only capture the error code
    if log::isTraceEnabled; then
      log::trace "Caught error in try/catch mode, error code ${errorCodesString} for the command:"
      log::printTrappedBashCommand
      log::printCallStack
    fi
    if [[ ! -v GLOBAL_ERROR_TRAP_ERROR_CODES ]]; then
      # shellcheck disable=SC2034
      declare -g -a \
        GLOBAL_ERROR_TRAP_ERROR_CODES=() \
        GLOBAL_ERROR_TRAP_ERROR_STACKS=()
    fi
    # shellcheck disable=SC2034
    GLOBAL_ERROR_TRAP_ERROR_CODES+=("${errorCodes[0]}")
    log::getCallStack
    # shellcheck disable=SC2034
    GLOBAL_ERROR_TRAP_ERROR_STACKS+=("Error code ${errorCodesString} for the command:"$'\n'"╭ ${BASH_COMMAND:-}"$'\n'"${REPLY}")
    return 0
  fi

  log::print "ERROR" "${ICON_ERROR:-}" "CMDERR" "Error code ${errorCodesString} for the command:"
  log::printTrappedBashCommand
  log::printCallStack

  # the following mark is used in self-test-utils
  : before-exit

  core::exit 1 silent=true
}

# This function is called when the program exits (on error, on success, on exit, on interrupt).
# It is executed in the same shell that exited, as if we called this function
# at the line where the exit command is called.
function trap::onExitInternal() {
  local exitCode="${?}"

  # as we want to make sure that we execute the cleanup function, we use the fact that
  # commands in if statements do not exit the program on error
  if trap::onExitInternalSafe "${exitCode}"; then
    :
  fi

  # always call cleanUp before exiting
  trap::onCleanUpInternal
}

# This function is called when the program is interrupted by the user (CTRL+C).
# It is executed in the same shell that has been interrupted, as if we called this function
# at the line executed at the moment when the interruption took place.
function trap::onInterruptInternal() {
  if declare -F trap::onInterrupt &>/dev/null && trap::onInterrupt; then
    # if trap::onInterrupt returns 0, then we cancel the interrupt
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    return 0
  fi

  if [[ ${_TRAP_PROGRAM_EXITING:-} == "true" ]]; then
    # we are here if the program was already interrupted,
    # it can happen if the user pressed CTRL+C multiple times
    # we are already exiting and we want the program to exit gracefully so
    # stop there
    return 0
  fi
  _TRAP_PROGRAM_EXITING=true

  if [[ -z ${GLOBAL_STTY_SAVED_CONFIG:-} ]]; then
    printf '\n' 1>&"${GLOBAL_FD_TUI}" # Set cursor to the next line of '^C' (only if stty echo is on)
  fi
  if [[ ${GLOBAL_WARN_ON_INTERRUPT_DISABLED:-} != "true" ]]; then
    log::print "WARNING" "${ICON_STOPPED:-}" "STOPPED" "Program interrupted by the user."
  fi

  if log::isDebugEnabled; then
    log::debug "Is your command stuck? Consider using the ⌜-x⌝ option to activate the profiler and identify what's wrong. Here is the current stack:"
    log::printTrappedBashCommand
    log::printCallStack
  fi

  core::exit 1 silent=true
}

# This function is called when the program is terminated by the system (SIGHUP, SIGTERM).
# It is called from the main process.
function trap::onTerminateInternal() {
  # check if the function exists
  if declare -F trap::onTerminate &>/dev/null && trap::onTerminate; then
    # if trap::onTerminate returns 0, then we cancel the termination
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    return 0
  fi

  # to avoid multiple calls
  if [[ ${_TRAP_PROGRAM_EXITING:-} == "true" ]]; then
    return 0
  fi
  _TRAP_PROGRAM_EXITING=true

  log::print "ERROR" "${ICON_KILLED:-}" "KILLED" "Program killed."

  core::exit 1 silent=true
}

# This function is called when terminal changes its size.
# It is called from the main process and it will not be triggered if the program is
# busy running an external command (e.g. sleep). Note that the builtin read command
# also blocks this trigger only it is finished.
function trap::onResizeInternal() {
  local currentSize="${GLOBAL_COLUMNS}x${GLOBAL_LINES}"
  terminal::getTerminalSize
  local newSize="${GLOBAL_COLUMNS}x${GLOBAL_LINES}"

  if [[ ${currentSize} == "${newSize}" ]]; then
    log::debug "Terminal size did not change, still ⌜${currentSize}⌝."
    return 0
  fi
  log::debug "Terminal size changed from ⌜${currentSize}⌝ to ⌜${newSize}⌝."

  # shellcheck disable=SC2034
  GLOBAL_SCREEN_REDRAW_REQUIRED=true

  # need to re init the logs because might depend on the number of columns for wrapping
  log::init

  if declare -F progress::onResize &>/dev/null; then
    progress::onResize
  fi
  if declare -F trap::onResize &>/dev/null && trap::onResize; then
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    :
  fi
}

# This function is called when the program is required to pause (stop/suspend).
# Usually this is called when the user presses CTRL+Z in bash.
function trap::onSuspendInternal() {
  # avoid multiple calls
  # shellcheck disable=SC2034
  trap SIGTSTP

  # check if the function exists
  if declare -F trap::onSuspend &>/dev/null && trap::onSuspend; then
    # if trap::onSuspend returns 0, then we cancel the suspend
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    return 0
  fi

  # save these value to restore them on continue
  # shellcheck disable=SC2034
  declare -g \
    GLOBAL_LOG_REROUTED_TO_FILE_ENABLED_SAVED="${GLOBAL_LOG_REROUTED_TO_FILE_ENABLED}" \
    GLOBAL_TERMINAL_RAW_MODE_ENABLED_SAVED="${GLOBAL_TERMINAL_RAW_MODE_ENABLED}"

  # if we were in interactive mode, we need to restore the logs
  if [[ ${GLOBAL_LOG_REROUTED_TO_FILE_ENABLED:-} == "true" ]]; then
    terminal::restoreLogs
  fi

  # restore the terminal in its original state, before running valet
  trap::restoreTerminal

  log::print "WARNING" "${ICON_HALT:-}" "PAUSED" "Program halted."

  # now that we have set up everything for a suspend, we temporarily remove this trap
  # and send the same signal again to let bash handle the suspend of the process
  kill -TSTP "${BASHPID}" &>/dev/null || :
}

# This function is called when the program is required to resume its execution.
function trap::onContinueInternal() {
  log::print "INFO" "${ICON_HALT:-}" "RESUMED" "Program resumed (press any key to unfreeze)."

  # we reregister the TSTP trap that removed on halt
  trap trap::onSuspendInternal SIGTSTP

  # check if the function exists
  if declare -F trap::onContinue &>/dev/null && trap::onContinue; then
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    :
  fi

  # if we are in interactive mode, we need to hide the cursor
  if [[ -t ${GLOBAL_FD_TUI} ]]; then
    terminal::getTerminalSize
    if [[ ${GLOBAL_SOURCED_FOR_PROMPT:-} != "true" ]]; then
      # hide the cursor (we restore on exit)
      printf "%s" "${ESC__CURSOR_HIDE}" 1>&"${GLOBAL_FD_TUI}"
    fi
  fi

  # restore tty settings if needed
  if [[ ${GLOBAL_TERMINAL_RAW_MODE_ENABLED_SAVED:-} == "true" ]]; then
    terminal::setRawMode
  fi

  # if we were in interactive mode, we need to restore the logs
  if [[ ${GLOBAL_LOG_REROUTED_TO_FILE_ENABLED_SAVED:-} == "true" ]]; then
    terminal::rerouteLogs
  fi

  # shellcheck disable=SC2034
  GLOBAL_SCREEN_REDRAW_REQUIRED=true
}

# Function to handle commands not found, so we can display a better message.
# The name of this function is a bash convention.
# This is called by bash and executed in a subshell (different PID than the main program).
function command_not_found_handle() {
  local commandNotFound="${1:-}"

  local errorMessage
  if [[ ${commandNotFound} == "curl" ]]; then
    errorMessage="This command requires ⌜curl⌝ to make https request to the internet."$'\n'"Please install it in your path and run this command again."
  elif [[ ${commandNotFound} == *::* ]]; then
    # if the command contains :: it is one of our function, we can suggest to source the 'package'
    errorMessage="Command not found: ⌜${commandNotFound}⌝."$'\n'"Did you forget to source/include the package? ⌜include ${commandNotFound%%::*}⌝"
  else
    errorMessage="Command not found: ⌜${commandNotFound}⌝."$'\n'"Please check your ⌜PATH⌝ variable."
  fi

  # check for recursive call
  if ((${GLOBAL_COMMAND_NOT_FOUND:-0} > 1)); then
    return 1
  elif ((${GLOBAL_COMMAND_NOT_FOUND:-0} == 1)); then
    # we are here if the error happened in a log function and thus we couldn't print the error
    printf '%s\n%s\n' "Command not found: ⌜${commandNotFound}⌝." "Error in a log function." >&"${GLOBAL_FD_LOG:-2}"
    log::getCallStack stackToSkip=2
    printf '%s\n' "${REPLY}" >&"${GLOBAL_FD_LOG:-2}"
  else
    GLOBAL_COMMAND_NOT_FOUND=$((${GLOBAL_COMMAND_NOT_FOUND:-0} + 1))
    log::print "ERROR" "${ICON_ERROR:-}" "CMDMISS" "${errorMessage}"
    log::printCallStack
  fi

  GLOBAL_EXPECTED_EXIT=true
  return 1
  # since this runs in a subshell, we don't actually exit the main program
  # but we set $? to 1 so ERR trap is called
}

# This function is called when the program exits (on error, on success, on exit, on interrupt).
# It is executed in the same shell that exited, as if we called this function
# at the line where the exit command is called.
function trap::onExitInternalSafe() {
  local exitCode="${1}"

  if [[ ${VALET_CONFIG_CORE_DUMP_ON_EXIT:-} == "true" || (${GLOBAL_EXPECTED_EXIT:-} != "true" && ${exitCode} != "0") ]]; then
    core::dump dumpSuffix="-exit-${exitCode}"
  fi

  # if we were in interactive mode, we need to restore the logs
  if [[ ${GLOBAL_LOG_REROUTED_TO_FILE_ENABLED:-} == "true" ]]; then
    terminal::restoreLogs
  fi

  log::debug "Exiting with code ${exitCode} after ${SECONDS}s."

  if [[ ${GLOBAL_EXPECTED_EXIT:-} != "true" ]]; then
    if [[ ${VALET_CONFIG_WARNING_ON_UNEXPECTED_EXIT:-} == "true" && ! ${BASH_COMMAND:-} =~ ^(exit|return) ]]; then
      log::print "WARNING" "${ICON_EXIT:-}" "EXIT" "Unexpected exit with code ${exitCode}:"
      log::printTrappedBashCommand
      log::printCallStack
    elif ((exitCode != 0)); then
      log::print "ERROR" "${ICON_EXIT:-}" "EXIT" "Exiting with code ${exitCode}, stack:"
      log::printTrappedBashCommand
      log::printCallStack
    fi
  fi

  if [[ -n ${GLOBAL_ON_EXIT_MESSAGE:-} ]]; then
    log::error "${GLOBAL_ON_EXIT_MESSAGE}"
  fi
}

# This functions is called before the program exits (in all cases, error or not).
# Important note: we can end up here while having the stdout/stderr redirected somewhere
# else (for example because the program exited in a command &>/dev/null). So we need to make
# sure to use our GLOBAL_FD variables to actually access the original stdout/stderr.
function trap::onCleanUpInternal() {
  if declare -F progress::stop &>/dev/null; then
    progress::stop
  fi

  # kill background processes if still running
  # we need to do this first because if one of the background is killed during "read"
  # it will restore the tty as it was when it entered read, effectively discarding our trap::restoreTerminal
  trap::killBackgroundProcesses

  # restore the terminal as it was before running this program
  trap::restoreTerminal

  # call the clean up functions if they exist
  if declare -F trap::onCleanUp &>/dev/null && trap::onCleanUp; then
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    :
  fi

  # disable the profiler if still on
  if [[ ${GLOBAL_PROFILER_ENABLED:-} == "true" ]]; then
    profiler::disable
  fi

  fs::cleanTempFiles
}

# restore the terminal in its original state, before running valet
function trap::restoreTerminal() {
  # Important note: we can end up here while having the stdout/stderr redirected somewhere
  # else (for example because the program exited in a command &>/dev/null). So we need to make
  # sure to use our GLOBAL_FD variables to actually access the original stdout/stderr.

  # if we are in interactive mode, we need to restore the cursor
  if [[ -t ${GLOBAL_FD_TUI} && ${VALET_CONFIG_DISABLE_ESC_CODES:-} != "true" ]]; then
    printf '%s' "${ESC__CURSOR_SHOW_FORCE:-$'\e[?25h'}" 1>&"${GLOBAL_FD_TUI}"
    printf '%s' "${ESC__DISABLE_MOUSE_BUTTON_TRACKING:-$'\e[?1006l'$'\e[?1000l'}${ESC__DISABLE_MOUSE_ANY_EVENT_TRACKING:-$'\e[?1006l'$'\e[?1003l'}" 1>&"${GLOBAL_FD_TUI}"
  fi

  # restore tty settings if needed
  if [[ ${GLOBAL_TERMINAL_RAW_MODE_ENABLED:-} == "true" ]]; then
    terminal::restoreSettings
  fi
}

# Kill all background processes that are still running.
function trap::killBackgroundProcesses() {
  if [[ ${#GLOBAL_BACKGROUND_PROCESSES[@]} -eq 0 ]]; then
    return 0
  fi

  local coprocName coprocPid coprocLogFile

  # display the logs for on going background processes that redirected their output to a file
  for coprocName in "${!GLOBAL_BACKGROUND_PROCESSES[@]}"; do
    coprocPid="${GLOBAL_BACKGROUND_PROCESSES[${coprocName}]:-}"
    coprocLogFile="${GLOBAL_BACKGROUND_PROCESSES_LOGS[${coprocName}]:-}"

    if [[ -n ${coprocLogFile} && -s ${coprocLogFile} ]] && log::isDebugEnabled; then
      log::debug "Redirected logs for on going background process ${coprocName} (pid ${coprocPid}):"
      log::printString "------"
      # shellcheck disable=SC1091
      source fs
      fs::readFile "${coprocLogFile}"
      log::printRaw REPLY
      log::printString "------"
    fi
  done

  # send SIGHUP to all background processes to terminate them
  for coprocName in "${!GLOBAL_BACKGROUND_PROCESSES[@]}"; do
    coprocPid="${GLOBAL_BACKGROUND_PROCESSES[${coprocName}]:-}"
    log::debug "Killing background process ${coprocName} with PID ${coprocPid}."
    kill -HUP "${coprocPid}" &>/dev/null || :
  done

  # wait for them to finish or force kill them after a timeout (500ms - 100ms per subshell level)
  time::getProgramElapsedMicroseconds
  local -i startTime=${REPLY} nowTime=${REPLY}
  for coprocName in "${!GLOBAL_BACKGROUND_PROCESSES[@]}"; do
    coprocPid="${GLOBAL_BACKGROUND_PROCESSES[${coprocName}]:-}"
    while kill -0 "${coprocPid}" &>/dev/null && ((nowTime - startTime < 500000 - BASH_SUBSHELL * 100000)); do
      time::getProgramElapsedMicroseconds
      nowTime=${REPLY}
    done
  done

  # if we did not manage to kill the background processes in time, we spawn a coproc to kill them/clean later
  if ((nowTime - startTime >= 500000 - BASH_SUBSHELL * 100000)); then
    local IFS=' '
    # shellcheck disable=SC2086
    # shellcheck disable=SC2048
    disown ${GLOBAL_BACKGROUND_PROCESSES[*]}
    log::debug "Some background processes did not terminate in time, starting a coproc to kill them asynchronously."
    # shellcheck disable=SC2034
    # shellcheck disable=SC2317
    function coproc_killer() {
      # shellcheck disable=SC1091
      source bash
      local IFS=' '
      GLOBAL_LOG_LEVEL_INT=9
      bash::sleep 5
      # shellcheck disable=SC2086
      # shellcheck disable=SC2048
      kill -9 ${GLOBAL_BACKGROUND_PROCESSES[*]}
      bash::sleep 5
      fs::cleanTempFiles
    }
    eval "{ coproc _coproc_killer { if coproc_killer; then : ; fi } } &>/dev/null"
  fi
}

#===============================================================
# >>> Traps for subshells
#===============================================================

# ## trap::registerForSubshell (private)
#
# Register the traps for a subshell.
#
# > - For a subshell, we do not want to execute the "cleanup" because it would also delete
# >   files of the main process.
# > - Additionally, we want to re-register the EXIT trap because it is not properly honored.
# > - External interruptions of the subshell (e.g. kill) are considered to be voluntary so we exit with 0;
# >   note that coproc do not respond to interrupt signals (CTRL+C does not work).
# > - coproc and jobs will not get SIGHUP when the main process ends and they will continue to execute
# >   until killed or until they check that the main process is dead.
function trap::registerSubshell() {
  if ((BASH_SUBSHELL == 0)); then
    core::fail "This function should only be called in a subshell."
  fi

  # in case we are in a subshell called within a bash::catchErrors, we reset errexit and not longer catch errors
  unset -v GLOBAL_ERROR_TRAP_TRY_MODE_ENABLED
  set -o errexit

  # reset the background processes
  declare -g -A GLOBAL_BACKGROUND_PROCESSES=() GLOBAL_BACKGROUND_PROCESSES_LOGS=()

  trap '_TRAP_SUBSHELL_EXIT_REASON=ERROR trap::onErrorInternal' ERR
  trap trap::onSubshellExitInternal EXIT
  # Register CTRL+C SIGINT (interrupt) and CTRL+\ QUIT (interrupt with a coredump) event handler
  trap '_TRAP_SUBSHELL_EXIT_REASON=SIGINT exit 0' SIGINT SIGQUIT
  # Register SIGHUP (hang up, terminal disconnected) and TERM (terminate the program) event handler
  trap '_TRAP_SUBSHELL_EXIT_REASON=SIGTERM exit 0' SIGHUP SIGTERM
  trap SIGWINCH
  trap SIGTSTP
  trap SIGCONT
}

# This function is called when a subshell exits (on error, on success, on exit, on interrupt).
# It is executed in the process that exited, as if we called this function
# at the line where the exit command is called.
function trap::onSubshellExitInternal() {
  local exitCode="${?}"

  local reason
  case "${_TRAP_SUBSHELL_EXIT_REASON:-}" in
  ERROR) reason=" (exited because of an error)" ;;
  SIGINT) reason=" (got interrupted)" ;;
  SIGTERM) reason=" (got terminated)" ;;
  *) reason="" ;;
  esac

  if [[ ${GLOBAL_EXPECTED_EXIT:-} != "true" && ${exitCode} -ne 0 ]]; then
    log::error "Exiting subshell${reason} depth ${BASH_SUBSHELL} with code ${exitCode}, stack:"
    log::printTrappedBashCommand
    log::printCallStack
  elif log::isDebugEnabled; then
    if log::isTraceEnabled; then
      log::debug "Exiting subshell${reason} depth ${BASH_SUBSHELL} with code ${exitCode}, stack:"
      log::printTrappedBashCommand
      log::printCallStack
    else
      log::debug "Exiting subshell${reason} depth ${BASH_SUBSHELL} with code ${exitCode}."
    fi
  fi

  # kill all background processes spawned in this subshell
  if trap::killBackgroundProcesses; then
    # (we execute it in a if statement to disable errexit and avoid exiting the program)
    :
  fi
}
