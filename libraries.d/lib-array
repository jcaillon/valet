#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## array::sort
#
# Sorts an array using the > bash operator (lexicographic order).
#
# - $1: **array name** _as string_:
#       The global variable name of array to sort.
#
# ```bash
# declare -g myArray=( "z" "a" "b" )
# array::sort myArray
# printf '%s\n' "${myArray[@]}"
# ```
#
# > TODO: Update this basic exchange sort implementation.
function array::sort() {
  local -n array=${1}
  local -i i j
  local temp
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      if [[ "${array[i]}" > "${array[j]}" ]]; then
        temp="${array[i]}"
        array[i]="${array[j]}"
        array[j]="${temp}"
      fi
    done
  done
}

quicksort() {
  local -i low=${1}
  local -i high=${2}
  if ((low >= high)); then
    return 0
  fi

  # we choose a pivot here, we could also select a random element
  local pivot=${KEYS[$(((low + high) / 2))]}

  local -i i=${low}
  local -i j=${high}
  local tmpKey tempValue
  while ((i <= j)); do
    while ((KEYS[i] < pivot)); do
      i+=1
    done
    while ((KEYS[j] > pivot)); do
      j=$((j - 1))
    done
    if ((i <= j)); then
      tmpKey=${KEYS[i]}
      tempValue=${VALUES[i]}
      KEYS[i]=${KEYS[j]}
      VALUES[i]=${VALUES[j]}
      KEYS[j]=${tmpKey}
      VALUES[j]=${tempValue}
      i+=1
      j=$((j - 1))
    fi
  done
  # recursion
  if ((low < j)); then
    quicksort "${low}" "${j}"
  fi
  if ((i < high)); then
    quicksort "${i}" "${high}"
  fi
}

# ## array::sortWithCriteria
#
# Sorts an array using multiple criteria.
# Excepts multiple arrays. The first array is the one to sort.
# The other arrays are used as criteria. Criteria are used in the order they are given.
# Each criteria array must have the same size as the array to sort.
# Each criteria array must containing integers representing the order of the elements.
# We first sort using the first criteria (from smallest to biggest), then the second, etc.
#
# - $1: **array name** _as string_:
#       the name of the array to sort (it is sorted in place)
# - $@: **criteria array names** _as string_:
#       the names of the arrays to use as criteria
#
# Returns:
#
# - `RETURNED_ARRAY`: An array that contains the corresponding indexes of the sorted array in the original array
#
# ```bash
# declare -g myArray=( "a" "b" "c" )
# declare -g criteria1=( 3 2 2 )
# declare -g criteria2=( 1 3 2 )
# array::sortWithCriteria myArray criteria1 criteria2
# printf '%s\n' "${myArray[@]}"
# # c b a
# printf '%s\n' "${RETURNED_ARRAY[@]}"
# # 3 2 1
# ```
#
# > TODO: Update this basic exchange sort implementation.
function array::sortWithCriteria() {
  local -n array="${1}"
  shift
  local -a criteria=("${@}")

  local -i i j k
  local temp
  local -a indexes

  # create an array of indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    indexes+=("${i}")
  done

  # sort the indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      for ((k = 0; k < ${#criteria[@]}; k++)); do
        local -n criterion="${criteria[k]}"
        if ((criterion[indexes[i]] > criterion[indexes[j]])); then
          temp="${indexes[i]}"
          indexes[i]="${indexes[j]}"
          indexes[j]="${temp}"
          break
        elif ((criterion[indexes[i]] < criterion[indexes[j]])); then
          break
        fi
      done
    done
  done

  # create the sorted array
  local -a sortedArray
  for i in "${indexes[@]}"; do
    sortedArray+=("${array[i]}")
  done

  RETURNED_ARRAY=("${indexes[@]}")

  array=("${sortedArray[@]}")
}

# ## array::appendIfNotPresent
#
# Add a value to an array if it is not already present.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any:
#       The value to add.
#
# Returns:
#
# - $?:
#   - 0 if the value was added
#   - 1 if it was already present
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::appendIfNotPresent myArray "c"
# printf '%s\n' "${myArray[@]}"
# ```
function array::appendIfNotPresent() {
  local -n array=${1}
  local value="${2}"

  # add value to array if not present, check in a loop
  local -i present=0
  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      present=1
      break
    fi
  done
  if [[ present -eq 0 ]]; then
    array+=("${value}")
  fi
  return ${present}
}

# ## array::isInArray
#
# Check if a value is in an array.
# It uses pure bash.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any_:
#       The value to check.
#
# Returns:
#
# - $?: 0 if the value is in the array, 1 otherwise.
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::isInArray myArray "b" && printf '%s\n' "b is in the array"
# ```
function array::isInArray() {
  local -n array="${1}"
  local value="${2}"

  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

# ## array::makeArraysSameSize
#
# This function makes sure that all the arrays have the same size.
# It will add empty strings to the arrays that are too short.
#
# - $@: **array names** _as string_:
#       The arrays (global variable names) to make the same size.
#
# ```bash
# array::makeArraysSameSize "array1" "array2" "array3"
# ```
function array::makeArraysSameSize() {
  local array
  local -i length
  local -a lengths
  local -i maxLength=0

  # compute max length among all arrays
  for array in "$@"; do
    if [[ ! -v "${array}" ]]; then
      eval "${array}=()"
    fi
    eval "length=\${#${array}[@]}" || length=0
    lengths+=("${length}")
    if [[ length -gt maxLength ]]; then
      maxLength=length
    fi
  done

  for length in "${lengths[@]}"; do
    while [[ length -lt maxLength ]]; do
      eval "${1}+=(\"\")"
      length+=1
    done
    shift
  done
}

# ## array::fuzzyFilterSortFileWithGrepAndAwk
#
# Allows to fuzzy sort a file against a given pattern.
# Outputs a file containing only the lines matching the pattern.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
#
# - $1: **pattern** _as string_:
#       The pattern to filter the file with.
# - $2: **file to filer** _as string_:
#       The input file to filter.
# - $3: **output filtered file** _as string_:
#       The output file containing the filtered lines.
# - $4: **output correspondences file** _as string_:
#       The output file containing the indexes of the matched lines in the original file.
#
# ```bash
# array::fuzzyFilterSortFileWithGrepAndAwk file.txt filtered.txt correspondences.txt
# ```
#
# > This is not a pure bash function! Use `array::fuzzyFilterSort` for pure bash alternative.
# > This function is useful for very large arrays.
function array::fuzzyFilterSortFileWithGrepAndAwk() {
  local pattern="${1}"
  local fileToFilter="${2}"
  local outputFilteredFile="${3}"
  local outputCorrespondencesFile="${4}"

  if [[ -z ${_ARRAY_TEMP_FILTER_FILE:-} ]]; then
    # shellcheck source=lib-io
    source io
    io::createTempFile
    _ARRAY_TEMP_FILTER_FILE="${RETURNED_VALUE}"
    io::createTempFile
    _ARRAY_TEMP_FILTERED_FILE="${RETURNED_VALUE}"
  fi

  # prepare the regex for the pattern
  # the -> '([^t]*)(t[^h]*h[^e]*e)'
  local patternRegex="([^${pattern:0:1}]*)(${pattern:0:1}"
  local -i index
  for ((index = 1; index < ${#pattern}; index++)); do
    patternRegex+="[^${pattern:index:1}]*${pattern:index:1}"
  done
  patternRegex+=")"

  # we use grep to pre-filter the lines.
  # We could do everything in awk but it would be slower for hugh files.
  grep --ignore-case --line-number "${patternRegex//[()]/}" "${fileToFilter}" >"${_ARRAY_TEMP_FILTER_FILE}"
  awk "
    BEGIN {
      IGNORECASE = 1;
    }
    # Store each line and its key for sorting
    {
      if (match(\$0, /^[0-9]+:${patternRegex}/, m)) {
        idx = idx + 1;
        # Store the full line
        lines[idx] = \$0
        originalLine = substr(\$0, 0, index(\$0, \":\") - 1)
        if (length(m[0]) == (length(originalLine) + 1 + ${#pattern})) {
          # exact match
          keys[idx] = substr(\$0, 0, index(\$0, \":\") - 1)
        } else {
          # Store the keys for sorting (size of the first match, size of the second match, original line number)
          keys[idx] = sprintf(\"%d%04d%04d\", length(m[1]), length(m[2]), originalLine)
        }
      }
    }
    END {
      # Sort the data
      n = length(lines)
      quicksort(keys, lines, 1, n)

      # Print sorted results
      for (i = 1; i <= n; i++) {
        semiColonIndex = index(lines[i], \":\");
        idx = substr(lines[i], 0, semiColonIndex - 1) - 1;
        print substr(lines[i], semiColonIndex + 1) >> \"${_ARRAY_TEMP_FILTERED_FILE}\"
        print idx >> \"${outputCorrespondencesFile}\"
      }
    }
    # Quicksort implementation from https://stackoverflow.com/questions/17048188/how-to-use-awk-sort-by-column-3
    function quicksort(keys, lines, left, right) {
      if (left >= right) return

      # Choose pivot (middle element)
      pivot_idx = int((left + right) / 2)
      pivot = keys[pivot_idx]

      # Partition
      i = left
      j = right
      while (i <= j) {
        while (compare(keys[i], pivot) < 0) i++
        while (compare(keys[j], pivot) > 0) j--
        if (i <= j) {
          temp_key = keys[i]
          temp_line = lines[i]
          keys[i] = keys[j]
          lines[i] = lines[j]
          keys[j] = temp_key
          lines[j] = temp_line
          i++
          j--
        }
      }
      # Recursive calls
      if (left < j) quicksort(keys, lines, left, j)
      if (i < right) quicksort(keys, lines, i, right)
    }
    function compare(a, b) { return (a + 0) - (b + 0) }
  " "${_ARRAY_TEMP_FILTER_FILE}"
  mv "${_ARRAY_TEMP_FILTERED_FILE}" "${outputFilteredFile}"
}