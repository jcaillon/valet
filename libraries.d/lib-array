#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## array::sort
#
# Sorts an array using the > bash operator (lexicographic order).
#
# - $1: **array name** _as string_:
#       The global variable name of array to sort.
#
# ```bash
# declare -g myArray=( "z" "a" "b" )
# array::sort myArray
# printf '%s\n' "${myArray[@]}"
# ```
function array::sort() {
  local arrayName=${1}
  local -n array=${arrayName}

  local IFS=" "
  array::quicksort "array_sortCompareCallBack ${arrayName}" "array_sortSwapCallBack ${arrayName}" 0 $(( ${#array[@]} - 1 ))
}

function array::quicksort() {
  local compareCallBack="${1}"
  local swapCallBack="${2}"
  local -i low=${3}
  local -i high=${4}

  if ((low >= high)); then
    return 0
  fi

  local -i pivotIndex=$((low))
  local -i ii=${low}
  local -i jj=${high}
  while ((ii <= jj)); do
    while ${compareCallBack} ${pivotIndex} ${ii}; do # pivot > ii
      ii+=1
    done
    while ${compareCallBack} ${jj} ${pivotIndex}; do  # jj > pivot
      jj=$((jj - 1))
    done
    if ((ii <= jj)); then
      ${swapCallBack} ii jj
      ii+=1
      jj=$((jj - 1))
    fi
  done

  if ((low < jj)); then
    array::quicksort "${compareCallBack}" "${swapCallBack}" ${low} ${jj}
  fi
  if ((ii < high)); then
    array::quicksort "${compareCallBack}" "${swapCallBack}" ${ii} ${high}
  fi
}

function array_sortCompareCallBack() {
  local -n array="${1}"
  local -i first=${2}
  local -i second=${3}
  [[ "${array[first]}" > "${array[second]}" ]] || return 1
  return 0
}

function array_sortSwapCallBack() {
  local -n array="${1}"
  local -i first=${2}
  local -i second=${3}
  local tmp="${array[first]}"
  array[first]="${array[second]}"
  array[second]="${tmp}"
}

# ## array::sortWithCriteria
#
# Sorts an array using multiple criteria.
# Excepts multiple arrays. The first array is the one to sort.
# The other arrays are used as criteria. Criteria are used in the order they are given.
# Each criteria array must have the same size as the array to sort.
# Each criteria array must containing integers representing the order of the elements.
# We first sort using the first criteria (from smallest to biggest), then the second, etc.
#
# - $1: **array name** _as string_:
#       the name of the array to sort (it is sorted in place)
# - $@: **criteria array names** _as string_:
#       the names of the arrays to use as criteria
#
# Returns:
#
# - `RETURNED_ARRAY`: An array that contains the corresponding indexes of the sorted array in the original array
#
# ```bash
# declare -g myArray=( "a" "b" "c" )
# declare -g criteria1=( 3 2 2 )
# declare -g criteria2=( 1 3 2 )
# array::sortWithCriteria myArray criteria1 criteria2
# printf '%s\n' "${myArray[@]}"
# # c b a
# printf '%s\n' "${RETURNED_ARRAY[@]}"
# # 3 2 1
# ```
#
# > TODO: Update this basic exchange sort implementation.
function array::sortWithCriteria() {
  local -n array="${1}"
  shift
  local -a criteria=("${@}")

  local -i i j k
  local temp
  local -a indexes

  # create an array of indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    indexes+=("${i}")
  done

  # sort the indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      for ((k = 0; k < ${#criteria[@]}; k++)); do
        local -n criterion="${criteria[k]}"
        if ((criterion[indexes[i]] > criterion[indexes[j]])); then
          temp="${indexes[i]}"
          indexes[i]="${indexes[j]}"
          indexes[j]="${temp}"
          break
        elif ((criterion[indexes[i]] < criterion[indexes[j]])); then
          break
        fi
      done
    done
  done

  # create the sorted array
  local -a sortedArray
  for i in "${indexes[@]}"; do
    sortedArray+=("${array[i]}")
  done

  RETURNED_ARRAY=("${indexes[@]}")

  array=("${sortedArray[@]}")
}

# ## array::appendIfNotPresent
#
# Add a value to an array if it is not already present.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any:
#       The value to add.
#
# Returns:
#
# - $?:
#   - 0 if the value was added
#   - 1 if it was already present
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::appendIfNotPresent myArray "c"
# printf '%s\n' "${myArray[@]}"
# ```
function array::appendIfNotPresent() {
  local -n array=${1}
  local value="${2}"

  # add value to array if not present, check in a loop
  local -i present=0
  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      present=1
      break
    fi
  done
  if [[ present -eq 0 ]]; then
    array+=("${value}")
  fi
  return ${present}
}

# ## array::isInArray
#
# Check if a value is in an array.
# It uses pure bash.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any_:
#       The value to check.
#
# Returns:
#
# - $?: 0 if the value is in the array, 1 otherwise.
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::isInArray myArray "b" && printf '%s\n' "b is in the array"
# ```
function array::isInArray() {
  local -n array="${1}"
  local value="${2}"

  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

# ## array::makeArraysSameSize
#
# This function makes sure that all the arrays have the same size.
# It will add empty strings to the arrays that are too short.
#
# - $@: **array names** _as string_:
#       The arrays (global variable names) to make the same size.
#
# ```bash
# array::makeArraysSameSize "array1" "array2" "array3"
# ```
function array::makeArraysSameSize() {
  local array
  local -i length
  local -a lengths
  local -i maxLength=0

  # compute max length among all arrays
  for array in "$@"; do
    if [[ ! -v "${array}" ]]; then
      eval "${array}=()"
    fi
    eval "length=\${#${array}[@]}" || length=0
    lengths+=("${length}")
    if [[ length -gt maxLength ]]; then
      maxLength=length
    fi
  done

  for length in "${lengths[@]}"; do
    while [[ length -lt maxLength ]]; do
      eval "${1}+=(\"\")"
      length+=1
    done
    shift
  done
}

# ## array::fuzzyFilterSortFileWithGrepAndAwk
#
# Allows to fuzzy sort a file against a given pattern.
# Outputs a file containing only the lines matching the pattern.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
#
# - $1: **pattern** _as string_:
#       The pattern to filter the file with.
# - $2: **file to filer** _as string_:
#       The input file to filter.
# - $3: **output filtered file** _as string_:
#       The output file containing the filtered lines.
# - $4: **output correspondences file** _as string_:
#       The output file containing the indexes of the matched lines in the original file.
#
# ```bash
# array::fuzzyFilterSortFileWithGrepAndAwk file.txt filtered.txt correspondences.txt
# ```
#
# > This is not a pure bash function! Use `array::fuzzyFilterSort` for pure bash alternative.
# > This function is useful for very large arrays.
function array::fuzzyFilterSortFileWithGrepAndAwk() {
  local pattern="${1}"
  local fileToFilter="${2}"
  local outputFilteredFile="${3}"
  local outputCorrespondencesFile="${4}"

  if [[ -z ${_ARRAY_TEMP_FILTER_FILE:-} ]]; then
    # shellcheck source=lib-io
    source io
    io::createTempFile
    _ARRAY_TEMP_FILTER_FILE="${RETURNED_VALUE}"
    io::createTempFile
    _ARRAY_TEMP_FILTERED_FILE="${RETURNED_VALUE}"
  fi

  # prepare the regex for the pattern
  # the -> '([^t]*)(t[^h]*h[^e]*e)'
  local patternRegex="([^${pattern:0:1}]*)(${pattern:0:1}"
  local -i index
  for ((index = 1; index < ${#pattern}; index++)); do
    patternRegex+="[^${pattern:index:1}]*${pattern:index:1}"
  done
  patternRegex+=")"

  # we use grep to pre-filter the lines.
  # We could do everything in awk but it would be slower for hugh files.
  grep --ignore-case --line-number "${patternRegex//[()]/}" "${fileToFilter}" >"${_ARRAY_TEMP_FILTER_FILE}"
  patternRegex="${patternRegex}(.?)"
  awk "
    BEGIN {
      # Ignore case when matching the pattern
      IGNORECASE = 1;
    }
    {
      # Store each line and its key for sorting (each line is prefixed by 'line_number:' from grep)
      if (match(\$0, /^[0-9]+:${patternRegex}/, m)) {
        idx = idx + 1;
        lines[idx] = \$0
        lineNumber = substr(\$0, 0, index(\$0, \":\") - 1)
        if (length(m[3]) == 0 && length(m[0]) == (length(lineNumber) + 1 + ${#pattern})) {
          # exact match should always be first
          keys[idx] = lineNumber
        } else {
          # Store the keys for sorting (size of the first match, size of the second match, original line number)
          keys[idx] = sprintf(\"%d%04d%04d\", length(m[1]), length(m[2]), lineNumber)
        }
      }
    }
    END {
      # Sort the lines
      nbLines = length(lines)
      quickSort(keys, lines, 1, nbLines)

      # Output the sorted lines in one file, and the correspondences in another
      for (i = 1; i <= nbLines; i++) {
        semiColonIndex = index(lines[i], \":\");
        idx = substr(lines[i], 0, semiColonIndex - 1) - 1;
        print substr(lines[i], semiColonIndex + 1) >> \"${_ARRAY_TEMP_FILTERED_FILE}\"
        print idx >> \"${outputCorrespondencesFile}\"
      }
    }
    function quickSort(keys, lines, left, right) {
      if (left >= right) return

      # Choose pivot, random element between left and right
      pivot = keys[left] + 0

      # Partition
      ii = left
      jj = right
      while (ii <= jj) {
        while (keys[ii] + 0 < pivot + 0) ii++
        while (pivot < keys[jj] + 0) jj--
        if (ii <= jj) {
          tempKey = keys[ii]
          tempLine = lines[ii]
          keys[ii] = keys[jj]
          lines[ii] = lines[jj]
          keys[jj] = tempKey
          lines[jj] = tempLine
          ii++
          jj--
        }
      }
      # Recursive calls
      if (left < jj) quickSort(keys, lines, left, jj)
      if (ii < right) quickSort(keys, lines, ii, right)
    }
  " "${_ARRAY_TEMP_FILTER_FILE}"
  mv "${_ARRAY_TEMP_FILTERED_FILE}" "${outputFilteredFile}"
}