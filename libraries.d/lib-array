#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# ## array::sort
#
# Sorts an array using the > bash operator (lexicographic order).
#
# - $1: **array name** _as string_:
#       The global variable name of array to sort.
#
# ```bash
# declare -g myArray=( "z" "a" "b" )
# array::sort myArray
# printf '%s\n' "${myArray[@]}"
# ```
#
# > TODO: Update this basic exchange sort implementation.
function array::sort() {
  local -n array=${1}
  local -i i j
  local temp
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      if [[ "${array[i]}" > "${array[j]}" ]]; then
        temp="${array[i]}"
        array[i]="${array[j]}"
        array[j]="${temp}"
      fi
    done
  done
}

# ## array::sortWithCriteria
#
# Sorts an array using multiple criteria.
# Excepts multiple arrays. The first array is the one to sort.
# The other arrays are used as criteria. Criteria are used in the order they are given.
# Each criteria array must have the same size as the array to sort.
# Each criteria array must containing integers representing the order of the elements.
# We first sort using the first criteria (from smallest to biggest), then the second, etc.
#
# - $1: **array name** _as string_:
#       the name of the array to sort (it is sorted in place)
# - $@: **criteria array names** _as string_:
#       the names of the arrays to use as criteria
#
# Returns:
#
# - `RETURNED_ARRAY`: An array that contains the corresponding indexes of the sorted array in the original array
#
# ```bash
# declare -g myArray=( "a" "b" "c" )
# declare -g criteria1=( 3 2 2 )
# declare -g criteria2=( 1 3 2 )
# array::sortWithCriteria myArray criteria1 criteria2
# printf '%s\n' "${myArray[@]}"
# # c b a
# printf '%s\n' "${RETURNED_ARRAY[@]}"
# # 3 2 1
# ```
#
# > TODO: Update this basic exchange sort implementation.
function array::sortWithCriteria() {
  local -n array="${1}"
  shift
  local -a criteria=("${@}")

  local -i i j k
  local temp
  local -a indexes

  # create an array of indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    indexes+=("${i}")
  done

  # sort the indexes
  for ((i = 0; i < ${#array[@]}; i++)); do
    for ((j = i + 1; j < ${#array[@]}; j++)); do
      for ((k = 0; k < ${#criteria[@]}; k++)); do
        local -n criterion="${criteria[k]}"
        if ((criterion[indexes[i]] > criterion[indexes[j]])); then
          temp="${indexes[i]}"
          indexes[i]="${indexes[j]}"
          indexes[j]="${temp}"
          break
        elif ((criterion[indexes[i]] < criterion[indexes[j]])); then
          break
        fi
      done
    done
  done

  # create the sorted array
  local -a sortedArray
  for i in "${indexes[@]}"; do
    sortedArray+=("${array[i]}")
  done

  RETURNED_ARRAY=("${indexes[@]}")

  array=("${sortedArray[@]}")
}

# ## array::appendIfNotPresent
#
# Add a value to an array if it is not already present.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any:
#       The value to add.
#
# Returns:
#
# - $?:
#   - 0 if the value was added
#   - 1 if it was already present
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::appendIfNotPresent myArray "c"
# printf '%s\n' "${myArray[@]}"
# ```
function array::appendIfNotPresent() {
  local -n array=${1}
  local value="${2}"

  # add value to array if not present, check in a loop
  local -i present=0
  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      present=1
      break
    fi
  done
  if [[ present -eq 0 ]]; then
    array+=("${value}")
  fi
  return ${present}
}

# ## array::isInArray
#
# Check if a value is in an array.
# It uses pure bash.
#
# - $1: **array name** _as string_:
#       The global variable name of the array.
# - $2: **value** _as any_:
#       The value to check.
#
# Returns:
#
# - $?: 0 if the value is in the array, 1 otherwise.
#
# ```bash
# declare -g myArray=( "a" "b" )
# array::isInArray myArray "b" && printf '%s\n' "b is in the array"
# ```
function array::isInArray() {
  local -n array="${1}"
  local value="${2}"

  local item
  for item in "${array[@]}"; do
    if [[ ${item} == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

# ## array::makeArraysSameSize
#
# This function makes sure that all the arrays have the same size.
# It will add empty strings to the arrays that are too short.
#
# - $@: **array names** _as string_:
#       The arrays (global variable names) to make the same size.
#
# ```bash
# array::makeArraysSameSize "array1" "array2" "array3"
# ```
function array::makeArraysSameSize() {
  local array
  local -i length
  local -a lengths
  local -i maxLength=0

  # compute max length among all arrays
  for array in "$@"; do
    if [[ ! -v "${array}" ]]; then
      eval "${array}=()"
    fi
    eval "length=\${#${array}[@]}" || length=0
    lengths+=("${length}")
    if [[ length -gt maxLength ]]; then
      maxLength=length
    fi
  done

  for length in "${lengths[@]}"; do
    while [[ length -lt maxLength ]]; do
      eval "${1}+=(\"\")"
      length+=1
    done
    shift
  done
}

# ## array::fuzzyFilterSort
#
# Allows to fuzzy sort an array against a given pattern.
# Returns an array containing only the lines matching the pattern.
# The array is sorted by (in order):
#
# - the index of the first matched character in the line
# - the distance between the first and last matched characters in the line
#
# - $1: **pattern** _as string_:
#       the pattern to match
# - $2: **array name** _as string_:
#       the initial array name
#
# Returns:
#
# - `RETURNED_ARRAY`: An array containing the items sorted and filtered
# - `RETURNED_ARRAY2`: An array containing the indexes of the matched items in the original array
#
# ```bash
# array::fuzzyFilterSort "pattern" "myarray" && local filteredArray="${RETURNED_ARRAY}"
# array::fuzzyFilterSort "pattern" "myarray" ⌜ ⌝ && local filteredArray="${RETURNED_ARRAY}"
# array::fuzzyFilterSort "pattern" "myarray" ⌜ ⌝ 10 && local filteredArray="${RETURNED_ARRAY}"
# ```
#
# > - All characters in the pattern must be found in the same order in the matched line.
# > - Use `shopt -s nocasematch` to make this function is case insensitive.
function array::fuzzyFilterSort() {
  local pattern="${1}"
  local -n array="${2}"

  # nothing to filter
  if [[ -z ${pattern} ]]; then
    RETURNED_ARRAY=("${array[@]}")
    eval "RETURNED_ARRAY2=( {0..$(( ${#array[@]} - 1 ))} )"
    return 0
  fi

  # prepare the regex for the pattern
  # the -> '([^t]*)(t[^h]*h[^e]*e)'
  local patternRegex="([^${pattern:0:1}]*)(${pattern:0:1}"
  local -i index
  for ((index = 1; index < ${#pattern}; index++)); do
    patternRegex+="[^${pattern:index:1}]*${pattern:index:1}"
  done
  patternRegex+=")"

  local -a -i originalIndexes firstCharacters matchedLengths sortedIndexes=()

  local -i itemIndex matchedIndex=-1 firstCharacter matchedLength loopIndex

  for(( itemIndex = 0 ; itemIndex< ${#array[@]}; itemIndex++ )); do
    if [[ ${array[itemIndex]} =~ ${patternRegex} ]]; then
      matchedIndex+=1
      firstCharacter="${#BASH_REMATCH[1]}"
      matchedLength="${#BASH_REMATCH[2]}"
    else
      continue
    fi

    # we have a match, now we need to sort it by firstCharacters then matchedLengths
    # the sortedIndexes array will contain the indexes of the sorted array
    loopIndex=0
    while (( loopIndex < ${#sortedIndexes[@]} )); do
      if ((firstCharacters[sortedIndexes[loopIndex]] > firstCharacter)); then
        break
      elif ((firstCharacters[sortedIndexes[loopIndex]] == firstCharacter && matchedLengths[sortedIndexes[loopIndex]] > matchedLength)); then
        break
      fi
      loopIndex+=1
    done
    sortedIndexes=("${sortedIndexes[@]:0:loopIndex}" "${matchedIndex}" "${sortedIndexes[@]:loopIndex}")

    originalIndexes+=("${itemIndex}")
    firstCharacters+=("${firstCharacter}")
    matchedLengths+=("${matchedLength}")
  done

  # will contain the matched lines, sorted
  RETURNED_ARRAY=()
  # will contain the original indexes corresponding to the sorted array
  RETURNED_ARRAY2=()

  for(( itemIndex = 0 ; itemIndex< ${#sortedIndexes[@]}; itemIndex++ )); do
    RETURNED_ARRAY+=("${array[originalIndexes[sortedIndexes[itemIndex]]]}")
    RETURNED_ARRAY2+=("${originalIndexes[sortedIndexes[itemIndex]]}")
  done
}