#!/usr/bin/env bash
# author: github.com/jcaillon
# description: This script can be sourced by commands to provide convenient functions.

# shellcheck source=lib-terminal
source terminal
# shellcheck source=lib-list
source list
# shellcheck source=lib-tui
source tui

#===============================================================
# >>> Interactive prompts
#===============================================================

# ## interactive::continue
#
# Ask the user to press the button to continue.
#
# - $1: **prompt** _as string_:
#       the prompt to display
#
# Returns:
#
# - $?:
#   - 0 if the user pressed enter
#   - 1 otherwise
#
# ```bash
# interactive::continue "Press enter to continue."
# ```
function interactive::continue() {
  interactive::displayQuestion "${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}"
  if ! interactive::continueRaw; then
    return 1
  fi
  return 0
}

# ## interactive::continueRaw
#
# Ask the user to press the button to continue.
#
# This raw version does not display the prompt or the answer.
#
# Returns:
#
# - $?:
#   - 0 if the user pressed enter
#   - 1 otherwise
#
# ```bash
# interactive::continueRaw
# ```
function interactive::continueRaw() {
  terminal::createSpace 2

  # print the current state (then move to column 1 to be ready to rewrite)
  printf ' %s%s%s' \
    "${ESC__CURSOR_HIDE}${STYLE_ACTIVE_BUTTON}" \
    "   (O)K   " \
    "${STYLE_RESET}${ESC__CURSOR_MOVE__}1${__ESC__COLUMN}" 1>&"${GLOBAL_FD_TUI}"

  local -i returnedCode=0
  while true; do
    # wait and handle key press
    if terminal::waitForChar -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ' | $'\r' | o | y)
        break
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      *)
        returnedCode=1
        break;
        ;;
      esac
    fi

    # break if fd 0 is closed or does not refer to a terminal.
    if [[ ! -t 0 ]]; then
      break;
    fi
  done

  printf '%s' "${ESC__ERASE_CHARS_RIGHT}${ESC__CURSOR_SHOW}" 1>&"${GLOBAL_FD_TUI}"

  return ${returnedCode}
}

# ## interactive::confirm
#
# Ask the user to yes or no.
#
# - The user can switch between the two options with the arrow keys or space.
# - The user can validate the choice with the enter key.
# - The user can also validate immediately with the y or n key.
#
# Dialog boxes are displayed for the question and answer.
#
# - $1: **prompt** _as string_:
#       the prompt to display
# - ${default} _as bool_:
#       (optional) the default value to select
#       (defaults to true)
#
# Returns:
#
# - $?:
#   - 0 if the user answered yes
#   - 1 otherwise
# - ${REPLY}: true or false.
#
# ```bash
# if interactive::confirm "Do you want to continue?"; then echo "Yes."; else echo "No."; fi
# ```
function interactive::confirm() {
  local \
    prompt="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    default=true \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  interactive::displayQuestion "${prompt}"

  if ! interactive::confirmRaw default="${default}"; then
    interactive::displayAnswer "No."
    REPLY=false
    return 1
  fi

  interactive::displayAnswer "Yes."
  REPLY=true
  return 0
}

# ## interactive::confirmRaw
#
# Ask the user to yes or no.
#
# - The user can switch between the two options with the arrow keys or space.
# - The user can validate the choice with the enter key.
# - The user can also validate immediately with the y or n key.
#
# This raw version does not display the prompt or the answer.
#
# - ${default} _as bool_:
#       (optional) the default value to select
#       (defaults to true)
#
# Returns:
#
# - $?:
#   - 0 if the user answered yes
#   - 1 otherwise
# - ${REPLY}: true or false.
#
# ```bash
# interactive::confirmRaw "Do you want to continue?" && local answer="${REPLY}"
# ```
function interactive::confirmRaw() {
  local \
    default=true \
    IFS=$' '
  eval "local a= ${*@Q}"

  local state="${default}"

  terminal::createSpace 2

  printf '%s' "${ESC__CURSOR_HIDE}" 1>&"${GLOBAL_FD_TUI}"

  local yesColor noColor
  while true; do
    if [[ ${state} == "true" ]]; then
      yesColor="${STYLE_ACTIVE_BUTTON}"
      noColor="${STYLE_INACTIVE_BUTTON}"
    else
      yesColor="${STYLE_INACTIVE_BUTTON}"
      noColor="${STYLE_ACTIVE_BUTTON}"
    fi

    # print the current state (then move to column 1 to be ready to rewrite)
    printf ' %s%s%s   %s%s%s' \
      "${yesColor}" \
      "   (Y)ES   " \
      "${STYLE_RESET}" \
      "${noColor}" \
      "   (N)O   " \
      "${STYLE_RESET}${ESC__CURSOR_MOVE__}1${__ESC__COLUMN}" 1>&"${GLOBAL_FD_TUI}"

    # wait and handle key press
    if terminal::waitForChar -t 1; then
      case ${LAST_KEY_PRESSED} in
      $'\n' | ' ')
        break
        ;;
      y | Y)
        state=true
        break
        ;;
      n | N)
        state=false
        break
        ;;
      UP | LEFT | RIGHT | DOWN)
        if [[ ${state} == "true" ]]; then state=false; else state=true; fi
        ;;
      ESC)
        core::fail "Interactive session cancelled."
        ;;
      esac
    fi

    # break if fd 0 is closed or does not refer to a terminal.
    if [[ ! -t 0 ]]; then break; fi
  done

  printf '%s' "${ESC__ERASE_CHARS_RIGHT}${ESC__CURSOR_SHOW}" 1>&"${GLOBAL_FD_TUI}"

  if [[ ${state} == "true" ]]; then
    REPLY=${state}
    return 0
  fi

  REPLY=${state}
  return 1
}

# ## interactive::displayQuestion
#
# Displays a question to the user.
#
# The text is wrapped and put inside a box like so:
#
# ```text
#    ╭────────────────────────────────╮
# ░──┤ Is this an important question? │
#    ╰────────────────────────────────╯
# ```
#
# - $1: **prompt** _as string_:
#       the prompt to display
# - ${width} _as int_:
#       (optional) the maximum width of the text in the dialog box
#       (defaults to "${GLOBAL_COLUMNS}")
#
# ```bash
# interactive::displayPrompt "Do you want to continue?"
# ```
function interactive::displayQuestion() {
  local \
    text="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    width="${GLOBAL_COLUMNS}" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  interactive::displayDialogBox "left" "${text}" width="${width}"
}

# ## interactive::displayAnswer
#
# Displays an answer to a previous question.
#
# The text is wrapped and put inside a box like so:
#
# ```text
#     ╭─────╮
#     │ No. ├──░
#     ╰─────╯
# ```
#
# - $1: **answer** _as string_:
#       the answer to display
# - ${width} _as int_:
#       (optional) the maximum width of the text in the dialog box
#       (defaults to "${GLOBAL_COLUMNS}")
#
# ```bash
# interactive::displayAnswer "My answer."
# ```
function interactive::displayAnswer() {
  local \
    text="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    width="${GLOBAL_COLUMNS}" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  interactive::displayDialogBox "right" "${text}" width="${width}"
}

# ## interactive::displayDialogBox (private)
#
# Displays a dialog box with a text, coming from the left or the right.
#
# - $1: **from** _as string_:
#       left or right, to indicate where the dialog box is "rooted"
# - $2: **text** _as string_:
#       the text to display
# - ${width} _as int_:
#       (optional) the maximum width of the text in the dialog box
#       (defaults to "${GLOBAL_COLUMNS}")
#
# ```bash
# interactive::displayDialogBox "system" "This is a system message."
# ```
function interactive::displayDialogBox() {
  local \
    from="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    text="${2?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    width="${GLOBAL_COLUMNS}" \
    IFS=$' '
  shift 2
  eval "local a= ${*@Q}"

  local -i maxTextWidth=$((GLOBAL_COLUMNS - 7))
  if (( width >= maxTextWidth )); then
    width=${maxTextWidth}
  fi
  local -i textWidth=${width}
  if (( ${#text} < textWidth )); then
    textWidth=${#text}
  fi

  string::wrapWords text width="${textWidth}"
  local wrappedText="${REPLY}"

  local finalString line sideString
  local -i lineNumber=0 maxLineLength=0

  while IFS=$'\n' read -r line; do
    if (( ${#line} > maxLineLength )); then
      maxLineLength=${#line}
    fi
  done <<<"${wrappedText}"
  textWidth=${maxLineLength}

  local frameBorder
  printf -v frameBorder "%${textWidth}s" " "
  frameBorder="${frameBorder// /─}"

  if [[ ${from} == "right" ]]; then

    local -i startColumn=$((GLOBAL_COLUMNS - textWidth - 7))
    startColumn=$((startColumn >= 0 ? startColumn : 0))
    startColumn=$((startColumn <= 8 ? startColumn : 8))
    startColumn+=1

    finalString+="${ESC__CURSOR_MOVE__}${startColumn}${__ESC__COLUMN}${STYLE_FRAMES}${SYMBOL_TL_CORNER}─${frameBorder}─${SYMBOL_TR_CORNER}${STYLE_RESET}"$'\n'
    while IFS=$'\n' read -r line; do
      if (( lineNumber == 0 )); then
        sideString="├──░"
      else
        sideString="│"
      fi
      finalString+="${ESC__CURSOR_MOVE__}${startColumn}${__ESC__COLUMN}${STYLE_FRAMES}│${STYLE_RESET} ${line} ${ESC__CURSOR_MOVE__}$((textWidth + 3 + startColumn))${__ESC__COLUMN}${STYLE_FRAMES}${sideString}${STYLE_RESET}"$'\n'
      lineNumber+=1
    done <<<"${wrappedText}"
    finalString+="${ESC__CURSOR_MOVE__}${startColumn}${__ESC__COLUMN}${STYLE_FRAMES}${SYMBOL_BL_CORNER}─${frameBorder}─${SYMBOL_BR_CORNER}${STYLE_RESET}"$'\n'

  else

    finalString+="   ${STYLE_FRAMES}${SYMBOL_TL_CORNER}─${frameBorder}─${SYMBOL_TR_CORNER}${STYLE_RESET}"$'\n'
    while IFS=$'\n' read -r line; do
      if (( lineNumber == 0 )); then
        sideString="${STYLE_FRAMES}░──┤"
      else
        sideString="   ${STYLE_FRAMES}│"
      fi
      finalString+="${sideString}${STYLE_RESET} ${line} ${ESC__CURSOR_MOVE__}$((textWidth + 7))${__ESC__COLUMN}${STYLE_FRAMES}│${STYLE_RESET}"$'\n'
      lineNumber+=1
    done <<<"${wrappedText}"
    finalString+="   ${STYLE_FRAMES}${SYMBOL_BL_CORNER}─${frameBorder}─${SYMBOL_BR_CORNER}${STYLE_RESET}"$'\n'

  fi

  printf '%s' "${finalString}" 1>&"${GLOBAL_FD_TUI}"
}

#===============================================================
# >>> List
#===============================================================

function interactive::choose() {
  local \
    arrayName="${1?"The function ⌜${FUNCNAME:-?}⌝ requires more than $# arguments."}" \
    width="${GLOBAL_COLUMNS}" \
    height="${GLOBAL_LINES}" \
    IFS=$' '
  shift 1
  eval "local a= ${*@Q}"

  height=$((height - 4))
  terminal::createSpace "$((height + 1))"
  terminal::getCursorPosition

  list::setOptions \
    itemHeight=1
  list::setViewport top="${GLOBAL_CURSOR_LINE}" height="${height}" width="${width}"

  list::setItems "${arrayName}"
  # list::filter "${filter}"
  # list::changeSelectedItemIndex "${move}"
  # list::onTick

  # define the callback function called when a special key is pressed
  function onKeyPress() {
    log::debug "Key pressed: ⌜${1}⌝"
    if [[ ${1} == ":"* ]]; then
      list::onKeyBindingPressed "${1#:}"
    fi
  }

  # define the callback function called when the screen needs to be redrawn
  function onRedrawRequired() {
    log::debug "Redraw required, terminal changed to: ⌜%s x %s⌝" "${GLOBAL_COLUMNS}" "${GLOBAL_LINES}"
    terminal::getCursorPosition
    list::setViewport top="${GLOBAL_CURSOR_LINE}" height="$((GLOBAL_LINES - 4))" width="${GLOBAL_COLUMNS}"
    list::draw
  }

  # define the callback function called on each loop iteration
  function onTick() {
    log::debug "Tick"
    list::onTick
  }

  tui::startMainLoop onKeyPress \
    onRedrawRequiredCallback=onRedrawRequired \
    onTickCallback=onTick \
    tickDelay=0.05
}